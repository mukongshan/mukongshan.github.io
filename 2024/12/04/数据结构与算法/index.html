<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"ebc5f2cd8493752a92129fa16b4bf1635308b0d6","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="第一章 · 导论什么是数据结构数据结构涉及三个方面：   数据的逻辑结构—–从用户视图看，是面向问题的。  数据的物理结构—–从具体实现视图看，是面向计算机的。  相关的操作及其实现。  注意：非线性逻辑结构的物理结构不一定是非线性的，反之亦然。 ADT ADTs: Abstract Data Types  是将类型和与这个类型有关的操作集合封装在一起的数据模型。 如：栈，字典，列表等等  思想：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://kongshan.me/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:description" content="第一章 · 导论什么是数据结构数据结构涉及三个方面：   数据的逻辑结构—–从用户视图看，是面向问题的。  数据的物理结构—–从具体实现视图看，是面向计算机的。  相关的操作及其实现。  注意：非线性逻辑结构的物理结构不一定是非线性的，反之亦然。 ADT ADTs: Abstract Data Types  是将类型和与这个类型有关的操作集合封装在一起的数据模型。 如：栈，字典，列表等等  思想：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105164244133.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220142720571.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153506582.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153752102.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241101152900625.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105175530052.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126202223795.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241206153859993.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt3/im3-16.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230129091917091.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204184853197.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204195723190.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208192950155.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208202359104.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208204647861.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142357142.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142416129.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209143950542.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209144057066.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213163633887.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152800463.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152808426.png">
<meta property="og:image" content="c:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213161401167.png">
<meta property="article:published_time" content="2024-12-04T04:00:00.000Z">
<meta property="article:modified_time" content="2025-12-03T09:38:18.479Z">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105164244133.png">


<link rel="canonical" href="https://kongshan.me/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongshan.me/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","path":"2024/12/04/数据结构与算法/","title":"数据结构与算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构与算法 | kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">kongshan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%C2%B7-%E5%AF%BC%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">第一章 · 导论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">什么是数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADT"><span class="nav-number">1.2.</span> <span class="nav-text">ADT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OO"><span class="nav-number">1.3.</span> <span class="nav-text">OO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A%E9%80%92%E5%BD%92%EF%BC%88Recursion"><span class="nav-number">1.4.</span> <span class="nav-text">算法思想：递归（Recursion)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.4.1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.2.</span> <span class="nav-text">分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">泛型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%C2%B7-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">第二章 · 算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A%E5%88%86%E6%B2%BB-divide-and-conquer"><span class="nav-number">2.3.</span> <span class="nav-text">基本思想：分治(divide-and -conquer)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">表示法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%C2%B7-%E5%88%97%E8%A1%A8%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">第三章 · 列表，栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">线性表 ***</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.2.</span> <span class="nav-text">栈 ***</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.3.</span> <span class="nav-text">队列 ***</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%C2%B7-%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">第四章 · 树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8%E8%A1%A5%E5%85%85"><span class="nav-number">4.1.</span> <span class="nav-text">性质补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA"><span class="nav-number">4.2.</span> <span class="nav-text">表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86"><span class="nav-number">4.3.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">4.4.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E6%A0%91"><span class="nav-number">4.5.</span> <span class="nav-text">线索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Index-BST%EF%BC%89"><span class="nav-number">4.6.1.</span> <span class="nav-text">带索引的搜索树（Index BST）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89"><span class="nav-number">4.6.2.</span> <span class="nav-text">平衡二叉搜索树（AVL Tree）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#m%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">4.6.3.</span> <span class="nav-text">m路搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1m%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88B-Tree"><span class="nav-number">4.6.4.</span> <span class="nav-text">平衡m路搜索树（B-Tree)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">4.7.</span> <span class="nav-text">霍夫曼树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%C2%B7-%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash%EF%BC%89-%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E4%BB%A3%E7%A0%81"><span class="nav-number">5.</span> <span class="nav-text">第五章 · 散列表（Hash）(需要掌握代码)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-number">5.1.</span> <span class="nav-text">设计目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">常见的散列函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">冲突处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">线性探测法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">5.3.2.</span> <span class="nav-text">二次探测法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%95%A3%E5%88%97"><span class="nav-number">5.3.3.</span> <span class="nav-text">双散列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="nav-number">5.3.4.</span> <span class="nav-text">分离链接法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%C2%B7-%E5%A0%86"><span class="nav-number">6.</span> <span class="nav-text">第六章 · 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">最大（小）优先队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E5%A0%86"><span class="nav-number">6.2.</span> <span class="nav-text">最大（小）堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%C2%B7-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">7.</span> <span class="nav-text">第七章 · 并查集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%C2%B7-%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">第八章 · 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">8.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">8.2.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.3.</span> <span class="nav-text">生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">8.4.</span> <span class="nav-text">最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8%E7%BD%91%E7%BB%9C"><span class="nav-number">8.5.</span> <span class="nav-text">活动网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%C2%B7-%E6%8E%92%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">第九章 · 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.1.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.2.</span> <span class="nav-text">折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">9.2.3.</span> <span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">9.3.</span> <span class="nav-text">交换排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">9.3.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">9.3.2.</span> <span class="nav-text">快速排序 ***</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.1.</span> <span class="nav-text">直接选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.2.</span> <span class="nav-text">竞标赛排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.3.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">9.4.4.</span> <span class="nav-text">归并排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0-%C2%B7-%E9%94%99%E9%A2%98%E9%9B%86"><span class="nav-number">10.</span> <span class="nav-text">笔记 · 错题集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0-%C2%B7-%E7%AE%97%E6%B3%95%E9%9B%86"><span class="nav-number">11.</span> <span class="nav-text">笔记 · 算法集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-1"><span class="nav-number">11.1.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-1"><span class="nav-number">11.1.2.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%A9%E6%8E%92%E5%BA%8F%EF%BC%88Rank-Sort%EF%BC%89"><span class="nav-number">11.1.3.</span> <span class="nav-text">秩排序（Rank Sort） ***</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1"><span class="nav-number">11.1.4.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">11.1.5.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">11.2.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">11.3.</span> <span class="nav-text">查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">11.3.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">11.3.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">11.4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%EF%BC%9A%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%EF%BC%88%E8%BF%98%E6%9C%89%E6%9B%B4%E7%AE%80%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">11.4.1.</span> <span class="nav-text">分治法：求最大子序列和（还有更简的算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="nav-number">11.4.2.</span> <span class="nav-text">寻找数组中第K小元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">11.4.3.</span> <span class="nav-text">杨辉三角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="nav-number">11.4.4.</span> <span class="nav-text">约瑟夫问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%9A%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0"><span class="nav-number">11.4.5.</span> <span class="nav-text">辗转相除法：求最大公因数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">11.4.6.</span> <span class="nav-text">一般二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">11.4.6.1.</span> <span class="nav-text">查找算法（递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">11.4.6.2.</span> <span class="nav-text">插入算法（递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">11.4.6.3.</span> <span class="nav-text">删除算法 ***</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89-1"><span class="nav-number">11.4.7.</span> <span class="nav-text">平衡二叉搜索树（AVL Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-1"><span class="nav-number">11.4.7.1.</span> <span class="nav-text">查找算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95"><span class="nav-number">11.4.7.2.</span> <span class="nav-text">插入算法 ***</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%AE%97%E6%B3%95-1"><span class="nav-number">11.4.7.3.</span> <span class="nav-text">删除算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#m%E8%B7%AF%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="nav-number">11.4.8.</span> <span class="nav-text">m路搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree"><span class="nav-number">11.4.9.</span> <span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="nav-number">11.4.10.</span> <span class="nav-text">最大堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">11.4.11.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-1"><span class="nav-number">11.4.11.1.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">11.4.11.2.</span> <span class="nav-text">贪心算法：最小生成树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0-%C2%B7-%E4%BB%A3%E7%A0%81%E9%9B%86"><span class="nav-number">12.</span> <span class="nav-text">笔记 · 代码集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">12.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">12.1.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C"><span class="nav-number">12.1.2.</span> <span class="nav-text">操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">12.1.3.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88-1"><span class="nav-number">12.2.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.2.1.</span> <span class="nav-text">链表实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">12.2.2.</span> <span class="nav-text">数组实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">12.2.3.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97-1"><span class="nav-number">12.3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">12.3.1.</span> <span class="nav-text">链表实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="nav-number">12.3.2.</span> <span class="nav-text">例题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">12.4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%AD%90%E5%A5%B3%E5%8F%B3%E5%85%84%E5%BC%9F"><span class="nav-number">12.4.1.</span> <span class="nav-text">左子女右兄弟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86-2"><span class="nav-number">12.4.2.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E6%A0%91"><span class="nav-number">12.4.3.</span> <span class="nav-text">根据前中后序表达式建树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91-1"><span class="nav-number">12.4.4.</span> <span class="nav-text">霍夫曼树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="nav-number">12.4.5.</span> <span class="nav-text">搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">12.4.5.1.</span> <span class="nav-text">二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">12.4.6.</span> <span class="nav-text">堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE-1"><span class="nav-number">12.5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">12.5.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">12.5.2.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kruskal"><span class="nav-number">12.5.3.</span> <span class="nav-text">kruskal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim"><span class="nav-number">12.5.4.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra"><span class="nav-number">12.5.5.</span> <span class="nav-text">Dijkstra</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">12.6.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-1"><span class="nav-number">12.6.1.</span> <span class="nav-text">归并排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0"><span class="nav-number">13.</span> <span class="nav-text">复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%9F%E6%9C%AB%E9%87%8D%E7%82%B9"><span class="nav-number">13.1.</span> <span class="nav-text">期末重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="nav-number">13.2.</span> <span class="nav-text">第一章</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%88%E9%80%89%E6%8B%A9%E3%80%81%E5%A1%AB%E7%A9%BA%EF%BC%89"><span class="nav-number">13.2.1.</span> <span class="nav-text">一、数据结构的定义（选择、填空）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E7%90%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-number">13.2.2.</span> <span class="nav-text">二、数据结构的逻辑结构与物理结构（理解即可）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81ADT%E3%80%81OO%E4%B8%8D%E8%80%83%EF%BC%8C%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3"><span class="nav-number">13.2.3.</span> <span class="nav-text">三、ADT、OO不考，需要理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%EF%BC%88%E9%80%89%E6%8B%A9%E3%80%81%E5%A1%AB%E7%A9%BA%EF%BC%89%E5%AE%9A%E4%B9%89%E3%80%81%E4%BA%94%E4%B8%AA%E6%80%A7%E8%B4%A8"><span class="nav-number">13.2.4.</span> <span class="nav-text">四、算法概念（选择、填空）定义、五个性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E5%AD%A6%E9%83%A8%E5%88%86%E8%BF%87%E4%B8%80%E9%81%8D%E5%8D%B3%E5%8F%AF"><span class="nav-number">13.2.5.</span> <span class="nav-text">五、数学部分过一遍即可</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%EF%BC%88%E7%89%A9%E7%90%86%E8%BF%87%E7%A8%8B%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">13.2.6.</span> <span class="nav-text">六、递归需要掌握（物理过程、逻辑过程）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%B3%9B%E5%9E%8B%E4%B8%8D%E8%80%83"><span class="nav-number">13.2.7.</span> <span class="nav-text">七、泛型不考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="nav-number">13.3.</span> <span class="nav-text">第二章</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%A6%82%E5%BF%B5"><span class="nav-number">13.3.1.</span> <span class="nav-text">一、空间复杂度、时间复杂度概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%9C%80%E5%A5%BD%E6%83%85%E5%86%B5%E3%80%81%E6%9C%80%E5%B7%AE%E6%83%85%E5%86%B5%E3%80%81%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%EF%BC%88%E7%AD%89%E6%A6%82%E7%8E%87%EF%BC%89"><span class="nav-number">13.3.2.</span> <span class="nav-text">二、最好情况、最差情况、平均情况（等概率）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">13.3.3.</span> <span class="nav-text">三、大O表示法（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E8%BF%87%E7%A8%8B-%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89"><span class="nav-number">13.3.4.</span> <span class="nav-text">四、二分查找（过程+复杂度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%8C%87%E5%AE%9A%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="nav-number">13.3.5.</span> <span class="nav-text">五、指定复杂度设计算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%EF%BC%88%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="nav-number">13.3.6.</span> <span class="nav-text">六、辗转相除（过程）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89-%E4%B8%80%E5%AE%9A%E6%9C%89%E9%A2%98"><span class="nav-number">13.4.</span> <span class="nav-text">第三章（线性表） 一定有题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81ADT%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E6%AF%94%E5%A6%82%E6%A0%88%E7%9A%84%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88peek%EF%BC%89"><span class="nav-number">13.4.1.</span> <span class="nav-text">一、ADT的基本操作（比如栈的进栈出栈peek）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%88%E5%B8%A6%E4%B8%8D%E5%B8%A6%E8%A1%A8%E5%A4%B4%EF%BC%8C%E4%B8%80%E8%88%AC%E4%B8%8D%E8%80%83%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%80%E8%88%AC%E4%B8%8D%E5%A4%AA%E8%80%83%EF%BC%89"><span class="nav-number">13.4.2.</span> <span class="nav-text">二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BE%8B%E9%A2%98%E8%BF%87%E4%B8%80%E9%81%8D%EF%BC%88%E6%87%82%EF%BC%89"><span class="nav-number">13.4.3.</span> <span class="nav-text">三、例题过一遍（懂）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%EF%BC%88%E5%B0%8F%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">13.4.4.</span> <span class="nav-text">四、栈和队列（小重点）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E6%A0%91%EF%BC%89"><span class="nav-number">13.5.</span> <span class="nav-text">第四章（树）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5%EF%BC%88%E5%A1%AB%E7%A9%BA%E9%80%89%E6%8B%A9%EF%BC%89"><span class="nav-number">13.5.1.</span> <span class="nav-text">一、概念（填空选择）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">13.5.2.</span> <span class="nav-text">二、表示方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E4%B8%8D%E8%80%83"><span class="nav-number">13.5.2.1.</span> <span class="nav-text">广义表不考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%A7%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">13.5.2.2.</span> <span class="nav-text">双亲表示法见并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%AD%90%E5%A5%B3%E5%8F%B3%E5%85%84%E5%BC%9F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">13.5.2.3.</span> <span class="nav-text">左子女右兄弟（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8FLVR"><span class="nav-number">13.5.2.3.1.</span> <span class="nav-text">中序LVR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8FLRV"><span class="nav-number">13.5.2.3.2.</span> <span class="nav-text">后序LRV</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88%E5%88%86%E5%B1%82%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="nav-number">13.5.2.4.</span> <span class="nav-text">广度优先遍历（分层访问）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">13.5.2.5.</span> <span class="nav-text">森林的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E3%80%81%E6%A0%B9%E6%8D%AE%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BB%BA%E6%A0%91"><span class="nav-number">13.5.3.</span> <span class="nav-text">补、根据前中后序表达式建树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%89"><span class="nav-number">13.5.4.</span> <span class="nav-text">四、线索化二叉树（常考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88%E5%B0%8F%E7%BB%93%E6%9E%84%EF%BC%8C%E8%BF%98%E6%9C%89%E6%95%A3%E5%88%97%E8%A1%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8C%E4%BA%A4%E6%9B%BF%E8%80%83%EF%BC%89"><span class="nav-number">13.5.5.</span> <span class="nav-text">五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88AVL%E6%A0%91%E5%B8%B8%E8%80%83%EF%BC%8CB%E6%A0%91%E5%B8%B8%E8%80%83%EF%BC%89%E5%90%84%E4%B8%AA%E7%AE%97%E6%B3%95%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">13.5.6.</span> <span class="nav-text">六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">13.5.6.1.</span> <span class="nav-text">6.1 二叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-AVL%E6%A0%91"><span class="nav-number">13.5.6.2.</span> <span class="nav-text">6.2 AVL树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-m%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">13.5.6.3.</span> <span class="nav-text">6.3 m叉搜索树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-B%E6%A0%91"><span class="nav-number">13.5.6.4.</span> <span class="nav-text">6.4 B树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89"><span class="nav-number">13.6.</span> <span class="nav-text">第五章（散列表）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">13.6.1.</span> <span class="nav-text">一、散列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-number">13.6.2.</span> <span class="nav-text">二、冲突处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5"><span class="nav-number">13.6.3.</span> <span class="nav-text">三、分离链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%8F%91%E7%8E%B0%E5%85%B6%E5%BA%94%E7%94%A8"><span class="nav-number">13.6.4.</span> <span class="nav-text">四、应用环境下发现其应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%88%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">13.7.</span> <span class="nav-text">第六章（优先级队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A0%86%EF%BC%88%E4%B8%8A%E6%BB%A4%E4%B8%8B%E6%BB%A4%E8%BF%9B%E5%A0%86%E5%87%BA%E5%A0%86%EF%BC%89%E8%BF%87%E7%A8%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%BB%BA%E5%A0%86"><span class="nav-number">13.7.1.</span> <span class="nav-text">一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E6%8F%92%E5%85%A5%EF%BC%88%E8%BF%9B%E5%A0%86%E3%80%81%E4%B8%8A%E6%BB%A4%EF%BC%89"><span class="nav-number">13.7.1.1.</span> <span class="nav-text">1.1 插入（进堆、上滤）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%88%A0%E9%99%A4%EF%BC%88%E5%87%BA%E5%A0%86%E3%80%81%E4%B8%8B%E6%BB%A4%EF%BC%89"><span class="nav-number">13.7.1.2.</span> <span class="nav-text">1.2 删除（出堆、下滤）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%BB%BA%E5%A0%86"><span class="nav-number">13.7.1.3.</span> <span class="nav-text">1.3 线性时间建堆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89"><span class="nav-number">13.8.</span> <span class="nav-text">第七章（并查集）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8A%9F%E8%83%BD%EF%BC%88Union%E3%80%81Find%EF%BC%89"><span class="nav-number">13.8.1.</span> <span class="nav-text">一、并查集功能（Union、Find）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">13.8.2.</span> <span class="nav-text">三、选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">13.8.3.</span> <span class="nav-text">四、堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">13.8.4.</span> <span class="nav-text">五、归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-number">13.9.</span> <span class="nav-text">算法思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-number">13.9.1.</span> <span class="nav-text">一、递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E6%B2%BB"><span class="nav-number">13.9.2.</span> <span class="nav-text">二、分治</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%B4%AA%E5%BF%83"><span class="nav-number">13.9.3.</span> <span class="nav-text">三、贪心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">13.9.4.</span> <span class="nav-text">四、动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%82%B9"><span class="nav-number">14.</span> <span class="nav-text">考点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-1"><span class="nav-number">14.1.</span> <span class="nav-text">第一章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-1"><span class="nav-number">14.2.</span> <span class="nav-text">第二章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%8C%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">14.3.</span> <span class="nav-text">第三章 （线性表，栈，队列）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="nav-number">14.4.</span> <span class="nav-text">第四章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="nav-number">14.5.</span> <span class="nav-text">第五章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="nav-number">14.6.</span> <span class="nav-text">第六章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="nav-number">14.7.</span> <span class="nav-text">第七章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%EF%BC%88%E5%9B%BE%EF%BC%89"><span class="nav-number">14.8.</span> <span class="nav-text">第八章 （图）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0"><span class="nav-number">14.9.</span> <span class="nav-text">第九章</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构与算法 | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第一章-·-导论"><a href="#第一章-·-导论" class="headerlink" title="第一章 · 导论"></a>第一章 · 导论</h1><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构涉及三个方面： </p>
<ul>
<li>数据的逻辑结构—–从用户视图看，是面向问题的。 </li>
<li>数据的物理结构—–从具体实现视图看，是面向计算机的。 </li>
<li>相关的操作及其实现。</li>
</ul>
<p>注意：非线性逻辑结构的物理结构不一定是非线性的，反之亦然。</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ol>
<li><p>ADTs: Abstract Data Types </p>
<p>是将类型和与这个类型有关的操作集合封装在一起的数据模型。</p>
<p>如：栈，字典，列表等等</p>
</li>
<li><p>思想：将数据类型的使用与它的表示（机内存储）、实现（机内操作的 实现）分开。更确切的说，把一个数据类型的表示及在这个类型 上的操作实现封装到一个程序模块中，用户不必知道它。</p>
</li>
</ol>
<h2 id="OO"><a href="#OO" class="headerlink" title="OO"></a>OO</h2><ol>
<li>OO：object-oriented＝object＋class＋inherit＋ communicate</li>
<li>面向对象编程核心思想：<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h2 id="算法思想：递归（Recursion"><a href="#算法思想：递归（Recursion" class="headerlink" title="算法思想：递归（Recursion)"></a>算法思想：递归（Recursion)</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol>
<li>基本情况：考虑“第一项”</li>
<li>递归过程：考虑第n项和第n-1项之间的关系<ul>
<li>注：递归过程一定要最终落在基本情况上，否则该递归是错误的</li>
</ul>
</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>直接递归（自递归）：自己调用自己</li>
<li>简介递归（互递归）：多个函数相互调用形成回路的递归</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li>理解：其实就是代码复用。有时候会通过模版来实现。java中看到的<Object>就是泛型的的例子</li>
<li>定义：泛型（Generics）是一种编程语言的特性，允许在定义函数、类或数据结构时使用类型参数，以便这些代码可以适用于多种数据类型，而不需要为每一种类型编写单独的代码。</li>
</ol>
<h1 id="第二章-·-算法分析"><a href="#第二章-·-算法分析" class="headerlink" title="第二章 · 算法分析"></a>第二章 · 算法分析</h1><ul>
<li>只关注量级，不太关心细节</li>
<li>计算机领域默认log的底数为2</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul>
<li>数变量的时候多一个少一个也没关系，不影响数量级就好</li>
</ul>
<ol>
<li><p>组成：</p>
<ol>
<li><p>指令空间</p>
</li>
<li><p>数据空间：</p>
<ol>
<li>常量</li>
<li>简单变量</li>
<li>组件变量</li>
</ol>
</li>
<li><p>环境栈空间</p>
</li>
</ol>
</li>
<li><p>两个部分：</p>
<ol>
<li>固定部分：指令空间，简单变量等等，在程序加载的时候就已经确定，大小是固定的。</li>
<li>可变部分：包括组件变量，动态分配，递归栈等等。</li>
</ol>
</li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol>
<li>关注关键步骤，忽略次要步骤（都是相对而言），如：关注比较，忽略赋值；关注元素比较，忽略下标比较；</li>
<li>最优最差平均复杂度：以查找为例，最优为1，第一个就找到了，最坏是n，遍历全部，平均为（n+1)&#x2F;2。</li>
</ol>
<h2 id="基本思想：分治-divide-and-conquer"><a href="#基本思想：分治-divide-and-conquer" class="headerlink" title="基本思想：分治(divide-and -conquer)"></a>基本思想：分治(divide-and -conquer)</h2><ol>
<li>两个阶段：<ol>
<li>分阶段：把问题分成两个大致相等的子问题，然后递归地 对它们求解。 </li>
<li>治阶段： 将两个子问题的解合并到一起，可能再做些少 量的附加工作，最后得到整个问题的解。</li>
</ol>
</li>
</ol>
<h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><ol>
<li>大O表示法：表示量级上界</li>
<li>Omega表示法：表示量级下界</li>
<li>θ表示法：表示量级</li>
</ol>
<h1 id="第三章-·-列表，栈和队列"><a href="#第三章-·-列表，栈和队列" class="headerlink" title="第三章 · 列表，栈和队列"></a>第三章 · 列表，栈和队列</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表 ***"></a>线性表 ***</h2><ol>
<li><p>逻辑层：</p>
<p>定义和功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractDateType LinearList&#123; </span><br><span class="line">instances</span><br><span class="line">	ordered finite collections of zero or more elements</span><br><span class="line">operations</span><br><span class="line">	<span class="title function_">Create</span><span class="params">()</span>; Destroy();</span><br><span class="line">	IsEmpty(); Length();</span><br><span class="line">	Find(k,x); Search(x);</span><br><span class="line">	Delete(k,x); Insert(k,x);</span><br><span class="line">	Output(out);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>物理层：</p>
<ol>
<li>用数组表示线性表<ol>
<li>根据索引访问：O(1)</li>
<li>查找：O(len)</li>
<li>根据索引删除：O(n)。因为需要挪动数据。</li>
<li>特点：<ol>
<li>优势：查找很快，O(1)</li>
<li>缺点：插入，删除慢</li>
</ol>
</li>
</ol>
</li>
<li>用链表表示<ol>
<li>时间复杂度<ol>
<li>访问：O(n)</li>
<li>查找：O(n)</li>
<li>删除：O(1)</li>
<li>插入：O(1)</li>
</ol>
</li>
<li>有表头节点的单链表：<ul>
<li>在第一个节点之前有一个header节点，不储存数据。它被header指针指向。</li>
<li>first是指第一个数据指针</li>
</ul>
</li>
<li>有游标的单链表<ul>
<li>定义了游标类LinkedListItr。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈 ***"></a>栈 ***</h2><ol>
<li><p>逻辑层：</p>
<ol>
<li><p>理解：实际上是对线性表做了限制，只允许有一端可以增添，删除和查找，其他地方都不行。活动端叫栈顶，另一端叫栈底。</p>
</li>
<li><p>操作：</p>
<ol>
<li>push：压栈（添加）</li>
<li>pop：出栈（删除）</li>
<li>peek：查看栈顶元素</li>
<li>isEmpty</li>
</ol>
</li>
</ol>
</li>
<li><p>物理层：和线性表一致。</p>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列 ***"></a>队列 ***</h2><ol>
<li>逻辑层：<ol>
<li>理解：像水管一样，一头进数据，一头出数据。出数据的叫队首，进数据的叫队尾。</li>
<li>操作：<ol>
<li>enqueue：入队</li>
<li>dequeue：出队</li>
<li>peek：查看队首数据</li>
</ol>
</li>
</ol>
</li>
<li>物理层：和线性表一致<ol>
<li>用数组表示：要把数组看成环形。表示下一个位置时，表示为front &#x3D; (front + 1) % arr.length。</li>
</ol>
</li>
</ol>
<h1 id="第四章-·-树"><a href="#第四章-·-树" class="headerlink" title="第四章 · 树"></a>第四章 · 树</h1><ul>
<li>主要研究二叉树</li>
</ul>
<h2 id="性质补充"><a href="#性质补充" class="headerlink" title="性质补充"></a>性质补充</h2><ol>
<li>根节点的高度为0</li>
<li>一棵树的叶有n个，有m个度数为2的节点，则：n&#x3D;m+1</li>
<li>如果对完全二叉树按层标号，则可以根据标号算出某个节点的子节点和父节点</li>
</ol>
<h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ol>
<li>用数组表示</li>
<li>用广义表：A（B，C，（D，E））</li>
<li>用双亲表示法</li>
<li>左子女，右兄弟法：注意，这种方法的逻辑层和物理层都是树</li>
</ol>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol>
<li><p>二叉树遍历算法：</p>
<ol>
<li>深度优先：先序、中序、后序。用递归实现，也可以用栈。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BinaryNode&lt;T&gt;* t)</span><br><span class="line">&#123;// preorder traversal of *t.</span><br><span class="line">	if(t)&#123; </span><br><span class="line">		visit(t);</span><br><span class="line">		PreOrder(t-&gt;Left);</span><br><span class="line">		PreOrder(t-&gt;Right);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>广度优先：按层次遍历。用队列实现</li>
</ol>
</li>
<li><p>一般树遍历：</p>
<ol>
<li>深度优先：<ol>
<li>逻辑上先根遍历（物理上先序遍历）</li>
<li>逻辑上后根遍历（物理上<strong>中序</strong>遍历）</li>
</ol>
</li>
</ol>
</li>
<li><p>森林遍历：</p>
<ol>
<li>先根&#x3D;&gt;先序</li>
<li>中根&#x3D;&gt;中序</li>
<li>后根&#x3D;&gt;后序</li>
</ol>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li>完全二叉树：除了最后一层，其它层节点都是满的</li>
<li>满二叉树：其中每个节点要么是叶子节点，要么是有两个子节点（即每个非叶子节点都有两个子节点）。每一层的节点数都达到了该层的最大节点数。</li>
<li>满二叉树<strong>一定</strong>是完全二叉树，完全二叉树也不一定是满二叉树</li>
</ol>
<h2 id="线索树"><a href="#线索树" class="headerlink" title="线索树"></a>线索树</h2><ol>
<li>n个结点的二叉树有2n个链域，<br>其中真正有用的是n – 1个，其它n + 1个都是空域。<br>让左指针指向前驱，右指针指向后继。</li>
<li>增加了2个标记位，leftThread和rightThread。为0则代表指向子女，为1则代表指向前驱后继。</li>
</ol>
<h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><ol>
<li>可以构造出一颗二叉搜索树，使得每个节点的左子树的所有节点比自己小，右子树的所有节点比自己大</li>
</ol>
<h3 id="带索引的搜索树（Index-BST）"><a href="#带索引的搜索树（Index-BST）" class="headerlink" title="带索引的搜索树（Index BST）"></a>带索引的搜索树（Index BST）</h3><p>在每个节点左侧添加一个索引，为其左子树中的所有节点数加一（也就是要包括自身）</p>
<h3 id="平衡二叉搜索树（AVL-Tree）"><a href="#平衡二叉搜索树（AVL-Tree）" class="headerlink" title="平衡二叉搜索树（AVL Tree）"></a>平衡二叉搜索树（AVL Tree）</h3><ol>
<li>定义：<ol>
<li>是二叉搜索树</li>
<li>左右子树高度差不能超过一</li>
</ol>
</li>
<li>旋转：详见算法</li>
</ol>
<h3 id="m路搜索树"><a href="#m路搜索树" class="headerlink" title="m路搜索树"></a>m路搜索树</h3><ol>
<li><p>定义：</p>
<ol>
<li><p>树中最多有m路分叉</p>
</li>
<li><p>一个节点最少有一个key，最多有m-1个key</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105164244133.png" alt="image-20241105164244133"></p>
</li>
<li><p>节点中的key是从小到大排好序的</p>
</li>
<li><p>分叉中的所有节点总是小于分叉的右边的key，大于左边的key</p>
</li>
</ol>
</li>
</ol>
<h3 id="平衡m路搜索树（B-Tree"><a href="#平衡m路搜索树（B-Tree" class="headerlink" title="平衡m路搜索树（B-Tree)"></a>平衡m路搜索树（B-Tree)</h3><ol>
<li>定义：<ol>
<li>根节点至少有2个子节点（即至少有1个key）</li>
<li>每个节点中的至少有 [m&#x2F;2]（向上取整）路</li>
<li>外节点全都在同一层，即树同高</li>
</ol>
</li>
<li>性质：<ol>
<li>外节点总数是key值总数加一</li>
</ol>
</li>
</ol>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><ol>
<li>概念：<ol>
<li>增长树：对原二叉树中度为1的结点， 增加一个空树叶 对原二叉树中的树叶， 增加两个空树叶</li>
<li>外通路长度（外路径）E： 根到每个外结点（增长树的叶子） 的路径长度的总和（边数） E&#x3D;3+3+2+3+4+4+3+3&#x3D;25 </li>
<li>内通路长度（内路径）I： 根到每个内结点（非叶子）的路径长度的总和（边 数）。 I&#x3D;2+1+0+3+2+2+1&#x3D;11 </li>
<li>结点的带权路径长度： 一个结点的权值与结点的路径长度的 乘积。</li>
<li>权的外路径长度： 各叶结点的带权路径长度之和。</li>
<li>带权的内路径长度：各非叶结点的带权路径长度之和。</li>
<li>霍夫曼树 1) <ol>
<li>给出m个实数W1，W2，…，Wm （m&gt;&#x3D;2） 作为m个外结 点的权构造一棵增长树， 使得带权外路径长度 </li>
<li>Wi l i最小。 m i&#x3D;1 其中l i 为从根结点出发到具有权为wi的外结点的通路长。</li>
</ol>
</li>
</ol>
</li>
<li>霍夫曼算法</li>
</ol>
<h1 id="第五章-·-散列表（Hash）-需要掌握代码"><a href="#第五章-·-散列表（Hash）-需要掌握代码" class="headerlink" title="第五章 · 散列表（Hash）(需要掌握代码)"></a>第五章 · 散列表（Hash）(需要掌握代码)</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ol>
<li>为了让插入和查找的时间复杂度为O(1)</li>
<li>代价是会有严重空间浪费</li>
<li>“hash值”是会冲突的，我们可以让冲突的数据挂在一个链表上，并且放在hash表的冲突的位置</li>
</ol>
<h2 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h2><ol>
<li>取余法<ol>
<li>H(key) &#x3D; Key % M</li>
<li>其中M是基本区长度的最大质数，这样的冲突概率最小。</li>
</ol>
</li>
<li>平方取中 todo</li>
<li>乘法杂凑函数<ol>
<li>H（Key) &#x3D; M * ((C * Key) % 1)向下取整</li>
<li>M是表的大小，C是任意无理数</li>
<li>原理是表达大小乘以一个0~1之间的数，得到下标</li>
</ol>
</li>
</ol>
<h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><ul>
<li>同义：算出来地址相同</li>
</ul>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><ol>
<li>发生冲突后往后面放，指导遇到空位置。</li>
<li>如果满了，就不放</li>
<li>缺点：堆积</li>
</ol>
<h3 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h3><ol>
<li>遇到冲突时，处理不一样。线性探测是一个一个往后找，二次探测是用一个平方算出来。<br>$$<br>h(x,i)&#x3D;(h(x)+i^<br>2<br> )modm<br>$$</li>
</ol>
<h3 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h3><ol>
<li>遇到冲突时，用另外一个完全不同的hash函数计算一个值，再从冲突位置按照这个值往后数。还冲突，再数。<br>$$<br>h(x,i)&#x3D;(h<br>1<br>​<br> (x)+i⋅h<br>2<br>​<br> (x))modm<br>$$</li>
</ol>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>冲突了就用单链表接在后面</p>
<h1 id="第六章-·-堆"><a href="#第六章-·-堆" class="headerlink" title="第六章 · 堆"></a>第六章 · 堆</h1><h2 id="最大（小）优先队列"><a href="#最大（小）优先队列" class="headerlink" title="最大（小）优先队列"></a>最大（小）优先队列</h2><h2 id="最大（小）堆"><a href="#最大（小）堆" class="headerlink" title="最大（小）堆"></a>最大（小）堆</h2><ol>
<li>性质<ol>
<li><strong>完全二叉树</strong>：最大堆必须是一个完全二叉树，即除了最后一层，其他层的节点都要满，最后一层的节点都集中在左侧。</li>
<li><strong>父节点大于或等于子节点</strong>：对于堆中的每一个父节点，其值都大于或等于它的两个子节点的值。换句话说，根节点的值是最大值。</li>
<li><strong>树的性质</strong>：最大堆的树结构是无序的，仅通过父子节点关系来确保堆性质</li>
</ol>
</li>
<li>算法：<ol>
<li><strong>插入（Insert）</strong>：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。</li>
<li><strong>删除最大元素（Extract Max）</strong>：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。</li>
</ol>
</li>
<li>求第K大元素：<ol>
<li><p>不用堆：</p>
<ol>
<li>1A算法：全部排序一遍，找到第K个。O(n^2^)</li>
<li>1B算法：取前K个数据排序，然后把后面的数据和前面K个数据中的最小值比较。如果小于，则跳过；若大于，则删除原来那个，把这个值插入合适位置。O(n*k)</li>
</ol>
</li>
<li><p>用堆</p>
<ol>
<li>6A算法：建堆，执行K次出堆。O(n*log(n))</li>
<li>6B算法：道理一样的，取前K个元素建堆，比较，重构。O(n*log(k))</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第七章-·-并查集"><a href="#第七章-·-并查集" class="headerlink" title="第七章 · 并查集"></a>第七章 · 并查集</h1><ol>
<li>定义：每个集合通过一个代表元素（root）来表示，每个元素都指向它所在集合的代表元素。通过这种方式，可以快速确定两个元素是否属于同一个集合，以及在需要时将两个集合合并成一个集合。</li>
<li>其物理层是森林，更进一步可以是数组。数组内容0或负数表示自己是父节点，非零表示父节点下标</li>
<li>操作：<ol>
<li><strong>Find 操作</strong>：用于查找某个元素所在的集合（即根节点），并在查找的过程中进行路径压缩，即每次查找让路径上的所有节点指向根节点，以减小树的高度，提高查找效率。</li>
<li><strong>Union 操作</strong>：用于合并两个集合，即将两个集合的代表元素连接在一起，通常按照某种规则（如按秩合并）来决定连接的方式，以保持树的平衡。为了不让union后的树形状太糟糕，采用下面的方法：<ol>
<li>在树根上缓存一个树高，把树高小的挂在树高大的上面</li>
</ol>
</li>
</ol>
</li>
<li>实现<ol>
<li>用一个数组来实现，根结点中放负数，而且是代表高度。</li>
</ol>
</li>
</ol>
<h1 id="第八章-·-图"><a href="#第八章-·-图" class="headerlink" title="第八章 · 图"></a>第八章 · 图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>有向图和无向图</p>
</li>
<li><p>完全图</p>
</li>
<li><p>e表示边，v表示节点</p>
</li>
<li><p>TD表示度数，ID表示入读，OD表示出度</p>
</li>
<li><p>$\sum^n_{i&#x3D;1}TD(v_i)&#x3D;2*e$</p>
</li>
<li><p>子图</p>
</li>
<li><p>连通分量：指的是一个图的一个子图，该子图是连通的，并且和图中任何其他子图都不连通。</p>
<ol>
<li>有向图的连通分量可以分为<strong>强连通分量</strong>（strongly connected component）和<strong>弱连通分量</strong>（weakly connected component）。<ul>
<li><strong>强连通分量</strong>：有向图中每个顶点都能到达该分量中的其他顶点。</li>
<li><strong>弱连通分量</strong>：忽略边的方向后，图是连通的。</li>
</ul>
</li>
</ol>
</li>
<li><p>生成树：实际上是极小连通子图</p>
</li>
</ol>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ol>
<li>邻接矩阵（数组）***<ol>
<li>矩阵的行列数都为v</li>
</ol>
</li>
<li>邻接表（链表）***<ol>
<li>对于无向图来说，邻接表节点数量是边的两倍；对有向图来说，是一样多的</li>
<li>每个表头代表起点，其后每个节点代表一个终点</li>
</ol>
</li>
<li>邻接多重表</li>
</ol>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><ol>
<li>定义：<ol>
<li>设G &#x3D;(V，E)是一个连通的无向图(或是强连通有向图) 从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE(G)，显然 G‘&#x3D;(V，TE)是G之子图， G‘被称为G的生成树(spanning tree)，也称为一个连通图.</li>
<li>n个结点的生成树有n-1条边。</li>
<li>生成树的代价(cost)：TE(G)上诸边的代价之和</li>
<li>生成树不唯一</li>
</ol>
</li>
</ol>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ol>
<li><p>概述</p>
<ol>
<li>三种算法： 1)边上权值为非负情况的从一个结点到其它各结点的最短路径 （单源最短路径）（Dijkstra算法） 2)边上权值为任意值的单源最短路径 3)边上权值为(任意值)的所有顶点之间的最短路径</li>
</ol>
</li>
<li><p>Dijkstra算法：</p>
<ol>
<li>起点V0，首先直接连接，不管是否直接连接。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png" alt="img"></a></p>
<ol>
<li>排好序后，V0-V1 10已经是最小的了，不可能再找到更短的路径</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png" alt="img"></a></p>
<ol>
<li>接下来，尝试V0-v2通过V1绕会不会比原来的更短(考虑V1-V2直连)，V0-V4从V1绕会不会比原来更短(考虑V2-V3直连)，如果短则更新，此时V0-V3是三者中最小值，所以选择V0-V3。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png" alt="img"></a></p>
<ol>
<li>尝试绕行V3，计算直连，更新掉，然后重复</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png" alt="img"></a></p>
<ol>
<li>红色是已经选择好的，绿色是绕行选择。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png" alt="img"></a></p>
<ol>
<li>进一步思考，就是只进行一步，不进行多不步。</li>
<li>总体来讲:不可能走更长的路径，然后回来</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png" alt="img"></a></p>
<ol>
<li>数值更新，路径数组对应位置更新</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png" alt="img"></a></p>
</li>
<li><p>贝尔曼·福特改进算法</p>
<ol>
<li>允许有负边，但是不允许有负环</li>
<li>思想是动态规划（迭代？），找到走一步的最短路径，再找两步以内的，一直到n-1步以内的。实际上是看现状加上直连边来看，每一个节点都可能会更新。</li>
</ol>
</li>
<li><p>floyed</p>
<ol>
<li>简单来说就是:每次都会选择一个中介点，然后遍历整个数组，更新相应的需要更新的数组。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png" alt="img"></li>
<li>在更新A时，也更新path矩阵，里面的值是到数第二个节点</li>
</ol>
</li>
</ol>
<h2 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h2><ol>
<li>用顶点表示活动的网络（AOV网络）<ol>
<li>AOV网（Activity On Vertex network)<br>用顶点表示活动，用弧表示活动间的优先关系的有向<br>图称为AOV网。<br>直接前驱，直接后继：&lt;i,j&gt;是网中一条弧，则i是j的<br>直接前驱，j是i的直接后继。<br>前驱，后继：从顶点i顶点j有一条有向路径，则称<br>i是j的前驱， j是i的后继。<br>AOV网中，不应该出现有向环</li>
<li>拓扑排序</li>
</ol>
</li>
<li>用边表示活动的网络（AOE网络）<ol>
<li>用边表示活动的网络（AOE网络, Activity On Edge Network）<br>又称为事件顶点网络<br>• 顶点：表示事件（event）<br>事件——状态。表示它的入边代表的活动已完成，它的出边<br>代表的活动可以开始，如下图v0表示整个工程开始<br>，v4表示a4，a5活动已完成a7，a8活动可开始。<br>有向边：表示活动。<br>边上的权——表示完成一项活动需要的时间</li>
<li>关键路径（critical path）<br>1)目的 : 利用事件顶点网络，研究完成整个工程需要多少时间<br>加快那些活动的速度后，可使整个工程提前完成。<br>2)关键路径：具有从开始顶点(源点）完成顶点（汇点）的<br>最长的路径<ol>
<li><p>一些定义</p>
<ol>
<li>对于事件:<ol>
<li>Ve[i]－表示事件Vi的可能最早发生时间。定义为从源点V0-&gt;Vi的最长路径长度, 如Ve[4]&#x3D;7天</li>
<li>Vl[i]－表示事件Vi的允许的最晚发生时间。是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi-&gt;Vn－1的最长路径长度。<strong>是从最后汇点时间长度-两者之间最长路径</strong></li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png" alt="img"></a></p>
<ol>
<li>解释:<ol>
<li>计算到最后汇点的总共最短时间:找到从源点到汇点的最大路径</li>
<li>最早12，因为之前不能做。</li>
<li>最晚12，是因为如果这时候不开始，最后完成不了。</li>
</ol>
</li>
<li>对于活动:<ol>
<li>e[k]－表示活动ak&#x3D;&lt;Vi,Vj&gt;的可能的最早开始时间。 即等于事件Vi的可能最早发生时间。 e[k]&#x3D;Ve[i]</li>
<li>l[k]－表示活动ak&#x3D; &lt;Vi,Vj&gt; 的允许的最迟开始时间 l[k]＝Vl[j]-dur(&lt;i,j&gt;);</li>
<li>l[k]-e[k]－表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack time)</li>
<li>l[k]&#x3D;&#x3D;e[k]－表示活动ak是没有时间余量的<strong>关键活动</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>找关键路径</p>
<ol>
<li>找关键活动的算法：<br>（1）定义几个量<br>对事件而言<br>Ve[i]－表示事件Vi的可能最早发生时间<br>定义为从源点V0 Vi的最长路径长度, 如Ve[4]&#x3D;7天<br>Vl[i]－表示事件Vi的允许的最晚发生时间。<br>是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，<br>事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi  Vn－1的最<br>长路径长度。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第九章-·-排序"><a href="#第九章-·-排序" class="headerlink" title="第九章 · 排序"></a>第九章 · 排序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>稳定性：如果待排序的对象序列中，含有多个关键码值 相等的对象，用某种方法排序后，这些对象的 相对次序不变的，则是稳定的，否则为不稳定 的。</li>
<li>两大类：<ol>
<li>内排序：对内存中的n个对象进行排序。</li>
<li>外排序：内存放不下，还要使用外存的 排序。</li>
</ol>
</li>
<li>排序的算法分析： <ol>
<li>时间开销—比较次数，移动次数 </li>
<li>所需的附加空间</li>
</ol>
</li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ol>
<li>思想：一个一个排</li>
<li>O(n^2^)</li>
<li>稳定的</li>
</ol>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ol>
<li>在直接插入排序的基础上，让比较的过程变成折半查找，而不是线性查找.注意，是在已经排好序的部分进行的二分查找。</li>
<li>O(n*log n)</li>
<li>稳定的</li>
</ol>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol>
<li><p>又称为缩小增量排序</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220142720571.png" alt="image-20241220142720571"></p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shellsort</span><span class="params">(datalist&lt;Type&gt;&amp; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> gap = list.CurrentSize / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(list, gap);</span><br><span class="line">        gap = (gap == <span class="number">2</span>) ? <span class="number">1</span> : gap / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> gap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; list.CurrentSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Element&lt;Type&gt; temp = list.Vector[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= gap &amp;&amp; temp.<span class="built_in">getkey</span>() &lt; list.Vector[j - gap].<span class="built_in">getkey</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[j] = list.Vector[j - gap];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        list.Vector[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>时间复杂度大概在n^1.3^左右</p>
</li>
<li><p>不稳定</p>
</li>
</ol>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li><p><strong>注意，我们可以记录是否有交换，如果某一次迭代时没有交换，就可以终止了</strong>。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(datalist&lt;Type&gt;&amp; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pass = <span class="number">1</span>; </span><br><span class="line">    <span class="type">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pass &lt; list.CurrentSize &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="number">0</span>;  <span class="comment">// 重置交换标志</span></span><br><span class="line">        <span class="built_in">BubbleExchange</span>(list, pass, exchange);  <span class="comment">// 执行一轮交换</span></span><br><span class="line">        pass++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleExchange</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> pass, <span class="type">int</span>&amp; exchange)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行一轮交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = list.CurrentSize - <span class="number">1</span>; j &gt;= pass; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.Vector[j - <span class="number">1</span>].<span class="built_in">getkey</span>() &gt; list.Vector[j].<span class="built_in">getkey</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(list.Vector[j - <span class="number">1</span>], list.Vector[j]);  <span class="comment">// 交换元素</span></span><br><span class="line">            exchange = <span class="number">1</span>;  <span class="comment">// 记录发生交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>O(n^2^)</p>
</li>
<li><p>稳定的</p>
</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序 ***"></a>快速排序 ***</h3><ol>
<li><p>方法： 1）在n个对象中，取一个对象（如第一个对象——基 准pivot），按该对象的关键码把所有 该关键码 的对象分划在它的左边。该关键码的对象分划 在它的右边。 2） 对左边和右边（子序列）分别再用快排序。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">partition</span>(list, left, right);  <span class="comment">// 获取基准元素的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(list, left, pivotpos - <span class="number">1</span>);  <span class="comment">// 排序左侧子数组</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(list, pivotpos + <span class="number">1</span>, right);  <span class="comment">// 排序右侧子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> low, <span class="type">const</span> <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = high;</span><br><span class="line">    Element&lt;Type&gt; pivot = list.Vector[low];  <span class="comment">// 选择基准元素（这里选择第一个元素）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (list.Vector[j].<span class="built_in">getkey</span>() &gt; pivot.<span class="built_in">getkey</span>() &amp;&amp; i &lt; j) j--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左向右找大于基准值的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[i] = list.Vector[j];  <span class="comment">// 交换</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (list.Vector[i].<span class="built_in">getkey</span>() &lt; pivot.<span class="built_in">getkey</span>() &amp;&amp; i &lt; j) i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[j] = list.Vector[i];  <span class="comment">// 交换</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准值放到正确的位置</span></span><br><span class="line">    list.Vector[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// 返回基准值的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>不稳定</p>
</li>
<li><p>时间平均O(n*log n)</p>
</li>
<li><p>空间：O(log n) ~ O(n)</p>
</li>
<li><p>不稳定</p>
</li>
<li><p>选取枢纽元</p>
<ol>
<li>用第一个元素作pivot是不太好的。</li>
<li>方法1：随机选取pivot, 但随机数的生成一般是昂贵的。 </li>
<li>方法2：三数中值分割法（Median-of-Three partitioning) N个数，最好选第N&#x2F;2个最大数，这是最好的中值，但这是很困难的。 一般选左端、右端和中心位置上的三个元素的中值作为枢纽元。 8, 1, 4, 9, 6, 3, 5, 2, 7, 0 (8, 6, 0) 具体实现时：将 8，6，0 先排序，即 0, 1, 4, 9, 6, 3, 5, 2 , 7, 8, 得到中值pivot为 6 。</li>
</ol>
</li>
<li><p>分割策略：将pivot与最后倒数第二个元素交换，使得pivot离开要被分割的数据段。然后， i 指向第一个元素，j 指向倒数第二个元素。 0, 1, 4, 9, 7, 3, 5, 2, 6, 8 然后进行分</p>
</li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><ol>
<li>思想：首先在n个记录中选出关键码最小（最大）的 记录，然后与第一个记录（最后第n个记录） 交换位置，再在其余的n-1个记录中选关键码 最小（最大）的记录，然后与第二 个记录（ 第n-1个记录）交换位置，直至选择了n－1个 记录。</li>
<li>不稳定</li>
<li>每次寻找都要扫描</li>
</ol>
<h3 id="竞标赛排序"><a href="#竞标赛排序" class="headerlink" title="竞标赛排序"></a>竞标赛排序</h3><ol>
<li>直接选择排序存在重复做比较的情况，锦标赛 排序克服了这一缺点。 </li>
<li>方法： 1. n个对象的关键码两两比较得到 n&#x2F;2 个 比较的优胜 者(关键码小者)保留下来, 再对这 n&#x2F;2 个对象再进行关键 码的两两比较, ……直至选出一个最小的关键码为止。 如果n不是2的K次幂，则让叶结点数补足到满足 2 k</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153506582.png" alt="image-20241220153506582"></li>
<li>树根为当前最小元素。取出后，把对应位置改为无穷</li>
<li>第一次扫描需要建树，但是后面更新只需要比较树高。</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153752102.png" alt="image-20241220153752102"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ol>
<li>分治思想，会合并</li>
</ol>
<h1 id="笔记-·-错题集"><a href="#笔记-·-错题集" class="headerlink" title="笔记 · 错题集"></a>笔记 · 错题集</h1><ol>
<li><p>如何求时间复杂度？</p>
<ol>
<li><p>步骤：</p>
<ol>
<li>找关键步骤。明确到底那些地方才算时间。</li>
<li>抓最大规模。如果问题有多个部分，取最慢、最复杂的部分算时间复杂度（其实大O就是这样）。</li>
<li>计算。嵌套向乘，平级相加。</li>
</ol>
</li>
<li><p>注意：</p>
<ul>
<li><p>一定要明确那些地方算时间，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for( i = 1; i &lt; n; i++ )     </span><br><span class="line">	for( j = 0; j &lt; i*i; j++ )</span><br><span class="line">    	if( j % i == 0 )</span><br><span class="line">        	for( k = 0; k &lt; j; k++ )</span><br><span class="line">            	sum++; </span><br></pre></td></tr></table></figure>


<p>不要把所有的循环都算到时间复杂度里，要抓的是执行了多少次sum++。</p>
</li>
<li><p>写成加和的形式，不要写成乘法，否则容易搞混。有一重循环就写一重加和。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>链表实现栈和队列：</p>
<ol>
<li>栈：表头为栈顶</li>
<li>队列：两个指针记录首尾</li>
</ol>
</li>
<li><p><code>Comparable</code> 不是一个类，而是一个<strong>接口</strong>，它用于在 Java 中定义对象的自然顺序。任何实现了 <code>Comparable</code> 接口的类都可以通过该接口提供的 <code>compareTo</code> 方法来进行对象的比较。这个接口是 Java 类库中非常重要的一部分，它允许你定义自定义的排序规则。</p>
</li>
</ol>
<h1 id="笔记-·-算法集"><a href="#笔记-·-算法集" class="headerlink" title="笔记 · 算法集"></a>笔记 · 算法集</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func(int[] a, int size)&#123;</span><br><span class="line">	for(int n = size; n &gt; 1; n--)&#123;</span><br><span class="line">		int j = Max(a, n); //找到数组a中的最大数，返回其索引</span><br><span class="line">		swap(a[j], a&#123;n-1&#125;); //交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>二重循环</p>
</li>
<li><p>时间复杂度为：<br>$$<br>(n-1)+(n-2)+…+3+2+1&#x3D;\frac{n*(n-1)}{2} ··· O(n^2)<br>$$</p>
</li>
</ul>
<h3 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func(int[] a, int size)&#123;</span><br><span class="line">	for(int i = 0; i &lt; size-1; i++)&#123;</span><br><span class="line">		if(a[i] &gt; a[i+1])swap(a[i], a[i+1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"> 	for(int i = size; i &gt; 1; i--)&#123;</span><br><span class="line"> 		func(a, i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>二重循环</li>
<li>时间复杂度：</li>
</ul>
<p>$$<br>O(n^2)<br>$$</p>
<h3 id="秩排序（Rank-Sort）"><a href="#秩排序（Rank-Sort）" class="headerlink" title="秩排序（Rank Sort） ***"></a>秩排序（Rank Sort） ***</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排名</span></span><br><span class="line"><span class="built_in">Rank</span>(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span>[] r)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//r数组初始化</span></span><br><span class="line">		r[i] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt;= a[i])</span><br><span class="line">				r&#123;i&#125;++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Rearrange</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span>[] r)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// In-place rearrangement into sorted order</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (r[i] != i) &#123;</span><br><span class="line">				<span class="type">int</span> t = r[i];</span><br><span class="line">				<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">				<span class="built_in">swap</span>(r[i], r[t]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>解释：先给数组里的每个数算排名，然后把数据按照排名放在对应的位置。</li>
<li>时间复杂度：</li>
</ul>
<h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>理解：<ol>
<li>从第二个元素开始，假设第一个元素已排序。</li>
<li>将当前元素与已排序部分的元素逐个比较，从后向前找到合适的位置。</li>
<li>将当前元素插入到适当的位置，移动已排序部分的元素以腾出空间。</li>
<li>重复以上步骤，直到所有元素都已排序。</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InsertionSort( int [ ]a, int n)&#123; </span><br><span class="line">	for(int i=0;i&lt;n;i++) &#123; </span><br><span class="line">		//insert a[i] into a[0:n-1]</span><br><span class="line">		int t=a[i];</span><br><span class="line">			int j;</span><br><span class="line">		for(j=i-1; j&gt;=0&amp;&amp;t&lt;a[j]; j--)</span><br><span class="line">			a[j+1]=a[j];</span><br><span class="line">		a[j+1]=t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>时间复杂度：$O(n^2)$</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li>基数：用什么进制，基数就是几。</li>
<li>理解：<ol>
<li>进桶。有基数个桶（每个桶实际上是单链表），把数字按照最高位放进桶里。</li>
<li>出桶。把每个桶接到前一个桶后面，这样就实现了按照某一位从小到大的排序。</li>
<li>循环，每次比较下一位。</li>
</ol>
</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ol>
<li>有向图G&#x3D;(V,E),V里结点的线性序列（vi1,vi2,…,vin),<br>如果满足: 在G中从结点vi到vj有一条路径，则序列中结点<br>vi必先于结点vj，称这样的线性序列为一拓扑序列。</li>
<li>拓扑序列不是唯一的</li>
<li>算法思想：<br>1）从图中选择一个入度为0的结点输出之。<br>（如果一个图中，同时存在多个入度为0的结点，则随便<br>输出那一个结点）<br>2）从图中删掉此结点及其所有的出边。<br>3）反复执行以上步骤：a）直到所有结点都输出了，则算法结束<br>b）如果图中还有结点，但入度不为0，则说<br>明有环路</li>
</ol>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>字面意思</p>
<ul>
<li>时间复杂度O(n)</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="分治法：求最大子序列和（还有更简的算法）"><a href="#分治法：求最大子序列和（还有更简的算法）" class="headerlink" title="分治法：求最大子序列和（还有更简的算法）"></a>分治法：求最大子序列和（还有更简的算法）</h3><ol>
<li><p>思想：</p>
<ol>
<li>从中间分裂成左右两个数组，分别递归调用求最大序列和</li>
<li>求横跨左右的最大序列和：以中点为边界，分别求向左、右的最大子序列，再把两者相加，得到横跨左右的最大子序列和。</li>
<li>把左最大、右最大、横跨最大三者相比较，保留最大的。</li>
</ol>
</li>
<li><p>时间复杂度：$O(n·log(n))$</p>
<ul>
<li>分：每次递归都是折半的，所以一共会分出log(n)层</li>
<li>治：每次递归都要调用两次，处理左边和右边。所以实际上如果我们把同一层的调用拼在一起，每一层都处理了完整的规模为O(n)的数据。</li>
<li>每层处理的规模为O(n)，有log(n)层，则有时间复杂度$O(n·log(n))$.</li>
</ul>
</li>
</ol>
<h3 id="寻找数组中第K小元素"><a href="#寻找数组中第K小元素" class="headerlink" title="寻找数组中第K小元素"></a>寻找数组中第K小元素</h3><ul>
<li>实际上就是在做选择排序，但是把问题规模限制在K，即做K个元素的排序后就结束</li>
</ul>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><ol>
<li><p>用队列实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHui</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printYangHui</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用队列来保存计算过程中的值</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">1</span>); <span class="comment">// 初始化队列</span></span><br><span class="line">        q.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印前置空格以对齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">10</span> - i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在每行计算开始前添加一个辅助的 0</span></span><br><span class="line">            q.add(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于记录前一个出队元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">                q.add(s + t); <span class="comment">// 将新的值入队</span></span><br><span class="line">                s = t; <span class="comment">// 更新 s</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">2</span>) &#123; <span class="comment">// 控制打印范围</span></span><br><span class="line">                    System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 打印前 5 行杨辉三角</span></span><br><span class="line">        printYangHui(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
<li><p>用可变长的二维数组实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yanghui</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 杨辉三角的行数</span></span><br><span class="line">        <span class="type">int</span>[][] mat = <span class="keyword">new</span> <span class="title class_">int</span>[n][]; <span class="comment">// 申请第一维的存储空间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成杨辉三角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mat[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>]; <span class="comment">// 申请第二维的存储空间，每行长度不同</span></span><br><span class="line">            mat[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 每行的第一个元素为 1</span></span><br><span class="line">            mat[i][i] = <span class="number">1</span>; <span class="comment">// 每行的最后一个元素为 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                mat[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j]; <span class="comment">// 计算中间元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印杨辉三角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mat.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 打印前置空格，用于对齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印每行的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mat[i].length; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span> + mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rear: 每次指向要出队列的前一个结点</span></span><br><span class="line"><span class="comment">//出队列的人也用链表来表示：</span></span><br><span class="line"><span class="comment">//head: 指向出队列结点链表的开头结点</span></span><br><span class="line"><span class="comment">//p: 指向出队列结点链表的尾结点</span></span><br><span class="line"><span class="comment">//以上rear, head, p都是ListNode的一个对象引用。</span></span><br><span class="line"><span class="number">1.</span> w = m;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">	<span class="number">1</span>) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j&lt;=w-<span class="number">1</span>; j++) </span><br><span class="line">		rear = rear.link;</span><br><span class="line">	<span class="number">2</span>) <span class="keyword">if</span> (i = = <span class="number">1</span>)&#123;</span><br><span class="line"> 	head = rear.link ; p = head; &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line"> 		p.link = rear.link; </span><br><span class="line">		p = rear.link;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="number">3</span>) rear.link = p.link;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">3.</span> P.link = rear;</span><br><span class="line">	rear.link = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="辗转相除法：求最大公因数"><a href="#辗转相除法：求最大公因数" class="headerlink" title="辗转相除法：求最大公因数"></a>辗转相除法：求最大公因数</h3><ol>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static long gcd( long m, long n )&#123; </span><br><span class="line">	while( n != 0 )&#123; </span><br><span class="line">		long rem = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = rem;</span><br><span class="line">	&#125;</span><br><span class="line">	return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>最坏情况是m, n取斐波那契数列的连续两位。</li>
<li>时间复杂度：估计得$O(n·log(n))$</li>
</ol>
</li>
</ol>
<h3 id="一般二叉搜索树"><a href="#一般二叉搜索树" class="headerlink" title="一般二叉搜索树"></a>一般二叉搜索树</h3><ul>
<li>每个节点有一个唯一的key值，左子结点比自己小，右子节点比自己大</li>
</ul>
<h4 id="查找算法（递归）"><a href="#查找算法（递归）" class="headerlink" title="查找算法（递归）"></a>查找算法（递归）</h4><ul>
<li><p>每个节点都有一个key值，当要查找的节点的key值小于当前节点，则只搜索左子树，反之搜索右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Find operation for binary search trees</span><br><span class="line">private BinaryNode find( Comparable x, BinaryNode t )&#123; 		if( t = = null )</span><br><span class="line">		return null;</span><br><span class="line">	if( x. compareTo( t.element ) &lt; 0 )</span><br><span class="line">		return find( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		return find( x, t.right );</span><br><span class="line">	else</span><br><span class="line">		return t; //Match</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="插入算法（递归）"><a href="#插入算法（递归）" class="headerlink" title="插入算法（递归）"></a>插入算法（递归）</h4><ul>
<li><p>不能够插入已有的key</p>
</li>
<li><p>当要插入的节点的key值小于当前节点，则只在左子树插入，反之在右子树插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private BinaryNode insert( Comparable x, BinaryNode t )&#123;</span><br><span class="line">	if( t = = null )</span><br><span class="line">		t = new BinaryNode( x, null, null );</span><br><span class="line">	else if( x.compareTo( t.element ) &lt; 0 )</span><br><span class="line">		t.left = insert( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		t.right = insert( x, t.right );</span><br><span class="line">	else</span><br><span class="line">		; //duplicate; do nothing</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法 ***"></a>删除算法 ***</h4><ul>
<li><p>考虑：</p>
<ul>
<li>P是叶节点</li>
<li>P有一棵子树</li>
<li>P有两棵子树</li>
</ul>
</li>
<li><p>前两种情况好理解，第三种情况下删除之后这个位子空出来怎么办呢?</p>
<ul>
<li>找到该节点左子树的最大节点或右子树的最小节点，代替到这个位置。找到的最大或最小节点一定至多有一颗子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private BinaryNode remove( Comparable x, BinaryNode t )&#123;</span><br><span class="line">	if( t == null )</span><br><span class="line">		return t;</span><br><span class="line">	if( x.compareTo( t.element ) &lt; 0 )</span><br><span class="line">		t.left = remove( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		t.right = remove( x, t.right );</span><br><span class="line">	else if( t.left != null &amp;&amp; t.right != null )&#123;	</span><br><span class="line">		t.element = findMin( t.right ).element;</span><br><span class="line">		t.right = remove( t.element , t.right );</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		t = ( t.left != null ) ? t.left : t.right;</span><br><span class="line">	return t; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉搜索树（AVL-Tree）-1"><a href="#平衡二叉搜索树（AVL-Tree）-1" class="headerlink" title="平衡二叉搜索树（AVL Tree）"></a>平衡二叉搜索树（AVL Tree）</h3><h4 id="查找算法-1"><a href="#查找算法-1" class="headerlink" title="查找算法"></a>查找算法</h4><ul>
<li>同一般搜索树</li>
</ul>
<h4 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法 ***"></a>插入算法 ***</h4><ul>
<li>考虑情景：要插入一个比根节点大的节点，但是右子树的高度已经比左子树大一了。<ul>
<li>解决方案：旋转。在这个情境中，左单旋，让右子节点变成根节点，原来的根节点变成左子结点，其余不变。然后向右子树插入。</li>
</ul>
</li>
<li>但是要讨论插入的位置，在外侧还是在内侧</li>
</ul>
<p>![屏幕截图 2024-11-01 152713](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-11-01 152713.png)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241101152900625.png" alt="image-20241101152900625"></p>
<ul>
<li>也可这样讲：插入一个新结点后，需要从插入位置沿通向根 的路径回溯，检查各结点左右子树的高度差， 如果发现某点高度不平衡则停止回溯。 </li>
<li>单旋转：外侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一直线A，C，E </li>
<li>双旋转：内侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一折线A，C，D<ul>
<li>左双旋则先左旋再右旋，右双旋反之</li>
</ul>
</li>
<li>*以上以右外侧，右内侧为例，左外侧，左内侧是对称的。 与前面对称的情况：左外侧，左内侧</li>
<li>时间复杂度：对数关系</li>
</ul>
<h4 id="删除算法-1"><a href="#删除算法-1" class="headerlink" title="删除算法"></a>删除算法</h4><ul>
<li>在一般二叉搜索树的删除算法基础上，引入平衡性检查和旋转</li>
<li>每个节点都有一个自己的树高的数据，用以回溯时检查平衡性</li>
</ul>
<h3 id="m路搜索树-1"><a href="#m路搜索树-1" class="headerlink" title="m路搜索树"></a>m路搜索树</h3><ol>
<li>查找算法<ol>
<li>从左到右排好序的，直接找就好了</li>
</ol>
</li>
<li>插入算法<ol>
<li>先查找，找到了就不用插入</li>
<li>找不到：<ol>
<li>找到了要插入的那个位置，如果key值没满，则插入一个key值；如果满了，就在那个位置的分叉上插入一个节点</li>
</ol>
</li>
</ol>
</li>
<li>删除算法<ol>
<li>没有子树：直接删除</li>
<li>一颗子树：找到对接近自己的key来代替自己</li>
<li>两颗子树：找到左或右子树中最接近自己的Key代替</li>
</ol>
</li>
</ol>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><ol>
<li><p>查找算法：直接找</p>
<ol>
<li>树高：$log_m(n+1)&lt;&#x3D;h&lt;&#x3D;1+log_{m&#x2F;2}(n+1)&#x2F;2$</li>
</ol>
</li>
<li><p>插入算法：</p>
<ol>
<li>总是先在叶节点插入</li>
<li>如果节点满了，就把节点从中间key值分裂，并在父节点中插入。对于根节点，把根节点分裂，提出新的根节点。</li>
</ol>
<p>![image-20241105175508641](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-11-05 175449.png)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105175530052.png" alt="image-20241105175530052"></p>
</li>
<li><p>删除算法：</p>
<ol>
<li><p>所有删除会转化为叶节点的删除</p>
</li>
<li><p>若下溢，先找兄弟节点借，让旁边的key到父节点，从父节点拉下一个key下来</p>
</li>
<li><p>没得借的，说明两个都是最小数（m&#x2F;2-1），就合并。合并后要从父节点拉一个key下来，注意检查父节点下溢问题，要满足B-Tree要求。</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126202223795.png" alt="image-20241126202223795"></p>
</li>
</ol>
</li>
</ol>
<h3 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h3><ol>
<li>插入：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。</li>
<li>删除最大元素：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。</li>
<li>建堆（初始化）：拿到一颗二叉树，有两种初始化方法。但是，完全二叉树的绝大多数节点都集中在底层附近，所以我们选择<strong>下滤</strong>算法，这样绝大多数节点跑的路径短，少数节点跑的路径长。注意，在数组中，下标为i的节点的父节点下标为i&#x2F;2。<ol>
<li>由底向上（更优）：总共有n个节点。叶节点不用下滤，我们从倒数第二层开始，所以索引从n&#x2F;2开始往下走，对每个节点做下滤。做完之后就完成了。</li>
<li>由顶向下：依次插入节点，然后做上滤（也只能上滤）。</li>
</ol>
</li>
<li>排序算法：以数组为物理层为例<ol>
<li>如何不额外创建数组就实现排序呢？当你从最大堆中取出根节点（最大值）后，剩下的节点要重构，这样数组的最后就会空出一格来，这样你可以把最大值放在最后。做到最后，数组就排序好了。</li>
<li>工作流程：<ol>
<li>先建堆</li>
<li>再排序（取出最大值，放在最后）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ol>
<li><p>深度优先DFS</p>
<ol>
<li><p>思想: 从图中某个顶点V0出发,访问它,然后选择一个 V0 邻接到的未被访问的一个邻接点V1出发深度优先遍 历图,当遇到一个所有邻接于它的结点都被访问过了的 结点U时,回退到前一次刚被访问过的拥有未被访问的 邻接点W,再从W出发深度遍历,……直到连通图中的所 有顶点都被访问过为止.</p>
</li>
<li><pre><code class="language-c++">//利用的是邻接矩阵来表示的图
//C++写的
//主过程:
template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS( ) {
    int *visited=new int[NumVertices];
    for ( int i=0; i&lt;NumVertices; i++)
        visited[i]=0;
        DFS(0,visited);//从顶点0开始深度优先搜索
        delete[] visited;//释放visited的空间
    }
//子过程
template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS(int v, visited[]) {
    cout&lt;&lt;GetValue(v)&lt;&lt;&quot;&quot;;
    visited[v]=1;
    int w = GetFirstNeighbor(v);
    while (w!=-1) {
        if(!visited[w])
            DFS(w,visited);//最坏情况，就是每一次w都没有被访问过
        w = GetNextNeighbor(v,w);
    }
    //无论如何，最坏情况下访问次数，也就只能是图中所有边的个数。
    //也就是对邻接矩阵所有边会被扫一遍
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   3. 用邻接表表示 O(n+e)</span><br><span class="line"></span><br><span class="line">   4. 用邻接矩阵表示 O(n2)</span><br><span class="line"></span><br><span class="line">2. 广度优先BFS</span><br><span class="line"></span><br><span class="line">   - 广度优先算法是一种先进先出的算法，所以常常用队列来实现</span><br><span class="line"></span><br><span class="line">   1. 思想：从图中某顶点V0出发，在访问了V0之后依次访</span><br><span class="line">      问v0的各个未曾访问过的邻接点，然后分别从这些邻接</span><br><span class="line">      点出发广度优先遍历图，直至图中所有顶点都被访问</span><br><span class="line">      到为止.</span><br><span class="line"></span><br><span class="line">   2. 算法同样需要一个辅助数组visited[] 表示顶点是否被访问过. 还需要一个队列,记正在访问的这一层和上一层的顶点. 算法显然是非递归的.</span><br><span class="line"></span><br><span class="line">   3. ```c++</span><br><span class="line">      template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::BFS(int v) &#123;</span><br><span class="line">          //这个算法使用了队列</span><br><span class="line">          int* visited=new int[NumVertices];</span><br><span class="line">          for (int i=0; i&lt;NumVertices; i++)</span><br><span class="line">              visited[i]=0;</span><br><span class="line">          cout &lt;&lt; GetValue(v) &lt;&lt; &quot;&quot;;</span><br><span class="line">      </span><br><span class="line">          //访问结点</span><br><span class="line">          visited[v]=1;</span><br><span class="line">      </span><br><span class="line">          //使用队列来存储顶点</span><br><span class="line">          queue&lt;int&gt; q;</span><br><span class="line">          q.EnQueue(v);</span><br><span class="line">          while(!q.IsEmpty()) &#123;</span><br><span class="line">              v= q.DeQueue();</span><br><span class="line">              int w= GetFirstNeighbor(v);</span><br><span class="line">              while (w!=-1) &#123;</span><br><span class="line">                  if(!visited[w]) &#123;</span><br><span class="line">                      cout&lt;&lt;GetValue(w)&lt;&lt;&quot;&quot;; </span><br><span class="line">                      visited[w]=1;</span><br><span class="line">                      q.EnQueue(w);</span><br><span class="line">                  &#125;</span><br><span class="line">                  w= GetNextNeighbor(v,w);</span><br><span class="line">                  //访问完成一层的结点</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          delete[] visited;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="贪心算法：最小生成树"><a href="#贪心算法：最小生成树" class="headerlink" title="贪心算法：最小生成树"></a>贪心算法：最小生成树</h4><ol>
<li><p>Prim（贪点）</p>
<ol>
<li>优化<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241206153859993.png" alt="image-20241206153859993"><ol>
<li>优化内容：<ol>
<li>使用两个数组Lowcost[ ]、nearvex[ ]</li>
<li>Lowcost[]:存放生成树顶点集合内顶点到生成树外各顶点的边上的当前最小权值</li>
<li>nearvex[]:记录生成树顶点集合外各顶点，距离集合内那个顶点最近。</li>
</ol>
</li>
<li>步骤：<ol>
<li>在Lowcost[ ]中选择nearvex[i]不等于-1,且lowcost[i] 最小的边用v标记它。，则选中的权值最小的边为(nearvex[v],v), 相应的权值为lowcost[v]。 例如在上面图中第一次选中的v&#x3D;5;则边(0，5)，是选中的权值最小的边，相应的权值为lowcost[5]&#x3D;10。 反复做以下工作</li>
<li>将nearvex[v] 改为-1，表示它已加入生成树顶点集合。将边(nearvex[v],v,lowcost[v])加入生成树的边集合。</li>
<li>修改。取lowcost[i]&#x3D;min{lowcost[i],Edge[v][i]},即用生成树顶点集合外各顶 点i到刚加入该集合的新顶点 v的距离(Edge[v][i])与原来它所到生成树顶点 集合中顶点的最短距离lowcost[i]做比较，取距离近的，作为这些集合外顶 点到生成树顶点集合内顶点的最短距离。</li>
<li>如果生成树顶点集合外的顶点i到刚加入该集合新顶点v的距离比原来它 到生成树顶点集合中顶点的最短距离还要近，则修改nearvex[i]: nearvex[i]&#x3D;v 表示生成树外顶点i到生成树的内顶点v 当前距离最短。</li>
</ol>
</li>
<li>O(n^2^)</li>
</ol>
</li>
</ol>
</li>
<li><p>Kruskal（贪边），小细节：用并查集判断回路</p>
<p>1. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Graph&lt;string,<span class="type">float</span>&gt;::<span class="built_in">Kruskal</span>(MinSpanTree&amp;T) &#123;</span><br><span class="line">    <span class="comment">//结果赋值给T</span></span><br><span class="line">    MSTEdgeNode e;</span><br><span class="line">    MinHeap&lt;MSTEdgeNode&gt;<span class="built_in">H</span>(currentEdges);</span><br><span class="line">    <span class="type">int</span> NumVertices=VerticesList.Last , u , v ;</span><br><span class="line">    <span class="function">Ufsets <span class="title">F</span><span class="params">(NumVertices)</span></span>;<span class="comment">//建立n个单元素的连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;NumVertices;u++)</span><br><span class="line">        <span class="keyword">for</span> (v=u<span class="number">+1</span>;v&lt;NumVertices;v++)</span><br><span class="line">            <span class="keyword">if</span>(Edge[u][v]!=MAXINT) &#123;</span><br><span class="line">                e.tail=u;</span><br><span class="line">                e.head=v;</span><br><span class="line">                e.cost=Edge[u][v];</span><br><span class="line">                H.<span class="built_in">insert</span>(e);</span><br><span class="line">                <span class="comment">//完成堆的初始化，将每一条边插入到优先级队列中去</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;<span class="comment">//生成树边计数</span></span><br><span class="line">    <span class="keyword">while</span>(count&lt;NumVertices) &#123;</span><br><span class="line">        H.<span class="built_in">RemoveMin</span>(e);</span><br><span class="line">        u=F.<span class="built_in">Find</span>(e.tail);<span class="comment">//找到并查集的树根</span></span><br><span class="line">        v=F.<span class="built_in">Find</span>(e.head);<span class="comment">//找到并查集的树根</span></span><br><span class="line">        <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">            <span class="comment">//并查集做回边检测，在同一个并查集中就是一个回边，不然就不是</span></span><br><span class="line">            F.<span class="built_in">union</span>(u,v);</span><br><span class="line">            T.<span class="built_in">Insert</span>(e);</span><br><span class="line">            count++;<span class="comment">//计数已经查找出来的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最坏的情况时所有的边都被访问一次，比如目标边是最后一条边。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>算法分析：<ol>
<li>建立e条边的最小堆<ol>
<li>检测邻接矩阵O(n2)</li>
<li>每插入一条边，执行一次 fiterup() 算法：log2e 所以，总的建堆时间为O(elog2e)</li>
</ol>
</li>
<li>构造最小生成树时<ol>
<li>e次出堆操作：每一次出堆，执行一次filterdown(), 总时间为O(elog2e)<ul>
<li>没有考虑悬挂问题</li>
</ul>
</li>
<li>2e次find操作：O(elog2n)，树高是log2n<ul>
<li>从头开始生成，两个高为1的树，做union，才有高度为2的树</li>
<li>两个高为2的树，做union，才有高度为3的树</li>
<li>树的高度最坏情况下是log2n，当切仅当第一个二叉树</li>
</ul>
</li>
<li>n-1次union操作：O(n)</li>
<li>所以，总的计算时间为O(elog2e+elog2n+n2+n)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="笔记-·-代码集"><a href="#笔记-·-代码集" class="headerlink" title="笔记 · 代码集"></a>笔记 · 代码集</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li><p>ListNode：代表结点的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;   </span><br><span class="line">    object element;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode( object theElement) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode( object theElement, ListNode n) &#123;</span><br><span class="line">        element = theElement; </span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
<li><p>LinkedListItr：代表游标(指针）位置的类。这里很重要！在Java中已经有一个封装好的类了，不要再自己用指针了。?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListItr</span> &#123;</span><br><span class="line">    LinkedListItr( ListNode  theNode) &#123;</span><br><span class="line">        current = theNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPastEnd</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> current == <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> object <span class="title function_">retrieve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获得当前节点的数据</span></span><br><span class="line">        <span class="keyword">return</span> isPastEnd( ) ? <span class="literal">null</span> : current.element; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">advance</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( ! isPastEnd( ) ) current = current.next; </span><br><span class="line">    &#125;</span><br><span class="line">    ListNode current; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>LinkedList：代表表本身的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode header;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">( )</span> &#123;<span class="comment">//这里是含有表头节点的单链表，如果不带表头的话，应该是heder = null</span></span><br><span class="line">        header = <span class="keyword">new</span> <span class="title class_">ListNode</span>( <span class="literal">null</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> header.next = = <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">( )</span> &#123;</span><br><span class="line">        header.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向头指针的Itr</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">zeroth</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( header );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向第一个项的Itr</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">first</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( header.next );</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">find</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">findPrevious</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">( object x, LinkedListItr p )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkedListItr <span class="title function_">find</span> <span class="params">(object x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">itr</span> <span class="operator">=</span> header.next;</span><br><span class="line">    <span class="keyword">while</span> ( itr != <span class="literal">null</span> &amp;&amp; !itr.element.equals( x ))</span><br><span class="line">        itr = itr.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( itr );</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



</li>
<li><p>移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">( object x )</span> &#123;</span><br><span class="line">    <span class="type">LinkedListItr</span> <span class="variable">p</span> <span class="operator">=</span> findprevious( x );</span><br><span class="line">    <span class="keyword">if</span>( p.current.next != <span class="literal">null</span> )</span><br><span class="line">        p.current.next = p.current.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>约瑟夫问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">w = m;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=w-<span class="number">1</span>; j++) rear = rear.link;</span><br><span class="line">    <span class="keyword">if</span> (i = = <span class="number">1</span>) &#123; </span><br><span class="line">        head = rear.link ; p = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        p.link = rear.link;</span><br><span class="line">        p = rear.link;</span><br><span class="line">    &#125;</span><br><span class="line">    rear.link = p.link;</span><br><span class="line">    &#125;</span><br><span class="line">    P.link = rear; rear.link = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>静态链表</p>
<ol>
<li>静态链表是由数组实现的单链表。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt3/im3-16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt3/im3-16.png" alt="img"></a></p>
<ol>
<li>在系统中，对于系统来说，内存时这样子的被系统管理的。</li>
<li>如果next是0，那么相当于null</li>
</ol>
</li>
</ol>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(object x)</span>&#123;</span><br><span class="line">    topOfStack = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, topOfStack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> topOfStack.element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Underflow &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Underflow</span>();</span><br><span class="line">    topOfStack = topOfStack.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">topAndPop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">object</span> <span class="variable">topItem</span> <span class="operator">=</span> topOfstack.element;</span><br><span class="line">    topOfStack = topOfStack.next;</span><br><span class="line">    <span class="keyword">return</span> topItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StackAr</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StackAr</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;   </span><br><span class="line">    theArray = <span class="keyword">new</span> <span class="title class_">object</span> [capacity];</span><br><span class="line">    topOfStack = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(object x)</span> <span class="keyword">throws</span> Overflow &#123;</span><br><span class="line">    <span class="keyword">if</span> (isfull())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Overflow</span>();</span><br><span class="line">    theArray[++topOfStack] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> theArray[ topOfStack ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Underflow &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Underflow</span>( );</span><br><span class="line">    theArray[ topOfStack-- ] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">topAndPop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">object</span> <span class="variable">topItem</span> <span class="operator">=</span> top( );</span><br><span class="line">    theArray[ topOfStack-- ] = <span class="literal">null</span>;</span><br><span class="line">    reurn topItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol>
<li>括号匹配</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxlength = <span class="number">100</span>; <span class="comment">// max expression length</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="type">char</span> *expr)</span> </span>&#123;</span><br><span class="line">    <span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(Maxlength)</span></span>;</span><br><span class="line">    <span class="type">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = l; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            s.<span class="built_in">Add</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.<span class="built_in">Delete</span>(j);<span class="comment">//进栈的是括号的位置</span></span><br><span class="line">                cout &lt;&lt; j &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt; endl;&#125;</span><br><span class="line">            <span class="built_in">catch</span> (OutOfBounds)</span><br><span class="line">                &#123;cout &lt;&lt; <span class="string">&quot;No match for right parenthesis&quot;</span> &lt;&lt; <span class="string">&quot;at&quot;</span>&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !s.<span class="built_in">IsEmpty</span> ())&#123;</span><br><span class="line">        s.<span class="built_in">Delete</span>(j);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;No match for left parenthesis at &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> expr[MaxLength];</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;type an expression of length at most&quot;</span> &lt;&lt;MaxLength&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(expr, MaxLength);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the pairs of matching parentheses in&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;are&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printMatcnedPairs</span>(expr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂度O(n)</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p>表达式求值</p>
<ul>
<li>中缀表达式变成后缀表达式</li>
<li>根据操作的<strong>元数</strong>来决定弹出几个来进行计算</li>
<li>分量是指除了运算符以外的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Infix</span> &#123;</span><br><span class="line">    <span class="comment">// 优先级映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; precedence = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        precedence.put(<span class="string">&quot;+&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;*&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;/&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;(&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法：计算中缀表达式的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">infix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// Step 1: 中缀转后缀</span></span><br><span class="line">        List&lt;String&gt; postfix = infixToPostfix(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 计算后缀表达式的值</span></span><br><span class="line">        <span class="keyword">return</span> evaluatePostfix(postfix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: 将中缀表达式转为后缀表达式</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">infixToPostfix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                output.add(token);  <span class="comment">// 如果是数字，直接加入输出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                stack.push(token);  <span class="comment">// 左括号直接入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; !stack.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    output.add(stack.pop());  <span class="comment">// 弹出栈顶操作符直到遇到左括号</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();  <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; precedence.get(stack.peek()) &gt;= precedence.get(token)) &#123;</span><br><span class="line">                    output.add(stack.pop());  <span class="comment">// 弹出栈顶优先级更高的操作符</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(token);  <span class="comment">// 将当前操作符压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后将栈中剩余的操作符添加到输出中</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            output.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Double.parseDouble(token);  <span class="comment">// 尝试转换为数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是操作符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOperator</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> precedence.containsKey(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: 计算后缀表达式的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="title function_">evaluatePostfix</span><span class="params">(List&lt;String&gt; postfix)</span> &#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String token : postfix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stack.push(Float.parseFloat(token));  <span class="comment">// 操作数直接压入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token)) &#123;</span><br><span class="line">                <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> stack.pop();  <span class="comment">// 弹出右操作数</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> stack.pop();  <span class="comment">// 弹出左操作数</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = a + b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = a - b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = a * b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        result = a / b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stack.push(result);  <span class="comment">// 将运算结果压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后栈中的唯一元素即为结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>中缀转后缀</p>
<ol>
<li><p>基本想法:</p>
<ul>
<li>遇到操作数(运算分量)直接输出。</li>
<li>遇到操作符:当前的操作符一定是不输出的，如果当前运算符低于栈顶预算符优先级低，则输出，一直到当前运算符高于栈顶运算符优先级</li>
</ul>
</li>
<li><p>括号比较麻烦:需要单独处理</p>
<ul>
<li>左半括号需要压栈，也就是只要保证任何一个优先级低就行，也就是我们希望左半括号永远不要输出出来，在遇到右半括号的时候出去左半括号。</li>
</ul>
</li>
<li><p>每一个符号都有两个优先级，加减乘除的两个优先级都是一样的，而括号的优先级不是。</p>
<ul>
<li>经过计算和推断，我们可以得知一个优先级体系是不能满足</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">我们来一步一步地将表达式 3 - 9 + 3 * 4 + 2 - 1 转换成后缀表达式，并且根据这个后缀表达式来求值。</span><br><span class="line"></span><br><span class="line">步骤 1：中缀转后缀</span><br><span class="line">中缀表达式：3 - 9 + 3 * 4 + 2 - 1</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line">操作符栈：[]（空）</span><br><span class="line">输出队列：[]</span><br><span class="line">逐步处理：</span><br><span class="line">处理数字 3：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[]</span><br><span class="line">输出队列：[3]</span><br><span class="line">处理操作符 -：</span><br><span class="line"></span><br><span class="line">是操作符，压入栈。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3]</span><br><span class="line">处理数字 9：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9]</span><br><span class="line">处理操作符 +：</span><br><span class="line"></span><br><span class="line">当前栈顶是 -，其优先级与 + 相同，先将 - 弹出并加入输出队列，再将 + 压入栈。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -]</span><br><span class="line">处理数字 3：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3]</span><br><span class="line">处理操作符 *：</span><br><span class="line"></span><br><span class="line">* 的优先级高于 +，直接压入栈。</span><br><span class="line">操作符栈：[+, *]</span><br><span class="line">输出队列：[3, 9, -, 3]</span><br><span class="line">处理数字 4：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+, *]</span><br><span class="line">输出队列：[3, 9, -, 3, 4]</span><br><span class="line">处理操作符 +：</span><br><span class="line"></span><br><span class="line">* 的优先级高于 +，所以先将 * 弹出并加入输出队列，再将 + 压入栈。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *]</span><br><span class="line">处理数字 2：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2]</span><br><span class="line">处理操作符 -：</span><br><span class="line"></span><br><span class="line">+ 的优先级与 - 相同，先将 + 弹出并加入输出队列，再将 - 压入栈。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +]</span><br><span class="line">处理数字 1：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +, 1]</span><br><span class="line">结束：</span><br><span class="line"></span><br><span class="line">最后将栈中的操作符 - 弹出并加入输出队列。</span><br><span class="line">操作符栈：[]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +, 1, -]</span><br><span class="line">后缀表达式：[3, 9, -, 3, 4, *, 2, +, 1, -]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;<span class="comment">//T是任意的类型</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkedQueue</span>()&#123;front=back=<span class="number">0</span>;&#125;</span><br><span class="line">        ~<span class="built_in">LinkedQueue</span>();<span class="comment">//无法调用析构函数，在delete对象的时候可以直接释放</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> ((front)?<span class="literal">false</span>:<span class="literal">true</span>);&#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">First</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">Last</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">LinkedQueue&lt;T&gt;&amp;<span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">        <span class="function">LinkedQueue&lt;T&gt;&amp; <span class="title">Delete</span><span class="params">(T&amp; x)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt;*front;</span><br><span class="line">        Node&lt;T&gt;*back;</span><br><span class="line">    &#125;;       </span><br></pre></td></tr></table></figure>


<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ol>
<li><p>杨辉三角</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YANGHUI</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">makeEmpty</span>();</span><br><span class="line">    q.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n;i++) &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">10</span>-i;k++)</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">Enqueue</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">+2</span>;j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">Dequeue</span>();</span><br><span class="line">            q.<span class="built_in">Enqueue</span>(s+t);</span><br><span class="line">            s = t;</span><br><span class="line">            <span class="comment">//0不需要进行打印</span></span><br><span class="line">            <span class="keyword">if</span> (j!=i<span class="number">+2</span>) cout&lt;&lt; s &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>循环移动？</p>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="左子女右兄弟"><a href="#左子女右兄弟" class="headerlink" title="左子女右兄弟"></a>左子女右兄弟</h3><ul>
<li><p>用于遍历森林</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    TreeNode *firstchild, *nextsibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    TreeNode *root, *c</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 插入算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">void</span> Tree&lt;T&gt;::<span class="built_in">Insertchild</span>(T value)&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* newnode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;firstchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current-&gt;firstchild = newnode;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode&lt;T&gt; *p = current-&gt;firstchild;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;nextsibling != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;nextsibling;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;nextsibling = newnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li><p>中序（利用栈，非递归）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现非递归中序遍历</span></span><br><span class="line"><span class="comment">//非递归使用stack实现中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BinaryNode &lt;T&gt;*t)</span></span>&#123;  </span><br><span class="line">    Stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="comment">//无条件进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//一直进行压栈，直到最左下部分</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。</span></span><br><span class="line">            p = s.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            p = p-&gt;Right;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
<li><p>后序（利用栈，非递归）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="comment">//结点的实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StkNode</span> &#123;</span><br><span class="line">    BinaryNode &lt;T&gt; * ptr;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(BinaryNode &lt;T&gt; * t)</span> </span>&#123;</span><br><span class="line">    Stack &lt;StkNode&lt;T&gt;&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    StkNode&lt;T&gt; Cnode;</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">//优先访问到最左下</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Cnode.ptr = p;</span><br><span class="line">            Cnode.tag = <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最左下结点出栈</span></span><br><span class="line">        Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">        p = Cnode.ptr;</span><br><span class="line">        <span class="keyword">while</span> (Cnode.tag == <span class="number">1</span>)<span class="comment">//从右子树回来 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果已经被访问一次了才进行输出</span></span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">                Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">                p = Cnode.ptr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//访问结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        Cnode.tag = <span class="number">1</span>;<span class="comment">//从左子树遍历完，而右子树还没有动。</span></span><br><span class="line">        s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">        p = p-&gt;Right;<span class="comment">//从左子树回来</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>


<ul>
<li>另外，非二叉树：<ul>
<li>先根：与原树的左子女右兄弟表示法的先序一致</li>
<li>后根：与原树的左子女右兄弟表示法的中序一致</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现层次访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; q=<span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    q.<span class="built_in">add</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Node temp = q.<span class="built_in">poll</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(temp.value);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=null) q.<span class="built_in">add</span>(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=null) q.<span class="built_in">add</span>(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>森林的遍历</p>
<ol>
<li>将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连</li>
<li><strong>先根次序遍历：</strong> <ol>
<li>访问F的第一棵树的根 </li>
<li>按先根遍历第一棵树的子树森林 </li>
<li>按先根遍历其它树组成的森林</li>
<li>等于二叉树的先序</li>
</ol>
</li>
<li><strong>中根次序遍历：</strong> <ol>
<li>按中根遍历第一棵树的子树森林 </li>
<li>访问F的第一棵树的根 </li>
<li>按中根遍历其它树组成的森林</li>
<li>等于二叉树的中序</li>
</ol>
</li>
</ol>
<ul>
<li><strong>后根次序遍历：</strong> <ol>
<li>按后根遍历第一棵树的子树森林 </li>
<li>按后根遍历其它树组成的森林 </li>
<li>访问F的第一棵树的根</li>
<li>等于二叉树的后序</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="根据前中后序表达式建树"><a href="#根据前中后序表达式建树" class="headerlink" title="根据前中后序表达式建树"></a>根据前中后序表达式建树</h3><ol>
<li><p>根据先序遍历和中序遍历</p>
<ul>
<li><p>先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树</p>
</li>
<li><pre><code class="language-java">// 根据先序遍历和中序遍历构建二叉树
    public static BinTree CreateBT(char[] pres, char[] ins) {
        // 如果先序或中序为空，则返回null
        if (pres.length == 0 || ins.length == 0) {
            return null;
        }

        // 构建根节点，先序遍历的第一个元素是根节点
        BinTree tree = new BinTree();
        tree.element = pres[0];

        // 查找根节点在中序遍历中的位置
        int i = 0;
        while (i &lt; ins.length &amp;&amp; ins[i] != pres[0]) {
            i++;
        }

        // 如果根节点存在
        if (i &lt; ins.length) {
            // 中序遍历中，根节点左侧是左子树的元素，右侧是右子树的元素
            // 递归构建左子树和右子树
            tree.left = CreateBT(Arrays.copyOfRange(pres, 1, i + 1), Arrays.copyOfRange(ins, 0, i));
            tree.right = CreateBT(Arrays.copyOfRange(pres, i + 1, pres.length), Arrays.copyOfRange(ins, i + 1, ins.length));
        }

        return tree;
    }
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 根据中序遍历和后序遍历</span><br><span class="line"></span><br><span class="line">   + 后序遍历树根在尾部，思路一致</span><br><span class="line">3. 根据先序遍历和后序遍历</span><br><span class="line"></span><br><span class="line">   + **单独依赖先序和后序遍历，无法唯一确定一棵二叉树**。如果只给出先序和后序遍历的结果，存在多个可能的二叉树结构。</span><br><span class="line"></span><br><span class="line">### 线索数</span><br><span class="line"></span><br><span class="line">1. 按中序遍历中序线索树</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   //使用是current来记录下来当前节点</span><br><span class="line">   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::First() &#123;</span><br><span class="line">       while (current-&gt;leftThread==0)&#123;</span><br><span class="line">           current = current-&gt;leftchild;</span><br><span class="line">       &#125;</span><br><span class="line">       return current;//找中序遍历的第一个节点</span><br><span class="line">   &#125;</span><br><span class="line">   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::Next() &#123;</span><br><span class="line">       ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;//可能是右子树的根节点，也可能是右链 </span><br><span class="line">       if(current-&gt;rightThread==0)</span><br><span class="line">           while(p-&gt;leftThread==0)&#123;</span><br><span class="line">               //如果有右子树就要搜索到最左下部分</span><br><span class="line">               p=p-&gt;leftchlid;</span><br><span class="line">           &#125;</span><br><span class="line">       current=p;</span><br><span class="line">   &#125;</span><br><span class="line">   template&lt;class Type&gt; void ThreadInorderIterator&lt;Type&gt;:: Inorder() &#123; </span><br><span class="line">       ThreadNode&lt;Type&gt; *p;</span><br><span class="line">       for ( p=Frist(); p!=NULL; p=Next()) </span><br><span class="line">           cout&lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>构造中序线索树</p>
<ul>
<li><p>对已存在的一棵二叉树建立中序线索树</p>
</li>
<li><p>在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">Inthread</span><span class="params">(threadNode&lt;T&gt; * T)</span> &#123;</span><br><span class="line">    stack &lt;threadNode &lt;T&gt;*&gt; s(<span class="number">10</span>)</span><br><span class="line">    ThreadNode &lt;T&gt; *p = T ;</span><br><span class="line">    ThreadNode &lt;T&gt; *pre = NULL;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找到最左下部分的</span></span><br><span class="line">        <span class="keyword">while</span> (p!=NULL) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p -&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始弹出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!s.IsEmpty())&#123;</span><br><span class="line">            p = s.pop;</span><br><span class="line">            <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">                <span class="comment">//添加的代码，在这时候处理pre</span></span><br><span class="line">                <span class="keyword">if</span> (pre -&gt;rightchild == NULL)&#123;</span><br><span class="line">                    pre -&gt;rightchild = p;  </span><br><span class="line">                    pre -&gt;rightthread = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理p</span></span><br><span class="line">                <span class="keyword">if</span>( p -&gt; leftchild == NULL) &#123;</span><br><span class="line">                    p -&gt; leftchild = pre;</span><br><span class="line">                    p -&gt;leftthread = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="comment">//添加的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = p ; <span class="comment">//这里更新了pre</span></span><br><span class="line">            p = p -&gt; rightchild ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//for </span></span><br><span class="line">&#125;<span class="comment">//建议把pre和p存储成全局变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="霍夫曼树-1"><a href="#霍夫曼树-1" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><ol>
<li><p>算法：</p>
<ol>
<li><p>从m个权值中找出两个最小值W1，W2构成</p>
<p>W &#x3D; W1 + W2表示通过该节点的频度</p>
</li>
<li><p>然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解</p>
</li>
</ol>
<ul>
<li>当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15</li>
</ul>
</li>
</ol>
<h3 id="搜索树-1"><a href="#搜索树-1" class="headerlink" title="搜索树"></a>搜索树</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ol>
<li><p>二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：</p>
<ul>
<li>每一个元素有key值（关键码、主码），key值独一无二不重复</li>
<li>一个树的左子树的关键字小于根中的关键字</li>
<li>一个树的右子树的关键字大于根中的关键字</li>
<li>根的左右子树还是二叉搜索树</li>
</ul>
</li>
<li><p>二叉搜索树可以在很大的数据量下，快速完成增删查改</p>
</li>
<li><p>索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1</p>
</li>
<li><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryNode 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    BinaryNode( Comparable theElement ) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>, <span class="literal">null</span> );<span class="comment">//调用本类中的其他构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;</span><br><span class="line">        element = <span class="type">theElement</span></span><br><span class="line">        <span class="variable">left</span> <span class="operator">=</span> lt;</span><br><span class="line">        right = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某元素</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">find</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">//Match </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找值最小的结点，找最大同理，往右找</span></span><br><span class="line"><span class="comment">//使用递归查找结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">( BinaryNode t )</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> findMin( t.left );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代找最小结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">(BinaryNode t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数值插入固定位置的算法</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">insert</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="comment">//先查找一次，如果找到了就不用进行查找</span></span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>( x, <span class="literal">null</span>, <span class="literal">null</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = insert( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = insert( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> ;<span class="comment">//duplicate; do nothing</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compareTo()方法如果小于返回负数，大于返回正数</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果结点本身不在树内，那么不需要删除</span></span><br><span class="line"><span class="comment"> * 如果结点本身在树里面，删除需要分类</span></span><br><span class="line"><span class="comment"> *  1.无子树:删除叶节点</span></span><br><span class="line"><span class="comment"> *  2.一颗子树:直接连接</span></span><br><span class="line"><span class="comment"> *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">remove</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = remove( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = remove( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span> ) &#123;</span><br><span class="line">        t.element = findMin( t.right ).element;<span class="comment">//把右树最小的复制给t</span></span><br><span class="line">        t.right = remove( t.element , t.right );<span class="comment">//递归的删除</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t = ( t.left != <span class="literal">null</span> ) ? t.left : t.right;<span class="comment">//一颗子树的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</p>
<ul>
<li>Best Case：$O(log_2n)$</li>
<li>最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去</li>
</ul>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li><p>插入（进堆，上滤）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: Insert(const T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize= =MaxSize) <span class="keyword">throw</span> NoMem(); </span><br><span class="line">    <span class="type">int</span> i= ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; x&gt;heap[i/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">//0不使用</span></span><br><span class="line">        heap[i]=heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不必每次都进行完全交换</span></span><br><span class="line">        i/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
<li><p>删除（出堆、下滤）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize==<span class="number">0</span>) <span class="keyword">throw</span> OutOfBounds(); </span><br><span class="line">    x = heap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0无存储，这个就是root结点</span></span><br><span class="line">    T y=heap[CurrentSize--];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;<span class="comment">//i标向树根</span></span><br><span class="line">    ci=<span class="number">2</span>;<span class="comment">//ci先标到左子树</span></span><br><span class="line">    <span class="keyword">while</span>(ci&lt;=CurrentSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci+<span class="number">1</span>])<span class="comment">//如果ci未越界，并且左子树的值小于右子树的值。</span></span><br><span class="line">            ci++;<span class="comment">//转向右子树</span></span><br><span class="line">        <span class="keyword">if</span>(y&gt;=heap[ci]) <span class="keyword">break</span>;</span><br><span class="line">        heap[i]=heap[ci];</span><br><span class="line">        i=ci;</span><br><span class="line">        ci*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=y;<span class="comment">//y是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

</li>
<li><p>线性时间建堆</p>
<ul>
<li><p>步骤：</p>
<ol>
<li>先将n个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意是对每个子树进行递归处理</span></span><br><span class="line">Template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span> MaxHeap&lt;T&gt;::<span class="built_in">Initialize</span> (T a[],<span class="type">int</span> size,<span class="type">int</span> ArraySize) &#123; </span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap=a;</span><br><span class="line">    CurrentSize=Size;</span><br><span class="line">    MaxSize=ArraySize;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=CurrentSize/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        T y=heap[i];</span><br><span class="line">        <span class="type">int</span> c=<span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c<span class="number">+1</span>])</span><br><span class="line">                c++;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[c/<span class="number">2</span>] = heap[c];</span><br><span class="line">            c*=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到其子节点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap[c/<span class="number">2</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)</p>
</li>
</ul>
</li>
</ol>
<h2 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNumEdges = <span class="number">50</span><span class="comment">// 最大边数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNumVertices = <span class="number">10</span><span class="comment">//最大顶点数 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> NameType, <span class="keyword">class</span> DistType&gt; <span class="keyword">class</span> Graph&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SeqList&lt;NameType&gt; <span class="built_in">VerticesList</span>(MaxNumVertices) <span class="comment">//顶点表</span></span><br><span class="line">        DistType Edge [MaxNumVertices] [MaxNumVertices]  <span class="comment">//邻接矩阵，一定是方阵</span></span><br><span class="line">        <span class="type">int</span> CurrentEdges;<span class="comment">//当前边数</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">FindVertex</span> <span class="params">(Seqlist &lt;NameType&gt; &amp;L; <span class="type">const</span>  NameType &amp;Vertex)</span></span></span><br><span class="line"><span class="function">            </span>&#123;<span class="keyword">return</span> L.<span class="built_in">Find</span>(Vertex);&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexPos</span> <span class="params">(<span class="type">const</span> NameTyoe &amp;Vertex)</span></span></span><br><span class="line"><span class="function">            </span>&#123;<span class="keyword">return</span> <span class="built_in">FindVertex</span>(VerticesList);&#125;<span class="comment">// 给出了顶点Vertex在图中的位置</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span> (<span class="type">const</span> <span class="type">int</span> sz=MaxNumEdges); </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GraphEmpty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> VerticesList.<span class="built_in">IsEmpty</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GraphFull</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> VerticesList.<span class="built_in">IsFull</span>() || CurrentEdges= =MaxNumEdges;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">NumberofVertices</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> VerticesList.last;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">NumberofEdges</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> CurrentEdges;&#125;</span><br><span class="line">        <span class="function">NameType <span class="title">Getvalue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span>  i&gt;=<span class="number">0</span> &amp;&amp; i&lt;VerticesList.last ? VerticesList.data[i] :  <span class="literal">NULL</span>;&#125; </span><br><span class="line">        <span class="function">DistType <span class="title">Getweight</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetFirstNeighbor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v)</span></span>; </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetNextNeighbor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InsertVertex</span><span class="params">(<span class="type">const</span> NameType &amp; Vertex)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InsertEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2, DistType weight)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(cosnt <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>




<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表的声明</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Defaultsize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>，<span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">class</span> <span class="title class_">Graph</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;       <span class="comment">//边的定义 </span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &lt;NameType,DistType&gt;;<span class="comment">//友元函数</span></span><br><span class="line">    <span class="type">int</span> dest;<span class="comment">//边的另一顶点在顶点表中的位置 </span></span><br><span class="line">    DistType cost;<span class="comment">//边上的权</span></span><br><span class="line">    Edge&lt;DistType&gt; *link;<span class="comment">//下一条边的链指针</span></span><br><span class="line">    <span class="built_in">Edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> D,DistType C):<span class="built_in">dest</span>(D),<span class="built_in">cost</span>(C),<span class="built_in">link</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> operate != (<span class="type">const</span> Edge&lt;DistType&gt; &amp;E) <span class="type">const</span> &#123;<span class="keyword">return</span> dest != E.dest; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&lt;DistType&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&lt;NameType, DistType&gt;; </span><br><span class="line">    NameType data;<span class="comment">//顶点名字</span></span><br><span class="line">    Edge&lt;DistType&gt; *adj;<span class="comment">//出边表头指针</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> edgesAccepted;</span><br><span class="line">    DisjSet s;</span><br><span class="line">    priorityQueue h;</span><br><span class="line">    Vertex u, v;</span><br><span class="line">    SetType uset, vset;</span><br><span class="line">    Edge e;</span><br><span class="line">    </span><br><span class="line">    h = readGraphIntoHeapArray( );</span><br><span class="line">    h.buildHeap() ;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="title class_">DisjSet</span>( NUM_VERTICES );</span><br><span class="line"></span><br><span class="line">    edgesAccepted = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>( edgesAccepted &lt; NUM_VERTICES – <span class="number">1</span> )&#123;</span><br><span class="line">        e = h.deleteMin() ;<span class="comment">//Edge e = (u, v)</span></span><br><span class="line">        uset = s. find(u);</span><br><span class="line">        vset = s.find(v);</span><br><span class="line">        <span class="keyword">if</span>( uset != vset ) &#123;</span><br><span class="line">            edgesAccepted++;</span><br><span class="line">            s.union( uset, vset );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> graph&lt;string,<span class="type">float</span>&gt;::<span class="built_in">Prim</span>(MinSpanTree&amp;T)&#123;</span><br><span class="line">    <span class="type">int</span> NumVertices=VerticesList.last; </span><br><span class="line">    <span class="type">float</span>*lowcost=<span class="keyword">new</span> <span class="type">float</span>[NumVertices]; </span><br><span class="line">    <span class="type">int</span> * nearvex=<span class="keyword">new</span> <span class="type">int</span>[NumVertices];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt; NumVertices;i++) &#123;</span><br><span class="line">        lowcost[i] = Edge[<span class="number">0</span>][i];<span class="comment">//0到其他所有边的权值</span></span><br><span class="line">        nearvex[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nearvex[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    MSTEdgeNode e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt; NumVertices; i++) &#123;</span><br><span class="line">        <span class="type">float</span> min=MAXINT;</span><br><span class="line">        <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j=<span class="number">1</span>; j&lt; NumVertices; j++)</span><br><span class="line">            <span class="keyword">if</span>(nearvex[j]!=<span class="number">-1</span>&amp;&amp;lowcost[j]&lt;min) &#123;</span><br><span class="line">                v=j;</span><br><span class="line">                min=lowcost[j];</span><br><span class="line">            &#125; <span class="comment">//for j,  选择最小的边</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v) &#123;</span><br><span class="line">            e.tail=nearvex[v];</span><br><span class="line">            e.head=v;</span><br><span class="line">            e.cost=lowcost[v];</span><br><span class="line">            T.<span class="built_in">Insert</span>(e);</span><br><span class="line">            <span class="comment">//添加边进入最小生成树中去</span></span><br><span class="line">            nearvex[v]=<span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt; NumVertices; j++)</span><br><span class="line">                <span class="keyword">if</span>( nearvex[j]!=<span class="number">-1</span> &amp;&amp; Edge[v][j]&lt;lowcost[j] ) &#123;</span><br><span class="line">                    lowcost[j]=Edge[v][j];</span><br><span class="line">                    nearvex[j]=v;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//for i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">NumVertices</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//大于所有边的权重的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> Edge[NumVertices][NumVertices]; </span><br><span class="line">        <span class="type">int</span> dist[NumVertices];</span><br><span class="line">        <span class="type">int</span> path[NumVertices];</span><br><span class="line">        <span class="type">int</span> S[NumVertices];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">shortestpath</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Graph::shortestpath(<span class="type">int</span> n,<span class="type">int</span> v) &#123;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="comment">//v为当前节点，dist数组是表示距离的数组</span></span><br><span class="line">        <span class="comment">//遍历n次</span></span><br><span class="line">        dist[i] = Edge[v][i];</span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( i!=v &amp;&amp; dist[i]&lt; MAXNUM )</span><br><span class="line">            path[i]= v;<span class="comment">//如果可达，则用path数组记录下路径</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=-<span class="number">1</span>;<span class="comment">//如果不可达，则用path数组记录下不可达(-1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        s[v]=<span class="number">1</span>;</span><br><span class="line">        dist[v]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示访问过当前节点，并且距离为0</span></span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">float</span> min=MAXNUM;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> v;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  j &lt; n;  j++)</span><br><span class="line">                <span class="keyword">if</span>( !s[j] &amp;&amp; dist[j]&lt;min ) &#123;</span><br><span class="line">                    <span class="comment">//如果结点j还没有访问过，并且dist[j]小于最小值</span></span><br><span class="line">                    u = j;</span><br><span class="line">                    min = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            s[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> w=<span class="number">0</span>; w&lt;n; w++)</span><br><span class="line">                <span class="comment">// 若 dist[u] + Edge[u][w] &lt; dist[w]，则说明通过 u 更新路径更短，更新 dist[w] 和 path[w]。</span></span><br><span class="line">                <span class="keyword">if</span>( !s[w] &amp;&amp; Edge[u][w] &lt; MAXNUM &amp;&amp; dist[u]+Edge[u][w] &lt; dist[w]) &#123;</span><br><span class="line">                    <span class="comment">//dist[u]就是起点到u的距离，下面是关键条件</span></span><br><span class="line">                    dist[w]=dist[u]+Edge[u][w];</span><br><span class="line">                    path[w]=u;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><ol>
<li><p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 迭代版的归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.length;</span><br><span class="line">        <span class="type">int</span>[] tempList = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次将len扩展，逐步合并</span></span><br><span class="line">        <span class="keyword">while</span> (len &lt; n) &#123;</span><br><span class="line">            mergePass(list, tempList, len);</span><br><span class="line">            len *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并函数，合并两个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePass</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span>[] tempList, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以len为子数组的大小，进行合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + len &lt; n) &#123;</span><br><span class="line">            merge(list, tempList, i, i + len, Math.min(i + <span class="number">2</span> * len - <span class="number">1</span>, n - <span class="number">1</span>));<span class="comment">//这里的数字看一下</span></span><br><span class="line">            i += <span class="number">2</span> * len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理剩余的部分</span></span><br><span class="line">        <span class="keyword">if</span> (i + len &lt; n) &#123;</span><br><span class="line">            merge(list, tempList, i, i + len, n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若后半部分已经是有序的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                tempList[j] = list[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将临时数组的内容复制回原数组</span></span><br><span class="line">        System.arraycopy(tempList, <span class="number">0</span>, list, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序区间的函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span>[] tempList, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个子数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i] &lt;= list[j]) &#123;</span><br><span class="line">                tempList[k++] = list[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tempList[k++] = list[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制剩余的部分</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tempList[k++] = list[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            tempList[k++] = list[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
<li><p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a )</span> &#123;</span><br><span class="line">    Comparable [ ] tmpArray = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    mergeSort( a, tmpArray, <span class="number">0</span>, a.length – <span class="number">1</span> );</span><br><span class="line">&#125;                            </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> left, <span class="type">int</span> right )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; right ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmparray, left, center );</span><br><span class="line">        mergeSort(a, tmpArray, center + <span class="number">1</span>, right );</span><br><span class="line">        merge( a, tmpArray, left, center + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd )</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> rightPos – <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> rightEnd – leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )</span><br><span class="line">        <span class="keyword">if</span>( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= <span class="number">0</span> )</span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ rightPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd )</span><br><span class="line">        tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( rightpos &lt;= rightEnd)</span><br><span class="line">        tmpArray[ tmpPos++] = a[ rightpos++ ];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; i++, rightEnd-- )</span><br><span class="line">        a[ rightEnd ] = tmpArray[ rightEnd ];</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="一、数据结构的定义（选择、填空）"><a href="#一、数据结构的定义（选择、填空）" class="headerlink" title="一、数据结构的定义（选择、填空）"></a>一、数据结构的定义（选择、填空）</h3><ul>
<li>数据结构是指某一数据元素的集合与该集合中数据元素之间的关系</li>
<li>Data Structure &#x3D; {D，R}<ul>
<li>D is a data object</li>
<li>R is a limited set of relationship of all the data members in D</li>
</ul>
</li>
</ul>
<h3 id="二、数据结构的逻辑结构与物理结构（理解即可）"><a href="#二、数据结构的逻辑结构与物理结构（理解即可）" class="headerlink" title="二、数据结构的逻辑结构与物理结构（理解即可）"></a>二、数据结构的逻辑结构与物理结构（理解即可）</h3><ul>
<li>逻辑结构——从用户视图看，是面向问题的</li>
<li>物理结构——从具体实现视图看，是面向计算机的</li>
</ul>
<h3 id="三、ADT、OO不考，需要理解"><a href="#三、ADT、OO不考，需要理解" class="headerlink" title="三、ADT、OO不考，需要理解"></a>三、ADT、OO不考，需要理解</h3><ul>
<li><p>ADT：abstract data types抽象数据类型</p>
<ul>
<li>将类型和有关操作封装在一起的数据模型</li>
<li><strong>思想</strong>：将数据类型的使用与它的表示（机内存储）、实现（机内操作的实现）分开。更确切的说，把一个数据类型的表示及在这个类型上的操作<strong>实现</strong>封装到一个程序模块中，用户不必知道它</li>
</ul>
</li>
<li><p>OO：object-oriented面向对象</p>
<ul>
<li>object-oriented＝object＋class＋inherit＋communicate</li>
<li><strong>思想：封装、继承、多态</strong>，使得软件开发团队个成员能够不关心其他成员代码，二只关注接口（这块可以看软工一的板块，主要抓住这三个概念）</li>
</ul>
</li>
</ul>
<h3 id="四、算法概念（选择、填空）定义、五个性质"><a href="#四、算法概念（选择、填空）定义、五个性质" class="headerlink" title="四、算法概念（选择、填空）定义、五个性质"></a>四、算法概念（选择、填空）定义、五个性质</h3><ul>
<li>算法是一个用来解决实际问题的计算机操作序列</li>
<li>五个性质：<ol>
<li><p>明确的输入</p>
</li>
<li><p>明确的输出</p>
</li>
<li><p>确定性（definiteness）有明确的定义，每一个步骤都明确地定义</p>
</li>
<li><p>可行性</p>
</li>
<li><p>有穷性</p>
</li>
</ol>
</li>
</ul>
<h3 id="五、数学部分过一遍即可"><a href="#五、数学部分过一遍即可" class="headerlink" title="五、数学部分过一遍即可"></a>五、数学部分过一遍即可</h3><h3 id="六、递归需要掌握（物理过程、逻辑过程）"><a href="#六、递归需要掌握（物理过程、逻辑过程）" class="headerlink" title="六、递归需要掌握（物理过程、逻辑过程）"></a>六、<strong>递归</strong>需要掌握（<strong>物理过程</strong>、逻辑过程）</h3><ul>
<li>见下算法思想板块</li>
</ul>
<h3 id="七、泛型不考"><a href="#七、泛型不考" class="headerlink" title="七、泛型不考"></a>七、泛型不考</h3><hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="一、空间复杂度、时间复杂度概念"><a href="#一、空间复杂度、时间复杂度概念" class="headerlink" title="一、空间复杂度、时间复杂度概念"></a>一、空间复杂度、时间复杂度概念</h3><ul>
<li>空间复杂度：程序运行到完成所需要的内存量</li>
<li>时间复杂度：程序运行到完成所需要的时间</li>
</ul>
<h3 id="二、最好情况、最差情况、平均情况（等概率）"><a href="#二、最好情况、最差情况、平均情况（等概率）" class="headerlink" title="二、最好情况、最差情况、平均情况（等概率）"></a>二、最好情况、最差情况、平均情况（等概率）</h3><ul>
<li>平均情况：以等概率为前提 各情况求和取平均</li>
<li>平均情况较难确定，一般将分析限制在最好和最坏情况中</li>
</ul>
<h3 id="三、大O表示法（重点）"><a href="#三、大O表示法（重点）" class="headerlink" title="三、大O表示法（重点）"></a>三、<strong>大O表示法</strong>（重点）</h3><ul>
<li>为函数提供一个上界，算法复杂度量级的上界</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230129091917091.png" alt="image-20230129091917091" style="zoom:67%;float:left" /></li>
</ul>
<h3 id="四、二分查找（过程-复杂度）"><a href="#四、二分查找（过程-复杂度）" class="headerlink" title="四、二分查找（过程+复杂度）"></a>四、二分查找（过程+复杂度）</h3><ul>
<li>$O(log_2n)$</li>
</ul>
<h3 id="五、指定复杂度设计算法"><a href="#五、指定复杂度设计算法" class="headerlink" title="五、指定复杂度设计算法"></a>五、指定复杂度设计算法</h3><h3 id="六、辗转相除（过程）"><a href="#六、辗转相除（过程）" class="headerlink" title="六、辗转相除（过程）"></a>六、辗转相除（过程）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">( <span class="type">long</span> m, <span class="type">long</span> n )</span> &#123;   </span><br><span class="line">    <span class="keyword">while</span>( n != <span class="number">0</span> ) &#123;    </span><br><span class="line">        <span class="type">long</span> <span class="variable">rem</span> <span class="operator">=</span> m % n; </span><br><span class="line">        m = n; </span><br><span class="line">        n = rem; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复杂度为O(logN)</span></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="第三章（线性表）-一定有题"><a href="#第三章（线性表）-一定有题" class="headerlink" title="第三章（线性表） 一定有题"></a>第三章（线性表） 一定有题</h2><h3 id="一、ADT的基本操作（比如栈的进栈出栈peek）"><a href="#一、ADT的基本操作（比如栈的进栈出栈peek）" class="headerlink" title="一、ADT的基本操作（比如栈的进栈出栈peek）"></a>一、ADT的基本操作（比如栈的进栈出栈peek）</h3><ul>
<li>创建、查找、删除、插入、输出、得到长度、判断为空……</li>
<li>代码实现基于ADT的物理实现<ol>
<li>数组实现：一整块连续内存，依次排放元素<ul>
<li>在这种情况下，查找操作复杂度为O(1)，但删除与插入操作为O(length)</li>
</ul>
</li>
<li>单链表实现：不要求连续内存，一个节点中存放一个数据，一个指针<ul>
<li>这样的物理实现，是的删除与插入的复杂度大大降低，具体内容在下一版块讨论</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）"><a href="#二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）" class="headerlink" title="二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）"></a>二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）</h3><ul>
<li><p>一个问题：单链表带不带表头，表头节点是没有数据的，其指针指向list的第一个元素</p>
</li>
<li><p>一些操作的实现</p>
<ol>
<li><p>删除操作：<code>Delete(index, x)</code></p>
<ul>
<li><p>删除第一个节点：重新指向新的第一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = first.next;</span><br><span class="line"><span class="comment">// C++中需要delete掉被解引用的对象</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>删除中间节点：先查询，后删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = first.next; <span class="comment">// 通过不断next，至要删除的节点前</span></span><br><span class="line">before.next = before.next.next;</span><br><span class="line"><span class="comment">// C++中需要delete掉被解引用的对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>插入操作：<code>Insert(index, x)</code></p>
<ul>
<li><p>在线性表开头插入元素：先插入，后移动表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;f&#x27;</span>, first);</span><br><span class="line">first = newNode;</span><br></pre></td></tr></table></figure>

</li>
<li><p>在线性表中间插入元素：先查询，后插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = first.next; <span class="comment">// 通过不断next，至要删除的节点前</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;f&#x27;</span>,before.next);</span><br><span class="line">before.next = newNode;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>java实现（看一下PPT或者笔记，关注一些方法，尤其是指针操作）DataStructure包中有LinkedListItr类：代表游标位置</p>
</li>
<li><p>双链表与循环链表看一下笔记</p>
</li>
</ul>
<h3 id="三、例题过一遍（懂）"><a href="#三、例题过一遍（懂）" class="headerlink" title="三、例题过一遍（懂）"></a>三、例题过一遍（懂）</h3><ul>
<li>多项式相加</li>
<li>循环链表解约瑟夫问题</li>
<li>最高效查找倒数第k个节点</li>
</ul>
<h3 id="四、栈和队列（小重点）"><a href="#四、栈和队列（小重点）" class="headerlink" title="四、栈和队列（小重点）"></a>四、<strong>栈和队列</strong>（小重点）</h3><ul>
<li><p>栈：LIFO，后进先出</p>
<ul>
<li><p>方法：push、pop</p>
</li>
<li><p>可以用单链表（表头为栈顶）也可以用数组（最后一位做栈顶，记录）进行实现</p>
<ul>
<li>使用数组实现栈的时候，可能存在空间的浪费，如果只有两个栈时，可以使他们从数组的头尾向中间生长</li>
</ul>
</li>
<li><p>无论何种的实现，栈操作的复杂度都是O(1)</p>
</li>
<li><p>例题：<strong>括号匹配、表达式计算、中缀和后缀表达式</strong></p>
<ul>
<li><p>括号匹配（输出匹配的对）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxlength = <span class="number">100</span>; <span class="comment">// max expression length</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="type">char</span> *expr)</span> </span>&#123;</span><br><span class="line">    <span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(Maxlength)</span></span>;</span><br><span class="line">    <span class="type">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = l; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            s.<span class="built_in">Add</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.<span class="built_in">Delete</span>(j);<span class="comment">//进栈的是括号的位置</span></span><br><span class="line">                cout &lt;&lt; j &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt; endl;&#125;</span><br><span class="line">            <span class="built_in">catch</span> (OutOfBounds)</span><br><span class="line">                &#123;cout &lt;&lt; <span class="string">&quot;No match for right parenthesis&quot;</span> &lt;&lt; <span class="string">&quot;at&quot;</span>&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !s.<span class="built_in">IsEmpty</span> ())&#123;</span><br><span class="line">        s.<span class="built_in">Delete</span>(j);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;No match for left parenthesis at &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> expr[MaxLength];</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;type an expression of length at most&quot;</span> &lt;&lt;MaxLength&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(expr, MaxLength);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the pairs of matching parentheses in&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;are&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printMatcnedPairs</span>(expr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂度O(n)</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>表达式计算看作业代码</p>
</li>
<li><p>后缀转中缀看SpriCoder</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>队列：FIFO，先进先出</p>
<ul>
<li><p>方法：add、delete</p>
</li>
<li><p>实现：</p>
<ul>
<li><p>数组实现：记录首尾</p>
<ul>
<li><p>如果delete不进行左移，一段时间后，数组的前段会存在一段free space，如何更好地利用？</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204184853197.png" alt="image-20230204184853197" style="zoom:70%;float:left" />
</li>
<li><p>如何实现环形数组？</p>
<ol>
<li>当首或尾达到<code>theArray.length-1</code>时，重置为0</li>
<li><code>back = (back + 1) % theArray.length</code> <code>front = (front + 1) % theArray.length</code></li>
</ol>
</li>
</ul>
</li>
<li><p>链表实现：两个指针记录首尾</p>
</li>
</ul>
</li>
<li><p>例题：杨辉三角、循环移动</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第四章（树）"><a href="#第四章（树）" class="headerlink" title="第四章（树）"></a>第四章（树）</h2><h3 id="一、概念（填空选择）"><a href="#一、概念（填空选择）" class="headerlink" title="一、概念（填空选择）"></a>一、概念（填空选择）</h3><ul>
<li><strong>树</strong>：非线性的数据结构，是一个可以为空的节点集，有一个独立节点为root和多棵（可以为0）子树</li>
<li><strong>节点的度数</strong>：有多少个子节点</li>
<li>树的度数：树中子节点的最大度数</li>
<li><strong>leaf叶节点</strong>：度数为0的节点</li>
<li>branch分支节点：度数不为0的节点</li>
<li><strong>level层数</strong>：根节点的层数为0（或规定为1），子节点的层数是其父节点层数+1</li>
<li>树的高度：其节点的最大层数</li>
<li><strong>二叉树</strong>：每个节点度数为2，如果有子树，则子树均为二叉树（称为左右子树）<ul>
<li>n个节点的二叉树有n-1条边（n &gt;&#x3D; 1）</li>
<li>第i层最多有2^i^个节点（根节点层数为0）</li>
<li>高度为h的二叉树，最少有2h+1个节点，最多有2^h+1^-1个节点</li>
<li>叶节点数量为n<del>0</del>，度数为2的节点数量为n<del>2</del>，则n<del>0</del> &#x3D; n<del>2</del> + 1</li>
<li>有n个结点的二叉树的高度最大为n-1，最小为log2(n+1)(向上取整)-1</li>
</ul>
</li>
<li><strong>满二叉树</strong><ul>
<li>把二叉树排满，即如果高度为n，则其节点数为2^n+1^ - 1</li>
</ul>
</li>
<li><strong>完全二叉树</strong><ul>
<li>定义：假设我们为一个高度为h的满二叉树从上到下，从左到右使用1 - 2^h+1^的数字进行编码，删除编号为2^h+1^ - i（1 &lt;&#x3D; i &lt;&#x3D; k）的节点，得到一棵完全二叉树</li>
<li>假设i,0&lt;&#x3D;i&lt;&#x3D;n-1，是一个确定二叉树的一个节点的编号<ul>
<li>如果i&#x3D;0，则是根节点，不然其父结点的编号为 <strong>(i-1)&#x2F;2</strong>(向下取整)</li>
<li>如果2*i+1&gt;&#x3D;n，那么这个元素没有左子树，不然左子树的编号就是这个数字</li>
<li>如果2*i+2&gt;&#x3D;n，那么这个元素没有右子树，不然右子树的编号就是这个数字</li>
</ul>
</li>
</ul>
</li>
<li>完全二叉树和满二叉树是不同的，完全二叉树的最后一层可以不全满，但是必须从左开始顺序无空缺</li>
</ul>
<h3 id="二、表示方式"><a href="#二、表示方式" class="headerlink" title="二、表示方式"></a>二、表示方式</h3><ul>
<li><h4 id="广义表不考"><a href="#广义表不考" class="headerlink" title="广义表不考"></a>广义表不考</h4></li>
<li><h4 id="双亲表示法见并查集"><a href="#双亲表示法见并查集" class="headerlink" title="双亲表示法见并查集"></a>双亲表示法见并查集</h4></li>
<li><h4 id="左子女右兄弟（重点）"><a href="#左子女右兄弟（重点）" class="headerlink" title="左子女右兄弟（重点）"></a><strong>左子女右兄弟</strong>（重点）</h4><ul>
<li><p>用于遍历森林</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204195723190.png" alt="image-20230204195723190" style="zoom:67%;float:left" />
</li>
<li><pre><code class="language-c++">class TreeNode{
    T data;
    TreeNode *firstchild, *nextsibling;
}
class Tree{
    TreeNode *root, *c
} 
// 插入算法
template&lt;class T&gt;void Tree&lt;T&gt;::Insertchild(T value){
    TreeNode&lt;T&gt;* newnode = new TreeNode&lt;T&gt;(value);
    if(current-&gt;firstchild == NULL){
        current-&gt;firstchild = newnode;
    } else{
        TreeNode&lt;T&gt; *p = current-&gt;firstchild;
        while(p-&gt;nextsibling != NULL){
            p = p-&gt;nextsibling;
        }
        p-&gt;nextsibling = newnode;
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 三、**树的遍历（重点）**</span><br><span class="line"></span><br><span class="line">+ #### 深度优先遍历</span><br><span class="line"></span><br><span class="line">  + ##### 前序VLR</span><br><span class="line"></span><br><span class="line">    ```C++</span><br><span class="line">    //递归实现先序遍历</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    void PreOrder(BinaryNode&lt;T&gt;* t) &#123;</span><br><span class="line">        // preorder traversal of *t.</span><br><span class="line">        if(t)&#123;</span><br><span class="line">            visit(t);</span><br><span class="line">            PreOrder(t-&gt;Left);</span><br><span class="line">            PreOrder(t-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><h5 id="中序LVR"><a href="#中序LVR" class="headerlink" title="中序LVR"></a>中序LVR</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现非递归中序遍历</span></span><br><span class="line"><span class="comment">//非递归使用stack实现中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BinaryNode &lt;T&gt;*t)</span></span>&#123;  </span><br><span class="line">    Stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="comment">//无条件进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//一直进行压栈，直到最左下部分</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。</span></span><br><span class="line">            p = s.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            p = p-&gt;Right;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><h5 id="后序LRV"><a href="#后序LRV" class="headerlink" title="后序LRV"></a>后序LRV</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="comment">//结点的实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StkNode</span> &#123;</span><br><span class="line">    BinaryNode &lt;T&gt; * ptr;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(BinaryNode &lt;T&gt; * t)</span> </span>&#123;</span><br><span class="line">    Stack &lt;StkNode&lt;T&gt;&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    StkNode&lt;T&gt; Cnode;</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">//优先访问到最左下</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Cnode.ptr = p;</span><br><span class="line">            Cnode.tag = <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最左下结点出栈</span></span><br><span class="line">        Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">        p = Cnode.ptr;</span><br><span class="line">        <span class="keyword">while</span> (Cnode.tag == <span class="number">1</span>)<span class="comment">//从右子树回来 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果已经被访问一次了才进行输出</span></span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">                Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">                p = Cnode.ptr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//访问结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        Cnode.tag = <span class="number">1</span>;<span class="comment">//从左子树遍历完，而右子树还没有动。</span></span><br><span class="line">        s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">        p = p-&gt;Right;<span class="comment">//从左子树回来</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

</li>
<li><p>另外，非二叉树：</p>
<ul>
<li>先根：与原树的左子女右兄弟表示法的先序一致</li>
<li>后根：与原树的左子女右兄弟表示法的中序一致</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="广度优先遍历（分层访问）"><a href="#广度优先遍历（分层访问）" class="headerlink" title="广度优先遍历（分层访问）"></a>广度优先遍历（分层访问）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现层次访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; q=<span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    q.<span class="built_in">add</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Node temp = q.<span class="built_in">poll</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(temp.value);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=null) q.<span class="built_in">add</span>(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=null) q.<span class="built_in">add</span>(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><ul>
<li>将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连</li>
<li><strong>先根次序遍历：</strong> <ol>
<li>访问F的第一棵树的根 </li>
<li>按先根遍历第一棵树的子树森林 </li>
<li>按先根遍历其它树组成的森林</li>
<li>等于二叉树的先序</li>
</ol>
</li>
<li><strong>中根次序遍历：</strong> <ol>
<li>按中根遍历第一棵树的子树森林 </li>
<li>访问F的第一棵树的根 </li>
<li>按中根遍历其它树组成的森林</li>
<li>等于二叉树的中序</li>
</ol>
</li>
</ul>
<ul>
<li><strong>后根次序遍历：</strong> <ol>
<li>按后根遍历第一棵树的子树森林 </li>
<li>按后根遍历其它树组成的森林 </li>
<li>访问F的第一棵树的根</li>
<li>等于二叉树的后序</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="补、根据前中后序表达式建树"><a href="#补、根据前中后序表达式建树" class="headerlink" title="补、根据前中后序表达式建树"></a>补、根据前中后序表达式建树</h3><ul>
<li><p>根据先序遍历和中序遍历</p>
<ul>
<li><p>先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树</p>
</li>
<li><p>C++实现（java实现看作业4.0）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是一个递归算法</span></span><br><span class="line"><span class="function">BinaryNode&lt;Type&gt;*<span class="type">void</span> <span class="title">CreateBT</span> <span class="params">(String pres, ins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> inpos;</span><br><span class="line">    BinaryNode &lt;Type&gt;* temp;<span class="comment">//当前二叉树的节点</span></span><br><span class="line">    String prestemp, instemp;</span><br><span class="line">    <span class="keyword">if</span> (pres.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> BinaryNode; </span><br><span class="line">        temp-&gt;element=pres.ch[<span class="number">0</span>];</span><br><span class="line">        inpos=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从中序遍历中找到根节点的位置，这样子根节点左侧的是左子树，右侧的是右子树</span></span><br><span class="line">        <span class="keyword">while</span> (ins.ch[inpos]!=temp-&gt;element) </span><br><span class="line">            inpos++;</span><br><span class="line">        </span><br><span class="line">        prestemp = <span class="built_in">pres</span>(<span class="number">1</span>,inpos);<span class="comment">//小括号是重载的，将先序遍历字符串的1到inpos取出来，赋给中间变量</span></span><br><span class="line">        instemp= <span class="built_in">ins</span>(<span class="number">0</span>,inpos<span class="number">-1</span>);</span><br><span class="line">        temp-&gt;left = <span class="built_in">CreateBT</span>(prestemp, instemp);</span><br><span class="line">        </span><br><span class="line">        prestemp=<span class="built_in">pres</span>(inpos<span class="number">+1</span>, pres.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        instemp=<span class="built_in">ins</span>(inpos<span class="number">+1</span>, pres.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        temp-&gt;right = <span class="built_in">CreateBT</span>(prestemp, instemp);</span><br><span class="line">        <span class="keyword">return</span> temp;<span class="comment">//完成组装返回</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据中序遍历和后序遍历</p>
<ul>
<li>后序遍历树根在尾部，思路一致</li>
</ul>
</li>
<li><p>根据先序遍历和后序遍历</p>
<ul>
<li>先序遍历第二个位置是左子树的根，在后序遍历中，它是左右子树的分界点</li>
</ul>
</li>
</ul>
<h3 id="四、线索化二叉树（常考）"><a href="#四、线索化二叉树（常考）" class="headerlink" title="四、线索化二叉树（常考）"></a>四、线索化二叉树（常考）</h3><ul>
<li><p>目的：为了让二叉树的遍历更快</p>
</li>
<li><p>结构：在树的节点中加入一个指针</p>
<ul>
<li>指针放在哪？——n个节点有2n个链域，期中只有n-1个有用，剩余均为空域。</li>
</ul>
</li>
<li><p>机内存储</p>
<ul>
<li><p>一个节点增加两个标记域</p>
<table>
<thead>
<tr>
<th>leftchild</th>
<th>leftthread</th>
<th>data</th>
<th>rightthread</th>
<th>rightchild</th>
</tr>
</thead>
</table>
<ul>
<li>leftthread与rightthread为bool型，用于表示leftchild与rightchild指向子女还是前驱（后继）</li>
</ul>
</li>
</ul>
</li>
<li><p>几个算法</p>
<ol>
<li><p>按中序遍历中序线索树</p>
<ul>
<li><p>找到中序下的第一个节点（first），不断找后继（next）</p>
<ul>
<li>p指节点没有右子树（p-&gt;rightthread &#x3D;&#x3D; 1），则rightchild就是后继</li>
<li>p指节点有右子树（p-&gt;rightthread &#x3D;&#x3D; 0），则去找右子树的第一个节点</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用是current来记录下来当前节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::<span class="built_in">First</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;leftThread==<span class="number">0</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;<span class="comment">//找中序遍历的第一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::<span class="built_in">Next</span>() &#123;</span><br><span class="line">    ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;<span class="comment">//可能是右子树的根节点，也可能是右链 </span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightThread==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;leftThread==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果有右子树就要搜索到最左下部分</span></span><br><span class="line">            p=p-&gt;leftchlid;</span><br><span class="line">        &#125;</span><br><span class="line">    current=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> ThreadInorderIterator&lt;Type&gt;:: <span class="built_in">Inorder</span>() &#123; </span><br><span class="line">    ThreadNode&lt;Type&gt; *p;</span><br><span class="line">    <span class="keyword">for</span> ( p=<span class="built_in">Frist</span>(); p!=<span class="literal">NULL</span>; p=<span class="built_in">Next</span>()) </span><br><span class="line">        cout&lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造中序线索树</p>
<ul>
<li><p>对已存在的一棵二叉树建立中序线索树</p>
</li>
<li><p>在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Inthread</span><span class="params">(threadNode&lt;T&gt; * T)</span> </span>&#123;</span><br><span class="line">    stack &lt;threadNode &lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>)</span><br><span class="line">    ThreadNode &lt;T&gt; *p = T ;</span><br><span class="line">    ThreadNode &lt;T&gt; *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找到最左下部分的</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p -&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始弹出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            p = s.pop;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//添加的代码，在这时候处理pre</span></span><br><span class="line">                <span class="keyword">if</span> (pre -&gt;rightchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    pre -&gt;rightchild = p;  </span><br><span class="line">                    pre -&gt;rightthread = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理p</span></span><br><span class="line">                <span class="keyword">if</span>( p -&gt; leftchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    p -&gt; leftchild = pre;</span><br><span class="line">                    p -&gt;leftthread = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="comment">//添加的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = p ;</span><br><span class="line">            p = p -&gt; rightchild ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//for </span></span><br><span class="line">&#125;<span class="comment">//建议把pre和p存储成全局变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）"><a href="#五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）" class="headerlink" title="五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）"></a>五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）</h3><ul>
<li><p>一些概念：</p>
<ul>
<li>增长树：原二叉树中度为1的节点，增加一个空树叶；元二叉树中的树叶，增加两个空树叶</li>
<li>外通路长度（外路径）E：根到每个外节点（增长树的叶）的路径长度的总和</li>
<li>内通路长度（内路径）I：更到每个内节点（增长树的非叶）的路径长度总和</li>
<li>节点的带权路径长度：一个节点的权值与节点的路径长度的乘积</li>
<li>带权的外路径长度：各叶节点的带权路径长度之和</li>
<li>带权的内路径长度：各非叶节点的带权路径长度之和</li>
</ul>
</li>
<li><p>霍夫曼树</p>
<ul>
<li>给出m个实数W1，W2，…，Wm（m&gt;&#x3D;2）作为m个外节点的权构造一颗增长树，是的带权外路径长度最小</li>
</ul>
</li>
<li><p>霍夫曼算法：</p>
<ul>
<li><p>思想：权大的外节点靠近根，权小的远离根</p>
</li>
<li><p>算法：</p>
<ol>
<li><p>从m个权值中找出两个最小值W1，W2构成</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208192950155.png" alt="image-20230208192950155" style="zoom:70%;float:left" />

<p>W &#x3D; W1 + W2表示通过该节点的频度</p>
</li>
<li><p>然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解</p>
</li>
</ol>
<ul>
<li>当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15</li>
</ul>
</li>
</ul>
</li>
<li><p>霍夫曼编码：</p>
<ul>
<li>利用Huffman算法， 把各字符出现的频率作为外部结点的权， 构造具有最小带权外路径长度的增长树，把每个结点的左子女的边标上0， 右子女标上1。 这样从根到每个叶子的路径上的号码连接起来， 就是外结点的字符编码</li>
<li>使得电文总长度最小，并且任意字符的编码不是其他字符的前缀（不相互干扰）</li>
</ul>
</li>
</ul>
<h3 id="六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程"><a href="#六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程" class="headerlink" title="六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程"></a>六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程</h3><h4 id="6-1-二叉搜索树"><a href="#6-1-二叉搜索树" class="headerlink" title="6.1 二叉搜索树"></a>6.1 二叉搜索树</h4><ul>
<li><p>二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：</p>
<ul>
<li>每一个元素有key值（关键码、主码），key值独一无二不重复</li>
<li>一个树的左子树的关键字小于根中的关键字</li>
<li>一个树的右子树的关键字大于根中的关键字</li>
<li>根的左右子树还是二叉搜索树</li>
</ul>
</li>
<li><p>二叉搜索树可以在很大的数据量下，快速完成增删查改</p>
</li>
<li><p>索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1</p>
</li>
<li><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryNode 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    BinaryNode( Comparable theElement ) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>, <span class="literal">null</span> );<span class="comment">//调用本类中的其他构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;</span><br><span class="line">        element = <span class="type">theElement</span></span><br><span class="line">        <span class="variable">left</span> <span class="operator">=</span> lt;</span><br><span class="line">        right = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某元素</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">find</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">//Match </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找值最小的结点，找最大同理，往右找</span></span><br><span class="line"><span class="comment">//使用递归查找结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">( BinaryNode t )</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> findMin( t.left );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代找最小结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">(BinaryNode t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数值插入固定位置的算法</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">insert</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="comment">//先查找一次，如果找到了就不用进行查找</span></span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>( x, <span class="literal">null</span>, <span class="literal">null</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = insert( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = insert( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> ;<span class="comment">//duplicate; do nothing</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compareTo()方法如果小于返回负数，大于返回正数</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果结点本身不在树内，那么不需要删除</span></span><br><span class="line"><span class="comment"> * 如果结点本身在树里面，删除需要分类</span></span><br><span class="line"><span class="comment"> *  1.无子树:删除叶节点</span></span><br><span class="line"><span class="comment"> *  2.一颗子树:直接连接</span></span><br><span class="line"><span class="comment"> *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">remove</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = remove( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = remove( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span> ) &#123;</span><br><span class="line">        t.element = findMin( t.right ).element;<span class="comment">//把右树最小的复制给t</span></span><br><span class="line">        t.right = remove( t.element , t.right );<span class="comment">//递归的删除</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t = ( t.left != <span class="literal">null</span> ) ? t.left : t.right;<span class="comment">//一颗子树的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</p>
<ul>
<li>Best Case：$O(log_2n)$</li>
<li>最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去</li>
</ul>
</li>
</ul>
<h4 id="6-2-AVL树"><a href="#6-2-AVL树" class="headerlink" title="6.2 AVL树"></a>6.2 AVL树</h4><ul>
<li>自平衡的二叉搜索树</li>
<li>始终保持高度是数据量的对数，目的是为了降低增删改查的复杂度</li>
<li>定义：是一棵二叉搜索树；对于任意一个节点为树根，其左子树与右子树的高度差不能超过1</li>
<li>结构：<ul>
<li>多一个元素，记录树高度，或者平衡因子（两子树高度差）</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208202359104.png" alt="image-20230208202359104" style="zoom:67%;float:left" /></li>
</ul>
</li>
<li>方法（具体看笔记C6-搜索树）：<ul>
<li>查询：与正常二叉搜索树相同</li>
<li>插入：外增高，单旋（左外增则右下旋）；内增高，双旋（左内增则先左下旋后右下旋）<strong>看清楚对谁而言的内外与左右</strong></li>
<li>删除：与二叉搜索树删除相同，再检查平衡因子，进行旋转</li>
</ul>
</li>
<li>算法分析：<ul>
<li><strong>具有n个结点的平衡二叉树（AVL），进行一次插入或删除的时间最坏情况 &lt;&#x3D; O(log<del>2</del> n)</strong></li>
</ul>
</li>
</ul>
<h4 id="6-3-m叉搜索树"><a href="#6-3-m叉搜索树" class="headerlink" title="6.3 m叉搜索树"></a>6.3 m叉搜索树</h4><ul>
<li><p>m叉搜索树可能为空，非空m叉搜索树满足如下属性：</p>
<ul>
<li><p>m路搜索树每个节点里最多有m-1个值和m个索引</p>
</li>
<li><p>每个具有p元素的节点正好有p+1个子节点</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208204647861.png" alt="image-20230208204647861" style="zoom:100%;float:left" />

<blockquote>
<p>假设任何节点都有p个元素，那么C0 - Cp是他们对应的p+1个子节点</p>
</blockquote>
</li>
<li><p>对于节点（以上为例）</p>
<ul>
<li>在以C0为根的所有子树中的结点的值都小于k1</li>
<li>在以Cp为根的子树中的所有子树的值都大于kp</li>
<li>在以Ci为根的子树中的所有子树的值都在ki与ki+1之间</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么选择m叉搜索树？</p>
<ol>
<li>复杂度（高度）进一步减小</li>
<li>m叉搜索树是可以存入磁盘的，增删改查任意一个数据，只需要访问高度次磁盘</li>
</ol>
</li>
<li><p>操作（具体看笔记C6-搜索树）：</p>
<ul>
<li>插入：未满同级插，已满下级插</li>
<li>删除：删完不空直接删，删完空了下上提</li>
</ul>
</li>
<li><p>行高：</p>
<ul>
<li>一个高为h的m路搜索树最少有h个结点(每一层只有一个结点)，最多有m^h^-1个结点</li>
<li>n个节点的m路搜索树高度在log<del>m</del>(n+1)和n之间</li>
</ul>
</li>
</ul>
<h4 id="6-4-B树"><a href="#6-4-B树" class="headerlink" title="6.4 B树"></a>6.4 B树</h4><ul>
<li><p>平衡的m路搜索树</p>
</li>
<li><p>在m路搜索树的基础上，非空B树有以下扩展属性</p>
<ul>
<li>每个根结点至少有两个子女</li>
<li>所有内节点都至少有m&#x2F;2(向上取整)个子结点</li>
<li>所有的外节点必须都在同一层（所有子树高度一样高）</li>
<li>外部节点的个数等于关键字数+1</li>
</ul>
</li>
<li><p>操作：</p>
<ul>
<li><p>搜索：与m路搜索数相同，与树高有关，一个m节有n个节点的树，高度在log<del>m</del>(n+1)与1+log<del>⌈m&#x2F;2⌉</del>(n+1)&#x2F;2之间</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142357142.png" alt="image-20230209142357142" style="zoom:60%;float:left" /><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142416129.png" alt="image-20230209142416129" style="zoom:80%;" /></p>
</li>
<li><p>插入：</p>
<ul>
<li>算法思想<ul>
<li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序</li>
<li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol>
<li>从该节点的原有元素和新的元素中选择出中位数</li>
<li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值</li>
<li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）</li>
</ol>
</li>
</ul>
</li>
<li>算法分析：如果操作导致s个节点分裂，那么磁盘查找次数为：h+2s+1<ul>
<li>h为在搜索路径上的读操作；2s为写出两个新节点操作；1为新节点（可能是创建的新根，也可能是最终一个节点被修改）</li>
</ul>
</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li><p>算法思想：</p>
<ol>
<li><p>如果要删除的关键码不在B数中，则直接退出</p>
</li>
<li><p>如果要删除的关键码在外部节点：</p>
<ul>
<li><p>如果删除后节点仍有超过⌈m&#x2F;2⌉个节点，则直接删除</p>
</li>
<li><p>如果不足，则需要向邻居<strong>借关键码</strong>：</p>
<table>
<thead>
<tr>
<th>邻居够借（进行调整）</th>
<th>邻居不够借（与邻居合并，导致上级节点关键码减少，再借或合并）</th>
</tr>
</thead>
<tbody><tr>
<td><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209143950542.png" alt="image-20230209143950542" style="zoom:110%;float:left" /><br />注意：相当于根节点与被借节点的一次旋转</td>
<td><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209144057066.png" alt="image-20230209144057066" style="zoom:120%;float:left" /><br />删除后“367 379 389 401 419 439”为新节点，但“283 353”出现不足，再求助与邻居</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>如果要删除的关键码在非叶节点：</p>
<ul>
<li>删除这个节点</li>
<li>把这个节点替换成右子树中的最小关键码(或者左子树中的最大关键码)</li>
<li>因为相当于删除了右子树的最小关键码(或者左子树中的最大关键码)，所以重复删除叶结点关键码的操作。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第五章（散列表）"><a href="#第五章（散列表）" class="headerlink" title="第五章（散列表）"></a>第五章（散列表）</h2><h3 id="一、散列函数"><a href="#一、散列函数" class="headerlink" title="一、散列函数"></a>一、散列函数</h3><ul>
<li><p>散列函数是为了将增删改查的复杂度降低至常数，代价是特别浪费空间</p>
</li>
<li><p>负载因子与再散列：</p>
<ul>
<li>为了减少冲突处理的次数，哈希表一般都是稀疏的。我们记整个哈希表容量为$n$，负载因子为$\alpha$，则一旦哈希表内数据量达到$n\alpha$，我们就需要扩充表容量了，这叫再散列</li>
<li>再散列：<ul>
<li>尽量保证表项数&gt;表的70%，也就是意味着如果不满足，就需要进行再散列</li>
<li>取比原表长*2大的指数再散列</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>取余法（大部分情况下）</strong>：</p>
<ul>
<li><code>H(key) = key % M</code>，M取小于基本区长度的<strong>最大质数</strong></li>
</ul>
</li>
<li><p>平方取余法</p>
<ul>
<li><code>H(key) = key * key的中间部分</code></li>
</ul>
</li>
<li><p>乘法杂凑函数</p>
</li>
</ul>
<h3 id="二、冲突处理"><a href="#二、冲突处理" class="headerlink" title="二、冲突处理"></a>二、冲突处理</h3><ul>
<li>碰撞的两个（或多个）关键码称为同义词，即H(k<del>1</del>) &#x3D; H(k<del>2</del>)，k<del>1</del> 不等于 k<del>2</del></li>
<li><strong>开放地址的线性探测法</strong><ul>
<li>方法：如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会按照线性顺序向后成环形查找</li>
<li>带来几个问题：<ol>
<li>散列表越满，查找的复杂度可能越高，需要更多的遍历</li>
<li>堆积问题：指不同的同义词表合为一张了。从而增加了插入，查找的时间</li>
<li>删除问题：不能进行真删除，会截断环型查找，而是通过标记表示数据无效</li>
</ol>
</li>
</ul>
</li>
<li>二次探测很少考<ul>
<li>如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会检查d+1，d+4，d+9，…的位置</li>
</ul>
</li>
<li>双散列（有时考）<ul>
<li>如果k的第一哈希值为d，而这个对应的格子已经被占用则我们继续计算k的第二哈希值，然后检查d+c…</li>
<li>第一个散列函数发生冲突，那么使用第二个散列函数来放置，如果再次冲突则进行相应探测</li>
</ul>
</li>
</ul>
<h3 id="三、分离链接"><a href="#三、分离链接" class="headerlink" title="三、分离链接"></a>三、分离链接</h3><ul>
<li>冲突了拖个链表，查找的时候需要遍历对应链表</li>
</ul>
<h3 id="四、应用环境下发现其应用"><a href="#四、应用环境下发现其应用" class="headerlink" title="四、应用环境下发现其应用"></a>四、应用环境下发现其应用</h3><ul>
<li><p>一般是元素本身可以提取出一个关键码，并且有需求实现快速增删改查的场景下</p>
</li>
<li><p>上段代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++的线性探测法实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;<span class="comment">// 假设每一元素的类型为E，并且有一个类型为k的关键码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HashTable</span>(<span class="type">int</span> divisor = <span class="number">11</span>);</span><br><span class="line">        ~<span class="built_in">HashTable</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[]ht;</span><br><span class="line">            <span class="keyword">delete</span> []empty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> K&amp;k ,E&amp; e)</span><span class="type">const</span></span>; </span><br><span class="line">        <span class="function">HashTable&lt;E,K&gt;&amp;<span class="title">Insert</span><span class="params">(<span class="type">const</span> E&amp;e)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">hSearch</span><span class="params">(<span class="type">const</span> K&amp; k)</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="type">int</span> D;<span class="comment">//hash function divisor</span></span><br><span class="line">        E *ht ; <span class="comment">//hash table array</span></span><br><span class="line">        <span class="type">bool</span> *empty ; <span class="comment">//1D array，为了实现标记删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable的构造方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;<span class="comment">//E和K需要被实例化后，这个类才能被调用。</span></span><br><span class="line">HashTable&lt;E,K&gt;::<span class="built_in">HashTable</span>(<span class="type">int</span> divisor)&#123;</span><br><span class="line">    D = divisor;</span><br><span class="line">    ht = <span class="keyword">new</span> E[D];</span><br><span class="line">    empty= <span class="keyword">new</span> <span class="type">bool</span>[D];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;i++)</span><br><span class="line">        empty[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="type">int</span> HashTable&lt;E,K&gt;::<span class="built_in">hSearch</span>(<span class="type">const</span> K&amp;k)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> i= k % D;<span class="comment">//home bucket</span></span><br><span class="line">    <span class="type">int</span> j= i ; <span class="comment">//start at home bucket</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty[j] || ht[j]==k) <span class="keyword">return</span> j;<span class="comment">//fit</span></span><br><span class="line">        j=(j<span class="number">+1</span>)%D; <span class="comment">//next bucket，%D是为了实现环型遍历</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(j!= i);  <span class="comment">//returned to home?是否循环完成一遍</span></span><br><span class="line">    <span class="keyword">return</span> j; <span class="comment">//table full;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数进行引用K&amp;k</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="type">const</span> K&amp;k,E&amp;e)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//put element that matches k in e.</span></span><br><span class="line">    <span class="comment">//return false if no match.</span></span><br><span class="line">    <span class="type">int</span> b= <span class="built_in">hSearch</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(empty[b]||ht[b].key!=k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=ht[b];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line">HashTable&lt;E,K&gt;&amp; HashTable&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> E&amp; e) &#123;</span><br><span class="line">     K k=e.key;<span class="comment">//extract key</span></span><br><span class="line">     <span class="type">int</span> b=<span class="built_in">hSearch</span>(k);</span><br><span class="line">     <span class="keyword">if</span>(empty[b])&#123;</span><br><span class="line">        empty[b]=<span class="literal">false</span>;</span><br><span class="line">        ht[b]=e;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NoMem</span>();  <span class="comment">//table full</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p> java二次探测与分离链接实现去看SpriCoder</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="第六章（优先级队列）"><a href="#第六章（优先级队列）" class="headerlink" title="第六章（优先级队列）"></a>第六章（优先级队列）</h2><ul>
<li>一个优先级队列是0个或者更多元素的集合，每一个元素都有一个优先级或者值</li>
<li>分为最大和最小优先级队列：删除（出列）优先删除优先级最大（小）的元素</li>
</ul>
<h3 id="一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆"><a href="#一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆" class="headerlink" title="一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆"></a>一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆</h3><ul>
<li>最大优先级队列——最大堆，最小优先级队列——最小堆</li>
<li>最大堆是一棵完全二叉树，每一个节点上的值都大于或等于它的子节点</li>
</ul>
<h4 id="1-1-插入（进堆、上滤）"><a href="#1-1-插入（进堆、上滤）" class="headerlink" title="1.1 插入（进堆、上滤）"></a>1.1 插入（进堆、上滤）</h4><ul>
<li><p>算法思想：在树最后插入后，与父节点进行比较，如果比父节点大，则交换，一直到不再大于父节点</p>
</li>
<li><p>复杂度分析：log<del>2</del>(n)</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: <span class="built_in">Insert</span>(<span class="type">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize= =MaxSize) <span class="keyword">throw</span> <span class="built_in">NoMem</span>(); </span><br><span class="line">    <span class="type">int</span> i= ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; x&gt;heap[i/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">//0不使用</span></span><br><span class="line">        heap[i]=heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不必每次都进行完全交换</span></span><br><span class="line">        i/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-删除（出堆、下滤）"><a href="#1-2-删除（出堆、下滤）" class="headerlink" title="1.2 删除（出堆、下滤）"></a>1.2 删除（出堆、下滤）</h4><ul>
<li><p>算法思想：将根删除，将树最后一个节点换为根，然后进行下滤操作</p>
</li>
<li><p>复杂度分析：log<del>2</del>(n)</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: <span class="built_in">DeleteMax</span>(T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize==<span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">OutOfBounds</span>(); </span><br><span class="line">    x = heap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0无存储，这个就是root结点</span></span><br><span class="line">    T y=heap[CurrentSize--];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;<span class="comment">//i标向树根</span></span><br><span class="line">    ci=<span class="number">2</span>;<span class="comment">//ci先标到左子树</span></span><br><span class="line">    <span class="keyword">while</span>(ci&lt;=CurrentSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci<span class="number">+1</span>])<span class="comment">//如果ci未越界，并且左子树的值小于右子树的值。</span></span><br><span class="line">            ci++;<span class="comment">//转向右子树</span></span><br><span class="line">        <span class="keyword">if</span>(y&gt;=heap[ci]) <span class="keyword">break</span>;</span><br><span class="line">        heap[i]=heap[ci];</span><br><span class="line">        i=ci;</span><br><span class="line">        ci*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=y;<span class="comment">//y是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-线性时间建堆"><a href="#1-3-线性时间建堆" class="headerlink" title="1.3 线性时间建堆"></a>1.3 线性时间建堆</h4><ul>
<li><p>步骤：</p>
<ol>
<li>先将n个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意是对每个子树进行递归处理</span></span><br><span class="line">Template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span> MaxHeap&lt;T&gt;::<span class="built_in">Initialize</span> (T a[],<span class="type">int</span> size,<span class="type">int</span> ArraySize) &#123; </span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap=a;</span><br><span class="line">    CurrentSize=Size;</span><br><span class="line">    MaxSize=ArraySize;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=CurrentSize/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        T y=heap[i];</span><br><span class="line">        <span class="type">int</span> c=<span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c<span class="number">+1</span>])</span><br><span class="line">                c++;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[c/<span class="number">2</span>] = heap[c];</span><br><span class="line">            c*=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到其子节点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap[c/<span class="number">2</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>算法分析：</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213163633887.png" alt="image-20230213163633887" style="zoom:100%;float:left" />

<ul>
<li>如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第七章（并查集）"><a href="#第七章（并查集）" class="headerlink" title="第七章（并查集）"></a>第七章（并查集）</h2><h3 id="一、并查集功能（Union、Find）"><a href="#一、并查集功能（Union、Find）" class="headerlink" title="一、并查集功能（Union、Find）"></a>一、并查集功能（Union、Find）</h3><ul>
<li><p>Combine：合并包含元素a和b的两个等价类为一个等价类</p>
<ul>
<li><p>Combine(a, b) ：<code>i = Find(a); j = Find(b); if(i != j) Union(i, j);</code></p>
</li>
<li><p>并查集的实现通过森林（下图是union(1,5)的实现，parent数组存放节点的父节点）</p>
<table>
<thead>
<tr>
<th><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152800463.png" alt="image-20230213152800463"></th>
<th><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152808426.png" alt="image-20230213152808426"></th>
</tr>
</thead>
</table>
</li>
</ul>
</li>
<li><p>Find：找到包含元素e的等价类</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simple tree solution to union-find problem </span></span><br><span class="line"><span class="comment">//使用简单的树结构解决并集的查找问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">1</span>;e&lt;=n;e++) parent[e]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向上找到其根结点</span></span><br><span class="line">    <span class="keyword">while</span>(parent[e]) e=parent[e];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//合并两个结点</span></span><br><span class="line">    parent[j]=i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
<li><p>性能估计</p>
<ul>
<li>Find——O(n)，n为树高</li>
<li>Union——$\theta$(1)</li>
</ul>
</li>
<li><p>性能提升</p>
<ul>
<li><p>优化Union</p>
<ul>
<li><p>方法一：（权值规则）<strong>节点数少的树挂到节点数多的树下</strong></p>
<ul>
<li><p>如何记录weight？新建一个bool类型数组表示是否为根节点，如果为根，则其父节点字段记录书中节点总数（如何省略标记根的数组？——用负数来表示）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入上两条优化</span></span><br><span class="line"><span class="comment">//Union with the weight rule</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    root=<span class="keyword">new</span> <span class="type">bool</span>[n<span class="number">+1</span>];</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">1</span>;e&lt;=n;e++) &#123;</span><br><span class="line">        parent[e]=<span class="number">1</span>;</span><br><span class="line">        root[e]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!root[e])</span><br><span class="line">        e=parent[e];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[i]&lt;parent[j])</span><br><span class="line">    <span class="comment">//i becomes subtree of j</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent[j]=parent[j]+parent[i];</span><br><span class="line">        root[i]=<span class="literal">false</span>;</span><br><span class="line">        parent[i]=j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i]=parent[i]+parent[j];</span><br><span class="line">        root[j]=<span class="literal">false</span>;</span><br><span class="line">        parent[j]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法二：（高度规则）<strong>高度低的树挂到高度高的树的下</strong></p>
</li>
</ul>
</li>
<li><p>优化Find</p>
<ul>
<li><p>如果路径上的点父节点非根节点，则将其与根节点相连</p>
</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213161401167.png" alt="image-20230213161401167" style="zoom:80%;float:left" />
</li>
<li><pre><code class="language-c++">int Find(int e) {
    /* C++ */
    int j = e;
    while(!root[j])
        j=parent[j];
    int f = e;
    while(f!=j) {
        int pf = parent[f];
        parent[f] = j;
        f = pf;
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 二、一般和最小生成树算法一起考（kruskal算法）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第八章（图）</span><br><span class="line"></span><br><span class="line">### 一、概念（选择填空）</span><br><span class="line"></span><br><span class="line">+ Graph = (V, E)，顶点集+边集</span><br><span class="line">+ 有向图与无向图，完全与否</span><br><span class="line">+ 度数：连到这个顶点的边的数量，有向图有出度与入度之分，所有顶点度数之和为边的两倍</span><br><span class="line">+ 子图：图 G=(V, E) 和图 G&#x27;=(V&#x27;, E&#x27;) ，如果V&#x27;包含于V，E’包含于E,并且E&#x27;中顶点的边也在G&#x27;中，那么G&#x27;是G的子图</span><br><span class="line">+ 路径：在图 G= (V, E)中，如果边(i~j~，i~j+1~)都在E中，1&lt;= j&lt; k，则顶点序列P=i~1~，i~2~，…,i~k~是i~1~到i~k~的路径</span><br><span class="line">  + 简单路径：路径除了第一个和最后一个顶点没有出现相同的顶点</span><br><span class="line">  + 环：起点和终点相同的简单路径</span><br><span class="line">+ 连通图：无向图中任意两个点是连通的，则为连通图</span><br><span class="line">+ 强连通图：有向图中，每对不同的顶点i, j，包含从i到j和从j到i的有向路径是，则为强联通图</span><br><span class="line">+ 加权图：边被分配权值</span><br><span class="line">+ 生成树：对于连通图来说，是其极小连通子图；n顶点的生成树有n-1条边</span><br><span class="line"></span><br><span class="line">### 二、邻接矩阵、邻接表掌握，邻接多重表不要求</span><br><span class="line"></span><br><span class="line">#### 2.1 邻接矩阵</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130091646130.png&quot; alt=&quot;image-20221130091646130&quot; style=&quot;zoom:60%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ 无向图的邻接矩阵：对称的、对角线为0（无自环）、度数等于对应行的和</span><br><span class="line"></span><br><span class="line">+ 有向图的邻接矩阵：行为起点，列为终点、出度对行求和，入度对列求和</span><br><span class="line"></span><br><span class="line">+ 加权图的邻接矩阵：</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130093426305.png&quot; alt=&quot;image-20221130093426305&quot; style=&quot;zoom:80%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2 邻接表</span><br><span class="line"></span><br><span class="line">+ &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130093948312.png&quot; alt=&quot;image-20221130093948312&quot; style=&quot;zoom:57%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130094057188.png&quot; alt=&quot;image-20221130094057188&quot; style=&quot;zoom:60%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ 代码看notes</span><br><span class="line"></span><br><span class="line">### 三、最小生成树（2个）算法掌握，流程复杂度清晰</span><br><span class="line"></span><br><span class="line">### 四、最小路径（3个）算法掌握，流程复杂度清晰</span><br><span class="line"></span><br><span class="line">### 五、活动网络常考（AOV拓扑排序，AOE关键路径）流程复杂度</span><br><span class="line"></span><br><span class="line">+ 上三个看notes</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 排序算法</span><br><span class="line"></span><br><span class="line">+ 流程</span><br><span class="line">+ 看代码（无代码不看代码）</span><br><span class="line">+ 复杂度</span><br><span class="line">+ 性质要求的</span><br><span class="line">+ 折半插入排序不做重点</span><br><span class="line">+ **快排**重点</span><br><span class="line">+ 锦标赛排序考得不多</span><br><span class="line">+ **选择排序**</span><br><span class="line">+ **堆排序**</span><br><span class="line">+ 堆排序注意其是一个固定算法，不额外占用空间</span><br><span class="line">+ **归并排序**</span><br><span class="line"></span><br><span class="line">### 一、PPT**最后的表格**</span><br><span class="line"></span><br><span class="line">| 排序方法        | 比较次数     | 平均比较次数 | 稳定性 | 移动次数     | 辅助存储    |</span><br><span class="line">| --------------- | ------------ | ------------ | ------ | ------------ | ----------- |</span><br><span class="line">| **1、插入排序** |              |              |        |              |             |</span><br><span class="line">| 直接插入排序    | n~n^2^/2     | $O(n^2)$     | 稳定   | 2n~n^2^/2    | $O(1)$      |</span><br><span class="line">| 二分法插入排序  | nlog~2~n     | $O(nlog_2n)$ | 稳定   | 2n~n^2^/2    | $O(1)$      |</span><br><span class="line">| 表插入排序      | n~n^2^/2     | $O(n^2)$     | 稳定   | 0            | $O(n)$      |</span><br><span class="line">| shell排序       |              |              | 不稳定 |              | $O(1)$      |</span><br><span class="line">| **2、选择排序** |              |              |        |              |             |</span><br><span class="line">| 直接选择排序    | n(n-1)/2     | $O(n^2)$     | 不稳定 | 3*(n-1)      | $O(1)$      |</span><br><span class="line">| 堆排序          | $O(nlog_2n)$ | $O(nlog_2n)$ | 不稳定 |              | $O(1)$      |</span><br><span class="line">| **3、交换排序** |              |              |        |              |             |</span><br><span class="line">| 冒泡排序        | n-1          | $O(n^2)$     | 稳定   | 0~3/2*n(n-1) | $O(1)$      |</span><br><span class="line">| 快排            | nlog~2~n     | $O(nlog_2n)$ | 不稳定 | &lt;=nlog~2~n   | $O(log_2n)$ |</span><br><span class="line">| **4、分配排序** |              |              |        |              |             |</span><br><span class="line">| 基数排序        | $O(d*(n+r))$ | $O(d*(n+r))$ | 稳定   | 拉链         | $O(n+r)$    |</span><br><span class="line">| **5、归并排序** |              |              |        |              |             |</span><br><span class="line">| 归并排序        | $O(nlog_2n)$ | $O(nlog_2n)$ | 稳定   |              | $O(n)$      |</span><br><span class="line"></span><br><span class="line">### 二、快排</span><br><span class="line"></span><br><span class="line">+ 方法：在n个对象中，取一个对象（如第一个对象）为基准pivot，按该对象的关键码把所有不大于该关键码的对象划在它的左边，大于该关键码的对象划到它右边；然后对于左右两个子序列再进行快排</span><br><span class="line"></span><br><span class="line">+ 注意这里的划分方法：PPT中采用两个指针，交换基准数与非序数（自己起的名字）来实现，直到两指针都指向基准数</span><br><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">  template &lt;class Type&gt; void QuickSort( datalist &lt;Type&gt;&amp; list, const int left,  const int right ) &#123;</span><br><span class="line">      if (left&lt;right) &#123;</span><br><span class="line">          int pivotpos = partition(list, left, right);</span><br><span class="line">          QuickSort(list, left, pivotpos-1);</span><br><span class="line">          QuickSort(list, pivotpos+1, right);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //partition</span><br><span class="line">  template &lt;class Type&gt; int partition(datalist&lt;Type&gt; &amp;list, const int low, const int high) &#123;</span><br><span class="line">      int i=low,j=high;</span><br><span class="line">      Element&lt;Type&gt;pivot=list.Vector[low];</span><br><span class="line">      while (i != j ) &#123;</span><br><span class="line">          while(list.Vector[j].getkey()&gt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">          if (i&lt;j) &#123;</span><br><span class="line">              list.Vector[i]=list.Vector[j];</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          while(list.Vector[i].getkey()&lt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          if (i&lt;j) &#123;</span><br><span class="line">              list.Vector[j]=list.Vector[i];</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      list.Vector[i]=pivot;</span><br><span class="line">      return i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时间复杂度$O(nlog_2n)$</p>
</li>
<li><p>空间复杂度：非递归算法需要使用栈来存放左部或右部的上下界的下标:$O(log_2n)$ ~ $O(n)$</p>
</li>
<li><p><strong>选择pivot</strong>：<strong>三数中值分割法</strong>（左端、右端和中心三个元素的中值为枢纽元）</p>
<ul>
<li>将枢纽元放在数组的末尾（倒数第二个位置，因为最后的值确定比枢纽元大）</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6262208.html">三数中值分隔法</a></li>
</ul>
</li>
</ul>
<h3 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h3><ul>
<li><p>方法：每次都选出一个最大（小）值，将其放到数组最前</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span> [] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//sort the n number in a[0:n-1].</span></span><br><span class="line">    <span class="comment">//找到大数字放置到后面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> n; size&gt;<span class="number">1</span>; size--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Max(a,size);</span><br><span class="line">        swap(a[j],a[size-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
<li><p>算法分析：</p>
<ul>
<li>比较次数，固定为n(n-1)&#x2F;2</li>
<li>移动次数，固定为3*(n-1)，每次swap有3次操作</li>
<li>$O(n^2)$</li>
</ul>
</li>
</ul>
<h3 id="四、堆排序"><a href="#四、堆排序" class="headerlink" title="四、堆排序"></a>四、堆排序</h3><ul>
<li><p>是固定的算法</p>
</li>
<li><p>方法：一开始先建立最大堆，最后调整为最小堆</p>
<ul>
<li>如何调整：将树根（最大值）与最后一个未定序的节点交换，再对新根做下滤，知道所有节点都定序</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java program</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapsort</span><span class="params">( Comparable []a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">        percDown( a, i, a.length );<span class="comment">// 建最大堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length – <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        swapReferences( a, <span class="number">0</span>, i );</span><br><span class="line">        percDown( a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">( <span class="type">int</span> i )</span> &#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">percDown</span><span class="params">( Comparable [ ] a, <span class="type">int</span>  i,  <span class="type">int</span> n )</span> &#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    Comparable tmp;</span><br><span class="line">    <span class="keyword">for</span>( tmp = a[i];leftChild(i) &lt; n ; i = child ) &#123;</span><br><span class="line">        child = leftchild( i );</span><br><span class="line">        <span class="keyword">if</span>( child!=n – <span class="number">1</span>&amp;&amp; a[child].compareTo( a[ child + <span class="number">1</span> ] ) &lt; <span class="number">0</span> )</span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>( tmp . compareTo( a[ child ] &lt; <span class="number">0</span> )</span><br><span class="line">            a[ i ] = a[ child ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>复杂度：$O(nlog_2n)$</p>
</li>
</ul>
<h3 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h3><ul>
<li><p>方法：每次去除两个序列中最小的元素输出，当一序列完，则输出另一序列</p>
</li>
<li><p>迭代的归并排序算法</p>
<ul>
<li>n个长为1的对象两两合并，得n&#x2F;2个长为2的文件</li>
<li>n&#x2F;2个长为2的对象两两合并，得n&#x2F;4个长为4的文件</li>
<li>……</li>
<li>2个长为n&#x2F;2的对象两两合并，得1个长为n的文件</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a )</span> &#123;</span><br><span class="line">    Comparable [ ] tmpArray = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    mergeSort( a, tmpArray, <span class="number">0</span>, a.length – <span class="number">1</span> );</span><br><span class="line">&#125;                            </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> left, <span class="type">int</span> right )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; right ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmparray, left, center );</span><br><span class="line">        mergeSort(a, tmpArray, center + <span class="number">1</span>, right );</span><br><span class="line">        merge( a, tmpArray, left, center + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd )</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> rightPos – <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> rightEnd – leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )</span><br><span class="line">        <span class="keyword">if</span>( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= <span class="number">0</span> )</span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ rightPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd )</span><br><span class="line">        tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( rightpos &lt;= rightEnd)</span><br><span class="line">        tmpArray[ tmpPos++] = a[ rightpos++ ];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; i++, rightEnd-- )</span><br><span class="line">        a[ rightEnd ] = tmpArray[ rightEnd ];</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

</li>
<li><p>算法分析：$O(nlog_2n)$</p>
</li>
<li><p>有序链表的merge算法</p>
<ul>
<li>切断链表：设两个流动指针p,q指向表的结点 一般来讲让p前进一步，q前进二步，最后当q&#x3D; NULL时，这时p 恰好指向前半张表的最后一个结点</li>
</ul>
</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><ul>
<li>程序调用自己的编程技巧。函数和函数的调用可以构成一个环，就可以称作一个递归</li>
<li>通过重复将问题分解为同类子问题来解决问题</li>
<li>注意：<ol>
<li>递归就是在过程或函数里面调用自身(自递归)</li>
<li>使用递归，必须有一个明确的递归结束条件，称为递归出口。只有<strong>一个</strong>就行</li>
<li>两个或者多个函数互相递归(互递归)</li>
</ol>
</li>
<li>过程：<ol>
<li>递归：把复杂的问题的求解推到比原问题更简单的问题的求解</li>
<li>回归：获得最简单的情况后，逐步返回，依次得到复杂的解</li>
</ol>
</li>
<li>物理层面：递归栈</li>
</ul>
<h3 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h3><ul>
<li>分阶段：把问题分成两个大致相等的子问题，然后递归地对它们求解。</li>
<li>治阶段： 将两个子问题的解合并到一起，可能再做些少量的附加工作，最后得到整个问题的解。</li>
</ul>
<h3 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h3><ul>
<li>逐步求解，只关心眼前</li>
<li>Prim、Kruskal、Dijkstra</li>
</ul>
<h3 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h3><ul>
<li><p>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p>
</li>
<li><p>Bellman-Ford</p>
</li>
</ul>
<h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><ol>
<li>最短路径算法</li>
<li>不会考概念默写</li>
</ol>
<h2 id="第一章-1"><a href="#第一章-1" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li>递归会考</li>
<li>汉诺塔？</li>
</ol>
<h2 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li>大O表示法，theta表示法，omega表示法，分析复杂度</li>
<li>分治？</li>
</ol>
<h2 id="第三章-（线性表，栈，队列）"><a href="#第三章-（线性表，栈，队列）" class="headerlink" title="第三章 （线性表，栈，队列）"></a>第三章 （线性表，栈，队列）</h2><ol>
<li>线性表<ol>
<li>单链表</li>
<li>双向链表不考，循环链表记不清了</li>
<li>约瑟夫不考</li>
<li>所有的排序都要注意</li>
</ol>
</li>
<li>栈<ol>
<li>栈的物理层实现不考</li>
</ol>
</li>
<li>队列</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol>
<li>概念要理解，如满二叉树和完全二叉树的区别</li>
<li>广义表不考</li>
<li>遍历，递归和<strong>非递归</strong></li>
<li>由序列建树</li>
<li>一般树的表示法：<ol>
<li>双亲表示（和并查集什么关系？）</li>
<li>左子女右兄弟</li>
<li>广义表（不考）</li>
</ol>
</li>
<li>线索树</li>
<li>搜索树</li>
<li>霍夫曼树</li>
<li>AVL树</li>
<li>B树</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol>
<li>平方取中法没考，杂乘没考，二次探测没考</li>
<li>线性探测容易考</li>
<li>链地址法（分离链接法）看看</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li>优先级队列就考堆了</li>
<li>证明不考</li>
<li>O（N）复杂度的建堆方法</li>
</ol>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol>
<li>并查集好像没考</li>
</ol>
<h2 id="第八章-（图）"><a href="#第八章-（图）" class="headerlink" title="第八章 （图）"></a>第八章 （图）</h2><ol>
<li>领接矩阵，邻接表要考</li>
<li>领结多重表不考</li>
<li>遍历算法</li>
<li>最小生成树，最短路径</li>
<li>AOE常考<ol>
<li>拓扑排序</li>
<li>算时间</li>
</ol>
</li>
</ol>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol>
<li>折半不考？</li>
<li>希尔不考</li>
<li>竞标赛不考</li>
<li>选择排序，快排，堆排序</li>
<li>归并是重点！！！</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/12/04/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" rel="prev" title="互联网计算">
                  <i class="fa fa-angle-left"></i> 互联网计算
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/04/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/" rel="next" title="毛概复习">
                  毛概复习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
