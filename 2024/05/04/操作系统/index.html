<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"ebc5f2cd8493752a92129fa16b4bf1635308b0d6","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="第一讲 · 操作系统概述概述 内核，进程和线程： 内核：控制多道程序执行的系统超级程序 进程：即内核控制下的多道程序实例(一个独立执行的程序指令流) 线程：是进程的基本执行单位，通常被称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源（如内存、打开的文件等）。   OS是中断驱动的 总览![屏幕截图 2025-02-24 113426](E:\Pictures\Screen">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://kongshan.me/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:description" content="第一讲 · 操作系统概述概述 内核，进程和线程： 内核：控制多道程序执行的系统超级程序 进程：即内核控制下的多道程序实例(一个独立执行的程序指令流) 线程：是进程的基本执行单位，通常被称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源（如内存、打开的文件等）。   OS是中断驱动的 总览![屏幕截图 2025-02-24 113426](E:\Pictures\Screen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/12.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/7.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/8.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/14.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/13.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/9.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/32.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/80.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/15.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/21.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/17.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/19.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/20.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/22.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/23.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318204105076.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102402017.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102526444.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/8.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103121851.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103508697.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103659047.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103801245.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324104131474.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324105052339.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/27.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/17.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/20.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/21.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104230843.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104328678.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331105353886.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104351141.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104416252.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/51.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/55.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/83.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/76.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/77.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/33.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/88.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/14.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/15.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/17.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421102810232.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421104404005.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105520096.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105553539.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/1.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421115348634.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428113341689.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/26.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/5.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/17.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428112651146.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/27.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/9.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/23.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/24.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512103948727.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112253396.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112306550.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112343027.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512113527360.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/41.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/42.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519105828495.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519110524795.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519111008420.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113033843.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113706958.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113726494.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115725366.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115455054.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115517425.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522104654836.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/60.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/61.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/62.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/63.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/64.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/65.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/66.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522114935161.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115334937.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115358852.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115425074.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115444182.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171023399.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171043589.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/112.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/25.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/26.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/86.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/87.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/88.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/89.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/90.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/91.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/27.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/92.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/113.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/28.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250427191806703.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250603203011372.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250608180546438.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602171744758.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172431181.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172450157.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602173324647.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250604173033445.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110727554.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110741521.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421111351369.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250610173842189.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png">
<meta property="og:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/11.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526153852861.png">
<meta property="article:published_time" content="2024-05-04T04:00:00.000Z">
<meta property="article:modified_time" content="2025-12-03T09:38:18.473Z">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/12.png">


<link rel="canonical" href="https://kongshan.me/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongshan.me/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","path":"2024/05/04/操作系统/","title":"操作系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统 | kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">kongshan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%C2%B7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">第一讲 · 操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%C2%B7-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">第二章 · 处理器管理文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">2.1.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">处理器模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="nav-number">2.1.2.</span> <span class="nav-text">处理器模式切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="nav-number">2.1.3.</span> <span class="nav-text">栈空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.4.</span> <span class="nav-text">中断系统处理流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.2.</span> <span class="nav-text">转态和转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E5%92%8C%E7%BB%84%E6%88%90"><span class="nav-number">2.2.3.</span> <span class="nav-text">描述和组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88Process-Control-Block%EF%BC%8CPCB%EF%BC%89"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">进程控制块&#x2F;描述符（Process Control Block，PCB）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">进程上下文</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97"><span class="nav-number">2.2.4.</span> <span class="nav-text">进程队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.5.</span> <span class="nav-text">进程管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.2.6.</span> <span class="nav-text">进程切换与模式切换(状态转换)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88-KLT-Kernel-Level-Threads%EF%BC%89"><span class="nav-number">2.3.2.</span> <span class="nav-text">内核级线程（ KLT, Kernel-Level Threads）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88ULT-User-Level-Threads%EF%BC%89"><span class="nav-number">2.3.3.</span> <span class="nav-text">用户级线程（ULT, User-Level Threads）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%BC%8F%E7%AD%96%E7%95%A5"><span class="nav-number">2.3.4.</span> <span class="nav-text">混合式策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="nav-number">2.4.1.</span> <span class="nav-text">处理器调度层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">先来先服务（FCFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%EF%BC%88SPN%EF%BC%89"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">最短进程优先（SPN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%88SRTF%EF%BC%89"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">最短剩余时间优先（SRTF）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%EF%BC%88HRRN%EF%BC%89"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">最高响应比优先（HRRN）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">优先级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6-%EF%BC%88RR%EF%BC%89"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">时间片轮转调度***（RR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E8%B0%83%E5%BA%A6-Multi-level-Feedback-Queue%EF%BC%8CMLFQ-%EF%BC%8C%E5%8F%88%E7%A7%B0%E5%88%86%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.2.8.</span> <span class="nav-text">多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A9%E7%A5%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">2.4.2.9.</span> <span class="nav-text">彩票调度</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%C2%B7-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">第三章 · 存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">连续存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.1.</span> <span class="nav-text">单连续分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%94%A8%E6%88%B7%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">单用户连续分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">固定分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">可变分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">动态分区分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%85%88%E9%80%82%E5%BA%94"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">最先适应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">最佳适应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">最坏适应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E8%BF%91%E9%80%82%E5%BA%94%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E6%B3%95%EF%BC%89"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">临近适应（循环首次适应法）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E9%9B%B6%E5%A4%B4"><span class="nav-number">3.2.3.</span> <span class="nav-text">分区方式的内存零头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%A6%86%E7%9B%96"><span class="nav-number">3.2.4.</span> <span class="nav-text">交换与覆盖</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.3.</span> <span class="nav-text">段式存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="nav-number">3.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.2.</span> <span class="nav-text">地址转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.4.</span> <span class="nav-text">页式存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="nav-number">3.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E7%AE%97%E6%B3%95OPT%EF%BC%88Belady%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">最佳算法OPT（Belady算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FIFO%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">FIFO先进先出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%EF%BC%8C%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E7%94%A8"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">LRU，最近最少用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LFU%EF%BC%8C%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">LFU，最不常用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLOCK%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">CLOCK算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-MIN-%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E8%80%83%EF%BC%89"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">局部最佳页面替换算法(MIN)（一般不考）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-WS"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">工作集模型和工作集置换算法(WS)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8-IPT"><span class="nav-number">3.4.4.</span> <span class="nav-text">反置页表(IPT)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">3.5.</span> <span class="nav-text">段页式存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%C2%B7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">第四章 · 设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">IO软件的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.1.</span> <span class="nav-text">IO软件的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.2.2.</span> <span class="nav-text">IO中断程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">IO驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E4%BA%8E%E8%AE%BE%E5%A4%87%E7%9A%84IO%E8%BD%AF%E4%BB%B6"><span class="nav-number">4.2.4.</span> <span class="nav-text">独立于设备的IO软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84IO%E8%BD%AF%E4%BB%B6"><span class="nav-number">4.2.5.</span> <span class="nav-text">用户空间的IO软件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF"><span class="nav-number">4.3.</span> <span class="nav-text">缓冲技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E8%B0%83%E5%BA%A6%E6%8A%80%E6%9C%AF"><span class="nav-number">4.4.</span> <span class="nav-text">驱动调度技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="nav-number">4.4.1.</span> <span class="nav-text">磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E8%87%82%E8%B0%83%E5%BA%A6"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">移臂调度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95-FCFS"><span class="nav-number">4.4.2.1.1.</span> <span class="nav-text">先来先服务算法 FCFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-%E6%9C%80%E5%B0%8F%E7%9F%AD%E8%B7%9D%E7%A6%BB%E6%B3%95-SSTF"><span class="nav-number">4.4.2.1.2.</span> <span class="nav-text">最短查找时间优先(最小短距离法) SSTF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95-SCAN%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.2.1.3.</span> <span class="nav-text">扫描算法 SCAN算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95-C-SCAN%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.2.1.4.</span> <span class="nav-text">循环扫描算法 C-SCAN算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95-N-step-SCAN"><span class="nav-number">4.4.2.1.5.</span> <span class="nav-text">分布扫描算法 N-step-SCAN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6-LOOK-%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.2.1.6.</span> <span class="nav-text">电梯调度(LOOK 算法)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E8%B0%83%E5%BA%A6"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">旋转调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E5%B8%83"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">优化分布</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97"><span class="nav-number">4.5.</span> <span class="nav-text">磁盘循环冗余阵列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPOOLing%EF%BC%88%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87%E8%81%94%E6%9C%BA%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%89%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.6.</span> <span class="nav-text">SPOOLing（外部设备联机并行操作）系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="nav-number">4.6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">4.6.2.</span> <span class="nav-text">组成部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="nav-number">4.6.3.</span> <span class="nav-text">作业调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%C2%B7-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">第五章 · 文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-number">5.1.</span> <span class="nav-text">文件的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8"><span class="nav-number">5.1.1.</span> <span class="nav-text">存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.2.</span> <span class="nav-text">逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3"><span class="nav-number">5.1.3.</span> <span class="nav-text">成组与分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.4.</span> <span class="nav-text">物理结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%EF%BC%8Cinode%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9D%97%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.5.</span> <span class="nav-text">目录项，inode和数据块的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%84%E7%BB%87%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">5.1.6.</span> <span class="nav-text">索引的组织（重要）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">文件系统功能及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="nav-number">5.2.2.</span> <span class="nav-text">目录管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.3.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">5.2.4.</span> <span class="nav-text">文件空间管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="nav-number">5.2.5.</span> <span class="nav-text">文件的共享</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%C2%B7-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">第六章 · 并发程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.1.</span> <span class="nav-text">并发程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%EF%BC%88%E4%BA%92%E6%96%A5%EF%BC%89%E4%B8%8E%E5%8D%8F%E4%BD%9C%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="nav-number">6.1.1.</span> <span class="nav-text">竞争（互斥）与协作（同步）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">6.1.2.</span> <span class="nav-text">临界区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CPV%E6%93%8D%E4%BD%9C"><span class="nav-number">6.2.</span> <span class="nav-text">信号量和PV操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.1.</span> <span class="nav-text">哲学家就餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.2.</span> <span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8B%B9%E6%9E%9C-%E6%A1%94%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.3.</span> <span class="nav-text">苹果-桔子问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">6.2.4.</span> <span class="nav-text">前驱关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.5.</span> <span class="nav-text">读写问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9D%A1%E7%9C%A0%E7%9A%84%E7%90%86%E5%8F%91%E5%B8%88"><span class="nav-number">6.2.6.</span> <span class="nav-text">睡眠的理发师</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%9C%E5%A4%AB%E7%8C%8E%E4%BA%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.7.</span> <span class="nav-text">农夫猎人问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.8.</span> <span class="nav-text">银行服务问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.9.</span> <span class="nav-text">缓冲区问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AE%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.10.</span> <span class="nav-text">售票问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.11.</span> <span class="nav-text">吸烟者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E6%9C%A8%E6%A1%A5%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.12.</span> <span class="nav-text">独木桥问题 ***</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">6.3.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="nav-number">6.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.2.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-number">6.3.3.</span> <span class="nav-text">习题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">哲学家就餐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">读者写者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">6.3.3.3.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8B%B9%E6%9E%9C%E6%A1%94%E5%AD%90"><span class="nav-number">6.3.3.4.</span> <span class="nav-text">苹果桔子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">6.4.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">6.5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="nav-number">6.5.1.</span> <span class="nav-text">死锁的避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">6.5.3.</span> <span class="nav-text">3. 算法原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="nav-number">6.5.3.1.</span> <span class="nav-text">3.1 进程启动时的检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">6.5.3.2.</span> <span class="nav-text">3.2 资源分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%A4%E6%96%AD"><span class="nav-number">6.5.3.3.</span> <span class="nav-text">3.3 安全性判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-number">6.5.4.</span> <span class="nav-text">4. 系统安全性定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">6.5.5.</span> <span class="nav-text">5. 示例说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-8-5-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.5.6.</span> <span class="nav-text">10.8.5. 银行家算法的程序及实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-8-6-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="nav-number">6.5.7.</span> <span class="nav-text">10.8.6. 银行家算法例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-8-6-1-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%BE%8B1"><span class="nav-number">6.5.7.1.</span> <span class="nav-text">10.8.6.1. 银行家算法例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-8-6-2-%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%B3%BB%E7%BB%9F%E6%89%80%E5%A4%84%E7%9A%84%E5%AE%89%E5%85%A8%E6%88%96%E4%B8%8D%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81-1"><span class="nav-number">6.5.7.2.</span> <span class="nav-text">10.8.6.2. 实例说明系统所处的安全或不安全状态(1)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="nav-number">6.5.8.</span> <span class="nav-text">死锁的检测和解除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B"><span class="nav-number">6.5.8.1.</span> <span class="nav-text">检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E4%B8%8E%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-number">6.5.8.2.</span> <span class="nav-text">资源分配图与死锁定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-number">6.5.8.3.</span> <span class="nav-text">死锁定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.8.4.</span> <span class="nav-text">死锁检测的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E7%A8%8B%E5%BA%8F%E5%8F%AF%E7%94%A8Warshall%E7%9A%84%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.8.5.</span> <span class="nav-text">死锁检测程序可用Warshall的传递闭包算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">6.5.9.</span> <span class="nav-text">死锁的恢复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0"><span class="nav-number">7.</span> <span class="nav-text">笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%C2%B7-%E5%AF%BC%E8%AE%BA"><span class="nav-number">7.1.</span> <span class="nav-text">第一章 · 导论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%C2%B7-%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86"><span class="nav-number">7.2.</span> <span class="nav-text">第二章 · 处理器管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%C2%B7-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-1"><span class="nav-number">7.3.</span> <span class="nav-text">第三章 · 存储管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%C2%B7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86-1"><span class="nav-number">7.4.</span> <span class="nav-text">第四章 · 设备管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%C2%B7-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86-1"><span class="nav-number">7.5.</span> <span class="nav-text">第五章 · 文件管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%C2%B7-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">7.6.</span> <span class="nav-text">第六章 · 并发程序设计</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统 | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-05-04T12:00:00+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第一讲-·-操作系统概述"><a href="#第一讲-·-操作系统概述" class="headerlink" title="第一讲 · 操作系统概述"></a>第一讲 · 操作系统概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>内核，进程和线程：<ol>
<li>内核：控制多道程序执行的系统超级程序</li>
<li>进程：即内核控制下的多道程序实例(一个独立执行的程序指令流)</li>
<li>线程：是进程的基本执行单位，通常被称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源（如内存、打开的文件等）。</li>
</ol>
</li>
<li>OS是中断驱动的</li>
<li>总览![屏幕截图 2025-02-24 113426](E:\Pictures\Screenshots\屏幕截图 2025-02-24 113426.png)</li>
</ol>
<span id="more"></span>

<h1 id="第二章-·-处理器管理文件"><a href="#第二章-·-处理器管理文件" class="headerlink" title="第二章 · 处理器管理文件"></a>第二章 · 处理器管理文件</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h3><ol>
<li>计算机通过设置处理器模式实现特权指令管理</li>
<li>计算器一般设置0、1、2、3等四种运行模式(保护级别)<ul>
<li>0:内核级，操作系统内核，可以执行全部指令，包括中断处理、处理I&#x2F;O操作等命令</li>
<li>1:系统调用级，执行系统调用，获得特定的和受保护的程序服务</li>
<li>2:共享库级，可以多个运行进程共享，允许调用库函数，读取但不修改相关数据。</li>
<li>3:用户程序，只能执行非特权指令，收到的保护最少</li>
</ul>
</li>
<li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li>
<li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li>
<li>处理器模式是由处理器模式位决定的。</li>
</ol>
<h3 id="处理器模式切换"><a href="#处理器模式切换" class="headerlink" title="处理器模式切换"></a>处理器模式切换</h3><ol>
<li>$用户态\to内核态$：<strong>中断、异常或系统异常</strong>等事件导致用户程序向OS内核切换。有以下三种：<ol>
<li>程序请求操作系统服务，执行系统调用</li>
<li>程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)</li>
<li>程序运行时发生并响应中断(一般是I&#x2F;O中断)</li>
</ol>
</li>
<li>$内核态\to用户态$：OS内核处理完成后，调用中断返回指令(如Intel的iret)触发</li>
</ol>
<h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><ol>
<li><p>用户栈：就是平常说的栈</p>
</li>
<li><p>核心栈：</p>
<ol>
<li><p>核心栈也叫系统栈或内核栈，是内存中属于操作系统空间的一块区域，其用途包含以下两种:</p>
<ol>
<li><p>保存中断现场，嵌套中断</p>
</li>
<li><p>保存操作系统程序(函数)间相互调用的参数、返回值、返回点以及程序局部变量。</p>
</li>
</ol>
</li>
<li><p><strong>每个进程</strong>有一个核心栈:可读可写不可执行，大小有限</p>
</li>
<li><p>硬件栈指针只有一个</p>
</li>
</ol>
</li>
</ol>
<h3 id="中断系统处理流程"><a href="#中断系统处理流程" class="headerlink" title="中断系统处理流程"></a>中断系统处理流程</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/12.png" alt="img"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li>概念：<strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。<ol>
<li>具有一定独立功能的程序：进程是相对独立的</li>
<li>关于某个数据集合：对于不同数据集合的操作不是同一个进程。</li>
<li>一次运行活动：有生命周期</li>
</ol>
</li>
<li><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>:这只限于单线程单进程的情况下</li>
<li>属性：<ol>
<li><strong>动态性</strong>:进程是程序在数据结合上的一次执行过程，是动态概念</li>
<li><strong>共享性</strong>:同一程序同时运行于不同数据集合上时都是不同的进程，即不同的进程可以运行相同的程序。</li>
<li><strong>独立性</strong>:每个进程是操作系统中的一个独立实体。有自己的虚存空间、程序计数器和内部状态.</li>
<li><strong>制约性</strong>:进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度予以协调。</li>
<li><strong>并发性</strong>:多个进程的执行在时间上可以重叠。</li>
</ol>
</li>
<li>组成：一个进程包括五个实体部分，分别是：<ol>
<li>(OS管理运行程序的)数据结构P</li>
<li>(运行程序的)内存代码C</li>
<li>(运行程序的)内存数据D</li>
<li>(运行程序的)通用寄存器信息R</li>
<li>(OS控制程序执行的)程序状态字信息PSW</li>
</ol>
</li>
</ol>
<h3 id="转态和转换"><a href="#转态和转换" class="headerlink" title="转态和转换"></a>转态和转换</h3><ol>
<li><p>进程三态模型<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/7.png" alt="img"></p>
<ol>
<li>只要操作系统支持多道程序设计，就必须要设计进程转换模型来管理，必须实现<strong>三个进程状态和四个跳转关系</strong></li>
<li>进程状态转换一定有<strong>内核</strong>的参与。</li>
<li>四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：<ol>
<li>没有就绪态到等待态:到等待态需要内核参与。</li>
<li>没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。</li>
</ol>
</li>
</ol>
</li>
<li><p>挂起</p>
<ol>
<li><p>概念</p>
<ol>
<li>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况。，现为<strong>性能低</strong>和<strong>死锁</strong>两种情况。</li>
<li>解决办法：剥夺某些进程的<strong>内存及其他资源</strong>，调入OS管理的<strong>对换区</strong>（对换区在磁盘上，是外存），不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是<strong>进程挂起</strong></li>
<li>挂起态与等待态有着本质区别<ol>
<li>进程挂起:<strong>没有任何资源</strong></li>
<li>进程等待:<strong>占有已申请到的资源处于等待</strong></li>
</ol>
</li>
<li>结束挂起状态的命令只能由<strong>操作系统和父进程</strong>发出。</li>
</ol>
</li>
<li><p>挂起的选择和恢复<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/8.png" alt="img"></p>
<ol>
<li>挂起的选择：<ol>
<li>一般选择<strong>等待态</strong>进程进入<strong>挂起等待态</strong></li>
<li>也可选择<strong>就绪态</strong>进程进入<strong>挂起就绪态</strong></li>
<li><strong>运行态</strong>进程还可以挂起自己</li>
</ol>
</li>
<li>挂起的恢复<ol>
<li>等待事件结束后，<strong>挂起等待态</strong>进入<strong>挂起就绪态</strong></li>
<li>一般选择<strong>挂起就绪态</strong>进程予以恢复</li>
<li>操作系统极其空闲才会选择调入<strong>挂起等待态</strong>的进程</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="描述和组成"><a href="#描述和组成" class="headerlink" title="描述和组成"></a>描述和组成</h3><h4 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h4><ol>
<li><strong>某一时刻进程的内容及其执行状态集合</strong>：<ol>
<li>进程控制块: 每个进程捆绑一个，保存进程的标识信息、现场信息和控制信息。进程创建时创建进程控制块，进程撤销时回收进程控制块，与进程一一对应，<strong>是进程存在的唯一标识</strong>。</li>
<li>进程程序块: 进程执行的程序空间，规定进程一次运行所应完成的功能。</li>
<li>进程数据块: 进程处理的数据空间，是进程的私有地址空间，包括各类私有数据、处理函数的用户栈和可修改的程序</li>
<li>进程核心栈: 每个进程捆绑一个，进程在<strong>内核模式</strong>下运行时使用的堆栈，中断或系统过程使用，保存函数调用的参数、局部变量和返回地址等。</li>
</ol>
</li>
<li>进程运行时如果遇到要执行操作系统内核函数，此时则保存应用程序的全部现场信息及其用户栈，使其不被内核程序破坏。而内核函数运行时使用进程的核心栈来放置工作信息。</li>
<li>进程映像是<strong>内存级</strong>的物理实体，又称为进程的内存映像</li>
<li>进程的内存映像示意图<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/14.png" alt="img"></li>
</ol>
<h4 id="进程控制块-描述符（Process-Control-Block，PCB）"><a href="#进程控制块-描述符（Process-Control-Block，PCB）" class="headerlink" title="进程控制块&#x2F;描述符（Process Control Block，PCB）"></a>进程控制块&#x2F;描述符（Process Control Block，PCB）</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/13.png" alt="img"></p>
<ol>
<li>进程控制块PCB是OS用于记录和刻画<strong>进程状态及环境信息</strong>的数据结构，是进程存在的唯一标识，是操作系统掌握进程的唯一资料结构和进程调度的主要依据</li>
<li>包括标识信息、现场信息和控制信息。</li>
</ol>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><ol>
<li>进程的执行需要环境支持，进程上下文刻画了进程的执行情况.</li>
</ol>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><ol>
<li>进程队列分类<ol>
<li>运行队列：通常只有一个进程</li>
<li>等待(阻塞)队列:也是有机会被调入，他等待的资源或事件完成后，调入就绪队列。</li>
<li>就绪队列:从就绪队列中挑选进程调入运行，按照优先级或FCFS的原则排队</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/9.png" alt="img"></p>
<ol start="2">
<li>进程队列组织方式<ol>
<li>链接方式：采用单向链接或双向链接。</li>
<li>索引方式：利用索引表记录不同状态进程的PCB地址或在PCB表中的编号</li>
<li>核心是完成入队和出队操作</li>
<li>进程与资源调度围绕进程队列展开</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/32.png" alt="img"></p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol>
<li><p>原语</p>
<ol>
<li><strong>原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性</strong>(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)。原语的执行可以通过<strong>关中断实现</strong></li>
<li>进程控制使用的原语被称为<strong>进程控制原语</strong>，另一类常用原语是<strong>进程通信原语</strong></li>
</ol>
</li>
<li><p>进程切换和模式切换</p>
<ol>
<li><h3 id="进程切换与模式切换-状态转换"><a href="#进程切换与模式切换-状态转换" class="headerlink" title="进程切换与模式切换(状态转换)"></a>进程切换与模式切换(状态转换)</h3><ol>
<li>一些中断&#x2F;异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：<ol>
<li>(中断&#x2F;异常触发)正向模式切换压入PSW&#x2F;PC</li>
<li>保存被中断进程的现场信息</li>
<li>处理中断&#x2F;异常</li>
<li>恢复被中断进程的现场信息</li>
<li>(中断返回指令触发)逆向模式转换弹出PSW&#x2F;PC</li>
</ol>
</li>
<li>比如计时中断，中断处理完成后直接恢复</li>
<li>模式切换是进程仍在自己的上下文进行处理，仅仅是处理器状态发生了变化，内核仍然被中断进程的上下文中进行处理。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/80.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>把进程的两项功能分离开来</p>
<ol>
<li>独立分配资源(进程概念上)，进程作为系统资源分配和保护的<strong>独立单位</strong>，不需要频繁地切换</li>
<li>被调度分派执行(线程概念上)，线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换</li>
</ol>
</li>
<li><p>多线程结构<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/15.png" alt="img"></p>
</li>
<li><p>概念</p>
<ol>
<li>线程是进程能够并发执行的实体，是进程的组成单位，也是处理器调度和分派的基本单位。</li>
<li>进程是一条执行路径，有独立的程序计数器，未运行时保护线程上下文。</li>
<li>同一个进程中的所有线程共享进程获得的主存空间和资源。</li>
</ol>
</li>
<li><p>多线程策略<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/21.png" alt="img"></p>
</li>
</ol>
<h3 id="内核级线程（-KLT-Kernel-Level-Threads）"><a href="#内核级线程（-KLT-Kernel-Level-Threads）" class="headerlink" title="内核级线程（ KLT, Kernel-Level Threads）"></a>内核级线程（ KLT, Kernel-Level Threads）</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/16.png" alt="img"></p>
<ol>
<li>特点<ol>
<li>优点：<ol>
<li>在多处理器上内核可以同时调度统一进程的多个线程运行。</li>
<li>进程中的某一线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行，也可以运行其他进程。</li>
<li>由于内核比较小，内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率。</li>
</ol>
</li>
<li>缺陷：<ol>
<li>应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大。</li>
<li>线程调度开销大，线程通信开销小。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="用户级线程（ULT-User-Level-Threads）"><a href="#用户级线程（ULT-User-Level-Threads）" class="headerlink" title="用户级线程（ULT, User-Level Threads）"></a>用户级线程（ULT, User-Level Threads）</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/17.png" alt="img"></p>
<ol>
<li>特点<ol>
<li>优点：<ol>
<li>节省开销和内核资源:所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能<strong>节省模式切换开销和内核的宝贵资源</strong>。</li>
<li>允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法。</li>
<li>可移植性好:能运行在任何OS上，内核在支持ULT方面不需要做任何工作。</li>
<li>ULT可以解决逻辑并行性问题。</li>
</ol>
</li>
<li>缺点：<ol>
<li>不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行。</li>
<li>一个ULT的阻塞，将引起整个进程的阻塞:不能完成切换线程，因为内核感知不到进程中的线程的存在。</li>
</ol>
</li>
<li>ULT可以解决逻辑并行性问题。</li>
</ol>
</li>
</ol>
<h3 id="混合式策略"><a href="#混合式策略" class="headerlink" title="混合式策略"></a>混合式策略</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/19.png" alt="img"></p>
<ol>
<li>特点：<ol>
<li>合并了用户级线程&#x2F;内核级线程设施</li>
<li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li>
<li>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上</li>
<li>程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果</li>
<li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点</li>
</ol>
</li>
<li>线程混合式策略下的线程状态<ol>
<li>KLT的三态模型，由系统调度负责</li>
<li>ULT的三态模型，由用户调度负责</li>
<li>活跃态的ULT代表绑定KLT的三态</li>
<li>活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/20.png" alt="img"></p>
<ul>
<li>为什么是活跃态绑定KLT的三态？<ul>
<li><strong>因为ULT 依赖于 KLT 执行，而 KLT 受操作系统的调度机制控制。用户级线程（ULT）需要绑定到内核级线程（KLT）上才能真正执行</strong></li>
<li>只有ULT为活跃态<strong>且</strong>KLT为运行态，ULT才处于运行态。</li>
</ul>
</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="处理器调度层次"><a href="#处理器调度层次" class="headerlink" title="处理器调度层次"></a>处理器调度层次</h3><ol>
<li>高级调度：又称长程调度、作业调度，决定能否加入到执行的进程池中，管理从创建进程到调度运行再到结束阶段后的善后部分的全过程。</li>
<li>中级调度，又称平衡调度、中程调度，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作。</li>
<li>低级调度：又称短程调度、进程调度&#x2F;线程调度，根据某种原则决定就绪队列中哪个进程&#x2F;线程获得处理器，并将处理器让出给它使用。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/22.png" alt="img"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/23.png" alt="img"></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>考虑因素</p>
<ol>
<li><p>资源利用率：使得CPU或其他资源的使用率尽可能高且能够并行工作<br>$$<br>CPU利用率&#x3D;\frac{CPU有效工作时间}{CPU总运行时间}<br>$$</p>
</li>
<li><p>吞吐量：单位事假内CPU处理作业的个数，服务器的TPS，例如12306或淘宝</p>
</li>
<li><p>公平性：确保每个用户每个进程获得合理的CPU份额或其他资源份额</p>
</li>
<li><p>响应时间：</p>
<ol>
<li>使交互式用户的响应时间尽可能小，或尽快处理实时任务</li>
<li>细分包含输入的程序命令传送到CPU时间、CPU处理请求命令的时间、处理所形成的响应回送到终端显示器的时间。</li>
</ol>
</li>
<li><p><strong>周转时间</strong>：从提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短。</p>
</li>
</ol>
</li>
<li><p>调度模式</p>
<ol>
<li>抢占式(剥夺式)调度：当前正在运行的进程可能被操作系统中断，并转移到就绪态。处理器剥夺原则：<ol>
<li>高优先级进程&#x2F;线程可剥夺低优先级进程&#x2F;线程。</li>
<li>运行进程&#x2F;线程时间片用完后被剥夺。</li>
</ol>
</li>
<li>非抢占式(非剥夺式)调度：一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I&#x2F;O或请求某些操作系统服务而阻塞自己。</li>
<li>与非抢占式调度相比，抢占式调度可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间</li>
</ol>
</li>
</ol>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><ul>
<li>非抢占式</li>
<li>弊端太大，性能会非常差，不被现在的操作系统使用</li>
</ul>
<h4 id="最短进程优先（SPN）"><a href="#最短进程优先（SPN）" class="headerlink" title="最短进程优先（SPN）"></a>最短进程优先（SPN）</h4><ul>
<li>非抢占式</li>
<li>缺点：<ul>
<li>需要预知作业所需的CPU运行时间</li>
<li>忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。</li>
<li>分时、实时处理仍然不理想。</li>
</ul>
</li>
</ul>
<h4 id="最短剩余时间优先（SRTF）"><a href="#最短剩余时间优先（SRTF）" class="headerlink" title="最短剩余时间优先（SRTF）"></a>最短剩余时间优先（SRTF）</h4><ul>
<li>抢占式</li>
</ul>
<h4 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h4><ul>
<li>非抢占式</li>
</ul>
<ol>
<li><p>每当需要调度时，计算出所有的响应比，选择最高的。</p>
</li>
<li><p>$$<br>响应比&#x3D;\frac{等待时间+期待服务时间}{期待服务时间}&#x3D;1+\frac{等待时间}{期待服务时间}<br>$$</p>
</li>
</ol>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ol>
<li>调度器总是选择优先级较高的进程，提供多个就绪队列(一组就绪队列)，代表各个级别的优先级。</li>
<li>低优先级的进程可能很难被执行到？一个进程的优先级应该随着它的时间或执行的历史而变化。</li>
<li>如果就绪队列中出现优先级高的进程&#x2F;线程，系统可以预先规定策略为非剥夺式和剥夺式策略。</li>
<li>优先级的确定<ol>
<li>用户给出优先级</li>
<li>系统综合考虑各因素，包括打开文件数、资源申请情况等等</li>
</ol>
</li>
<li>优先级确定方式<ol>
<li>静态：生命周期内不改变，容易造成饥饿问题。</li>
<li>动态：生命周期内可能会发生改变，正在运行的进程逐渐降低优先级，正在等待的进程逐渐提高优先级。</li>
</ol>
</li>
</ol>
<h4 id="时间片轮转调度-（RR）"><a href="#时间片轮转调度-（RR）" class="headerlink" title="时间片轮转调度***（RR）"></a>时间片轮转调度***（RR）</h4><ol>
<li>本质也是<strong>先来先服务</strong>，但是要按照时间片来进行调度。</li>
<li>根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片，基于时钟做抢占式调度。</li>
<li>时间片中断：以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列队尾，然后基于FCFS策略选择下一个就绪进程运行</li>
<li>时间片的确定：选择长短合适的时间片，一般为10ms到200ms<ol>
<li>过长则退化为先来先服务算法</li>
<li>过短则调度开销显著增大</li>
</ol>
</li>
<li>时间片分为单时间片、多时间片和动态时间片三种</li>
<li>使用时间片轮转调度算法，在给一个进程分配处理器的时候，不需要知道进程需要多长时间</li>
<li>很多的调度都会结合时间片轮转调度算法来实现</li>
<li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318204105076.png" alt="image-20250318204105076"></li>
</ol>
<h4 id="多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度"><a href="#多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度" class="headerlink" title="多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度"></a>多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度</h4><ol>
<li>基本思想<ol>
<li>建立多个不同优先级的就绪进程队列</li>
<li>多个就绪进程队列之间按照优先数调度</li>
<li>高优先级的就绪进程, 分配的时间片短</li>
<li>单个就绪进程队列中的进程的优先数和时间片相同,按照先来先服务算法调度</li>
</ol>
</li>
<li>如果没做完会惩罚降级，做题目要至少画一下前几个RQ。如果进程掉出去的同时，有新的进程进入，那么新的进程优先进入就绪队列</li>
<li>对以计算为主的长进程不友好，就绪队列越深获得调度的机会越小</li>
<li>不同的进程可以设置不同的时间片长度：q&#x3D;2^i^(可选)，i是第几次处理的意思</li>
<li>多级队列更能够发现先到达的，时间片比较短的处理完。</li>
<li>除了极少数的硬实时操作系统使用抢占式调度算法，绝大多数操作系统有效地组合时间片调度算法和优先数调度算法，采用分级调度算法的策略加以实现</li>
<li>如果没有竞争不掉下去，时刻1(根据考试具体情况决定)</li>
</ol>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><ol>
<li>基本思想：为进程发放针对<strong>系统各种资源</strong>(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</li>
</ol>
<h1 id="第三章-·-存储管理"><a href="#第三章-·-存储管理" class="headerlink" title="第三章 · 存储管理"></a>第三章 · 存储管理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>逻辑地址<ol>
<li>逻辑地址：又称相对地址，即用户编程所使用的地址空间</li>
<li>逻辑地址从零开始编号，有两种形式：<ol>
<li>一维逻辑地址(地址)</li>
<li>二维逻辑地址(段号:段内地址)</li>
</ol>
</li>
</ol>
</li>
<li>物理地址<ol>
<li>又称绝对地址，从处理器角度看到的物理内存单元。</li>
<li>处理器执行指令时按照物理地址进行</li>
</ol>
</li>
</ol>
<h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="单连续分区存储管理"><a href="#单连续分区存储管理" class="headerlink" title="单连续分区存储管理"></a>单连续分区存储管理</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ol>
<li>每个进程占用一个物理上完全连续的存储空间(区域)</li>
<li>单连续分区存储管理细分:<ol>
<li>单用户连续存储管理</li>
<li>固定分区存储管理</li>
<li>可变分区存储管理</li>
</ol>
</li>
<li>分区方式不能实现虚拟存储。</li>
<li>内部碎片和外部碎片<ol>
<li>内部碎片：比如在固定分区中，某一块被使用的分区中还有空闲</li>
<li>外部碎片：比如在固定分区中，有空闲的小分区</li>
</ol>
</li>
</ol>
<h4 id="单用户连续分区"><a href="#单用户连续分区" class="headerlink" title="单用户连续分区"></a>单用户连续分区</h4><ol>
<li><p>适用于单用户单任务操作系统，如DOS</p>
</li>
<li><p>主存区域(内存空间)划分为系统区与用户区</p>
<ol>
<li>系统区用于存放操作系统内核程序和数据结构等</li>
<li>用户区用于存放应用程序和数据</li>
</ol>
</li>
<li><p>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</p>
</li>
<li><p>一般采用<strong>静态重定位</strong>进行地址转换</p>
</li>
<li><p>硬件实现代价低</p>
</li>
<li><p>单用户连续分区存储管理示意</p>
<ol>
<li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址全部转换成绝对地址</li>
<li>界限地址:放置软件访问到操作系统的部分<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102402017.png" alt="image-20250324102402017"></li>
</ol>
</li>
</ol>
<h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><ol>
<li><p>又称静态分区模式</p>
</li>
<li><p>基本思想：</p>
<ol>
<li>内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们都可以并发执行。</li>
<li>可用静态&#x2F;动态重定位、硬件实现代价低、被早期OS采用<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102526444.png" alt="image-20250324102526444"></li>
</ol>
</li>
<li><p>主存分配</p>
<ol>
<li>主存分配表：包含内容：起始地址、长度、占用标志</li>
<li>内存分配方法很简单，其任务有何时吧内存空间划分成分区：由系统管理员和操作系统初始化模块协同完成。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/8.png" alt="img"></a></p>
<ol>
<li>作业进入分区的排队策略：<ol>
<li>每个分区有自己的作业等待队列，作业等待能装下自身的最小分区。</li>
<li>所有等待处理作业排成等待队列，每当有空闲，找到队列中能进入的最大的一个。</li>
</ol>
</li>
</ol>
</li>
<li><p>地址转换：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103121851.png" alt="image-20250324103121851"></p>
</li>
<li><p>缺点：</p>
<ol>
<li>由于预先规定了分区的大小，使得大作业无法装入，而不得不采用覆盖技术，带来负担。</li>
<li>内存空间利用率不高，作业很少填满分区：固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费，内存内零头是因为在分区内部有零头。</li>
<li>如果作业在运行中要求动态扩展内存空间是困难的。</li>
<li>分区数目是操作系统初启动时确定的，会限制多道运行程序的道数。</li>
</ol>
</li>
</ol>
<h4 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h4><ol>
<li>概述<ol>
<li>可变分区存储管理又称动态分区模式，按照作业大小划分分区，但划分的时间、大小和位置都是动态的。</li>
<li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间<ol>
<li>若有，则按需要量分割一个分区</li>
<li>若无，则令该进程等待主存资源</li>
</ol>
</li>
<li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li>
</ol>
</li>
<li>示例<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103508697.png" alt="image-20250324103508697"></li>
<li>主存分配表<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103659047.png" alt="image-20250324103659047"><ol>
<li>管理的数据结构：已分配区表与未分配区表，采用链表实现</li>
<li>找一个最大的空闲的位置进行分配</li>
</ol>
</li>
<li>内存回收<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103801245.png" alt="image-20250324103801245"><ol>
<li>可变分区方式的内存回收会导致内存空间的转换</li>
<li>作业X撤离后有且仅有如上4种情况</li>
</ol>
</li>
<li>地址转换<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324104131474.png" alt="image-20250324104131474"><ol>
<li>硬件实现机制与动态重定位</li>
<li>进程的程序和数据的地址由硬件完成<ol>
<li>基址寄存器：分配进程的起始地址</li>
<li>限长寄存器：进程占用的连续存储空间的长度</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="最先适应"><a href="#最先适应" class="headerlink" title="最先适应"></a>最先适应</h4><p>优先使用低地址空闲分区</p>
<h4 id="最佳适应"><a href="#最佳适应" class="headerlink" title="最佳适应"></a>最佳适应</h4><p>优先使用更小的空闲分区</p>
<h4 id="最坏适应"><a href="#最坏适应" class="headerlink" title="最坏适应"></a>最坏适应</h4><p>优先使用更大的空闲分区</p>
<h4 id="临近适应（循环首次适应法）"><a href="#临近适应（循环首次适应法）" class="headerlink" title="临近适应（循环首次适应法）"></a>临近适应（循环首次适应法）</h4><p>每次都从上次查找结束的位置开始查找空闲分区链</p>
<h3 id="分区方式的内存零头"><a href="#分区方式的内存零头" class="headerlink" title="分区方式的内存零头"></a>分区方式的内存零头</h3><ol>
<li>固定分区方式会产生<strong>内存内零头</strong></li>
<li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong>，内存外零头是指分区内部是没有零头的，而是在外面的零头。</li>
<li><strong>最优适配算法最容易产生外零头</strong></li>
<li>任何适配算法都<strong>不能避免</strong>产生外零头</li>
</ol>
<h3 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h3><ol>
<li><p>移动技术（程序浮动）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324105052339.png" alt="image-20250324105052339"></p>
<ol>
<li>碎片：内存中的小空闲区，移动分区来解决内存外零头问题。</li>
<li>需要动态重定位支撑:静态重定位无法解决内存外零头</li>
<li>问题：移动技术有极大的系统开销。</li>
</ol>
</li>
<li><p>对换技术：</p>
<ol>
<li>如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为<strong>对换</strong>。</li>
<li>被对换出去的进程的状态会调整为就绪态，并且通知存储管理程序，一旦内存可用，立即将该进程对换回内存。</li>
<li>对换技术关键点<ol>
<li>被对换进程：通常系统选择时间片耗尽或优先级较低的进程对换出去。</li>
<li>对换的进程信息：将数据区和堆栈通过文件系统转换为特殊文件保存。</li>
<li>被对换的时机：<ol>
<li>批处理系统中：进程需要扩充内存空间但不能被满足时</li>
<li>分时系统：<ol>
<li>时间片结束时</li>
<li>执行I&#x2F;O操作时</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>覆盖技术</p>
<ol>
<li><p>移动和对换技术解决因多个程序存在而导致内存区不足问题。</p>
</li>
<li><p>但是如果程序长度超过物理内存的总和，或者超出固定分区大小，则会出现内存永久性短缺，大程序无法运行，解决方案是覆盖技术。</p>
</li>
<li><p><strong>程序分段：</strong> 将一个大程序划分为多个独立的部分（通常是功能模块），这些部分通常称为”覆盖块”（Overlay Blocks）。</p>
<p><strong>内存交换：</strong> 在程序执行过程中，操作系统将某些覆盖块从磁盘加载到内存中运行，当这些块不再需要时，操作系统可以将它们从内存中卸载，释放空间给其他块。</p>
</li>
</ol>
</li>
</ol>
<h2 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ol>
<li>高级语言采用模块化程序设计方法。应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每一段都从0开始编制，各有各自名字和长度且实现不同功能。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/27.png" alt="img"></a></p>
<ol start="2">
<li>编译后段间地址是不连续的，段内地址是连续的。</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ol>
<li>分段存储器的逻辑地址由两部分组成:段号+段内偏移</li>
<li>页式存储管理中页的划分对程序员不可见。</li>
<li>段式存储管理中段的划分对程序员可见。</li>
</ol>
<h2 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>基本原理</p>
<ol>
<li><p>页面：金层逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始编号。比如出版一本书，出版受到页大小影响，最后由若干页组成，一般大小为4KB</p>
</li>
<li><p>页框：又称页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区都是一个页框(物理块)，块号从0开始。</p>
</li>
<li><p>逻辑地址：分页存储器的逻辑地址由页号 + 页面偏移组成(地址总线32位)</p>
<ol>
<li>页号：32-12 &#x3D; 20位，则包含页220220位</li>
<li>页面偏移：页面大小为4KB，则需要12位</li>
</ol>
</li>
<li><p>内存页框表：该表长度取决于内存划分的物理块数，表项中给出物理块使用情况，0为空闲，1为占用，有的系统还会添加保护位、脏位等等。</p>
</li>
<li><p>页表：将页装入到内存中，</p>
<p>页未必连续</p>
<p>，我们需要为每一个页面设立一个重定向寄存器，这个寄存器的集合就是页表。</p>
<ol>
<li>数学角度：页面号→页框号页面号→页框号</li>
<li>系统设置页表基址寄存器，存放当前运行进程的页表起始地址。</li>
<li>物理地址&#x3D;页框号∗块长+页内偏移物理地址&#x3D;页框号∗块长+页内偏移，实际转换时，我们将页内偏移作为低地址，根据页号从页表中查找到页框号并作为高地址即可。</li>
<li>页表不存储<strong>页号</strong>，只存储页框号和相应标志位</li>
</ol>
</li>
<li><p>页式存储产生的碎片是内部碎片</p>
<ol>
<li>可以类比固定分区</li>
<li>比如19KB的程序，加载到页大小为4KB中，会产生1KB的内存内零头。</li>
</ol>
</li>
</ol>
</li>
<li><p>地址：</p>
<ol>
<li>页式存储管理的逻辑地址由两部分组成，<strong>页号和单元号(页内偏移)</strong>，逻辑地址形式：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/16.png" alt="img"></a></p>
<ol>
<li>页式存储管理的物理地址也有两部分组成：<strong>页架号(页框号)和单元号(页内偏移)</strong>，物理地址形式：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/17.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/17.png" alt="img"></a></p>
</li>
<li><p>多道程序环境下的进程表</p>
<ol>
<li>进程表中登记了每个进程的页表</li>
<li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/20.png" alt="img"></li>
</ol>
</li>
<li><p>多道程序环境下的地址转换</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/21.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/21.png" alt="img"></a></p>
<ol>
<li>页表控制寄存器存储了当前的页表的地址和长度</li>
<li>页表控制寄存器和进程表是有关联的，所有进程在进程表中都有一项，当这个进程占据CPU时，这个进程就占据页表控制寄存器。</li>
<li>不使用快表:首先从逻辑地址中，提取出页号，比较页号是否出现越界中断，如果没有越界，则根据页表向下偏移到对应的块号，提取出页表信息和页框号，页框号结合单元号，得到物理地址</li>
<li>快表:不是从页表中查找，而是优先从快表中查询块号。</li>
</ol>
</li>
</ol>
<h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="最佳算法OPT（Belady算法）"><a href="#最佳算法OPT（Belady算法）" class="headerlink" title="最佳算法OPT（Belady算法）"></a>最佳算法OPT（Belady算法）</h4><ol>
<li>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择<strong>距现在最长时间后再访问</strong>的页。</li>
<li>该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)</li>
<li>OPT只可以<strong>模拟</strong>，不可以实现，因为永远无法预知之后的事情。</li>
<li>这种算法可以用作衡量其他各种算法的标准。</li>
<li>图示。（这个图应该斜着看，左下的栈和右上的数字搭配，更新后得到右下的栈）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104230843.png" alt="image-20250331104230843"></li>
</ol>
<h4 id="FIFO先进先出"><a href="#FIFO先进先出" class="headerlink" title="FIFO先进先出"></a>FIFO先进先出<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104328678.png" alt="image-20250331104328678"></h4><ol>
<li><strong>FIFO算法的Belady异常</strong>：更多的页框导致了更高的缺页率，页框为3和4的时候。注意，Belady异常和Beladey算法没关系。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331105353886.png" alt="image-20250331105353886"></li>
</ol>
<h4 id="LRU，最近最少用"><a href="#LRU，最近最少用" class="headerlink" title="LRU，最近最少用"></a>LRU，最近最少用<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104351141.png" alt="image-20250331104351141"></h4><h4 id="LFU，最不常用"><a href="#LFU，最不常用" class="headerlink" title="LFU，最不常用"></a>LFU，最不常用</h4><h4 id="CLOCK算法"><a href="#CLOCK算法" class="headerlink" title="CLOCK算法"></a>CLOCK算法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104416252.png" alt="image-20250331104416252"></h4><ol>
<li>CLOCK就是SCR结合FIFO形成循环，使用页引用标志位。</li>
<li>流程<ol>
<li>页面调入主存时，其引用标志位置为1</li>
<li>访问主存页面时，其引用标志位置为1</li>
<li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ol>
<li>把所遇到的引用标志位是1的页面的引用标志位清0并跳过</li>
<li>把所遇到的引用标志位是0的页面淘汰，<strong>指针推进一步</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="局部最佳页面替换算法-MIN-（一般不考）"><a href="#局部最佳页面替换算法-MIN-（一般不考）" class="headerlink" title="局部最佳页面替换算法(MIN)（一般不考）"></a>局部最佳页面替换算法(MIN)（一般不考）</h4><ol>
<li>实现思想：进程在时刻t访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框.</li>
<li>不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</li>
<li>t为一个系统常量，间隔(t, t+τ)称作滑动窗口 。例子中τ&#x3D;3，双闭区间</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/51.png" alt="img"></p>
<h4 id="工作集模型和工作集置换算法-WS"><a href="#工作集模型和工作集置换算法-WS" class="headerlink" title="工作集模型和工作集置换算法(WS)"></a>工作集模型和工作集置换算法(WS)</h4><ol>
<li>进程工作集指”在某一段时间间隔内进程运行所需访问的页面集合”</li>
<li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li>
<li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li>
<li>双闭区间</li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/55.png" alt="img"></li>
</ol>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><ul>
<li>页表是面向进程的，每个进程都要有页表，标记为页号</li>
<li>反置页表是面向内存的，标记为页框号</li>
</ul>
<ol>
<li>为每个进程创建完整的页表开销很大</li>
<li>既然页表也是数据，我们就为页表再创建一个页表，每一页称为页表页，新页表叫页目录表</li>
<li>做法：把整个页表分割成许多小页表，每个称为页表页，它的大小与页框长度相同，于是每个页表页含有若干页表表项。<ol>
<li>页表项从0开始编号，允许放到不连续的页框中，为了找到页表页，建立地质索引，称为<strong>页目录表</strong>。</li>
<li>系统为每一个进程建立一张页目录表，他的每一个表项指出一个页表页，而页表页的每个表项给出页面和页框的对应关系。</li>
</ol>
</li>
<li>逻辑地址结构有三部分组成：页目录、页表页和位移</li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/83.png" alt="img"></li>
<li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li>
</ol>
<h3 id="反置页表-IPT"><a href="#反置页表-IPT" class="headerlink" title="反置页表(IPT)"></a>反置页表(IPT)</h3><ol>
<li><p>正向页表(名单)、反置页表(现场坐的是谁)</p>
<ol>
<li>正向页表:以<strong>页号</strong>为索引(隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表</li>
<li>反置页表:以<strong>页框号</strong>为索引(隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号</li>
</ol>
</li>
<li><p>基本设计思想：</p>
<ol>
<li><strong>针对内存中的每个页架建立一个页表</strong>，按照块号(页架号)排序</li>
<li>表项包含：正在访问该页框的进程标识、页号及特征位，和<strong>哈希链指针</strong>等</li>
<li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li>
</ol>
</li>
<li><p>反置页表的页表项</p>
<ol>
<li>页号：虚拟地址页号</li>
<li>进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)</li>
<li>标志位：有效、引用、修改、保护和锁定等标志信息</li>
<li>链指针：<strong>哈希链</strong>，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li>
</ol>
</li>
<li><p>反置页表的逻辑地址</p>
<ol>
<li>进程标识符：使用该页的进程。</li>
<li>页号：虚拟地址页号部分，页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li>
<li>页内位移</li>
</ol>
</li>
<li><p>地址转换<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/76.png" alt="img"></p>
<ol>
<li>反置页表地址转换过程如下:<ol>
<li>需要访问内存地址时，地址转换机制用进程标识符与页号作为输入，由哈希函数先映射到哈希表，哈希表项存放的是指向IPT表项的指针<ol>
<li>此指针可能就是指向匹配的IPT表项</li>
<li>如果不是则遍历哈希链直至找到进程标识符与页号均匹配的IPT表项：因为多个页号通过哈希函数可能得到了相同的哈希值，所以我们选择使用哈希链。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/77.png" alt="img"></li>
</ol>
</li>
<li>而此表项的**序号(索引)**就是页框号，通过拼接页内位移便可生成物理地址。</li>
<li>若在反置页表中未能找到匹配的IPT页表项，说明此页不在内存，触发缺页异常，请求操作系统通过页表调入：发生缺页中断时需要多访问一次磁盘，速度会比较慢。</li>
</ol>
</li>
<li>页框号是根据公式换算出来的：$x_i&#x3D;x_0+4*i$，其中$x_i$ 表示第 <em>i</em> 个表项的物理地址，$x_0$ 表示反置页表的起始物理地址，4 表示每个表项的大小（以字节为单位）</li>
</ol>
</li>
</ol>
<h2 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h2><ol>
<li><p>基本原理</p>
<ol>
<li>一言以蔽之：先分段，再分页</li>
<li>逻辑地址由段号s、段内页号p和页内偏移d组成<ol>
<li>对用户，虚拟地址由段号s和段内位移d’组成</li>
<li>系统内部将d’分解为p和d，d’ &#x3D; p * 块长 + d</li>
</ol>
</li>
<li>请求段页式虚拟存储管理的数据结构比较复杂，包含作业表、段表和页表三部分。<ol>
<li>作业表：进入系统的作业和作业段表的起始地址</li>
<li>段表：是否在内存、段页表起始地址</li>
<li>页表：是否在内存、对应内存块号</li>
</ol>
</li>
</ol>
</li>
<li><p>地址转换</p>
<ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/33.png" alt="img"></li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/88.png" alt="img"></li>
</ol>
</li>
</ol>
<h1 id="第四章-·-设备管理"><a href="#第四章-·-设备管理" class="headerlink" title="第四章 · 设备管理"></a>第四章 · 设备管理</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ol>
<li>知道三种控制方式：轮询，中断，DMA（直接存储器访问）</li>
<li>IO通道<ol>
<li>描述：<ol>
<li>设备控制器包含自身专用的<strong>处理器和通道程序</strong>，自成体系，使得<strong>CPU与通道高度并行</strong>，实现通道和CPU并行操作，通道之间并行操作，设备之间并行操作。</li>
</ol>
</li>
<li>工作流程（就是中断那一套）<ol>
<li>CPU在执行主程序时遇到I&#x2F;O任务，启动指定通道(通过通道程序地址字CAW)上选址的设备。</li>
<li>启动成功，通道开始控制设备进行操作，此时CPU继续执行其他任务，直到I&#x2F;O操作完成。</li>
<li>通道发出I&#x2F;O操作结束中断，处理器相应并停止当前工作，转向处理I&#x2F;O操作结束事件。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IO软件的实现"><a href="#IO软件的实现" class="headerlink" title="IO软件的实现"></a>IO软件的实现</h2><h3 id="IO软件的层次结构"><a href="#IO软件的层次结构" class="headerlink" title="IO软件的层次结构"></a>IO软件的层次结构</h3><ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png" alt="img"></li>
</ol>
<h3 id="IO中断程序"><a href="#IO中断程序" class="headerlink" title="IO中断程序"></a>IO中断程序</h3><ol>
<li>I&#x2F;O中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系</li>
<li>进程请求I&#x2F;O操作时，通常被挂起，直到数据传输结束后并产生I&#x2F;O中断时，操作系统接管CPU后转向中断处理程序</li>
<li>当设备向CPU提出中断请求时，CPU响应请求并转入中断处理程序</li>
<li>I&#x2F;O中断处理程序的功能<ol>
<li>检查设备状态寄存器内容，判断<strong>产生中断的原因</strong>，根据I&#x2F;O操作的完成情况进行相应的处理</li>
<li>如果数据传输有错，向<strong>上层软件</strong>报告设备的<strong>出错信息</strong>，实施<strong>重新执行</strong></li>
<li>如果正常结束，唤醒等待传输的进程，使其转换为<strong>就绪态</strong></li>
<li>如果有等待传输的I&#x2F;O命令，通知相关软件启动下一个I&#x2F;O请求</li>
</ol>
</li>
</ol>
<h3 id="IO驱动程序"><a href="#IO驱动程序" class="headerlink" title="IO驱动程序"></a>IO驱动程序</h3><ol>
<li>概念：<ol>
<li>I&#x2F;O设备驱动程序是操作系统与I&#x2F;O设备之间的接口软件。它是一组软件代码，用于控制和管理I&#x2F;O设备的运行。驱动程序为操作系统提供了一种与硬件设备进行通信的方式，使得操作系统能够通过标准的接口来操作各种不同的硬件设备。</li>
</ol>
</li>
<li>任务<ol>
<li>把用户提交的<strong>逻辑I&#x2F;O请求</strong>转化为<strong>物理I&#x2F;O操作</strong>的启动和执行，如设备名转换为端口等</li>
<li>监督设备是否正确执行，管理<strong>数据缓冲区</strong>，进行必要的纠错处理</li>
</ol>
</li>
<li>功能<ol>
<li><strong>设备初始化</strong>:在系统<strong>初次启动或设备传输数据</strong>时，预置设备和控制器以及通道状态</li>
<li>执行设备驱动例程<ol>
<li>负责启动设备，进行数据传输</li>
<li>对于具有通道方式，还负责生成<strong>通道指令和通道程序</strong>，启动通道工作</li>
</ol>
</li>
<li><strong>调用和执行中断处理程序</strong>:负责处理设备和控制器及通道所发出的各种中断</li>
</ol>
</li>
</ol>
<h3 id="独立于设备的IO软件"><a href="#独立于设备的IO软件" class="headerlink" title="独立于设备的IO软件"></a>独立于设备的IO软件</h3><ol>
<li>基本功能：执行适用于所有设备的常用I&#x2F;O功能，并向<strong>用户层软件</strong>提供一致性接口</li>
<li>设备命名：通过路径名寻址设备</li>
<li>设备保护：检查用户是否有权访问所申请设备</li>
<li>资源分配方式<ol>
<li>静态分配：进程运行前申请。实现简单，能够防止死锁，但会降低设备利用率</li>
<li>动态分配：进程随用随申请。考虑互锁管理，需要结合信号量与PV操作</li>
</ol>
</li>
<li>缓冲技术：<ol>
<li>通过缓冲消除填满速率和清空速率的影响<ol>
<li>网络上数据需要分析检查才知道去哪里。</li>
<li>有些设备有严格时间约束，比如数字音频设备。</li>
</ol>
</li>
<li>块设备和字符设备都需要缓冲技术<ol>
<li>块设备：磁盘读写以块为单位，应用程序以任意大小单元处理设备，如果应用程序读写长度和位置不是完整扇区，则需要使用缓冲区来缓冲。</li>
<li>字符设备：字符设备提供数据速度快于或慢于应用程序消耗数据的速度。</li>
</ol>
</li>
<li>缓冲设计大量复制操作，对I&#x2F;O性能有较大开销</li>
</ol>
</li>
</ol>
<h3 id="用户空间的IO软件"><a href="#用户空间的IO软件" class="headerlink" title="用户空间的IO软件"></a>用户空间的IO软件</h3><ol>
<li>库函数<ol>
<li>一小部分I&#x2F;O软件<strong>不在</strong>操作系统中，是与<strong>应用程序链接在一起的库函数</strong>，甚至完全由运行于<strong>用户态</strong>的程序组成</li>
<li><strong>系统调用通常由库函数封装后供用户使用</strong>，封装函数只是将系统调用所用的参数放在合适位置，然后执行<strong>访管指令</strong>来陷入内核，再由内核函数实现真正的I&#x2F;O操作</li>
</ol>
</li>
<li>SPOOLing软件<ol>
<li>在<strong>内核外运行</strong>的<strong>系统</strong>I&#x2F;O软件，采用<strong>预输入、缓输出和井管理</strong>技术，是多道程序设计系统中处理<strong>独占型设备</strong>的一种方法，通过创建守护进程和特殊目录解决<strong>独占型设备</strong>的<strong>空占</strong>问题</li>
</ol>
</li>
</ol>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><ol>
<li><p>概述</p>
<ol>
<li>缓冲区:在<strong>内存</strong>中开辟的存储区，专门用于临时存放I&#x2F;O操作的数据</li>
<li>目的：<ol>
<li>解决<strong>CPU与设备之间速度不匹配</strong>的矛盾，协调逻辑记录大小和物理记录大小不一致的问题</li>
<li>减少I&#x2F;O操作对CPU的中断次数</li>
<li>放宽对CPU中断响应时间的要求</li>
<li>提高CPU和设备的并行性</li>
</ol>
</li>
</ol>
</li>
<li><p>单缓冲</p>
<ol>
<li>每当应用程序发出I&#x2F;O操作时，操作系统在主存(内存)的系统区中开设一个缓冲区</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/14.png" alt="img"></a></p>
<ol>
<li><p>如果希望输入的数据被加工后再输出，则需要双缓冲。</p>
</li>
<li><p>工作机制：</p>
<ol>
<li>输入：将数据读至缓冲区，系统将缓冲区数据送至用户区，应用程序对数据进行处理；如此往复，系统读入后续的数据</li>
<li>输出：把数据从用户区复制到缓冲区，再将数据输出后，应用程序继续请求输出</li>
</ol>
</li>
<li><p>双缓冲</p>
<ol>
<li>操作系统在主存的系统区中开设两个缓冲区</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/15.png" alt="img"></a></p>
<ol start="2">
<li><p>工作机制</p>
<ol>
<li>输入：<ol>
<li>设备首先将数据输入缓冲区1，系统再从缓冲区1把数据传到用户区，供应用程序处理，同时从设备数据传送到缓冲区2</li>
<li>当缓冲区1为空，则再次从设备读出数据到缓冲区1，将缓冲区2的数据传送到用户区，供应用程序处理，同时从设备数据传送到缓冲区1</li>
<li>仅当两个缓冲区全为空，并且进程还要提取数据时等待。</li>
</ol>
</li>
<li>输出：<ol>
<li>第一张卡片读入缓冲区1，在打印缓冲区1中数据的同时，又把第二张卡片读入缓冲区2。</li>
<li>缓冲区1打印完毕时，缓冲区2也刚好输入完毕，让读卡机和打印机交换缓冲区。这样，I&#x2F;O设备就能够处于并行工作状态。</li>
</ol>
</li>
</ol>
</li>
<li><p>多缓冲</p>
</li>
</ol>
<ul>
<li>多缓冲的缓冲区是系统的<strong>公共资源</strong>，可供进程共享并由系统<strong>统一分配和管理</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/16.png" alt="img"></p>
<h2 id="驱动调度技术"><a href="#驱动调度技术" class="headerlink" title="驱动调度技术"></a>驱动调度技术</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ol>
<li>组成<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/17.png" alt="img"></li>
<li>术语<ol>
<li>盘面号也被叫做<strong>磁头号</strong></li>
<li>磁道号也被叫做<strong>柱面号</strong></li>
<li>区别:”0面0道1扇区”中的”面”是指磁头，不是柱面<ol>
<li><strong>面和道都是0开始</strong></li>
<li><strong>扇区是从1开始</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="调度-1"><a href="#调度-1" class="headerlink" title="调度"></a>调度</h3><ol>
<li>调度耗时：磁盘完成数据读写所需要的时间:是<strong>寻道时间、旋转延迟、传送时间</strong>的总和</li>
<li>调度策略包括<strong>旋转调度</strong>和<strong>移臂调度</strong></li>
</ol>
<h4 id="移臂调度"><a href="#移臂调度" class="headerlink" title="移臂调度"></a>移臂调度</h4><ul>
<li>目的：使移动臂的移动时间最短，从而减少寻道总时间</li>
</ul>
<h5 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法 FCFS"></a>先来先服务算法 FCFS</h5><ol>
<li>移臂距离大，性能不好，移动臂是<strong>随机移动</strong>，寻道性能较差</li>
<li>按顺序处理请求，对所有进程公平</li>
</ol>
<h5 id="最短查找时间优先-最小短距离法-SSTF"><a href="#最短查找时间优先-最小短距离法-SSTF" class="headerlink" title="最短查找时间优先(最小短距离法) SSTF"></a>最短查找时间优先(最小短距离法) SSTF</h5><ol>
<li>先执行<strong>查找时间最短</strong>的请求，具有较好的寻道性能，<strong>存在”饥饿”现象</strong>：距离比较远的被满足</li>
<li>选择使磁头臂从当前位置开始移动最少的磁盘I&#x2F;O请求，因此SSTF策略总是选择导致<strong>最小寻道时间</strong>的请求，总是选择最小寻道时间并不能保证平均寻道时间最小，但是，它的性能比FCFS更好</li>
</ol>
<h5 id="扫描算法-SCAN算法"><a href="#扫描算法-SCAN算法" class="headerlink" title="扫描算法 SCAN算法"></a>扫描算法 SCAN算法</h5><ol>
<li>移动臂每次向一个方向移动，遇到最近的I&#x2F;O请求便进行处理，到达<strong>最后一个</strong>柱面后再向相反方向移动</li>
<li>对最近扫描所跨越区域的请求响应较慢</li>
<li>和电梯调度算法的不同：碰壁才会折返</li>
</ol>
<h5 id="循环扫描算法-C-SCAN算法"><a href="#循环扫描算法-C-SCAN算法" class="headerlink" title="循环扫描算法 C-SCAN算法"></a>循环扫描算法 C-SCAN算法</h5><ol>
<li>单向移动的扫描算法</li>
</ol>
<h5 id="分布扫描算法-N-step-SCAN"><a href="#分布扫描算法-N-step-SCAN" class="headerlink" title="分布扫描算法 N-step-SCAN"></a>分布扫描算法 N-step-SCAN</h5><ol>
<li><p>进程</p>
<p>重复请求同一磁道会垄断整个设备造成磁头臂的粘性，采用分步扫描可避免这类问题</p>
<ol>
<li><strong>把磁盘I&#x2F;O请求队列分成长度为N的子队列，按照FIFO处理每一个子队列，每个子队列内部使用扫描算法</strong></li>
<li>在处理一个队列时，新请求必须添加到<strong>其他</strong>某个队列中</li>
<li>处理完一个子队列后再服务下一个队列</li>
</ol>
</li>
<li><p>如果在扫描的最后剩下的请求数小于N，则它们全部将在下一次扫描时处理</p>
<ol>
<li>当N→∞时，N-step-SCAN的性能接近SCAN</li>
<li>当N&#x3D;1时，实际上是FIFO</li>
</ol>
</li>
</ol>
<h5 id="电梯调度-LOOK-算法"><a href="#电梯调度-LOOK-算法" class="headerlink" title="电梯调度(LOOK 算法)"></a>电梯调度(LOOK 算法)</h5><ol>
<li>无请求时移动臂停止不动，有请求时按电梯规律移动</li>
<li>每次选择沿移动臂的移动方向最近的柱面</li>
<li>如果当前移动方向上没有但相反方向有请求时，改变移动方向</li>
</ol>
<h4 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h4><ul>
<li>目的：使得旋转延迟的总时间最少<ol>
<li>循环排序：通过优化I&#x2F;O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求 </li>
<li>旋转位置测定硬件和多磁头同时读写 技术有利于提高旋转调度的效率</li>
<li>优化分布如下</li>
</ol>
</li>
</ul>
<h4 id="优化分布"><a href="#优化分布" class="headerlink" title="优化分布"></a>优化分布</h4><ul>
<li>通过信息在存储空间的排列方式来减少旋转延迟</li>
<li>交替排序：由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，如交叉因子为n:1表示相邻编号间会间隔n-1个扇区</li>
<li>把相邻扇区集中成簇读写</li>
<li>按柱面集中存储数据（另一种集簇方式），可以减少数据读写时的移臂操作</li>
</ul>
<h2 id="磁盘循环冗余阵列"><a href="#磁盘循环冗余阵列" class="headerlink" title="磁盘循环冗余阵列"></a>磁盘循环冗余阵列</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421102810232.png" alt="image-20250421102810232"></p>
<h2 id="SPOOLing（外部设备联机并行操作）系统"><a href="#SPOOLing（外部设备联机并行操作）系统" class="headerlink" title="SPOOLing（外部设备联机并行操作）系统"></a>SPOOLing（外部设备联机并行操作）系统</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>实质：<strong>让独享型设备变为共享设备</strong></li>
</ul>
<ol>
<li>相关概念：<ol>
<li>独占性设备：指在一段时间内只能被一个进程独占使用的设备</li>
<li>输入井，输出井：类似于缓冲区。但是缓冲区在内存，输入输出井在磁盘</li>
<li>虚拟设备：使用一类物理设备模拟另一类物理设备的技术，<strong>让独享型设备变为共享设备</strong><ol>
<li>示例<ol>
<li>内存卡模拟磁盘</li>
<li>块设备模拟字符设备</li>
<li>输入输出重定向</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>作用：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421104404005.png" alt="image-20250421104404005"></li>
</ol>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>软件组成：<ol>
<li>预输入程序**：**预先把数据从输入设备传送到磁盘输入井</li>
<li>缓输出程序：把数据从磁盘输出井传送到输出设备</li>
<li>井管理程序：控制作进程和井之间的数据交换（事实上是I&#x2F;O重定向）<ol>
<li>目标：预输入，缓输出</li>
</ol>
</li>
</ol>
</li>
<li>数据结构：<ol>
<li>系统有一张作业表来登记进入系统的所有作业的JCB，包括作业名、作业状态等信息。</li>
<li>预输入表用来登记作业的各个输入文件的情况。</li>
<li>缓输出表用来登记作业的各个输出文件的情况。</li>
</ol>
</li>
</ol>
<h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><ul>
<li>是指从<strong>后备状态</strong>作业中选择进入运行状态</li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105520096.png" alt="image-20250421105520096"></p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105553539.png" alt="image-20250421105553539"></p>
<h1 id="第五章-·-文件管理"><a href="#第五章-·-文件管理" class="headerlink" title="第五章 · 文件管理"></a>第五章 · 文件管理</h1><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/1.png" alt="img"></p>
<h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol>
<li>卷和块<ol>
<li>卷：卷是存储介质的物理单位，对应于一盘磁带、 一块软盘、一个光盘片、一个硬盘分区</li>
<li>块是存储介质上连续信息所组成的一个区域， 也叫做物理记录<ol>
<li>块是主存储器和辅助存储器进行信息交换的 物理单位，每次总是交换一块或整数块信息</li>
</ol>
</li>
</ol>
</li>
<li>顺序存取存储设备：<ol>
<li>顺序存取设备是严格依赖信息的物理位置次 序进行定位和读写的存储设备</li>
<li>磁带机是最常用的一种顺序存取存储设备， 它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档。现在也有在用</li>
</ol>
</li>
<li>直接存取存储设备<ol>
<li>磁盘是一种直接存取存储设备，又叫 随机存取存储设备</li>
</ol>
</li>
</ol>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ol>
<li>流式文件<ol>
<li>流式文件指文件内的数据不再组成记 录，只是由一串依次的字节组成的信 息流序列 </li>
<li>这种文件常常按长度来读取所需信息， 也可以用插入的特殊字符作为分界</li>
</ol>
</li>
<li>记录式文件<ol>
<li>记录式文件是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件<ol>
<li>逻辑记录是文件中按<strong>信息</strong>在<strong>逻辑</strong>上的<strong>独立含义</strong>所划分的信息单位</li>
<li>每个职工的工资信息是一个<strong>逻辑记录</strong>；</li>
<li>整个单位职工的工资信息便组成了该单位工资信息的<strong>记录式文件</strong></li>
</ol>
</li>
<li>逻辑记录是文件内<strong>独立的最小信息单位</strong>，记录位置代替字节位置。</li>
<li>记录是文件常用的记录组织和使用方法<ol>
<li>记录式顺序文件：文件的记录顺序生成并被顺序访问。</li>
<li>记录式索引文件：文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引文件便指向相应记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="成组与分解"><a href="#成组与分解" class="headerlink" title="成组与分解"></a>成组与分解</h3><ul>
<li>记录式文件才有成组与分解</li>
</ul>
<ol>
<li>基本概念<ol>
<li>一些定义：<ol>
<li>逻辑记录：是按信息在逻辑上的<strong>独立含义</strong>由用户所划分的<strong>单位</strong>。</li>
<li>块：是系统划分的存储介质上连续信息所组成的区域。<ol>
<li>一条逻辑记录被存放到文件存储器的存储介质上时可能占用一个或多块，或者一个物理块包含多条逻辑记录。</li>
<li>扇区也叫做物理块，或者物理记录</li>
</ol>
</li>
<li>组：若干逻辑记录的组合。</li>
<li>块因子：每块中逻辑记录的个数。比如物理块800K，卡片80K，此时的块因子数就是10。</li>
<li>对于流式文件，一个物理记录可以存放很多个连续字节。</li>
</ol>
</li>
<li>记录的成组操作在输出<strong>缓冲区</strong>内进行， 凑满一块后才将缓冲区内的信息写到 存储介质上</li>
<li>当存储介质上的一个物理记录读进输入<strong>缓冲区</strong>后，把逻辑记录从块中分离 出来的操作叫记录的分解操作<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421115348634.png" alt="image-20250421115348634"></li>
</ol>
</li>
<li>特点：<ol>
<li>优点：记录成组与分解不仅<strong>节省存储空间</strong>，还能<strong>减少输入输出操作次数</strong>，提高系统效率</li>
<li>记录成组与分解处理带来的新特征：<ol>
<li><strong>提前读</strong>：用户读请求，导致包含该逻辑记录的<strong>物理块</strong>读入输入缓冲区；这一操作可能读入了多个逻辑记录，可以更快的访问附近的记录。</li>
<li><strong>推迟写</strong>：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出。</li>
</ol>
</li>
<li>副作用(推迟写操作)：因为优先写到输出缓冲区，等到缓冲区满，才会写到磁盘，可能会造成<strong>数据不一致</strong>(写到缓冲区，但是因为<strong>停电</strong>等原因没有办法同步到磁盘)</li>
</ol>
</li>
</ol>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ol>
<li><p>文件分类：</p>
<ol>
<li>顺序文件</li>
<li>连接文件，又称串联文件</li>
<li>直接文件，又称散列文件</li>
<li>索引文件</li>
</ol>
</li>
<li><p>FCB：文件控制块</p>
<ol>
<li>在Linux系统中，FCB中的管理信息单独组成一个数据结构，称为inode</li>
</ol>
</li>
<li><p>目录项（Directory Entry）：</p>
<p>目录项是目录文件中的一个条目，用于存储文件或子目录的名称和对应的 inode 号。目录本身也是一个文件，它包含多个目录项。每个目录项包含以下信息：</p>
<ul>
<li>文件或子目录的名称</li>
<li>对应的 inode 号</li>
</ul>
</li>
<li></li>
</ol>
<h3 id="目录项，inode和数据块的关系"><a href="#目录项，inode和数据块的关系" class="headerlink" title="目录项，inode和数据块的关系"></a>目录项，inode和数据块的关系</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428113341689.png" alt="image-20250428113341689"></p>
<ol>
<li>物理结构：<ol>
<li>引导块</li>
<li>超级块：<ol>
<li>存放<strong>文件系统结构和管理信息</strong>，如记录inode表所占盘块数</li>
<li>可见<strong>超级块</strong>既有<strong>盘位示图</strong>的功能，又记录<strong>整个文件卷的控制数据</strong>。</li>
</ol>
</li>
<li>磁盘inode：<ol>
<li>有K块，K待定</li>
<li>每个文件都有<strong>各种属性</strong>，它们被记录在称为索引节点inode的结构中</li>
<li>所有inode都有<strong>相同大小</strong>，且inode表是inode结构的列表，文件系统中的每个文件在该表中都有一个inode。</li>
</ol>
</li>
<li>数据区</li>
<li>索引文件详细<ol>
<li>访问方式：<ol>
<li>索引文件在文件存储器上分两个区：<strong>索引区和数据区</strong></li>
<li>访问索引文件需两步操作<ol>
<li>第一步查找索引表</li>
<li>第二步获得记录物理地址</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>目录项与 inode 的关系<ol>
<li>目录项指向 inode：目录项中的 inode 号是关键。通过目录项中的 inode 号，文件系统可以找到对应的 inode。</li>
<li>inode 与文件名分离：inode 本身不存储文件名，文件名存储在目录项中。这种分离使得硬链接成为可能，多个目录项可以指向同一个 inode。</li>
</ol>
</li>
<li>inode 与数据块的关系<ol>
<li>inode 指向数据块：inode 中的块号字段存储了文件内容所在的磁盘块号。通过这些块号，文件系统可以找到文件的实际存储位置。</li>
<li>数据块存储文件内容：数据块中存储了文件的实际内容。</li>
</ol>
</li>
</ol>
<h3 id="索引的组织（重要）"><a href="#索引的组织（重要）" class="headerlink" title="索引的组织（重要）"></a>索引的组织（重要）</h3><ul>
<li>注意，这里索引文件的组织是指一个文件内部的数据的组织方式，而不是多个文件之间的组织<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/26.png" alt="img"></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/5.png" alt="img"></p>
<ol>
<li>一级索引：存放的是物理地址</li>
<li>两级索引：若干索引本身也是一种记录。</li>
<li>多级索引：以三级索引为例，一个地址指引12831283个地址，但是全部使用三级索引也不行，性能会比较差，所以我们往往选择使用混编的方式。</li>
<li>动态扩容：放不下就扩容</li>
<li>inode规定了15个索引项，每项4KB<ol>
<li>直接索引：前12项存放文件信息的磁盘块号</li>
<li>一次间接索引：第13项指向一个物理块</li>
<li>二次间接索引：第14项指向一个物理块</li>
<li>三次间接索引：第15项指向一个物理块</li>
<li>ext2中，每个物理块存放1KB，所以下面右图最多存放12KB+256KB+2562KB+2563KB<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/17.png" alt="img"></li>
</ol>
</li>
</ol>
<h2 id="文件系统功能及实现"><a href="#文件系统功能及实现" class="headerlink" title="文件系统功能及实现"></a>文件系统功能及实现</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li>一级目录结构：顾名思义</li>
<li>二级目录结构：<ol>
<li>第一级为主文件目录，它用于管理所有用户文件目录</li>
<li>第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428112651146.png" alt="image-20250428112651146"></li>
</ol>
</li>
<li>树形目录结构<ol>
<li>是一种层次目录结构</li>
<li>一个硬盘分区可以组织成一颗子树<ol>
<li>每棵子树可以对应于一个逻辑盘符（Win）</li>
<li>也可以把众多子树嫁接成一颗大树（UNIX）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ol>
<li><p>文件的定位</p>
</li>
<li><p>目录项的查找</p>
</li>
<li><p>活动文件表</p>
<ol>
<li>文件系统向应用程序提供了一组系统调用，包括建立、打开、关闭、撤销、读&#x2F;写和控制，通过这些系统调用，用户能够获得文件系统的各种服务。</li>
<li>系统会为每一个用户进程建立一张打开文件表<ol>
<li>用户使用文件之前先通过<strong>打开</strong>操作，将文件FCB拷贝到指定内存位置</li>
<li>当不在使用时，通过<strong>关闭</strong>操作切断和文件的联系，释放文件的FCB。</li>
</ol>
</li>
<li>接下来以Linux系统为例，介绍其文件系统调用的种类、功能和实现。内核将磁盘作为主要文件存储器，磁盘按扇区编号，扇区序列分成三个部分。</li>
<li>文件系统内部结构如下图所示：不是三级坐标，是经过转化后的结构</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png" alt="img"></a></p>
</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>见spricoder</li>
</ul>
<h3 id="文件空间管理"><a href="#文件空间管理" class="headerlink" title="文件空间管理"></a>文件空间管理</h3><ol>
<li>位示图<ol>
<li>磁盘空间通常使用<strong>固定大小</strong>的块，<strong>可方便地用位示图管理，用若干字节构成一张位示图</strong>，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。</li>
</ol>
</li>
<li>空闲块的管理：成组连接法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/27.png" alt="img"><ol>
<li>第一行指出有多少个空闲块</li>
<li>第二行指向下一级</li>
<li>从第三行起指向空闲块</li>
</ol>
</li>
<li>管理的算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/9.png" alt="img"></li>
</ol>
<h3 id="文件的共享"><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h3><ul>
<li>文件共享指不同进程共同使用同一个文件，文件共享为不同进程完成共同任务所需。</li>
<li>节省大量外存空间，减少因文件复制而增加的I&#x2F;O操作次数。</li>
</ul>
<ol>
<li><p>静态共享</p>
<ol>
<li><p>允许一个文件同时属于多个目录，但是实际上文件仅有一处物理存储。</p>
</li>
<li><p>文件链接：从多个目录可到达文件的链接。</p>
</li>
<li><p>无论进程是否运行，文件链接关系都存在，所以称为静态共享。</p>
</li>
<li><p>链接的文件的存在形式：</p>
<ol>
<li>同一父目录下的不同文件名出现</li>
<li>不同父目录下的相同或不同文件名出现</li>
</ol>
</li>
<li><p>链接实际上是共享已存在文件的索引节点inode，完成链接的系统调用：</p>
<p>link(“&#x2F;home&#x2F;fei1&#x2F;myfile.c” <strong>,</strong> ”&#x2F;home&#x2F;fei2&#x2F;myfile.c”)；硬链接</p>
</li>
</ol>
</li>
<li><p>动态链接：</p>
<ol>
<li><p>使用同一位移指针的文件共享：先打开文件，再fork()<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/23.png" alt="img"></p>
<ol>
<li>同一用户父、子进程协同完成任务，使用同一读&#x2F;写位移，同步地对文件进行操作。</li>
<li>该位移指针宜放在相应文件的活动inode中。当用系统调用fork()建立子进程时，父进程的PCB结构被复制到子进程的PCB结构中，使两个进程的打开文件表指向同一活动的索引节点，达到共享同一位移指针的目的。</li>
</ol>
</li>
<li><p>使用不同位移指针的文件共享：先fork()，再打开文件<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/24.png" alt="img"></p>
<ol>
<li>多用户进程共享文件，每个希望独立地读、写文件，这时不能只设置一个读写位移指针，须为每个用户进程分别设置一个<strong>读、写位移指针</strong>。</li>
<li>位移指针应放在每个进程<strong>用户打开文件表</strong>的表目中。</li>
<li>这样，当一个进程读、写文件，并修改位移指针时，另一个进程的位移指针不会随之改变，从而，使两个进程能独立地访问同一文件，会新建系统打开文件表(包含f_offset)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第六章-·-并发程序设计"><a href="#第六章-·-并发程序设计" class="headerlink" title="第六章 · 并发程序设计"></a>第六章 · 并发程序设计</h1><h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><ol>
<li>顺序程序设计<ol>
<li>特点：<ol>
<li>程序执行的<strong>顺序性</strong>：程序指令执行是严格按序的，每个操作必须在下一个操作开始前结束。</li>
<li>计算环境的<strong>封闭性</strong>：程序运行时如同独占受操作系统保护的资源，资源状态只能由程序本身决定和改变，不受外界因素改变。</li>
<li>计算结果的<strong>确定性</strong>：程序执行结果与执行速度和执行时段无关</li>
<li>计算过程的<strong>可再见性</strong>：程序对相同数据集的执行轨迹是确定的</li>
</ol>
</li>
</ol>
</li>
<li>并发程序设计：<ol>
<li>无关与交往：<ol>
<li><strong>无关</strong>的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关<ol>
<li><strong>Bernstein条件</strong>：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512103948727.png" alt="image-20250512103948727"></li>
<li>这样的无关性使得进程之间互不影响</li>
</ol>
</li>
</ol>
</li>
<li><strong>交往</strong>的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果</li>
</ol>
</li>
<li>两个视角：<ol>
<li>宏观上，并发性反应了一个时间段内有几个程序都处于运行但运行尚未结束的状态。</li>
<li>微观上，任一时刻都只有一个程序在运行。</li>
</ol>
</li>
<li>特点：<ol>
<li>不再满足顺序程序设计的四个特点</li>
<li><strong>并行性</strong>：多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行，提高了计算效率</li>
<li><strong>共享性</strong>：多个进程共享软件资源</li>
<li><strong>交往性</strong>：多个进程并发执行时存在制约，增加了程序设计的难度</li>
</ol>
</li>
<li>与时间有关的错误<ol>
<li>结果不唯一</li>
<li>永久等待</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="竞争（互斥）与协作（同步）"><a href="#竞争（互斥）与协作（同步）" class="headerlink" title="竞争（互斥）与协作（同步）"></a>竞争（互斥）与协作（同步）</h3><ul>
<li>$竞争\to互斥\to等待$</li>
<li>$协作\to同步\to等待$</li>
</ul>
<ol>
<li>竞争：<ol>
<li>：并发进程之间因相互争夺<strong>独占性资源</strong>而产生的竞争制约关系</li>
<li>竞争带来的问题：<ol>
<li><strong>死锁(Deadlock)问题</strong>: 一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</li>
<li><strong>饥饿(Starvation)问题</strong>: 一个进程由于其他进程总是优先于它而被无限期拖延，可以使用FCFS来解决饥饿问题</li>
</ol>
</li>
<li>操作系统需要保证诸进程能<strong>互斥</strong>地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li>
<li></li>
</ol>
</li>
<li>协作：<ol>
<li>概念：某些进程为完成同一任务需要<strong>分工协作</strong>，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上<strong>协调</strong>各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应<strong>阻塞自己</strong>，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行</li>
<li>进程互斥关系是一种特殊的<strong>进程同步</strong>关系，即<strong>逐次使用互斥</strong>共享资源，是对进程使用资源次序上的一种协调</li>
</ol>
</li>
</ol>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ol>
<li>临界区：是指包含对共享资源进行访问的代码段。</li>
<li>临界区管理的三个要求(Dijkstra, 1965)<ol>
<li><strong>一次至多一个</strong>进程能够进入临界区内执行：在某些特殊情况下可能会突破</li>
<li>如果已有进程在临界区，其他试图进入的进程应<strong>等待</strong></li>
<li>进入临界区内的进程应在<strong>有限时间</strong>内退出，以便让等待进程中的一个进入</li>
</ol>
</li>
<li>进程互斥的软件实现方法：<ol>
<li><p>单标志法</p>
</li>
<li><p>双标志先检查法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112253396.png" alt="image-20250512112253396"></p>
<ol>
<li>可能两个都进</li>
</ol>
</li>
<li><p>双标志后检查法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112306550.png" alt="image-20250512112306550"></p>
<ol>
<li>可能两个都不进</li>
</ol>
</li>
<li><p>Peterson算法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112343027.png" alt="image-20250512112343027"></p>
<ul>
<li><p>原理：结合了双标志法和一个额外的“进入”标志<code>turn</code>。每个进程在进入临界区前，先设置自己的标志为<code>true</code>，然后检查对方的标志和<code>turn</code>标志。如果对方标志为<code>true</code>且<code>turn</code>指向对方，则等待。</p>
</li>
<li><p>优点：完全避免了死锁和忙等问题，且满足互斥条件。</p>
</li>
<li><p>缺点：实现较为复杂，且仅适用于两个进程的情况。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512113527360.png" alt="image-20250512113527360"></p>
<ol>
<li><p>信号量：</p>
<ol>
<li>是一个数据结构，由两部分组成：<ol>
<li>信号量的值：为正数是代表空闲资源数量，为负数代表等待进程数量</li>
<li>信号量队列指针：指向等待队列</li>
</ol>
</li>
</ol>
</li>
<li><p>PV操作：</p>
<ol>
<li><p>P(s)：</p>
<ol>
<li>将信号量s减去1，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态</li>
<li>负数的绝对值就是等待的进程的个数</li>
</ol>
</li>
<li><p>V(s)：将信号量s加1，若结果不大于0，则释放(唤醒)一个等待信号量s的进程，使其转换为就绪态</p>
</li>
<li><p><strong>原语</strong>：CPU处于内核态，在关中断环境下执行的一段<strong>指令序列</strong></p>
</li>
<li><p>强调：对于信号量，只允许使用P和V原语操作访问信号量，不能直接对信号量的整型值做读写操作，也不能直接对信号量的队列做任何其他操作</p>
</li>
<li><p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">   <span class="type">int</span> value;           <span class="comment">/*信号量值，正值表示资源可复用次数，0值表示无资源且无进程等待，负数的绝对*/</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">pcb</span>* list;    <span class="comment">/*信号量队列指针，等待队列*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// P操作原语</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(semahore s)</span> </span>&#123;</span><br><span class="line">   s.value--;           <span class="comment">/* 信号量值减1 */</span></span><br><span class="line">   <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">sleep</span>(s.list);</span><br><span class="line">   <span class="comment">/* 若信号量值小于0,执行P操作的进程调用sleep(s.list)阻塞自己，被置成等待信号量s状态并移人s信号量队列,转向进程调度程序*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V操作原语</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span> <span class="params">( semaphore s)</span> </span>&#123;</span><br><span class="line">   s.value++;           <span class="comment">/* 信号量值加 1*/</span></span><br><span class="line">   <span class="keyword">if</span>(s.value &lt;=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">wakeup</span>(s.list) ;</span><br><span class="line">   <span class="comment">/*若信号量值小于等于0,则调用wakeup(s. list) 从信号量s队列中释放一-个等待信号量s的进程并转换成就绪态,进程则继续执行*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PV操作解决进程互斥问题框架</span></span><br><span class="line">semaphore s;</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line">cobegin</span><br><span class="line">   process Pi &#123;</span><br><span class="line">      ……</span><br><span class="line">      <span class="built_in">P</span>(s);</span><br><span class="line">      临界区;</span><br><span class="line">      <span class="built_in">V</span>(s);</span><br><span class="line">      ……</span><br><span class="line">   &#125;</span><br><span class="line">coend;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>信号量与状态：</p>
<ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/41.png" alt="img"></li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/42.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><ol>
<li><p>问题：</p>
<ol>
<li>五个哲学家，五把叉子，必须拿到左右两把叉子才能吃上饭。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519105828495.png" alt="image-20250519105828495"></li>
<li>即使使用了PV操作，还是可能死锁。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519110524795.png" alt="image-20250519110524795"></li>
</ol>
</li>
<li><p>解决方案</p>
<ol>
<li><p>霍尔方案：控制人数，至多有四个人可以拿叉子<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519111008420.png" alt="image-20250519111008420"></p>
<ol>
<li>这里声明了两个信号量。fork表示叉子，每个叉子值为1，表示互斥关系。room表示可以同时拿叉子的人数。</li>
<li>每次都是先控制人数，然后再去叉子，这样就不会死锁</li>
</ol>
</li>
<li><p>编号方案：奇数号先取左手边的叉子，偶数号先取右手边的叉子</p>
</li>
</ol>
</li>
</ol>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ol>
<li>问题描述：<ol>
<li>互斥访问：缓冲区同一时间只能被一个生产者或消费者访问。</li>
<li>同步：生产者不能在缓冲区满时继续生产，消费者不能在缓冲区空时尝试消费。</li>
</ol>
</li>
<li>解决方案：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113033843.png" alt="image-20250519113033843"><ol>
<li>设计两个信号量sput和sget，分别表示可以生产的量和可以消耗的量。</li>
<li>注意，每段代码的P操作和V操作不是同一个信号量</li>
<li>设计两个信号量S1,S2，若有多个消费者和生产者，他们要互斥的访问缓冲区.</li>
</ol>
</li>
</ol>
<h3 id="苹果-桔子问题"><a href="#苹果-桔子问题" class="headerlink" title="苹果-桔子问题"></a>苹果-桔子问题</h3><ol>
<li><p>问题描述：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113706958.png" alt="image-20250519113706958"></p>
</li>
<li><p>解决方案：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113726494.png" alt="image-20250519113726494"></p>
</li>
</ol>
<h3 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115725366.png" alt="image-20250519115725366"></p>
<h3 id="读写问题"><a href="#读写问题" class="headerlink" title="读写问题"></a>读写问题</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115455054.png" alt="image-20250519115455054"></p>
<h3 id="睡眠的理发师"><a href="#睡眠的理发师" class="headerlink" title="睡眠的理发师"></a>睡眠的理发师</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115517425.png" alt="image-20250519115517425"></p>
<ul>
<li>这里的mutex是必要的。访问共享的变量时，需要互斥！</li>
</ul>
<h3 id="农夫猎人问题"><a href="#农夫猎人问题" class="headerlink" title="农夫猎人问题"></a>农夫猎人问题</h3><ul>
<li>和苹果-桔子问题本质上是一样的</li>
</ul>
<h3 id="银行服务问题"><a href="#银行服务问题" class="headerlink" title="银行服务问题"></a>银行服务问题</h3><ul>
<li>这个例子对理解PV操作有帮助</li>
<li>信号量就像是一个通讯方式（实际上就是IPC对象），PV就是等待信号和发送信号</li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522104654836.png" alt="image-20250522104654836"></p>
<h3 id="缓冲区问题"><a href="#缓冲区问题" class="headerlink" title="缓冲区问题"></a>缓冲区问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/60.png" alt="img"></p>
<h3 id="售票问题"><a href="#售票问题" class="headerlink" title="售票问题"></a>售票问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/61.png" alt="img"></p>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/62.png" alt="img"></p>
<h3 id="独木桥问题"><a href="#独木桥问题" class="headerlink" title="独木桥问题 ***"></a>独木桥问题 ***</h3><ol>
<li><p>问题一：东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。请用信号量和PV操作写出过独木桥问题的同步算法。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/63.png" alt="img"></p>
<ol>
<li><strong>确保同一时间只有一个方向的行人过桥</strong>：<ul>
<li>通过 <code>wait</code> 信号量，确保同一时间只有一个方向的行人可以过桥。如果一个方向的行人已经占用桥，另一个方向的行人必须等待。</li>
</ul>
</li>
</ol>
</li>
<li><p>问题二：在独木桥问题1中，限制桥面上最多可以有k辆汽车通过。试用信号量和P，V操作写出过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/64.png" alt="img"></p>
</li>
<li><p>问题三：在独木桥问题1中，以3辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。试用信号量和P，V操作写出汽车过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/65.png" alt="img"></p>
</li>
<li><p>问题四：在独木桥问题1中，要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。试用信号量和P，V操作写出过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/66.png" alt="img"></p>
</li>
</ol>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>概念：它是一种封装了共享数据和操作这些数据的过程（或函数）的模块。</p>
</li>
<li><p><strong>功能</strong>：管程不仅提供互斥功能，还提供条件变量（condition variables）用于线程或进程之间的同步。它通常包含：</p>
<ul>
<li><strong>共享数据</strong>：封装的共享数据，只能通过管程提供的过程访问。</li>
<li><strong>过程（或函数）</strong>：操作共享数据的过程。</li>
<li><strong>互斥锁</strong>：内部的互斥锁，确保一次只有一个线程或进程可以执行管程中的操作。</li>
<li><strong>条件变量</strong>：用于线程或进程之间的同步，提供 <code>wait</code> 和 <code>signal</code>（或 <code>broadcast</code>）操作。</li>
</ul>
</li>
<li><p><strong>为什么要引入管程</strong>？</p>
<ul>
<li><p>把分散在各进程中的临界区集中起来进行管理 </p>
</li>
<li><p>防止进程有意或无意的违法同步操作 </p>
</li>
<li><p>便于用高级语言来书写程序</p>
</li>
</ul>
</li>
<li><p>管程和互斥锁有什么区别？</p>
<ol>
<li>互斥锁：是一种低级同步原语，用于确保一次只有一个线程或进程可以访问共享资源。</li>
<li>管程：是一种高级同步机制，封装了共享数据和操作这些数据的过程（或函数），并提供了一种安全的方式来访问和修改共享数据。</li>
</ol>
</li>
<li><p>形式：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522114935161.png" alt="image-20250522114935161"></p>
</li>
<li><p>条件变量</p>
<ol>
<li>当资源不足导致进程阻塞时，同时开放冠层，让挡在管程外的一个进程进入管程。</li>
<li>条件变量：是出现在管程内的一种数据结构，且只有在管程中才能被访问，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它，用于阻塞进程的信号量。<ol>
<li>wait()：当一个管程过程发现无法继续时(如发现没有可用资源时)，它在某些条件变量上执行wait，这个动作引起调用进程阻塞，直到另一个进程在该条件变量上执行signal()</li>
<li>signal()<ol>
<li>如果存在其他进程由于对条件变量执行wait()而被阻塞，便释放之</li>
<li>如果没有进程在等待，那么信号不被保存，并不是立即退出管程等待队列，而是进入next信号量，以保证多个进程都可以正常退出。</li>
</ol>
</li>
<li>条件变量仅仅维护阻塞队列的作用，如果没有等待时发生signal()操作，相当于空操作。</li>
</ol>
</li>
<li>使用signal释放等待进程时，可能出现两个进程同时停留在管程内。解决方法：<ol>
<li><strong>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件</strong></li>
<li>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</li>
</ol>
</li>
<li>霍尔(Hoare, 1974)采用第一种办法</li>
<li>汉森(Hansen)选择两者的折衷，规定管程中的过程所执行的signal操作是过程体的最后一个操作</li>
</ol>
</li>
</ol>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li><p>Hoare管程的enter()和leave()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enter</span><span class="params">(InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">P</span>(IM.mutex);         <span class="comment">//判有否发出过signal的进程?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leave</span><span class="params">(InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (IM.next_count&gt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">V</span>(IM.next);       <span class="comment">//有就释放一个发出过signal的进程</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">V</span>(IM.mutex);      <span class="comment">//否则开放管程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Hoare管程的wait()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_sem: semaphore;       <span class="comment">// 与资源相关的信号量</span></span><br><span class="line">x_count: integer;       <span class="comment">// 在x_sem上等待的进程数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore &amp;x_sem,<span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">      x_count,InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   x_count++;           <span class="comment">//等资源进程个数加1，x_count初始化为0</span></span><br><span class="line">   <span class="keyword">if</span> (IM.next_count&gt;<span class="number">0</span>) <span class="comment">//判断是否有发出过signal的进程</span></span><br><span class="line">      <span class="built_in">V</span>(IM.next);       <span class="comment">//有就释放一个</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">V</span>(IM.mutex);      <span class="comment">//否则开放管程</span></span><br><span class="line">   <span class="built_in">P</span>(x_sem);            <span class="comment">//等资源进程阻塞自己，x_sem初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Hoare管程的signal()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore &amp;x_sem,<span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">      &amp;x_count,InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x_count&gt;<span class="number">0</span>) &#123;      <span class="comment">//判断是否有等待资源的进程</span></span><br><span class="line">      IM.next_count++;  <span class="comment">//发出signal进程个数加1</span></span><br><span class="line">      <span class="built_in">V</span>(x_sem);         <span class="comment">//释放一个等资源的进程</span></span><br><span class="line">      <span class="built_in">P</span>(IM.next);       <span class="comment">//发出signal进程阻塞自己**</span></span><br><span class="line">      x_count--;        <span class="comment">//发出signal进程个数减1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 霍尔管程执行signal的进程等待，直到被释放进程退出管程或等待另一个条件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115334937.png" alt="image-20250526115334937"></p>
<h4 id="读者写者"><a href="#读者写者" class="headerlink" title="读者写者"></a>读者写者</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115358852.png" alt="image-20250526115358852"></p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115425074.png" alt="image-20250526115425074"></p>
<h4 id="苹果桔子"><a href="#苹果桔子" class="headerlink" title="苹果桔子"></a>苹果桔子</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115444182.png" alt="image-20250526115444182"></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol>
<li>必要条件：<ol>
<li><strong>互斥条件</strong>: 进程应互斥使用资源，任一时刻一个资源仅为一个进程独占</li>
<li><strong>占有和等待条件</strong>: 一个进程请求资源得不到满足而等待时，不释放已占有的资源</li>
<li><strong>不剥夺条件</strong>: 任一进程不能从另一进程那里抢夺资源</li>
<li><strong>循环等待条件</strong>: 存在一个循环等待链，每一个进程分别等待它前一个进程所持有的资源<ul>
<li>前三个是死锁存在的必要条件，但不是充分条件，第四个条件是前三个条件同时存在时所产生的结果。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ol>
<li>死锁的避免<ol>
<li>当不能防止死锁的产生时，如果能掌握并发进程中与每个进程有关的<strong>资源申请情况</strong>，仍然可以避免死锁的发生</li>
<li>只需在为申请者分配资源前先测试系统状态，若把资源分配给申请者会产生死锁的话，则拒绝分配，否则接收申请，为它分配资源</li>
</ol>
</li>
</ol>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>总结：牢记两个关键点：<ul>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171023399.png" alt="image-20250526171023399"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171043589.png" alt="image-20250526171043589"></li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>算法背景和目的</strong></p>
<p>银行家算法是一种预防死锁的资源分配算法，其灵感来源于银行家的贷款原则。在计算机系统中，操作系统就像银行家，管理着有限的资源（如内存、磁盘空间等）。进程就像要求贷款的客户，需要向操作系统申请资源。银行家算法的目标是确保系统在分配资源的过程中不会出现死锁情况，即避免多个进程因相互等待资源而无法继续执行。</p>
</li>
<li><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>银行家算法使用以下数据结构来管理资源和进程：</p>
<ol>
<li><strong>资源总数向量（Resource）</strong>：<ul>
<li>表示系统中每类资源的总数。</li>
<li>例如，Resource &#x3D; (R1, R2, …, Rm)，其中R1表示第一类资源的总数，R2表示第二类资源的总数，依此类推。</li>
</ul>
</li>
<li><strong>可用资源向量（Available）</strong>：<ul>
<li>表示系统中每类资源当前可用的数量。</li>
<li>例如，Available &#x3D; (V1, V2, …, Vm)，其中V1表示第一类资源当前可用的数量，V2表示第二类资源当前可用的数量。</li>
</ul>
</li>
<li><strong>最大需求矩阵（Claim）</strong>：<ul>
<li>Claim[i, j]表示进程Pi对Rj类资源的最大需求量。</li>
<li>例如，Claim[1, 2] &#x3D; 3表示进程P1对第二类资源的最大需求量是3个。</li>
</ul>
</li>
<li><strong>分配矩阵（Allocation）</strong>：<ul>
<li>Allocation[i, j]表示进程Pi已经分配到的Rj类资源数量。</li>
<li>初始值为0，随着进程申请资源而更新。</li>
</ul>
</li>
<li><strong>需求矩阵（Need）</strong>：<ul>
<li>Need[i, j]表示进程Pi还需要的Rj类资源数量。</li>
<li>计算公式为：Need[i, j] &#x3D; Claim[i, j] - Allocation[i, j]。</li>
</ul>
</li>
<li><strong>请求矩阵（Request）</strong>：<ul>
<li>Request[i, j]表示进程Pi当前申请的Rj类资源数量。</li>
</ul>
</li>
</ol>
<h3 id="3-算法原理"><a href="#3-算法原理" class="headerlink" title="3. 算法原理"></a>3. 算法原理</h3><p>银行家算法通过以下步骤确保系统不会进入死锁状态：</p>
<h4 id="3-1-进程启动时的检查"><a href="#3-1-进程启动时的检查" class="headerlink" title="3.1 进程启动时的检查"></a>3.1 进程启动时的检查</h4><ul>
<li><p>当系统要启动一个新进程时，需要检查是否满足以下不等式：</p>
<p><em>R**i</em>≥Claim[(<em>n</em>+1),<em>i</em>]+<em>k</em>&#x3D;1∑<em>n</em>Claim[<em>k</em>,<em>i</em>]</p>
<p>其中，Ri表示第i类资源的总数，Claim[(n+1),i]表示新进程对第i类资源的最大需求量，Claim[k,i]表示已存在的进程对第i类资源的最大需求量。</p>
</li>
<li><p>如果不满足上述条件，系统拒绝启动该进程，以防止资源不足导致死锁。</p>
</li>
</ul>
<h4 id="3-2-资源分配过程"><a href="#3-2-资源分配过程" class="headerlink" title="3.2 资源分配过程"></a>3.2 资源分配过程</h4><ol>
<li><strong>试探性分配</strong>：<ul>
<li>当系统收到进程的资源请求后，先进行试探性分配。即假设系统满足了进程的请求，更新资源分配情况。</li>
</ul>
</li>
<li><strong>安全性检查</strong>：<ul>
<li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较。</li>
<li>在进程集合中找到剩余资源能满足最大需求量的进程。这样可以保证这个进程运行完毕并归还全部资源。</li>
</ul>
</li>
<li><strong>资源回收</strong>：<ul>
<li>把这个进程从集合中去掉，系统的剩余资源会增加。</li>
<li>然后反复执行上述步骤，逐步减少进程集合中的进程数量。</li>
</ul>
</li>
</ol>
<h4 id="3-3-安全性判断"><a href="#3-3-安全性判断" class="headerlink" title="3.3 安全性判断"></a>3.3 安全性判断</h4><ul>
<li>如果最后进程集合为空，说明本次申请可行，系统处于安全状态，可以实施本次分配。</li>
<li>如果进程集合不为空，说明有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。</li>
</ul>
<h3 id="4-系统安全性定义"><a href="#4-系统安全性定义" class="headerlink" title="4. 系统安全性定义"></a>4. 系统安全性定义</h3><p>在时刻T0，系统是安全的，当且仅当存在一个进程序列P1，…，Pn，对进程Pk满足公式：</p>
<p>Need[<em>k</em>,<em>i</em>]≤Available[<em>i</em>]+<em>j</em>&#x3D;1∑<em>k</em>−1Allocation[<em>j</em>,<em>i</em>]</p>
<p>这个公式的意思是，对于每个进程Pk，它还需要的资源数量（Need[k,i]）不能超过当前可用资源数量（Available[i]）加上前面已经分配资源的进程（j &#x3D; 1到k - 1）所分配的资源数量总和。这说明系统能够按照这个序列依次满足进程的最大资源需求，从而保证系统不会出现死锁。</p>
<h3 id="5-示例说明"><a href="#5-示例说明" class="headerlink" title="5. 示例说明"></a>5. 示例说明</h3><p>假设系统有三个进程P, Q, R，系统只有一类资源共10个，目前分配情况如下：</p>
<p>表格</p>
<p>复制</p>
<table>
<thead>
<tr>
<th align="left">进程</th>
<th align="left">最大需求（Claim）</th>
<th align="left">已分配（Allocation）</th>
<th align="left">需求（Need）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">P</td>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Q</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>当前可用资源（Available）为：5</p>
<ol>
<li><strong>安全性检查</strong>：<ul>
<li>检查是否存在一个安全序列。假设序列是P, Q, R。</li>
<li>对于P：Need[P] &#x3D; 3，Available + Allocation[Q] + Allocation[R] &#x3D; 5 + 1 + 2 &#x3D; 8，满足Need[P] ≤ 8。</li>
<li>P运行完毕后，释放资源2，Available &#x3D; 7。</li>
<li>对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 7 + 2 &#x3D; 9，满足Need[Q] ≤ 9。</li>
<li>Q运行完毕后，释放资源1，Available &#x3D; 8。</li>
<li>对于R：Need[R] &#x3D; 1，Available &#x3D; 8，满足Need[R] ≤ 8。</li>
<li>R运行完毕后，释放资源2，Available &#x3D; 10。</li>
<li>进程集合为空，系统处于安全状态。</li>
</ul>
</li>
<li><strong>资源请求</strong>：<ul>
<li>假设进程P请求2个资源。</li>
<li>试探性分配后，Available &#x3D; 3，Allocation[P] &#x3D; 4，Need[P] &#x3D; 1。</li>
<li>检查安全性：新的序列可能是Q, R, P。<ul>
<li>对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 3 + 2 &#x3D; 5，满足Need[Q] ≤ 5。</li>
<li>Q运行完毕后，释放资源1，Available &#x3D; 4。</li>
<li>对于R：Need[R] &#x3D; 1，Available &#x3D; 4，满足Need[R] ≤ 4。</li>
<li>R运行完毕后，释放资源2，Available &#x3D; 6。</li>
<li>对于P：Need[P] &#x3D; 1，Available &#x3D; 6，满足Need[P] ≤ 6。</li>
<li>P运行完毕后，释放资源4，Available &#x3D; 10。</li>
<li>进程集合为空，系统处于安全状态。</li>
</ul>
</li>
<li>因此，可以真正分配资源给P。</li>
</ul>
</li>
</ol>
<p>通过上述步骤，银行家算法能够有效地预防死锁的发生，确保系统资源的安全分配。</p>
</li>
</ol>
<h3 id="10-8-5-银行家算法的程序及实现"><a href="#10-8-5-银行家算法的程序及实现" class="headerlink" title="10.8.5. 银行家算法的程序及实现"></a>10.8.5. 银行家算法的程序及实现</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/112.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/112.png" alt="img"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">state</span> &#123;<span class="comment">//全局数据结构</span></span><br><span class="line">   <span class="type">int</span> resource[m];</span><br><span class="line">   <span class="type">int</span> available[m];</span><br><span class="line">   <span class="type">int</span> claim[n][m];</span><br><span class="line">   <span class="type">int</span> allocation[n][m];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resource_allocation</span><span class="params">( )</span> </span>&#123; <span class="comment">//资源分配算法</span></span><br><span class="line">   <span class="keyword">if</span>(allocation[i,*]+request[*]&gt;claim[i,*])</span><br><span class="line">      &#123;error&#125;; <span class="comment">//申请量超过最大需求值</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(request[*]&gt;available[*])</span><br><span class="line">         &#123;suspend process.&#125;;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//尝试分配，define newstate by:</span></span><br><span class="line">         allocation[i,*]=allocation[i,*]+request[*];</span><br><span class="line">         available[*]=available[*]-request[*];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">safe</span>(newstate))</span><br><span class="line">      &#123;carry out allocation&#125;;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      &#123;restore original state&#125;;</span><br><span class="line">      &#123;suspend process&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">safe</span><span class="params">(state s)</span> </span>&#123; <span class="comment">//安全性测试算法</span></span><br><span class="line">   <span class="type">int</span> currentavail[m];</span><br><span class="line">   set &lt;process&gt; rest;</span><br><span class="line">   currentavail[*]=available[*];</span><br><span class="line">   rest=&#123;all process&#125;;</span><br><span class="line">   possible=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(possible)&#123; <span class="comment">//rest中找一个Pk，满足以下条件</span></span><br><span class="line">      claim[k,*]-allocation[k,*]&lt;=currentavail[*]</span><br><span class="line">      <span class="keyword">if</span>(found)&#123;</span><br><span class="line">         currentavail[*]=currentavail[*]+allocation[k,*];</span><br><span class="line">         rest=rest–&#123;Pk&#125;;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         possible=<span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(rest=null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure>


<h3 id="10-8-6-银行家算法例子"><a href="#10-8-6-银行家算法例子" class="headerlink" title="10.8.6. 银行家算法例子"></a>10.8.6. 银行家算法例子</h3><h4 id="10-8-6-1-银行家算法例1"><a href="#10-8-6-1-银行家算法例1" class="headerlink" title="10.8.6.1. 银行家算法例1"></a>10.8.6.1. 银行家算法例1</h4><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/25.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/25.png" alt="img"></a></th>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/26.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>P或者R再申请资源时，不能分配，因为现在只剩下2个资源，不能满足它们的最大需求</p>
<h4 id="10-8-6-2-实例说明系统所处的安全或不安全状态-1"><a href="#10-8-6-2-实例说明系统所处的安全或不安全状态-1" class="headerlink" title="10.8.6.2. 实例说明系统所处的安全或不安全状态(1)"></a>10.8.6.2. 实例说明系统所处的安全或不安全状态(1)</h4><ol>
<li>如果系统中共有五个进程和A、B、C三类资源</li>
<li>A类资源共有10个,B类资源共有5个,C类资源共有7个</li>
<li>在时刻T0T0,系统目前资源分配情况如下：</li>
</ol>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/86.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/86.png" alt="img"></a></th>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/87.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/87.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>可以断言目前系统处于安全状态，因为序列{P1,P3,P4,P2,P0}{P1,P3,P4,P2,P0}能满足安全性条件</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/88.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/88.png" alt="img"></a></p>
<ol>
<li><p>假设</p>
<p>P1P1</p>
<p>又请求1个A类资源和2个c类资源，得到新的状态如下图所示：</p>
<ol>
<li>Request1(1,0,2)≤Need(1,2,2)Request1(1,0,2)≤Need(1,2,2)</li>
<li>Request1(1,0,2)≤Available(3,3,2)Request1(1,0,2)≤Available(3,3,2)</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/89.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/89.png" alt="img"></a></p>
<ol>
<li>判定新状态是否安全?可执行安全性测试算法，找到一个进程序列{P1,P3,P4,P0,P2}{P1,P3,P4,P0,P2}能满足安全性条件，所以可正式把资源分配给进程P1；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/90.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/90.png" alt="img"></a></p>
<ol>
<li><p>假设</p>
<p>P4P4</p>
<p>发起资源请求，按照银行家算法检查，资源不足不予以分配</p>
<ol>
<li>Request4(3,3,0)≤Need(4,3,1)Request4(3,3,0)≤Need(4,3,1)</li>
<li>Request4(3,3,0)&gt;Available(2,3,0)Request4(3,3,0)&gt;Available(2,3,0)</li>
</ol>
</li>
<li><p>假设</p>
<p>P0P0</p>
<p>发起资源请求，按照银行加算法检查，得到中间结果如下</p>
<ol>
<li>Request0(0,2,0)≤Need(7,3,1)Request0(0,2,0)≤Need(7,3,1)</li>
<li>Request0(0,2,0)≤Available(2,3,0)Request0(0,2,0)≤Available(2,3,0)</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/91.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/91.png" alt="img"></a></p>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ol>
<li><p>解决死锁问题的另一条途径是<strong>死锁检测方法</strong></p>
</li>
<li><p>这种方法对资源的分配不加限制，但系统定时运行一个”<strong>死锁检测</strong>“程序，判断系统内是否已出现死锁，若检测到死锁则设法加以解除</p>
</li>
<li><p>检测的一种方法：可设置两张表格来记录进程使用资源的情况</p>
<ol>
<li>等待资源表记录每个被<strong>阻塞进程等待</strong>的资源</li>
<li>占用资源表记录每个进程<strong>占有</strong>的资源</li>
</ol>
</li>
<li><p>进程申请资源时，先查该资源</p>
<p>是否为其它进程所占用</p>
<ol>
<li>若资源空闲，则把该资源分配给申请者且登入占用资源表</li>
<li>否则，则登入进程等待资源表</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/27.png" alt="img"></a></p>
<ol>
<li>死锁检测程序定时检测这两张表，若有进程Pi等待资源rk，且rk被进程Pj占用，则说PiPi和PjPj具有”等待占用关系”，记为W(Pi,Pj)</li>
<li>死锁检测程序反复检测这两张表，可以列出所有的”<strong>等待占用</strong>关系”</li>
<li>如果出现循环等待占用时，显然，系统中存在一组循环等待资源的进程：Pi，Pj，Pk，…，Pm，Pn也就是说出现了死锁</li>
</ol>
<h4 id="资源分配图与死锁定理"><a href="#资源分配图与死锁定理" class="headerlink" title="资源分配图与死锁定理"></a>资源分配图与死锁定理</h4><ol>
<li>资源分配图的图例<ol>
<li>每个资源用一个<strong>方框</strong>表示</li>
<li>方框中的<strong>黑圆点</strong>表示此资源类中的各个资源</li>
<li>每个进程用一个<strong>圆圈</strong>表示</li>
<li><strong>有向边</strong>表示进程申请资源和资源被分配情况</li>
</ol>
</li>
<li>约定Pi→Rj为请求边，表示进程Pi申请资源类Rj中的一个资源得不到满足而处于等待Rj类资源的状态，该有向边从进程开始指到方框的边缘，表示进程Pi申请Rj类中的一个资源。</li>
<li>Rj→Pi为分配边，表示Rj类中的一个资源已被进程Pi占用，由于已把一个具体的资源分给了进程Pi，故该有向边从方框内的某个黑圆点出发指向进程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/92.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/92.png" alt="img"></a></p>
<ol>
<li><p>图3.6中存在环路，经过分析是存在死锁的</p>
</li>
<li><p>图3.7中存在环路，但是经过分析是不存在死锁的，因为R1和R2资源都不只一个，P2和P4进程归还后是可以避免的。</p>
</li>
<li><p>简化：</p>
<ol>
<li><p><strong>简化步骤</strong>：</p>
<ol>
<li><strong>寻找可完成的进程</strong>：找到一个进程 <em>P**i</em>，它请求的资源都能得到满足。即 <em>P**i</em> 所需的资源要么是未分配的，要么是已分配给其他进程但这些进程可以释放这些资源。</li>
<li><strong>释放资源</strong>：假设 <em>P**i</em> 获得了所需资源并运行完成，它会释放所有分配给它的资源。这相当于从图中移除所有与 <em>P**i</em> 相关的申请边和分配边。</li>
<li><strong>重复步骤</strong>：重复上述步骤，寻找下一个可完成的进程，直到所有边都被消去。</li>
</ol>
<p>如果最终所有边都被消去，资源分配图是可完全简化的，系统不存在死锁。</p>
</li>
</ol>
</li>
</ol>
<h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是<strong>不可完全简化</strong>的。该充分条件称为死锁定理</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/113.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/113.png" alt="img"></a></p>
<h4 id="死锁检测的数据结构"><a href="#死锁检测的数据结构" class="headerlink" title="死锁检测的数据结构"></a>死锁检测的数据结构</h4><ol>
<li>把两张表格中记录的进程使用和等待资源的情况用一个矩阵A来表示</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/28.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/28.png" alt="img"></a></p>
<h4 id="死锁检测程序可用Warshall的传递闭包算法"><a href="#死锁检测程序可用Warshall的传递闭包算法" class="headerlink" title="死锁检测程序可用Warshall的传递闭包算法"></a>死锁检测程序可用Warshall的传递闭包算法</h4><ol>
<li>检测是否有死锁发生，即对矩阵A构造传递闭包A∗[bij]</li>
<li>A∗[bij]中的每个bij是对A[bij]执行如下算法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for k:=1 to n do</span><br><span class="line">   for i:=1 to n do </span><br><span class="line">      for j:=1 to do</span><br><span class="line">         bij:= bij 并 (bik 并 bkj)</span><br><span class="line">         </span><br><span class="line">      </span><br></pre></td></tr></table></figure>


<p>在计算完传递闭包矩阵 <em>W</em>∗ 后，检查对角线上的元素 <em>W</em>∗[<em>i</em>][<em>i</em>]：</p>
<ul>
<li>如果存在某个 <em>i</em> 使得 <em>W</em>∗[<em>i</em>][<em>i</em>]&#x3D;1，则表示存在从节点 <em>i</em> 到自身的路径，即存在循环等待，系统可能处于死锁状态。</li>
</ul>
<h3 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h3><ol>
<li>死锁被检测到后可以通过各种方法来解除系统死锁以恢复到可运行状态，方法有资源剥夺法、进程回退法、进程撤销法和系统重启法。<ol>
<li>资源剥夺法：剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。可仿照撤销陷于死锁的进程那样来选择剥夺资源的进程。</li>
<li>进程回退法：根据系统保存的检查点让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检査点、回退及重启机制。</li>
<li>进程撤销法：<ol>
<li>撤销陷于死锁的<strong>所有进程</strong>，解除死锁，继续运行。</li>
<li>逐个撤销<strong>陷于死锁</strong>的进程，回收其资源并<strong>重新分派</strong>，直至死锁解除。但是究竟先撤销哪个死锁进程呢？可选择符合下面条件之一的进程先撤销： PU消耗时间最少者、产生的输出量最少者、预计剩余执行时间最长者、分得的资源数量最少者或优先级最低者。</li>
</ol>
</li>
<li>系统重启法：结束所有进程的执行并<strong>重新启动</strong>操作系统。这种方法很简单，但先前的工作全部作废，损失很大。</li>
</ol>
</li>
<li>检测死锁是否出现和发现死锁后实现恢复的代价大于防止和避免死锁花费的代价，但是这样的代价是值得的，因为死锁不是经常出现的。<ol>
<li>检测策略的代价依赖于<strong>死锁出现的频率</strong></li>
<li>恢复的代价是指处理器<strong>时间的损失</strong>。</li>
</ol>
</li>
</ol>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="第一章-·-导论"><a href="#第一章-·-导论" class="headerlink" title="第一章 · 导论"></a>第一章 · 导论</h2><ol>
<li><blockquote>
<p>____C____操作系统允许在一台主机上同时联接多台终端，多个用户可以通过各自的终端同时交互使用计算机。</p>
<p>A. 网络    B. 分布式    C. 分时    D. 实时</p>
</blockquote>
</li>
<li><p>分时操作系统、实时操作系统的特点和应用领域</p>
<ol>
<li><p>分时操作系统（Time-Sharing Operating System）</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>多用户交互</strong>：允许多个用户同时通过终端与计算机交互。</li>
<li>时间片轮转：采用时间片轮转（Round Robin）调度算法，将CPU时间分配给多个用户，每个用户感觉像是独占计算机。</li>
<li>快速响应：系统对用户输入的响应时间较短，通常在几秒内。</li>
<li>资源共享：系统中的资源（如CPU、内存、I&#x2F;O设备）被多个用户共享。</li>
</ul>
</li>
<li>应用领域：<ul>
<li>多用户环境：如大学计算机实验室、企业办公环境等。</li>
<li>交互式应用：如文本编辑、电子邮件、在线数据库查询等。</li>
<li>云计算服务：云平台提供多用户访问和资源共享，类似于分时系统。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>实时操作系统（Real-Time Operating System, RTOS）</li>
</ol>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>严格的时间约束</strong>：系统必须在严格的时间限制内完成任务，否则可能导致严重后果。</li>
<li>高可靠性：系统必须高度可靠，能够处理突发的事件和任务。</li>
<li>优先级调度：采用优先级调度算法，确保高优先级任务优先执行。</li>
<li>快速响应：系统对事件的响应时间非常短，通常在毫秒甚至微秒级别。</li>
</ul>
</li>
<li>应用领域：<ul>
<li><strong>嵌入式系统</strong>：如汽车电子控制系统、工业自动化设备、医疗设备等。</li>
<li><strong>航空航天</strong>：如飞行控制系统、卫星通信系统等。</li>
<li>军事应用：如雷达系统、导弹制导系统等。</li>
<li><strong>金融服务</strong>：如高频交易系统，需要快速处理交易请求。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>配置了操作系统的机器是一台比原来的物理机器功能更强的计算机，这样的计算机只是一台逻辑上的计算机，称为____虚拟____计算机。</p>
</li>
<li><blockquote>
<p>实时操作系统必须在__ A __内处理来自外部的事件。</p>
<ul>
<li>A.规定时间；</li>
<li>B.调度时间；</li>
<li>C.响应时间；</li>
<li>D.周转时间；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>特权指令是指____A____。</p>
<ul>
<li>A.其执行可能有损系统的安全性；</li>
<li>B.机器指令；</li>
<li>C.控制指令；</li>
<li>D.系统管理员可用的指令；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍____Celeron____不是一个操作系统环境。</p>
</blockquote>
</li>
</ol>
<p>‎</p>
<h2 id="第二章-·-处理器管理"><a href="#第二章-·-处理器管理" class="headerlink" title="第二章 · 处理器管理"></a>第二章 · 处理器管理</h2><ol>
<li><p>静态共享进程时间图像如下，注意B处理完IO之后马上就可以执行C的IO。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250427191806703.png" alt="image-20250427191806703"></p>
</li>
<li><p>在做进程调度大题时，列出详细的表格，不会错：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250603203011372.png" alt="image-20250603203011372"></p>
<ol>
<li><strong>注意可能会需要平分CPU时间！！！</strong></li>
</ol>
</li>
<li><blockquote>
<p>试写出进程映像包括哪些组成部分(不必详述每个组成部分的具体内容)。(2 分)</p>
<p>答: 程序块、数据块、核心栈、进程控制块(PCB)</p>
</blockquote>
</li>
<li><p>七状态图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250608180546438.png" alt="image-20250608180546438"></p>
</li>
<li><p>时间片轮转调度（RR）：</p>
<ol>
<li>不考虑优先级的，就是先来先服务，服务完了到最后排队。</li>
<li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li>
</ol>
</li>
<li><p>多级反馈调度：</p>
<ol>
<li>在时间片调度（RR）的基础上，引入了优先级。刚进入队列时优先级最高，被抢占一次就降一级。</li>
<li>设置的q就是指时间片长度</li>
<li>而前面笔记中的 q&#x3D;2^i^ 是指我们希望动态调整时间片长度</li>
</ol>
</li>
<li><p>注意看题目中同时最多支持几道程序。</p>
</li>
<li><blockquote>
<p>实模式下 16 位 CPU 使用段偏移方式的寻址能力为_______B___。</p>
<p>A. 64kb B. 1M C. 16M D. 4G</p>
</blockquote>
<ul>
<li>记住实模式的寻址能力就是20位也可以</li>
</ul>
</li>
<li><p>段偏移：</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602171744758.png" alt="image-20250602171744758"></p>
</li>
<li><p>通过段地址和偏移地址相加的方式来寻址</p>
</li>
<li><p>为了表示更大范围的地址，我们对段地址左移四位再和偏移地址相加。</p>
</li>
<li><p>此时我们可以认为我们有了20位的寻址能力，即1M</p>
</li>
</ol>
</li>
<li><blockquote>
<p>下面哪条指令不是从实模式进入保护模式需要的指令______C____。</p>
<p>A. lgdt [GdtPtr] B. out 92h, al C. jmp $ D. mov cr0, eax</p>
</blockquote>
<ul>
<li>jmp $。 其中$是指前地址。这句指令会形成死循环</li>
</ul>
</li>
<li><p>实模式和保护模式：</p>
</li>
<li><p>实模式：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172431181.png" alt="image-20250602172431181"></li>
</ol>
</li>
<li><p>保护模式</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172450157.png" alt="image-20250602172450157"></li>
</ol>
</li>
<li><p>模式切换：</p>
<ol>
<li><p>实模式切换到保护模式：</p>
<ol>
<li><p>一般步骤：</p>
<ol>
<li><p><strong>构造 GDT（全局描述符表）</strong><br> 并使用 <code>lgdt [GdtPtr]</code> 加载 GDT。</p>
</li>
<li><p><strong>设置 PE 位（Protection Enable）</strong><br> 把 <code>CR0</code> 的第 0 位（PE 位）设置为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0  </span><br><span class="line">or eax, 1  </span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>立即跳转（Far Jump）刷新流水线和 CS 段寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp selector:offset</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><blockquote>
<p>Solaris 的多线程的实现方式为___B___</p>
<p>A.纯内核级线程 </p>
<p>B.混合式 </p>
<p>C.纯用户级多线程 </p>
<p>D.单线程结构进程</p>
</blockquote>
</li>
<li><blockquote>
<p>引入多道程序设计技术的前ᨀ条件之一是系统具有___C__。</p>
<p>A. 多个 CPU </p>
<p>B.多个终端 </p>
<p>C. 中断功能 </p>
<p>D.分时功能</p>
</blockquote>
</li>
<li><blockquote>
<p>操作系统里没有下面哪种述符表______D___。</p>
<p>A. GDT B. LDT C. IDT D. KDT</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602173324647.png" alt="image-20250602173324647"></p>
</blockquote>
</li>
<li><blockquote>
<p>C 语言里面调用汇编的函数方法为______A___。 </p>
<p>A. C 代码中使用 extern 声明，汇编中使用 global 导出 </p>
<p>B. C 代码中使用 global 声明，汇编中使用 extern 导出 </p>
<p>C. C 代码中使用 extern 声明，汇编中使用 extern 导出 </p>
<p>D. C 代码中使用 global 声明，汇编中使用 global 导出</p>
</blockquote>
</li>
<li><p>进程包含的实体部分：OS 管理程序的<strong>数据结构</strong>和程序状态字（对应进程控制块），运⾏程序的<strong>内存代码</strong>、内存数据（对应程序块和数据块）、<strong>通⽤寄存器信息</strong>（对应核心栈）</p>
</li>
<li><p>进程映像：进程控制块、进程程序块、进程数据块、核⼼栈</p>
</li>
<li><p>对进程的管理和控制通过<strong>原语</strong></p>
</li>
<li><p>系统调用的实现流程，画图！</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250604173033445.png" alt="image-20250604173033445"></li>
</ol>
</li>
<li><p>线程的调度</p>
</li>
<li><blockquote>
<p>当计算机提供了管态（内核态）和目态（用户态）时，____A____必须在管态下运行</p>
<p>A. 输入输出指令</p>
<p>B. 从内存中取数</p>
<p>C. 运算指令</p>
<p>D. 把运算结果存回内存</p>
<ul>
<li>输入输出涉及到IO设备，要用内核指令调用</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>关于内核级线程，以下描述不正确的是_­­­­­­__­­­­­­_B_­­­­­­__­­­­­­。</p>
<p>‎</p>
<ul>
<li>A.内核可以将处理器调度直接分配给某个内核级线程；</li>
<li>B.控制权从一个线程传送到另一个线程时不需要用户态-内核态-用户态的模式切换；</li>
<li>C.可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势；</li>
<li>D.建立和维护线程的数据结构及保存每个线程的入口；</li>
<li><strong>内核级线程的定义</strong><ul>
<li>内核级线程是操作系统内核能够感知的线程。内核为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息。</li>
</ul>
</li>
<li><strong>选项A的正确性</strong><ul>
<li>内核可以将处理器调度直接分配给某个内核级线程。因为内核级线程是内核能够感知和管理的实体，内核可以直接对它们进行调度，将处理器分配给某个线程运行。</li>
</ul>
</li>
<li><strong>选项B的错误性</strong><ul>
<li>控制权从一个线程传送到另一个线程时，通常需要进行用户态-内核态-用户态的模式切换。这是因为线程切换涉及到内核对线程上下文的切换，而上下文切换需要内核的参与。具体过程如下：<ul>
<li>当一个线程运行时，它可能处于用户态。</li>
<li>当需要切换到另一个线程时，当前线程需要将控制权交回内核，这涉及到从用户态切换到内核态。</li>
<li>内核保存当前线程的上下文，加载下一个线程的上下文，然后将控制权交给下一个线程，这又涉及到从内核态切换回用户态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选项C的正确性</strong><ul>
<li>可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势。内核级线程是内核能够感知的线程，内核可以将它们分派到不同的处理器上运行，从而实现多处理器并行工作。</li>
</ul>
</li>
<li><strong>选项D的正确性</strong><ul>
<li>建立和维护线程的数据结构及保存每个线程的入口是内核级线程的特性。内核需要为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息，这些信息构成了线程的数据结构。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍__B__优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。</p>
<p>‎</p>
<ul>
<li>A.短作业；</li>
<li>B.静态；</li>
<li>C.先来先服务；</li>
<li>D.动态；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>下面对进程的描述中，错误的是__B__。</p>
<p>‍</p>
<ul>
<li>A.进程执行需要处理机；</li>
<li>B.进程是指令的集合；</li>
<li>C.进程是有生命周期的；</li>
<li>D.进程是动态的概念；<ul>
<li>进程是操作系统中一个独立运行的基本单位，它包含了程序运行时所需的全部信息和资源。它不仅仅是一组指令，还包括以下几个重要组成部分</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>下面所述步骤中，__ C __不是创建进程所必需的。</p>
<p>‏</p>
<ul>
<li>A.为进程分配内存；</li>
<li>B.建立一个进程控制块；</li>
<li>C.由调度程序为进程分配CPU；</li>
<li>D.将进程控制块链入就绪队列；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>所谓“可重入”程序是指___C___。</p>
<ul>
<li>A.在执行过程中其代码自身会发生变化的程序；</li>
<li>B.不能够被多个程序同时调用的程序；</li>
<li>C.能够被多个进程共享的程序；</li>
<li>D.无限循环程序；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍在下述关于父进程和子进程的叙述中，正确的是__C___。</p>
<ul>
<li>A.父进程创建了子进程，因此父进程执行完了，子进程才能运行；</li>
<li>B.撤销子进程时，应该同时撤销父进程；</li>
<li>C.父进程和子进程可以并发执行；</li>
<li>D.撤销父进程时，应该同时撤销子进程；<ul>
<li>父进程创建子进程后，父进程和子进程可以独立运行。操作系统会根据调度策略来决定哪个进程运行，而不是依赖于父进程是否完成。父进程和子进程可以并发执行，互不干扰。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>一个可共享的程序在执行过程中是不能被修改的，这样的程序代码应该是­<strong>C</strong>_。</p>
<ul>
<li>A.可再现代码；</li>
<li>B.可执行代码；</li>
<li>C.可重入代码；</li>
<li>D.封闭的代码；</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="第三章-·-存储管理-1"><a href="#第三章-·-存储管理-1" class="headerlink" title="第三章 · 存储管理"></a>第三章 · 存储管理</h2><ol>
<li><p>页式存储地址转换</p>
<ol>
<li>在做题时，中间过程可以先用十进制表示，不用完全展开为二进制，提高做题速度。</li>
</ol>
</li>
<li><p>clock算法：</p>
<ol>
<li><p>如果在页表中找到了某一页，设置完引用位之后不用推进指针。</p>
</li>
<li><p>那个‘*’叫引用位</p>
</li>
<li><p>淘汰需要推进指针，找到了页不用</p>
</li>
</ol>
</li>
<li><p>MIN算法和WS算法一次只会引入一个页</p>
</li>
<li><p>页式存储会导致内部碎片，包括段页式，分页式等。而分段式不会</p>
</li>
<li><p>程序装入与链接：</p>
<ol>
<li><strong>装入</strong>是指将程序从外存（如磁盘）加载到内存的过程。</li>
<li><strong>链接</strong>是指将多个目标模块（如程序模块、库模块等）组合成一个可执行程序的过程。链接可以分为静态链接和动态链接。</li>
</ol>
</li>
<li><p>静态重定位：</p>
<ol>
<li>是一种地址转换的方法，比如把逻辑地址变为物理地址。</li>
<li>一般在进程装入的时候发生</li>
</ol>
</li>
<li><p>能够装入内存任何位置的代码程序必须是__<strong>可动态链接的</strong>__。</p>
</li>
<li><p>在分页式虚存中，分页由__<strong>操作系统</strong>___实现。</p>
</li>
<li><p>缺⻚中断后重新执⾏被中断的指令</p>
</li>
<li><p>分段式不会产生内部碎片，分页式不会产生外部碎片。</p>
</li>
<li><p>在请求分页存储管理中，当访问的页面不在内存时，便产生缺页中断，缺页中断是属于_<em>C</em>_。😥</p>
</li>
</ol>
<blockquote>
<p>A. 访管中断</p>
<p>B. 外中断；</p>
<p><strong>C. I&#x2F;O中断；</strong></p>
<p>D. 程序中断；</p>
</blockquote>
<ol start="11">
<li><p>虚存的可行性基础是____。😥</p>
<blockquote>
<p><strong>A. 程序执行的局部性；</strong></p>
<p>B. 程序执行的顺序性；</p>
<p>C. 程序执行的离散性；</p>
<p>D. 程序执行的并发性；</p>
</blockquote>
</li>
<li><p>把逻辑地址转变为内存的物理地址的过程称作__<strong>重定位或地址映射</strong>__。</p>
</li>
<li><p>页面替换算法_____有可能会产生Belady异常现象。</p>
<blockquote>
<p><strong>A. FIFO；</strong></p>
<p>B. OPT；</p>
<p>C. Clock；</p>
<p>D. LRU；</p>
</blockquote>
</li>
<li><p><strong>Belady异常</strong>是指在分页式虚拟存储器管理中，当使用某些页面置换算法（如FIFO）时，增加分配给进程的页面帧数反而导致页面错误（缺页）次数增加的异常现象。就是可能马上就要访问的页面被淘汰了。</p>
</li>
<li><blockquote>
<p>FAT12 文件系统里，FAT 表的数量和每张 FAT 表占用的扇区数量为______A___。</p>
<p>A. 2, 9 B. 2, 10 C. 3, 9 D. 3, 10</p>
<ul>
<li>没印象，硬记吧</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>静态重定位的时机是__D__。</p>
<ul>
<li>A.程序运行时；</li>
<li>B.程序链接时；</li>
<li>C.程序编译时；</li>
<li>D.程序装入时；</li>
<li>重定位可以理解为地址映射，也就是把逻辑地址转换为物理地址。当程序装入内存的时候就要做转换了</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>通常所说的”存储保护”的基本含义是__防止程序间相互越界访问__。</p>
<p>‏</p>
</blockquote>
</li>
<li><blockquote>
<p>LRU置换算法所基于的思想是__A__。</p>
<ul>
<li>A.在最近的过去很久未使用的在最近的将来也不会使用；</li>
<li>B在最近的过去用得少的在最近的将来也用得少；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>作业在执行中发生了缺页中断，经操作系统处理后，应该让其执行____A___指令。</p>
<ul>
<li>A.被中断的；</li>
<li>B.被中断的前一条；</li>
<li>C.被中断的后一条；</li>
<li>D.启动时的第一条；</li>
<li>被中断的指令还没做完，要重新做一遍。比如说有两条指令A和B，A执行的过程中发现了缺页中断，那么处理完以后执行指令A</li>
</ul>
</blockquote>
</li>
<li><p>段式存储是<strong>不定长不连续的</strong></p>
</li>
</ol>
<h2 id="第四章-·-设备管理-1"><a href="#第四章-·-设备管理-1" class="headerlink" title="第四章 · 设备管理"></a>第四章 · 设备管理</h2><ol>
<li><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png" alt="img"></p>
</li>
<li><p>死锁：</p>
<ol>
<li>就是循环等待</li>
<li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。。</li>
</ol>
</li>
<li><p>通道：通道是一种专门用于处理I&#x2F;O操作的硬件设备，它可以通过通道程序和通道指令独立于CPU运行，控制I&#x2F;O设备与内存之间的数据传输</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110727554.png" alt="image-20250421110727554"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110741521.png" alt="image-20250421110741521"></p>
<blockquote>
<p>注意，J1退出的时间是11:50，是其所需要的时间的两倍。因为用的时间片调度算法，有两个进程。</p>
</blockquote>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421111351369.png" alt="image-20250421111351369"></p>
</li>
<li><p>过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为__<strong>虚拟设备</strong>__。😥</p>
</li>
<li><p>通道又称I&#x2F;O处理机，它用于实现__<strong>内存与外设</strong>__之间的信息传输。</p>
</li>
<li><p>大多数低速设备都属于____设备。</p>
<blockquote>
<p>A. 虚拟；</p>
<p>B. SPOOLing；</p>
<p>C. 共享；</p>
<p><strong>D. 独享；</strong></p>
</blockquote>
</li>
<li><p>在操作系统中，用户程序申请使用I&#x2F;O设备时，通常采用____。😥😇</p>
<blockquote>
<p>A. 独占设备名；</p>
<p>B. 虚拟设备名；</p>
<p>C. 物理设备名；</p>
<p><strong>D. 逻辑设备名；</strong></p>
<ul>
<li>注：逻辑设备名：逻辑设备名是用户程序在请求I&#x2F;O操作时使用的设备名称，它是用户程序与实际物理设备之间的一个抽象层。</li>
</ul>
</blockquote>
</li>
<li><p>使用SPOOLing系统的目的是为了提高______的使用效率。</p>
<blockquote>
<p>A. CPU；</p>
<p><strong>B. I&#x2F;O设备；</strong></p>
<p>C. 操作系统；</p>
<p>D. 内存；</p>
</blockquote>
</li>
<li><p>工作集模型和工作集置换算法(WS)！！</p>
</li>
<li><p>SPOOLing的实质是<strong>让独享型设备变为共享设备</strong></p>
</li>
<li><blockquote>
<p>在操作系统中，__D__指的是一种硬件机制。</p>
<p>‌</p>
<ul>
<li>A.内存覆盖技术；</li>
<li>B.SPOOLing技术；</li>
<li>C.缓冲池；</li>
<li>D.通道技术；</li>
<li>硬记，ABC是软件机制，D是硬件机制</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‏__C__算法是设备分配常用的一种算法。</p>
<p>‍</p>
<ul>
<li>A.首次适应；</li>
<li>B.短作业优先；</li>
<li>C.先来先服务；</li>
<li>D.最佳适应；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>采用假脱机技术，将磁盘的一部分作为公共缓冲区以代替打印机，用户对打印机的操作实际上是对磁盘的存储操作，用以代替打印机的部分是__C__。</p>
<ul>
<li>A.独占设备；</li>
<li>B.一般物理设备；</li>
<li>C.虚拟设备；</li>
<li>D.共享设备；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>使用SPOOLing系统的目的是为了提高___D___的使用效率。</p>
<p>‎</p>
<p>得分&#x2F;总分</p>
<ul>
<li>A.操作系统；</li>
<li>B.CPU；</li>
<li>C.内存；</li>
<li><strong>D.I&#x2F;O设备；</strong></li>
</ul>
</blockquote>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250610173842189.png" alt="image-20250610173842189"></p>
</li>
</ol>
<h2 id="第五章-·-文件管理-1"><a href="#第五章-·-文件管理-1" class="headerlink" title="第五章 · 文件管理"></a>第五章 · 文件管理</h2><ol>
<li><p>逻辑结构的文件：</p>
<ol start="2">
<li>流式文件</li>
<li>记录式文件</li>
</ol>
</li>
<li><p>物理结构的文件：</p>
<ol>
<li>顺序文件</li>
<li>直接文件（散列文件）</li>
<li>连接文件（串联文件）</li>
<li>索引文件</li>
</ol>
</li>
<li><p>文件系统的主要目的是____。</p>
<blockquote>
<p>A. 提高外存的读写速度；</p>
<p>B. 用于存储系统文件；</p>
<p>C. 实现虚拟存储；</p>
<p><strong>D. 实现对文件的按名存取；</strong></p>
</blockquote>
</li>
<li><p>文件系统采用多级目录结构后，对于不同用户的文件，其文件名____。</p>
<blockquote>
<p>A. 受系统约束；</p>
<p>B. 应该不同；</p>
<p><strong>C. 可以相同也可以不同；</strong></p>
<p>D. 应该相同；</p>
</blockquote>
</li>
<li><p>为了解决不同用户文件的“命名冲突”问题，通常在文件系统中采用____。</p>
<blockquote>
<p>A. 索引；</p>
<p><strong>B. 多级目录；</strong></p>
<p>C. 路径；</p>
<p>D. 约定的方法；</p>
</blockquote>
</li>
<li><p>文件系统的主要目的是__<strong>实现对文件的按名存取</strong>__。</p>
</li>
<li><p>文件目录的主要作用是____<strong>按名存取</strong>____。</p>
</li>
<li><p>在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中，______具有直接读写文件任意一个记录的能力，又提高了文件存储空间的利用率。</p>
<blockquote>
<p>A. 链接结构；</p>
<p><strong>B. 索引结构；</strong></p>
<p>C. Hash结构；</p>
<p>D. 顺序结构；</p>
<ul>
<li>注：</li>
<li>散列文件：不适合直接读写文件的任意记录</li>
<li>链接文件：不支持直接访问文件的任意记录</li>
<li>顺序文件：不支持高效的随机访问</li>
</ul>
</blockquote>
</li>
<li><p>存放在磁盘上的文件__<strong>既可随机访问，又可顺序访问</strong>__。😥</p>
</li>
<li><p>Unix文件系统中，打开文件的系统调用open返回值是____<strong>文件描述符（字）</strong>____。</p>
</li>
<li><p>文件的动态共享！！！</p>
</li>
<li><p>打开文件的系统调用open接收的参数是<strong>文件名</strong>，返回值是<strong>文件描述符</strong></p>
</li>
<li><blockquote>
<p>文件系统用__B__组织文件。</p>
<ul>
<li>A.堆栈；</li>
<li><strong>B.目录；</strong></li>
<li>C.指针；</li>
<li>D.路径；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>在inode中的i_count是什么含义？</p>
<p><strong>A.不同进程在同一系统下共享的文件数</strong></p>
<p>B.不同进程在不同系统下共享的文件数</p>
<p>C.相同进程在同一系统下共享的文件数</p>
<p>D.不同进程在不同系统下共享的文件数</p>
<ul>
<li><code>i_count</code> 是 Linux&#x2F;UNIX 内核中 内存中的 inode（也称为 in-core inode） 的一个字段，用于记录： <strong>有多少个进程正在使用这个 inode</strong>（即该文件当前被打开了多少次）.它通常作为 引用计数（reference count），防止 inode 被释放（如释放内存）时仍有进程在使用它。</li>
</ul>
</blockquote>
</li>
<li><p>文件系统磁盘结构：<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png" alt="img"></p>
<ol>
<li>用户打开文件表：进程的PCB结构中保留一个files_struct，称为用户打开文件表或文件描述符表<ol>
<li>表项的序号为文件描述符fd</li>
<li>该登记项内<strong>登记系统打开文件表的一个入口指针fp</strong></li>
<li>通过此系统打开文件表项<strong>连接到打开文件的活动inode</strong>。</li>
</ol>
</li>
<li>系统打开文件表：是为解决多用户进程共享文件、父子进程共享文件而设置的系统数据结构file_struct<ol>
<li>一个文件可能被多个进程同时打开或打开多次，导致位移量不同。</li>
<li>每次打开就是一个file，多次打开就是多个file。</li>
<li>一个inode可以连接0个或多个file，多个file对应一个inode。</li>
<li>内核内存区开辟最多存放256项的系统打开表区。</li>
</ol>
</li>
<li><strong>主存活动inode表</strong>：为解决频繁访问磁盘索引节点inode表的效率问题，系统开辟的主存区，正在使用的文件的inode被调入主活动索引节点inode中，以加快文件访问速度。</li>
</ol>
</li>
<li><p>目录项：包含inode号和文件名<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/11.png" alt="img"></p>
</li>
<li><p>文件操作：</p>
<ol>
<li><p>创建文件（create）过程：</p>
<ol>
<li>例如create(“path”, 0775)<ol>
<li>为新文件newfile分配磁盘inode和活动inode，并把inode编号与文件分量名newfile组成新目录项，记到目录中，这个过程中执行目录检索程序。</li>
<li>在新文件所对应的活动inode中置初值，如置存取权限i_mode&#x3D;0775，连接计数i_nlink&#x3D;1等。</li>
<li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，为后者置初值，包括特征位为写，读写位移f_offset清0。</li>
<li>把各表项及文件对应的活动inode用指针连接起来</li>
<li>把文件描述字fd返回给调用者。</li>
</ol>
</li>
</ol>
</li>
<li><p>删除过程：</p>
<ol>
<li>删除把指定文件从所在的<strong>目录文件</strong>中除去。</li>
<li>如果没有连接用户(i_link为1)，还要<strong>把文件占用的存储空间释放</strong>。删除系统调用形式为：<code>unlink(filenamep)</code>。</li>
<li>在执行删除时，必须要求用户对该文件具有”<strong>写</strong>“操作权。</li>
</ol>
</li>
<li><p>打开过程：</p>
<ol>
<li>文件使用前需要打开，以建立进程与文件之间的联系，而文件描述符唯一标识了这种连接，其任务是<strong>把文件的磁盘inode复制到内存活动inode</strong>中去，同时建立一个独立的读写文件数据结构，即系统打开文件表的一个表项。</li>
<li>打开过程：<ol>
<li>检索目录<ol>
<li>如果没有则会出错</li>
<li>检索到指定文件后，把它的磁盘inode复制到活动inode表中。</li>
<li>如果inode号<strong>已经</strong>在活动表项中则直接执行下一步。</li>
</ol>
</li>
<li>根据参数mode核对权限(与创建时的mode)<ol>
<li>如果非法，则这次打开失败。</li>
<li>当”打开”合法时，为文件分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，并为后者赋初值。通过指针建立这些表项与活动inode间的联系。把文件描述字，即用户打开文件表中相应文件表项的序号返回给调用者。</li>
</ol>
</li>
</ol>
</li>
<li>输入是含路径的文件名 →→ 依据层次式目录结构解释与检索 →→ 匹配文件名并读取目录项 →→ 提取inode号 →→ 按号定位，在inode区读取inode数据结构(主存活动inode)</li>
<li>系统实现上必须有inode号，但是对文件名而言是透明的。</li>
</ol>
</li>
<li><p>关闭过程：</p>
<ol>
<li>关闭文件时需要释放掉inode来保证空间。</li>
<li>关闭过程<ol>
<li>根据fd找到用户打开文件表项，再找到系统打开文件表项。释放<strong>用户打开文件表项</strong>。</li>
<li>把对应<strong>系统打开文件表项</strong>中的f_count减1，如果非0，说明还有进程共享这一表项，不用释放直接返回；否则释放表项。</li>
<li>把活动索引节点中的i_count减1（前提是系统打开文件表项被释放），若不为0，表明还有用户进程正在使用该文件，不用释放而直接返回，否则在<strong>把该活动索引节点中的内容复制回文件卷上的相应索引节点中</strong>后，<strong>释放</strong>该活动索引节点。</li>
</ol>
</li>
<li>f_count和i_count分别反映进程动态地共享一个文件的两种方式<ol>
<li>f_count反映<strong>不同进程</strong>通过<strong>同一个</strong>系统打开文件表项共享一个文件的情况；</li>
<li>i_count反映<strong>不同进程</strong>通过<strong>不同</strong>系统打开文件表项共享一个文件的情况。</li>
</ol>
</li>
<li>通过两种方式，进程之间既可用相同的位移指针f_offset，也可用不同位移指针f_offset共享同一个文件。</li>
</ol>
</li>
</ol>
</li>
<li><p>虚拟文件系统（VFS，Virtual File System）是现代操作系统中用于管理文件系统的一个抽象层。VFS通常分为三个层次：实现层、虚拟层和应用层。</p>
</li>
<li></li>
</ol>
<h2 id="第六章-·-并发程序设计-1"><a href="#第六章-·-并发程序设计-1" class="headerlink" title="第六章 · 并发程序设计"></a>第六章 · 并发程序设计</h2><ol>
<li><p>注意，写管程或者PV操作的时候，如果说到“有两个进程”，就要有两个process，例如：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526153852861.png" alt="image-20250526153852861"></p>
</li>
<li><blockquote>
<p>在操作系统中，临界区指___D____ </p>
<p>。</p>
<p>A．一个缓冲区 </p>
<p>B.一个数据区 </p>
<p>C.同步机构 </p>
<p>D.一段程序</p>
</blockquote>
</li>
<li><p><strong>死锁的检测和解除</strong></p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" rel="prev" title="数据管理基础">
                  <i class="fa fa-angle-left"></i> 数据管理基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/" rel="next" title="计算机组成结构">
                  计算机组成结构 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
