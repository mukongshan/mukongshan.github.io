<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"98f8cddec87decff88b20807b414767528f9bec3","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="kongshan&#39;s blog">
<meta property="og:url" content="https://kongshan.me/blog/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kongshan.me/blog/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"blog/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">kongshan's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/10/03/poem/%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span><a href="/2024/10/03/poem/%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0/" class="post-title-link" itemprop="url">登泰山记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 01:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T01:00:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 18:27:26" itemprop="dateModified" datetime="2025-12-03T18:27:26+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/poem/" itemprop="url" rel="index"><span itemprop="name">诗文</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="登泰山记"><a href="#登泰山记" class="headerlink" title="登泰山记"></a>登泰山记</h1><h3 id="写于公历二零二四年十月三日"><a href="#写于公历二零二四年十月三日" class="headerlink" title="写于公历二零二四年十月三日"></a>写于公历二零二四年十月三日</h3><p>去红门约莫百米，可窥泰山之峻。实乃拔地通天，造化神功，绝云擎日，横断南北，有如石屏缀之以青柏，刀峰砺之以白岩。及穿红门，入山口，侧柏林立，以至幽寒。左右皆有碑，多为明清民国文人所记。</p>
<p>前行约半时，过斗母宫及三官庙，有歧路至经石峪。一心登山者众而闲心赏景者寡。余取小道，过石桥，沸腾声远而清流音近。此径侧柏郁郁，幽邃寂寥，凄神寒骨。有石亭侧立，曰高山流水亭，盖文人常饮于此，举酒斗文，抚琴尽兴，而今不得也。至经石峪，豁然开朗。裸石居中，其上有文，想是千古奇篇，只惜山溪漱石，千风摩崖，而今已不可明鉴。环石有阶，可观四周名迹，皆彼时达官之笔，虽不细看亦饶有风趣。此宝地也，然四下无人，其距三官庙不过百米，不得见者实然可惜。</p>
<p>循路登山，约二时可至中天门。见主峰巍然，真所谓巇山锁玉顶，峦岳镇天关。岱宗压顶，心寒者不可视；王山遗威，胆怯者不可行。登十八盘，乱石嶙峋，枯木倒挂，路窄而崎岖，阶陡而不平。加之时值正午，金阳高照，以至余疲于登山，心绪杂陈。再约二时，可至山顶。</p>
<p>余尝闻不登高山不知天之高，实不然。今登泰山，方知天非不可及也。亲临穹顶，似有玉音漻漻，撼心涤尘，超凡脱俗。足下千峰攒聚，万壑凌历，险阻化平丘，大石作砂砾；决眦远眺，见巉石峦岳千转穀，万川湍流吞穹庐；至于颅顶，乃有星宫亹亹，天河毖流，紫薇环照，金乌射影。登临此地，吸则有高天灵气，呼则有浩然清风。真洋洋得意也，志盖五岳，气涤九江，快哉，快哉！</p>
<p>此美景赏心，不可骤得，快意平生有此观，故余作文以记之。</p>
<p>至中天门时，见主峰庄严，不禁感叹。心中灵动，偶得一诗。即兴之作，虽音律欠佳，不赞改。诗曰：</p>
<p>青柏画石屏，白岩镇天关。<br>四岳三俯首，两江一东流。<br>天子受命处，我今亦登临。<br>王山遗威在，浩气荡乾坤。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/C++%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/C++%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:40:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:40:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="第一章（C1、C2）-·-介绍"><a href="#第一章（C1、C2）-·-介绍" class="headerlink" title="第一章（C1、C2） · 介绍"></a>第一章（C1、C2） · 介绍</h2><h3 id="主流编程范式对比"><a href="#主流编程范式对比" class="headerlink" title="主流编程范式对比"></a>主流编程范式对比</h3><ol>
<li>面向对象编程（OOP）<ul>
<li>起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言</li>
<li>核心概念：类&#x2F;对象、继承、多态、垃圾回收</li>
<li>设计哲学：自底向上程序设计，虚拟过程机制</li>
</ul>
</li>
<li>函数式编程（FP）<ul>
<li>理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑</li>
<li>核心特性：数据不可变性、无副作用、函数一等公民引用透明性：相同输入始终产生相同输出</li>
<li>应用场景：实时游戏状态管理、高频交易系统</li>
<li>局限：学习曲线陡峭，调试复杂，不适合状态密集型场景</li>
</ul>
</li>
<li>逻辑编程<ul>
<li>代表语言：Prolog</li>
<li>特点：基于公理、推理规则和查询的自动证明</li>
<li>经典案例：专家系统诊断、鸡兔同笼问题、斑马逻辑谜题</li>
</ul>
</li>
<li>并发编程与泛型编程</li>
</ol>
<ul>
<li>并发编程：程序分解为可独立运行部分的能力</li>
<li>泛型编程：通过抽象找到算法实现的共性，提高代码复用性</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/C++%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java与JVM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:30:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:30:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java生命周期"><a href="#Java生命周期" class="headerlink" title="Java生命周期"></a>Java生命周期</h2><ol>
<li>编码阶段（Writing Code）</li>
</ol>
<ul>
<li><strong>开发者编写源代码</strong>，文件后缀为 <code>.java</code>。<br>比如：<code>HelloWorld.java</code>。</li>
<li>源代码中包含类（<code>class</code>）、方法（<code>method</code>）等，使用 <strong>Java 语法</strong>。</li>
</ul>
<hr>
<ol start="2">
<li>编译阶段（Compiling）</li>
</ol>
<ul>
<li><p>使用 <strong>Java 编译器 <code>javac</code></strong> 将 <code>.java</code> 文件编译成 <strong>字节码文件</strong>（<code>.class</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>

</li>
<li><p>编译后生成 <code>HelloWorld.class</code> 文件。</p>
</li>
<li><p>注意：字节码不是机器码，而是一种中间形式，跨平台。</p>
</li>
</ul>
<hr>
<ol start="3">
<li>类加载阶段（Class Loading）</li>
</ol>
<ul>
<li>当运行程序时（<code>java HelloWorld</code>），<strong>类加载器（ClassLoader）</strong> 会把需要的 <code>.class</code> 文件加载进内存。</li>
<li>类加载过程分为三个小步骤：<ol>
<li><strong>加载（Loading）</strong>：把字节码读到内存。</li>
<li><strong>连接（Linking）</strong>：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。</li>
<li><strong>初始化（Initialization）</strong>：执行静态代码块、给静态变量赋初值。</li>
</ol>
</li>
</ul>
<hr>
<ol start="4">
<li>字节码执行阶段（Execution）</li>
</ol>
<ul>
<li><p><strong>Java 虚拟机（JVM）解释执行字节码</strong>，也可能使用 <strong>JIT（即时编译器）</strong> 把热点代码编译成本地机器码，以提高运行效率。</p>
</li>
<li><p>执行的起点是程序入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="5">
<li>程序运行时（Runtime）</li>
</ol>
<ul>
<li>JVM 在运行时会：<ul>
<li><strong>内存管理</strong>：使用 <strong>堆、栈、方法区、运行时常量池</strong> 等。</li>
<li><strong>垃圾回收（GC）</strong>：回收不再使用的对象内存。</li>
<li><strong>异常处理</strong>：执行过程中出现异常时，JVM 按照异常机制处理。</li>
</ul>
</li>
</ul>
<hr>
<ol start="6">
<li>程序终止（Termination）</li>
</ol>
<ul>
<li>当 <code>main</code> 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。</li>
<li>在退出前，可能会执行 <code>finally</code> 块、<code>shutdown hook</code>（关闭钩子）。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="机器学习四大问题"><a href="#机器学习四大问题" class="headerlink" title="机器学习四大问题"></a>机器学习四大问题</h1><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul>
<li><strong>定义</strong>：一种 <strong>无监督学习方法</strong>，目标是把样本自动划分为若干组（簇），同一簇内的样本相似度高，不同簇间的相似度低。</li>
<li><strong>常见算法</strong><ul>
<li><strong>K-means</strong>：基于中心点迭代优化，快速但对初始值和簇数敏感。</li>
<li><strong>层次聚类</strong>（Hierarchical Clustering）：逐层合并或拆分，得到树状聚类结构。</li>
<li><strong>DBSCAN</strong>：基于密度，能发现任意形状的簇，并识别噪声。</li>
<li><strong>高斯混合模型 (GMM)</strong>：用概率分布来建模簇。</li>
</ul>
</li>
<li><strong>应用</strong>：用户分群、市场细分、异常检测、推荐系统。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">Java八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><h3 id="Java中有哪些创建线程的方式？"><a href="#Java中有哪些创建线程的方式？" class="headerlink" title="Java中有哪些创建线程的方式？"></a>Java中有哪些创建线程的方式？</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1️⃣ 继承 <code>Thread</code>类</strong></td>
<td align="left">自定义类继承 <code>Thread</code>，并重写 <code>run()</code>方法，然后调用 <code>start()</code>启动线程</td>
<td align="left">实现简单，直观易懂</td>
<td align="left">Java 是单继承，继承了 <code>Thread</code>后不能再继承其他类；耦合性高，不够灵活</td>
<td align="left">适用于简单的示例代码、初学者理解线程基本概念</td>
</tr>
<tr>
<td align="left"><strong>2️⃣ 实现 <code>Runnable</code>接口</strong></td>
<td align="left">自定义类实现 <code>Runnable</code>接口，实现 <code>run()</code>方法，将实例作为参数传给 <code>Thread</code>对象，再调用 <code>start()</code></td>
<td align="left">实现接口，不占用继承名额，更灵活；适合多个线程共享同一个 Runnable 实例；面向接口编程</td>
<td align="left">依然需要显式创建 Thread 对象，不能直接获取返回值</td>
<td align="left">适用于大多数异步任务、线程任务无返回值的场景，是主流推荐方式之一</td>
</tr>
<tr>
<td align="left"><strong>3️⃣ 实现 <code>Callable&lt;V&gt;</code>接口 + 线程池&#x2F;Future</strong></td>
<td align="left">实现 <code>Callable&lt;V&gt;</code>接口，重写 <code>call()</code>方法（有返回值，可抛异常），通过 <code>ExecutorService.submit(Callable)</code>提交，返回 <code>Future&lt;V&gt;</code>对象获取结果</td>
<td align="left">可以<strong>返回执行结果</strong>，支持抛出异常，功能更强大</td>
<td align="left">使用稍复杂，需要依赖线程池和 Future 机制</td>
<td align="left">适用于需要获取线程执行结果、处理异常、并发计算等复杂任务</td>
</tr>
<tr>
<td align="left"><strong>4️⃣ 使用线程池（Executor 框架）</strong></td>
<td align="left">通过 <code>Executors</code>或 <code>ThreadPoolExecutor</code>创建线程池，提交 <code>Runnable</code>或 <code>Callable</code>任务，由线程池管理线程的创建与调度</td>
<td align="left">线程复用，避免频繁创建&#x2F;销毁线程的开销；统一管理线程生命周期；提高性能与资源利用率</td>
<td align="left">需要对线程池有一定了解，使用不当可能引发资源耗尽等问题</td>
<td align="left">生产环境、高并发、需要高效管理线程的场景，是业界最佳实践</td>
</tr>
</tbody></table>
<ol>
<li><p>继承 <code>Thread</code>类</p>
<ol>
<li><p>继承Thread类并重写run方法</p>
</li>
<li><pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println(&quot;线程运行中（继承Thread类）：&quot; + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程，调用run()
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 实现 `Runnable`接口</span><br><span class="line"></span><br><span class="line">   1. 重写（实现）run方法</span><br><span class="line"></span><br><span class="line">   2. ```java</span><br><span class="line">      class MyRunnable implements Runnable &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              System.out.println(&quot;线程运行中（实现Runnable接口）：&quot; + Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              Thread thread = new Thread(new MyRunnable());</span><br><span class="line">              thread.start();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>基于runnable的lambda表达式</p>
<ol>
<li><pre><code class="language-java">new Thread(() -&gt; {
    System.out.println(&quot;线程运行中（Lambda表达式）：&quot; + Thread.currentThread().getName());
}).start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">3. 实现 `Callable&lt;V&gt;`接口 + `FutureTask`</span><br><span class="line"></span><br><span class="line">   1. 类似 Runnable，但可以**有返回值**，能抛异常</span><br><span class="line"></span><br><span class="line">   2. ```JAVA</span><br><span class="line">      import java.util.concurrent.*;</span><br><span class="line">      </span><br><span class="line">      class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public String call() throws Exception &#123;</span><br><span class="line">              return &quot;线程返回值（实现Callable接口）：&quot; + Thread.currentThread().getName();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) throws Exception &#123;</span><br><span class="line">              // 创建线程池</span><br><span class="line">              ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">      </span><br><span class="line">              // 提交 Callable 任务，返回 Future</span><br><span class="line">              Future&lt;String&gt; future = executor.submit(new MyCallable());</span><br><span class="line">      </span><br><span class="line">              // 获取返回值（会阻塞直到任务完成）</span><br><span class="line">              String result = future.get();</span><br><span class="line">              System.out.println(result);</span><br><span class="line">      </span><br><span class="line">              // 关闭线程池</span><br><span class="line">              executor.shutdown();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用线程池（Executor 框架）</p>
<ol>
<li><p>通过线程池（如 <code>Executors</code>）管理线程的创建和执行</p>
</li>
<li><pre><code class="language-java">import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建 ThreadPoolExecutor
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,                      // 核心线程数（corePoolSize）
            4,                      // 最大线程数（maximumPoolSize）
            60,                     // 空闲线程存活时间
            TimeUnit.SECONDS,       // 时间单位
            new LinkedBlockingQueue&lt;&gt;(2),  // 任务队列（容量为2）
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：直接抛出异常
        );

        // 提交 8 个任务，观察线程池行为
        for (int i = 1; i &lt;= 8; i++) {
            final int taskId = i;
            executor.execute(() -&gt; {
                System.out.println(&quot;正在执行任务 &quot; + taskId + &quot;，线程：&quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // 模拟任务执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;任务 &quot; + taskId + &quot; 执行完毕&quot;);
            });
        }

        // 关闭线程池（不再接受新任务，等待已提交任务完成）
        executor.shutdown();
        System.out.println(&quot;所有任务已提交，线程池准备关闭...&quot;);
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">### 为什么不建议使用Excutors创建线程池？</span><br><span class="line"></span><br><span class="line">1. `Executors`是 Java 并发包 `java.util.concurrent`中的一个**工具类**，提供了几个静态工厂方法，用于**快速创建常见类型的线程池**。</span><br><span class="line">2. 不建议直接使用 `Executors`工具类提供的快捷方法（如 `newFixedThreadPool`、`newCachedThreadPool`等）来创建线程池，是因为这些方法在某些场景下可能导致资源耗尽、线程爆炸、任务堆积、内存溢出（OOM）等严重问题，存在潜在风险。</span><br><span class="line">   1. 原因：</span><br><span class="line">      1. 底层其实都是调用了 `ThreadPoolExecutor`或 `ScheduledThreadPoolExecutor`，但是对参数进行了**封装和默认设置**</span><br><span class="line">      2. 使用的是**无界队列** `LinkedBlockingQueue`，队列容量为 Integer.MAX_VALUE（约 2^31-1，非常大）</span><br><span class="line">      3. 如果任务提交速度 &gt; 线程处理速度，任务会不断堆积在队列中</span><br><span class="line">      4. 最终可能导致 **内存耗尽（OOM，OutOfMemoryError）**，因为任务对象、数据不断累积，队列无限增长</span><br><span class="line">3. 推荐使用 `ThreadPoolExecutor`手动构造线程池，以精确控制线程池行为，提高稳定性和可控性。</span><br><span class="line"></span><br><span class="line">### 线程池有哪几种状态？</span><br><span class="line"></span><br><span class="line">5种。</span><br><span class="line"></span><br><span class="line">| 状态名         | 值（高 3 位）                          | 含义                     | 说明                                                         |</span><br><span class="line">| :------------- | :------------------------------------- | :----------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **RUNNING**    | 111 （二进制） 即 -536870912（十进制） | **运行中**               | **接受新任务，并处理队列中的任务**                           |</span><br><span class="line">| **SHUTDOWN**   | 000 （二进制） 即 0（十进制）          | **关闭（不接受新任务）** | **不再接受新任务，但会继续处理队列中的任务**                 |</span><br><span class="line">| **STOP**       | 001 （二进制） 即 1（十进制）          | **停止**                 | **不再接受新任务，也不处理队列中的任务，并中断正在执行的任务** |</span><br><span class="line">| **TIDYING**    | 010 （二进制） 即 2（十进制）          | **整理中**               | **所有任务都已终止，workerCount = 0，线程池即将执行 terminated() 钩子方法** |</span><br><span class="line">| **TERMINATED** | 011 （二进制） 即 3（十进制）          | **已终止**               | **terminated() 方法已经执行完毕，线程池完全停止**            |</span><br><span class="line"></span><br><span class="line">### ThreadLocal</span><br><span class="line"></span><br><span class="line">详见笔记《ThreadLocal》</span><br><span class="line"></span><br><span class="line">### Tomcat为什么要用自定义类加载器？</span><br><span class="line"></span><br><span class="line">1. 在Tomcat中可能存在同名类。为了避免冲突和隔离资源，应该使用自定义类加载器。</span><br><span class="line"></span><br><span class="line">2. **Tomcat 是一个 Servlet 容器**，它负责运行多个独立的 Web 应用。每个 Web 应用可能有自己依赖的库，甚至可能用到相同库的不同版本。为了实现：</span><br><span class="line"></span><br><span class="line">   - **应用间类隔离**</span><br><span class="line">   - **核心库与用户库的区分加载**</span><br><span class="line">   - **支持热部署和灵活管理**</span><br><span class="line"></span><br><span class="line">   Tomcat **不得不打破双亲委派模型**。</span><br><span class="line"></span><br><span class="line">3. Tomcat 的类加载器架构（简化版）</span><br><span class="line"></span><br><span class="line">   1. Tomcat 设计了多种类加载器，典型的类加载器层次结构如下（从上到下）：</span><br><span class="line">      1. Bootstrap ClassLoader（JVM 提供，加载核心 Java 类，如 `java.*`）</span><br><span class="line">      2. Extension ClassLoader（加载扩展库，如 `javax.*`或 `$JAVA_HOME/lib/ext`下的类）</span><br><span class="line">      3. Application ClassLoader（即系统类加载器，加载 `classpath`下的类，通常是你的工程依赖）</span><br><span class="line">      4. **Common ClassLoader**（Tomcat 提供，加载 `CATALINA_HOME/lib`下的类，如 `servlet-api.jar`，这些是所有 Web 应用共享的）</span><br><span class="line">      5. **Webapp ClassLoader**（每个 Web 应用独有，加载该应用 `WEB-INF/classes`和 `WEB-INF/lib`下的类）</span><br><span class="line"></span><br><span class="line">4. Tomcat 如何打破双亲委派？</span><br><span class="line"></span><br><span class="line">   1. 关键点在于 **WebappClassLoader（Web 应用类加载器）** 的加载行为</span><br><span class="line"></span><br><span class="line">      1. 默认情况下（即标准双亲委派）：</span><br><span class="line"></span><br><span class="line">      - 当加载一个类时，类加载器会先委派给父加载器去加载，只有在父加载器找不到时，自己才尝试加载。</span><br><span class="line"></span><br><span class="line">   2. 但 Tomcat 的 WebappClassLoader **刻意颠倒了这一逻辑（部分打破双亲委派）**：对于 **Web 应用私有的类（如 WEB-INF 下的类）**，**WebappClassLoader 会优先尝试自己加载，而不是先委派给父加载器！*</span><br><span class="line"></span><br><span class="line">      1. 换句话说：</span><br><span class="line"></span><br><span class="line">      - 当 Web 应用需要加载一个类时，Tomcat 的 WebappClassLoader 会首先从当前应用的 `WEB-INF/classes`和 `WEB-INF/lib`中查找并加载类；</span><br><span class="line"></span><br><span class="line">      - 只有当找不到时，才会委派给父类加载器（如 CommonClassLoader 或更上层）去加载；</span><br><span class="line"></span><br><span class="line">5. 意义：</span><br><span class="line"></span><br><span class="line">   1. 不同 Web 应用可以拥有相同类库的不同版本，因为它们各自用自己的 WebappClassLoader 加载，互不干扰；</span><br><span class="line">   2. 核心类（如 Servlet API）仍然由 CommonClassLoader 或更上层加载，保证一致性；</span><br><span class="line">   3. **实现了类隔离与应用独立性**；</span><br><span class="line"></span><br><span class="line">6. 但 Tomcat 并没有完全抛弃双亲委派！</span><br><span class="line"></span><br><span class="line">   1. 对于一些 关键的、应该由全局统一管理的类（如 Servlet API、JSP 相关类等），Tomcat 仍然希望它们由公共的类加载器（如 CommonClassLoader）加载，而不是由每个 Web 应用自己的加载器加载，以避免混乱和冲突。</span><br><span class="line">   2. 因此，Tomcat 在实现 WebappClassLoader 时，对于 一些指定的包名（如 `javax.\*`, `org.apache.tomcat.\*`, `java.\*`等），仍然会优先走双亲委派，确保这些类由上层加载器加载，而不是由 Web 应用私自提供。</span><br><span class="line"></span><br><span class="line">### hashCode（）和 equals（）的联系</span><br><span class="line"></span><br><span class="line">1. 如果两个对象通过 `equals()`方法比较是相等的，那么它们的 `hashCode()`**必须相同**！</span><br><span class="line">2. 如果两个对象的 `hashCode()`相同，它们 **不一定** `equals()`为 true！</span><br><span class="line">   1. 这被称为 **哈希碰撞（Hash Collision）**，即不同的对象可能计算出相同的哈希值。这是 **允许的，并且很常见**，好的 hashCode 方法应尽量减少碰撞，但不能完全避免。</span><br><span class="line">3. 一定要同时重写 hashCode() 和 equals()</span><br><span class="line"></span><br><span class="line">### String，StringBuffer，StringBuilder</span><br><span class="line"></span><br><span class="line">1. String是常量，不可变</span><br><span class="line">2. StringBuilder可变，线程不安全。</span><br><span class="line">3. StringBuffer可变，线程安全（有synchronized修饰）</span><br><span class="line"></span><br><span class="line">### &quot;==&quot;和equals()的区别</span><br><span class="line"></span><br><span class="line">1. ==：如果比较的是基础数据类型，则比较值；如果是引用类型，则比较引用地址</span><br><span class="line">2. equals（）有比较逻辑</span><br><span class="line"></span><br><span class="line">### 重载和重写的区别（细节）</span><br><span class="line"></span><br><span class="line">1. 重载：发生在同一个类中，**方法名必须相同，必须要求参数列表不同**，如类型、个数、顺序不同。与返回值类型、访问修饰符、抛出的异常等无关。发生在编译时。</span><br><span class="line">2. 重写：发生在父子类中，方法名、参数列表必须相同。返回值、抛出异常的范围不大于父类，访问修饰符范围不小于父类（所以父类的private方法不可重写）。发生在运行时。</span><br><span class="line"></span><br><span class="line">### List和Set的区别</span><br><span class="line"></span><br><span class="line">1. ## </span><br><span class="line"></span><br><span class="line">2. | 区别维度             | **List（列表）**                                             | **Set（集合）**                                              |</span><br><span class="line">   | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">   | **是否允许重复元素** | **允许重复**                                                 | **不允许重复**（如果试图添加已存在的元素，添加失败，返回 false） |</span><br><span class="line">   | **是否有序**         | **有序**（按照元素的插入顺序保存，遍历时按插入顺序输出）     | **默认无序**（不保证顺序，但某些实现如 `LinkedHashSet`和 `TreeSet`有特定顺序） |</span><br><span class="line">   | **访问方式**         | 允许下标访问和迭代器遍历。                                   | 不允许下表访问，可以用迭代器访问。                           |</span><br><span class="line">   | **底层常用实现类**   | `ArrayList`、`LinkedList`、`Vector`                          | `HashSet`、`LinkedHashSet`、`TreeSet`                        |</span><br><span class="line">   | **主要用途**         | 适合存储 **有序的、可能重复的数据列表**，比如用户列表、商品列表等 | 适合存储 **唯一值的集合**，比如标签、黑名单、不重复的用户 ID 等 |</span><br><span class="line">   | **接口继承自**       | `Collection`                                                 | `Collection`                                                 |</span><br><span class="line">   | **元素排序**         | 按插入顺序                                                   | 默认无序，但： • `TreeSet`：**自然排序 或 自定义排序** • `LinkedHashSet`：**按插入顺序** |</span><br><span class="line"></span><br><span class="line">### HashMap 是线程安全的吗？不是的话，多线程操作会导致什么问题？</span><br><span class="line"></span><br><span class="line">- （1.7 的死循环问题了解吗？1.8 数据覆盖问题了解吗？）</span><br><span class="line"></span><br><span class="line">1. **JDK 1.7 中 HashMap 的并发问题（经典死循环问题！）**</span><br><span class="line"></span><br><span class="line">   1. 问题背景：</span><br><span class="line"></span><br><span class="line">   在 JDK 1.7 的 HashMap 中，多线程并发执行 put 操作，并且触发了扩容（rehash），可能会导致链表形成环形结构（环形链表），进而导致后续 get() 操作时 CPU 100%、死循环！</span><br><span class="line"></span><br><span class="line">   2. 问题原因（核心）：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容机制是：创建新数组，然后对原数组每个桶上的 Entry 链表进行头插法迁移</span><br><span class="line"></span><br><span class="line">      - 头插法：新节点插入链表头部</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，多个线程同时对同一个链表进行头插，可能导致链表节点互相引用，形成环</span><br><span class="line"></span><br><span class="line">   3. 举例说明（简化版）：</span><br><span class="line"></span><br><span class="line">      1. 假设线程 A 和线程 B 同时触发扩容，都操作同一个链表：</span><br><span class="line"></span><br><span class="line">         - 原链表：A → B → C</span><br><span class="line"></span><br><span class="line">         - 线程 A 执行了一半，链表变成了 B → A</span><br><span class="line"></span><br><span class="line">         - 线程 B 也执行，可能把链表改成了 C → B → A → C → …（形成环）</span><br><span class="line"></span><br><span class="line">         - 当你后续调用 `get(key)`，遍历这个链表时，就会 陷入死循环，CPU 飙升！</span><br><span class="line"></span><br><span class="line">   4. 根本原因：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容是头插法 + 单线程逐个迁移 + 没有同步机制</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，链表可能倒置、成环，造成死循环</span><br><span class="line"></span><br><span class="line">   &gt; **这是 JDK 1.7 HashMap 最著名、最严重的并发 Bug 之一，在生产环境中出现过多次事故！**</span><br><span class="line"></span><br><span class="line">2. **JDK 1.8 中 HashMap 的并发问题**</span><br><span class="line"></span><br><span class="line">   1. JDK 1.8 对 HashMap 做了重大优化，包括：</span><br><span class="line"></span><br><span class="line">      1. 改用 尾插法（解决了 1.7 头插法导致的链表倒置与死循环问题）</span><br><span class="line">      2. 引入 红黑树（优化查询效率）</span><br><span class="line">      3. 优化了 hash 计算与扩容机制</span><br><span class="line"></span><br><span class="line">      - 但！**JDK 1.8 的 HashMap 仍然是线程不安全的！**</span><br><span class="line"></span><br><span class="line">   2. 在多线程环境下，JDK 1.8 的 HashMap 可能出现以下问题：</span><br><span class="line"></span><br><span class="line">      1. **数据覆盖（Lost Update）**</span><br><span class="line"></span><br><span class="line">         - 多个线程同时 put 同一个 key，后写入的线程可能覆盖先写入的线程的值</span><br><span class="line"></span><br><span class="line">         - 因为 put 操作没有加锁，没有原子性保证</span><br><span class="line"></span><br><span class="line">      2. **数据丢失**</span><br><span class="line">         - 多线程同时执行 put，某些线程的 put 可能因为并发问题没有成功写入</span><br><span class="line"></span><br><span class="line">      3. **扩容时的数据错乱**</span><br><span class="line"></span><br><span class="line">         - 虽然 1.8 改用 尾插法，不再容易形成环形链表，但多线程并发扩容时，仍然可能导致链表或树结构混乱，数据错乱或丢失</span><br><span class="line"></span><br><span class="line">         - 比如多个线程同时迁移数据，可能没有正确链接节点</span><br><span class="line"></span><br><span class="line">      4. **仍然是非原子操作**</span><br><span class="line">         - 比如 **putIfAbsent、computeIfAbsent** 等复合逻辑，在多线程下也可能有问题，除非使用 ConcurrentHashMap 提供的对应原子方法</span><br><span class="line"></span><br><span class="line">### hashMap的扩容机制</span><br><span class="line"></span><br><span class="line">详见下面的ConcurrentHashMap的扩容机制。只不过线程不安全且不能多线程扩容。</span><br><span class="line"></span><br><span class="line">### 谈谈ConcurrentHashMap的扩容机制</span><br><span class="line"></span><br><span class="line">1. 为什么要扩容</span><br><span class="line"></span><br><span class="line">   1. 和 `HashMap`一样，`ConcurrentHashMap`也是基于 **哈希表（数组 + 链表/红黑树）** 实现的。</span><br><span class="line"></span><br><span class="line">      随着不断向 `ConcurrentHashMap`中 添加元素（put），哈希冲突可能增多，当某个桶（bucket）中的元素越来越多时：</span><br><span class="line"></span><br><span class="line">      - 如果是链表形式，查询效率会从 O(1) 退化为 O(n)；</span><br><span class="line">      - 如果链表长度超过阈值（默认为 8），并且数组长度达到一定大小，链表会转为 红黑树（O(log n)）；</span><br><span class="line">      - 但即便有了红黑树，如果 整个哈希表中的数据量很大，而底层数组（table）容量较小，依然会导致 哈希冲突严重，性能下降。</span><br><span class="line"></span><br><span class="line">      👉 因此，为了保证查询、插入的高效性，当元素数量达到一定阈值时，ConcurrentHashMap 会进行扩容（resize），即扩大底层数组的大小，重新分配元素，降低哈希冲突。</span><br><span class="line"></span><br><span class="line">2. 以Java 8为主，讲解扩容机制</span><br><span class="line"></span><br><span class="line">   1. 扩容触发条件</span><br><span class="line"></span><br><span class="line">      1. 当 **元素的总数量（默认16）超过 负载因子（默认 0.75） × 当前容量（capacity）** 时，即：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
size &gt;= capacity * loadFactor（默认 0.75）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">      也就是说，当 哈希表中的元素数量“过密”时，就会触发扩容。</span><br><span class="line"></span><br><span class="line">      2. **链表长度超过阈值（8），但数组长度较小（&lt; 64）时，也可能先触发扩容而非树化**</span><br><span class="line">         1. 链表转红黑树之前，可能先触发扩容</span><br><span class="line"></span><br><span class="line">   2. 扩容目标</span><br><span class="line"></span><br><span class="line">      - 扩容就是将 原数组（table）的容量扩大为原来的 2 倍（即 newCapacity = oldCapacity &lt;&lt; 1）。</span><br><span class="line">      - 扩容过程中，需要将旧数组中的每个 桶（bucket）中的元素，重新计算在新数组中的位置，并迁移到新数组中。</span><br><span class="line"></span><br><span class="line">   3. 扩容的核心思想：**多线程协同扩容（协助迁移）**</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容机制中一个非常 **厉害且高效的设计** 👇：</span><br><span class="line"></span><br><span class="line">      &gt; **扩容不再由某一个线程全权负责，而是支持多个线程并发地协助进行数据迁移，大大提升了扩容效率，避免了单线程扩容成为瓶颈。**</span><br><span class="line"></span><br><span class="line">      - **table**：当前正在使用的哈希桶数组。</span><br><span class="line">      - **nextTable**：扩容时创建的新数组，大小是原数组的两倍。</span><br><span class="line">      - **transferIndex**：表示当前迁移进度，从高位（数组末尾）开始，逐步向低位（数组开头）迁移。</span><br><span class="line">      - **sizeCtl**：控制标识符，用于表示当前容器的状态，比如是否正在初始化、是否正在扩容等。当 `sizeCtl &lt; 0`时，可能表示正在初始化或扩容。扩容时，它还用于控制并发扩容的线程数等。</span><br><span class="line"></span><br><span class="line">   4. 扩容大致流程（简化版）</span><br><span class="line"></span><br><span class="line">      1. **检测是否需要扩容**：当插入新元素后，总元素数超过 `capacity * loadFactor`，或者某个桶太满时，触发扩容检查。</span><br><span class="line">      2. **初始化 nextTable（新数组）**：创建一个新的数组，容量是原数组的 **2 倍**。</span><br><span class="line">      3. **多线程协同迁移（transfer）**：将原数组（table）中的每个 bucket 上的节点，**重新计算在新数组（nextTable）中的位置，并迁移过去**。每个线程会负责迁移一部分 bucket，通过 `transferIndex`控制迁移区间，避免冲突。每个 bucket 的迁移是通过 **锁住当前桶（synchronized 锁住链表头/树根节点）** 来进行的，保证线程安全。</span><br><span class="line">      4. **迁移完成后切换引用**：当所有 bucket 都迁移完成后，将 `table`指向 `nextTable`，`nextTable`成为新的主表，完成扩容。</span><br><span class="line"></span><br><span class="line">   5. 为什么能支持多线程协助扩容？</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容最牛的地方之一 ✨：</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，如果某个线程 put 时发现正在扩容，**它不会等待，而是主动参与迁移工作（协助扩容）**。</span><br><span class="line">      - 每个线程会分配到一部分 bucket 去迁移，通过 CAS 和 `transferIndex`控制各自负责的范围，避免重复和冲突。</span><br><span class="line">      - 这种 **“众人拾柴火焰高”** 的设计，极大地提升了大容量情况下的扩容速度，充分利用了多核 CPU 的能力。</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   6. 扩容期间访问怎么办？</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，**读操作（get）可以正常进行**，即使数据正在迁移。</span><br><span class="line">      - 如果读线程访问的 bucket **尚未迁移**，则从旧数组 table 中读取；</span><br><span class="line">      - 如果 **已经迁移**，则从新数组 nextTable 中读取；</span><br><span class="line">      - 写操作（put/remove）如果发现正在扩容，也可能 **协助迁移或等待迁移完成后再操作**。</span><br><span class="line"></span><br><span class="line">3. Java7是怎么实现的呢</span><br><span class="line"></span><br><span class="line">   1. 分段锁（Segment 继承 ReentrantLock）</span><br><span class="line">   2. 数据结构：</span><br><span class="line">      - ConcurrentHashMap 由多个 Segment 组成（默认是 16 个）</span><br><span class="line">      - 每个 Segment 继承自 ReentrantLock，是一个小的 HashMap（数组 + 链表）</span><br><span class="line">      - 每个 Segment 内部维护了一个 HashEntry&lt;K,V&gt;[] table</span><br><span class="line">   3.  线程安全如何保证？</span><br><span class="line">      - 对某个 Segment 的操作（如 put、get），只需要锁住该 Segment</span><br><span class="line">      - 不同 Segment 之间的操作是 并发安全且互不阻塞 的</span><br><span class="line">   4. 优点：</span><br><span class="line">      - 相比 Hashtable 的全表锁，并发度更高（默认支持 16 个线程并发写）</span><br><span class="line">      - 细化锁粒度，提升吞吐量</span><br><span class="line">   5. 缺点：</span><br><span class="line">      - 结构复杂：外层是 Segment 数组，内层是 HashEntry 数组</span><br><span class="line">      - 锁的粒度仍然较粗（一个 Segment 内还是锁整个桶）</span><br><span class="line">      - 不支持链表转红黑树，链表过长时性能下降明显</span><br><span class="line">      - 代码可维护性较差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 深拷贝和浅拷贝</span><br><span class="line"></span><br><span class="line">1. 浅拷贝会复制基本数据类型，但是对于引用对象只会复制一个地址。即，引用对象还是指向同一个。</span><br><span class="line">2. 深拷贝既会复制基本数据类型，也会复制引用对象。即，引用对象不是同一个。</span><br><span class="line"></span><br><span class="line">### 引用类型</span><br><span class="line"></span><br><span class="line">Java 主要提供了 **4 种引用类型**，按强度从强到弱依次为：</span><br><span class="line"></span><br><span class="line">1. **强引用（Strong Reference）** —— 默认的引用类型</span><br><span class="line">   1. 强引用是 Java 中最常见、默认的引用类型。只要强引用存在，对象就绝对不会被垃圾回收器回收。</span><br><span class="line">2. **软引用（Soft Reference）**</span><br><span class="line">   1. 软引用是一种比强引用弱、但比弱引用强的引用类型。如果一个对象只被软引用指向，在内存不足时，它才会被垃圾回收。</span><br><span class="line">3. **弱引用（Weak Reference）**</span><br><span class="line">   1. 弱引用比软引用更弱。只要发生垃圾回收，无论内存是否充足，只要对象只被弱引用指向，它就会被回收。</span><br><span class="line">4. **虚引用（Phantom Reference）**</span><br><span class="line">   1. get() 方法永远返回 null！</span><br><span class="line">   2. 无法通过虚引用来获取对象</span><br><span class="line">   3. 虚引用唯一的作用，是通过 ReferenceQueue 监听对象是否已被回收</span><br><span class="line"></span><br><span class="line">### Java中的异常体系</span><br><span class="line"></span><br><span class="line">详见笔记《异常处理》</span><br><span class="line"></span><br><span class="line">### 什么时候应该抛出异常，什么时候捕获异常</span><br><span class="line"></span><br><span class="line">1. **抛出异常（throw / throws）：** 是 **发现问题、抛出问题**，通常由 **底层方法、工具类、数据校验模块** 完成，表示 “这里可能出错了，我处理不了，交给调用者决定”。</span><br><span class="line">2. **捕获异常（try-catch）：** 是 **处理问题、解决问题**，通常由 **调用方、业务逻辑层、UI 层、控制器层** 完成，表示 “我知道这里可能出错，我来处理”。</span><br><span class="line"></span><br><span class="line">### JVM中那些是线程共享区</span><br><span class="line"></span><br><span class="line">| 区域                                       | 是否线程共享   | 说明                                                         |</span><br><span class="line">| :----------------------------------------- | :------------- | :----------------------------------------------------------- |</span><br><span class="line">| **堆（Heap）**                             | ✅ **线程共享** | 所有对象实例和数组都在这里分配，是 GC 主要管理的区域         |</span><br><span class="line">| **方法区（Method Area）**                  | ✅ **线程共享** | 存储已被虚拟机加载的 **类信息、常量、静态变量、即时编译器编译后的代码等** |</span><br><span class="line">| **Java 虚拟机栈（JVM Stack）**             | ❌ **线程私有** | 每个线程私有，存储 **栈帧（局部变量表、操作数栈、动态链接、方法出口等）** |</span><br><span class="line">| **本地方法栈（Native Method Stack）**      | ❌ **线程私有** | 为 JVM 调用的 **Native 方法服务**                            |</span><br><span class="line">| **程序计数器（Program Counter Register）** | ❌ **线程私有** | 当前线程执行的字节码行号指示器（线程切换时能恢复执行位置）   |</span><br><span class="line"></span><br><span class="line">### 如何排查JVM的问题？（待学习）</span><br><span class="line"></span><br><span class="line">- 我会去问LLM</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- | 步骤 | 操作                 | 工具/命令                                        | 目的                             |</span><br><span class="line">  | :--- | :------------------- | :----------------------------------------------- | :------------------------------- |</span><br><span class="line">  | 1    | 查看 OOM 错误日志    | 控制台 / 日志文件                                | 确定 OOM 类型（堆、元空间等）    |</span><br><span class="line">  | 2    | 生成 Heap Dump       | `jmap -dump`或 `-XX:+HeapDumpOnOutOfMemoryError` | 获取堆内存快照                   |</span><br><span class="line">  | 3    | 分析 Heap Dump       | Eclipse MAT / VisualVM                           | 找到大对象、内存泄漏、对象引用链 |</span><br><span class="line">  | 4    | 查看线程状态（可选） | `jstack &lt;pid&gt;`                                   | 分析线程死锁、线程数过多等问题   |</span><br><span class="line">  | 5    | 定位代码问题         | 结合 dump 分析 + 业务代码                        | 修复内存泄漏、优化对象使用       |</span><br><span class="line"></span><br><span class="line">1. 一般而言，排查问题可以从以下方面入手</span><br><span class="line">   1. 对于还在运行的系统，通过jmap, jstack, jstat等工具查看系统信息。</span><br><span class="line">   2. 对于已经发生OOM的系统，可以去看日志</span><br><span class="line">2. 常见类型：</span><br><span class="line">   1. 内存溢出，CPU使用率过高，线程问题，GC问题</span><br><span class="line"></span><br><span class="line">3. OOM怎么解决</span><br><span class="line"></span><br><span class="line">### 一个对象从加载到JVM，再到被GC处理，经历了什么？</span><br><span class="line"></span><br><span class="line">1. 类加载：把字节码（.class）加载到方法区</span><br><span class="line">2. 创建对象：在堆中分配内存</span><br><span class="line">3. 在堆中E区、S区、O区流转</span><br><span class="line">4. 被GC清理</span><br><span class="line"></span><br><span class="line">### 怎么确定一个对象是不是垃圾？</span><br><span class="line"></span><br><span class="line">1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。</span><br><span class="line">2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。</span><br><span class="line">   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。</span><br><span class="line">   2. 有多个根对象，但是只会选用一个。</span><br><span class="line"></span><br><span class="line">### 有哪些GC算法</span><br><span class="line"></span><br><span class="line">1. **标记清除算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。</span><br><span class="line">      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 不需要移动对象，实现相对简单</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 内存碎片化严重</span><br><span class="line">      2. 效率问题</span><br><span class="line">2. **复制算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）</span><br><span class="line">      2. 每次只使用其中一块（如 From 区）来分配对象</span><br><span class="line">      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）</span><br><span class="line">      4. 交换角色：原来的 To 区成为新的 From 区，继续使用</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！</span><br><span class="line">      2. 分配效率高</span><br><span class="line">      3. 适合对象存活率低的场景</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 浪费了一半的内存空间</span><br><span class="line">      2. 不适合存活对象多的场景</span><br><span class="line">3. **标记压缩算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象</span><br><span class="line">      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）</span><br><span class="line">      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）</span><br><span class="line">      2. 内存利用率高，适合大对象和长期存活对象分配</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 移动对象成本高！</span><br><span class="line"></span><br><span class="line">### 什么是STW</span><br><span class="line"></span><br><span class="line">1. 全称Stop-The-World</span><br><span class="line">2. 在垃圾回收（GC）过程中，Java 虚拟机（JVM）为了保证垃圾回收的正确性，会暂停所有的应用线程（也就是用户线程 / 业务线程），只让垃圾回收线程运行。</span><br><span class="line"></span><br><span class="line">### 什么是反射</span><br><span class="line"></span><br><span class="line">- **反射（Reflection）** 是一种强大的机制，它允许程序在**运行时**（而不是编译时）获取类的信息，并且可以动态地操作类或对象的属性、方法和构造器等。</span><br><span class="line">-  反射使得程序可以在运行时“发现”和“操作”类，而不需要在编译期明确知道这些类的具体信息</span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">### 线程安全</span><br><span class="line"></span><br><span class="line">1. 线程安全（Thread Safety） 是指：当一个类、方法或代码块在多线程环境下被多个线程同时访问时，仍然能正确地工作，不会导致数据错误、逻辑混乱或程序崩溃，那么它就是线程安全的。</span><br><span class="line"></span><br><span class="line">2. 针对某一段代码，多线程同时执行时，不会造成混乱</span><br><span class="line"></span><br><span class="line">3. 举例：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class UnsafeCounter &#123;</span><br><span class="line">          private int count = 0;</span><br><span class="line">      </span><br><span class="line">          public void increment() &#123;</span><br><span class="line">              count++; // 实际上是 read -&gt; add -&gt; write，非原子！</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上面的代码，如果有两个线程执行，那么应该一个结果是1，一个结果是2。如果不是，就说明造成了混乱。</p>
</li>
</ol>
</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>守护线程（Daemon Thread） 是 Java 线程中的一种特殊线程，它的作用通常是 为其他线程（用户线程 &#x2F; 非守护线程）提供后台服务支持</p>
</li>
<li><p>守护线程和用户线程对比</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>守护线程（Daemon Thread）</strong></th>
<th align="left"><strong>用户线程（User Thread &#x2F; 非守护线程）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用</strong></td>
<td align="left">为其他线程提供<strong>后台服务</strong></td>
<td align="left">执行<strong>主要任务</strong>，是程序的核心逻辑</td>
</tr>
<tr>
<td align="left"><strong>JVM 是否会等待其结束</strong></td>
<td align="left"><strong>不会</strong>，只要用户线程结束，JVM 就会退出，不管守护线程是否还在运行</td>
<td align="left"><strong>会</strong>，JVM 会等待所有用户线程执行完毕才会退出</td>
</tr>
<tr>
<td align="left"><strong>默认情况</strong></td>
<td align="left">线程默认是<strong>用户线程</strong></td>
<td align="left">是</td>
</tr>
<tr>
<td align="left"><strong>如何设置</strong></td>
<td align="left">通过 <code>setDaemon(true)</code>设置</td>
<td align="left">不设置或设置为 false</td>
</tr>
<tr>
<td align="left"><strong>典型例子</strong></td>
<td align="left">垃圾回收线程、日志线程、监控线程</td>
<td align="left">主线程、业务逻辑线程、用户交互线程</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="并发、并行、串行"><a href="#并发、并行、串行" class="headerlink" title="并发、并行、串行"></a>并发、并行、串行</h3><ol>
<li>串行：一个一个执行</li>
<li>并行：物理世界，同时进行。比如一边跑步一遍听歌。</li>
<li>并发：两个任务轮流执行，但是轮转很快。比如CPU分时的处理两个请求</li>
</ol>
<h3 id="死锁如何解决"><a href="#死锁如何解决" class="headerlink" title="死锁如何解决"></a>死锁如何解决</h3><ol>
<li><p>产生的必要条件</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">说明</th>
<th align="left">是否必须</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 互斥条件（Mutual Exclusion）</strong></td>
<td align="left">某资源一次只能被一个线程占用（如锁、对象、文件等）</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>2. 占有并等待（Hold and Wait）</strong></td>
<td align="left">线程持有至少一个资源，并等待获取其他被占用的资源</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>3. 不可剥夺（No Preemption）</strong></td>
<td align="left">线程已获得的资源，在未使用完之前，<strong>不能被其他线程强行夺取</strong>，只能由自己释放</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>4. 循环依赖（Circular Wait）</strong></td>
<td align="left">存在一个线程的循环等待链，比如 T1 等 T2 的资源，T2 等 T1 的资源，形成一个闭环</td>
<td align="left">✅ 必须</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>如何排查？</p>
<ol>
<li>用<code>jstack</code>到处堆内存快照，然后分析文件。jastack会为你分析出是否存在死锁。</li>
</ol>
</li>
<li><p>如何避免</p>
<ol>
<li>破坏循环依赖（推荐）—— 按固定顺序获取锁</li>
<li>破坏循环依赖占有并等待——使用超时机制（tryLock）</li>
<li>检测与恢复（高级 &#x2F; 系统级，预防措施）</li>
</ol>
</li>
</ol>
<h3 id="CountDownLatch和Semaphore的区别和底层实现"><a href="#CountDownLatch和Semaphore的区别和底层实现" class="headerlink" title="CountDownLatch和Semaphore的区别和底层实现"></a>CountDownLatch和Semaphore的区别和底层实现</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized的偏向锁，轻量级锁，重量级锁"><a href="#synchronized的偏向锁，轻量级锁，重量级锁" class="headerlink" title="synchronized的偏向锁，轻量级锁，重量级锁"></a>synchronized的偏向锁，轻量级锁，重量级锁</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>synchronized（内置锁）</strong></th>
<th align="left"><strong>ReentrantLock（可重入锁）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">Java 关键字（语法层面，JVM 实现）</td>
<td align="left">Java 类（<code>java.util.concurrent.locks.ReentrantLock</code>，API 层面）</td>
</tr>
<tr>
<td align="left"><strong>使用方式</strong></td>
<td align="left">直接修饰方法或代码块，语法简洁</td>
<td align="left">需要手动加锁 <code>lock()</code>和解锁 <code>unlock()</code>，通常配合 <code>try-finally</code>使用</td>
</tr>
<tr>
<td align="left"><strong>锁的获取与释放</strong></td>
<td align="left"><strong>自动加锁与释放</strong>（进入同步块加锁，退出时释放）</td>
<td align="left"><strong>手动加锁与释放</strong>，必须显式调用 <code>lock()</code>和 <code>unlock()</code>，推荐在 <code>finally</code>块中释放</td>
</tr>
<tr>
<td align="left"><strong>可重入性</strong></td>
<td align="left">✅ 支持（同一个线程可重复获取同一把锁）</td>
<td align="left">✅ 支持（同一个线程可多次获取锁，必须释放同样次数）</td>
</tr>
<tr>
<td align="left"><strong>公平性</strong></td>
<td align="left">❌ 非公平锁（不保证等待顺序）</td>
<td align="left">✅ <strong>可选择公平或非公平（构造方法传参）</strong></td>
</tr>
<tr>
<td align="left"><strong>是否可中断</strong></td>
<td align="left">❌ 不支持中断等待锁</td>
<td align="left">✅ 支持 <code>lockInterruptibly()</code>，可响应中断</td>
</tr>
<tr>
<td align="left"><strong>是否可设置超时</strong></td>
<td align="left">❌ 不支持尝试获取锁的超时机制</td>
<td align="left">✅ 支持 <code>tryLock(long time, TimeUnit unit)</code>，可以设置超时等待</td>
</tr>
<tr>
<td align="left"><strong>是否支持多个条件变量（Condition）</strong></td>
<td align="left">❌ 只有一个隐式的等待队列（通过 <code>wait/notify</code>）</td>
<td align="left">✅ 支持多个 <code>Condition</code>，可精细控制线程等待&#x2F;唤醒（如不同条件队列）</td>
</tr>
</tbody></table>
<h3 id="谈谈你对AQS的理解"><a href="#谈谈你对AQS的理解" class="headerlink" title="谈谈你对AQS的理解"></a>谈谈你对AQS的理解</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="如何保证操作的原子性"><a href="#如何保证操作的原子性" class="headerlink" title="如何保证操作的原子性"></a>如何保证操作的原子性</h3><ol>
<li><p>使用AotmicXXX类</p>
<ol>
<li><pre><code class="language-java">// 使用 AtomicInteger 代替 int
private static AtomicInteger i = new AtomicInteger(0);

i.incrementAndGet()就是 // 原子版本的 i++
getAndIncrement() // 相当于 i++
addAndGet(1) // 加一个指定的值
get() // 获取当前值
set(int newValue) // 设置值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   2. 这是推荐做法，性能好，线程安全。</span><br><span class="line"></span><br><span class="line">2. `AtomicInteger`的核心实现依赖于：</span><br><span class="line"></span><br><span class="line">   - **CAS（Compare-And-Swap）**：一种硬件级别的原子操作</span><br><span class="line">   - 利用循环 + CAS 的方式实现 **无锁的线程安全操作（乐观锁）**</span><br><span class="line"></span><br><span class="line">3. CAS</span><br><span class="line">   1. CAS 是一种原子操作，它的功能是：比较某个内存位置的值与预期值，如果匹配，则将该内存位置的值更新为新值；如果不匹配，则不修改值。整个操作是原子的（不可中断），由 CPU 硬件保证。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Spring</span><br><span class="line"></span><br><span class="line">### 谈谈你对IOC的理解</span><br><span class="line"></span><br><span class="line">- IoC：控制反转</span><br><span class="line"></span><br><span class="line">1. 什么是控制？控制了什么？</span><br><span class="line"></span><br><span class="line">   1. 具体来说，控制了以下内容：</span><br><span class="line"></span><br><span class="line">      | 控制的内容         | 说明                                                        |</span><br><span class="line">      | :----------------- | :---------------------------------------------------------- |</span><br><span class="line">      | 对象的创建         | 谁负责 new 一个对象出来（比如 `new UserService()`）         |</span><br><span class="line">      | 依赖关系的组装     | 比如一个 Service 依赖一个 DAO，谁来把 DAO 注入到 Service 中 |</span><br><span class="line">      | 对象之间的耦合关系 | 对象之间如何关联、谁依赖谁、怎么管理这些依赖                |</span><br><span class="line">      | **对象的生命周期** | 比如对象什么时候创建、什么时候销毁、是否单例等              |</span><br><span class="line"></span><br><span class="line">      在传统编程中，这些控制都是由程序员在代码中显式完成的。</span><br><span class="line"></span><br><span class="line">2. 什么是反转？反转前是谁控制？反转后呢？如何控制的？</span><br><span class="line"></span><br><span class="line">   1. 反转前（传统方式）—— “正序控制” / “主动控制”</span><br><span class="line">      - 谁控制？ → 由程序员 / 开发者控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖关系的手动组装</span><br><span class="line">      - 如何实现的？ → 通过 new 关键字、手动赋值、层层构造</span><br><span class="line">   2. 反转后（IoC 方式）—— **“控制权反转给容器”**</span><br><span class="line">      - 谁控制？ → 由外部容器（比如 Spring IoC 容器）控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖注入、生命周期管理</span><br><span class="line">      - 如何实现的？ → 通过依赖注入（DI）、配置文件 / 注解，让容器来管理对象和依赖关系</span><br><span class="line"></span><br><span class="line">3. 为什么要反转？有什么好处？</span><br><span class="line"></span><br><span class="line">   1. 控制反转（IoC）的主要目的是为了解耦、提高代码的灵活性、可测试性和可维护性。</span><br><span class="line"></span><br><span class="line">### IoC和DI怎么通过反射实现的？</span><br><span class="line"></span><br><span class="line">1. **扫描类路径，找到需要管理的 Bean（使用反射）**</span><br><span class="line"></span><br><span class="line">   Spring 启动时，会扫描你指定的包路径（比如 `com.example`），找出所有带有 `@Component`、`@Service`、`@RestController`等注解的类。</span><br><span class="line"></span><br><span class="line">   &gt; 这一步是通过 **反射机制** 去**读取类上的注解信息**，判断哪些类需要由 Spring 管理，变成一个个 Bean。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">2. **实例化 Bean（通过反射创建对象）**</span><br><span class="line"></span><br><span class="line">   对于每一个需要管理的类（比如 `UserService`和 `UserController`），Spring 会：</span><br><span class="line"></span><br><span class="line">   - 通过反射调用其构造器（通常是默认的无参构造器，或有参构造器），</span><br><span class="line">   - 动态地创建出一个对象实例，</span><br><span class="line"></span><br><span class="line">   比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>Class&lt;?&gt; clazz &#x3D; Class.forName(“com.example.UserService”);<br>Object userServiceObj &#x3D; clazz.getDeclaredConstructor().newInstance(); &#x2F;&#x2F; 反射创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   &gt; 这一步就是用反射来代替你手动写 `new UserService()`。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">3. **依赖注入（通过反射实现 @Autowired 等注入）**</span><br><span class="line"></span><br><span class="line">   如果一个类中有依赖其它 Bean 的字段（比如 `@Autowired private UserService userService;`），Spring 会：</span><br><span class="line"></span><br><span class="line">   1. 找到这个字段，</span><br><span class="line">   2. 知道它需要注入一个 `UserService`类型的 Bean，</span><br><span class="line">   3. 从容器中找出已经创建好的 `UserService`对象，</span><br><span class="line">   4. **通过反射调用 `Field.set(对象, 值)`，把这个依赖注入到目标字段中。**</span><br><span class="line"></span><br><span class="line">   即使这个字段是 `private`的，Spring 也会通过 `field.setAccessible(true)`来绕过访问限制，然后进行赋值。</span><br><span class="line"></span><br><span class="line">   &gt; 这就是通过反射实现的 **依赖注入（DI）**，而依赖注入是 IoC 的一种实现方式。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">4. **管理 Bean 的生命周期、作用域等**</span><br><span class="line"></span><br><span class="line">   Spring 还会通过反射调用一些初始化方法（比如 `@PostConstruct`标记的方法）、销毁方法等，也是依赖反射来动态调用的。</span><br><span class="line"></span><br><span class="line">### 单例Bean和单例模式</span><br><span class="line"></span><br><span class="line">一定条件下，可以认为单利Bean是单例模式。</span><br><span class="line"></span><br><span class="line">1. 在单例模式下，一个类只能有一个对象。</span><br><span class="line">2. 但是单例Bean不一样。一个类可以有多个对象，但是通过同一个名字只能获得一个对象。</span><br><span class="line">3. 所以说，在Sping的范围内，如果只有一个Bean的话，我们可以认为单利Bean是单例模式</span><br><span class="line"></span><br><span class="line">### Spring事务传播机制</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事物传播就是指事务被调用时，还是不是事务，是嵌套事务还是合并事务等等</span><br><span class="line"></span><br><span class="line">### Spring事务什么时候会失效</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 跟AOP、事务管理器相关</span><br><span class="line"></span><br><span class="line">### Spring事务如何实现的</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的</span><br><span class="line">- 两种调用方式：声明式事务（@Transactional）或编程式事务（TransactionTemplate）</span><br><span class="line"></span><br><span class="line">### Bean是线程安全的吗</span><br><span class="line"></span><br><span class="line">1. Bean的本质还是类</span><br><span class="line">2. 如果Bean是无状态的，那就是线程安全的。否则反之。</span><br><span class="line"></span><br><span class="line">### Bean的生命周期</span><br><span class="line"></span><br><span class="line">1. **实例化**：Spring 创建对象（相当于 `new`）</span><br><span class="line">2. **属性赋值 / 依赖注入**：给 Bean 注入依赖（DI, Dependency Injection）</span><br><span class="line">3. **初始化**：执行初始化方法（`@PostConstruct` / `InitializingBean.afterPropertiesSet()`）</span><br><span class="line">4. **使用**：在应用中被调用</span><br><span class="line">5. **销毁**：应用关闭时销毁 Bean（`@PreDestroy` / `DisposableBean.destroy()`）</span><br><span class="line"></span><br><span class="line">### ApplicationContext和BeanFactory的区别</span><br><span class="line"></span><br><span class="line">| 概念                   | 一句话解释                                                   |</span><br><span class="line">| :--------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **BeanFactory**        | 是 Spring **最底层、最核心的 IoC 容器接口**，**负责管理 Bean 的创建与依赖注入，但功能相对基础，懒加载为主** |</span><br><span class="line">| **ApplicationContext** | 是 **BeanFactory 的高级扩展接口**，不仅具备 BeanFactory 的所有功能，还提供了 **更多企业级特性，比如国际化、事件机制、AOP 支持、自动装配等**，是 Spring 应用中最常用的容器 |</span><br><span class="line"></span><br><span class="line">### Spring容器的启动流程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">SpringApplication.run()</span><br><span class="line">       ↓</span><br><span class="line">创建 ApplicationContext（如 AnnotationConfigApplicationContext）</span><br><span class="line">       ↓</span><br><span class="line">扫描 @ComponentScan 包路径，解析 @Component、@Service、@Configuration 等</span><br><span class="line">       ↓</span><br><span class="line">生成 BeanDefinition（Bean 的定义信息）</span><br><span class="line">       ↓</span><br><span class="line">将 BeanDefinition 注册到容器中（BeanDefinitionRegistry）</span><br><span class="line">       ↓</span><br><span class="line">根据 BeanDefinition 实例化 Bean（创建对象，比如通过反射调用构造方法）// 这里只有急加载的Bean会实例化</span><br><span class="line">       ↓</span><br><span class="line">进行依赖注入（DI，比如 @Autowired 字段注入）</span><br><span class="line">       ↓</span><br><span class="line">执行初始化回调（@PostConstruct、InitializingBean、init-method）</span><br><span class="line">       ↓</span><br><span class="line">发布 ContextRefreshedEvent 事件（容器初始化完成）</span><br><span class="line">       ↓</span><br><span class="line">✅ Spring 容器启动完成，应用可正常运行</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Spring用了哪些设计模式"><a href="#Spring用了哪些设计模式" class="headerlink" title="Spring用了哪些设计模式"></a>Spring用了哪些设计模式</h3><table>
<thead>
<tr>
<th align="left">设计模式</th>
<th align="left">应用场景</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工厂模式</strong></td>
<td align="left">BeanFactory &#x2F; ApplicationContext</td>
<td align="left">管理 Bean 的创建</td>
</tr>
<tr>
<td align="left"><strong>单例模式</strong></td>
<td align="left">默认的 Bean Scope</td>
<td align="left">一个 Bean 只有一个实例</td>
</tr>
<tr>
<td align="left"><strong>代理模式</strong></td>
<td align="left">Spring AOP</td>
<td align="left">实现方法拦截与增强</td>
</tr>
<tr>
<td align="left"><strong>模板方法模式</strong></td>
<td align="left">JdbcTemplate、RestTemplate</td>
<td align="left">封装固定流程</td>
</tr>
<tr>
<td align="left"><strong>观察者模式</strong></td>
<td align="left">ApplicationEvent &#x2F; Listener</td>
<td align="left">事件发布与订阅</td>
</tr>
<tr>
<td align="left"><strong>适配器模式</strong></td>
<td align="left">HandlerAdapter、AdvisorAdapter</td>
<td align="left">接口转换与兼容</td>
</tr>
<tr>
<td align="left"><strong>装饰器模式</strong></td>
<td align="left">BeanPostProcessor</td>
<td align="left">增强 Bean 功能</td>
</tr>
<tr>
<td align="left"><strong>策略模式</strong></td>
<td align="left">事务管理器、视图解析器</td>
<td align="left">多种实现动态选择</td>
</tr>
<tr>
<td align="left"><strong>责任链模式</strong></td>
<td align="left">过滤器链、拦截器链</td>
<td align="left">多个处理器依次处理请求</td>
</tr>
<tr>
<td align="left"><strong>原型模式</strong></td>
<td align="left">Bean Scope 为 prototype</td>
<td align="left">每次获取新实例</td>
</tr>
<tr>
<td align="left"><strong>组合模式</strong></td>
<td align="left">树形结构数据（非核心）</td>
<td align="left">组合对象与叶子对象统一处理</td>
</tr>
<tr>
<td align="left"><strong>外观模式</strong></td>
<td align="left">高级封装（如 JdbcTemplate）</td>
<td align="left">简化复杂 API</td>
</tr>
<tr>
<td align="left"><strong>建造者模式</strong></td>
<td align="left">SpringApplicationBuilder</td>
<td align="left">分步骤构建复杂对象</td>
</tr>
</tbody></table>
<h3 id="Spring常用的注解及其底层实现"><a href="#Spring常用的注解及其底层实现" class="headerlink" title="Spring常用的注解及其底层实现"></a>Spring常用的注解及其底层实现</h3><p>详见《SSM学习笔记》</p>
<h3 id="SpringBoot怎么启动Tomcat的"><a href="#SpringBoot怎么启动Tomcat的" class="headerlink" title="SpringBoot怎么启动Tomcat的"></a>SpringBoot怎么启动Tomcat的</h3><ol>
<li>先启动Spring容器</li>
<li>自动配置： @EnableAutoConfiguration（包含在 @SpringBootApplication 中）启用自动配置。它会根据你的 classpath 下的依赖（比如 tomcat-embed-core.jar），自动加载一系列自动配置类。生成一个启动Tomcat的Bean。</li>
<li>Spring容器创建完之后，启动Tomcat的Bean，创建对象，并绑定端口。</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li><strong>MyBatis 是一个优秀的 Java 持久层框架，它简化了 JDBC 的操作，通过 XML 或注解的方式，将 Java 对象与 SQL 语句进行映射，让开发者可以更灵活、更高效地操作数据库，而不用过多关心底层的 JDBC 细节。</strong></li>
</ul>
<h3 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h3><h3 id="Mybatis中-和-的区别是什么？"><a href="#Mybatis中-和-的区别是什么？" class="headerlink" title="Mybatis中#{}和${}的区别是什么？"></a>Mybatis中#{}和${}的区别是什么？</h3><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="设计MySQL表时应该注意什么"><a href="#设计MySQL表时应该注意什么" class="headerlink" title="设计MySQL表时应该注意什么"></a>设计MySQL表时应该注意什么</h3><h4 id="遵循第三范式（3NF）"><a href="#遵循第三范式（3NF）" class="headerlink" title="遵循第三范式（3NF）"></a>遵循第三范式（3NF）</h4><ul>
<li><strong>第一范式（1NF）</strong>：字段不可再分，每列都是原子的。</li>
<li><strong>第二范式（2NF）</strong>：满足1NF，且非主键字段完全依赖于完整主键（针对联合主键的情况）。<ul>
<li>2NF 消除了<strong>部分函数依赖</strong>，即非主键字段不能只依赖主键的一部分。</li>
</ul>
</li>
<li><strong>第三范式（3NF）</strong>：满足2NF，且非主键字段不传递依赖于主键。<ul>
<li>消除了<strong>传递依赖</strong>，不能通过其他非主键字段间接依赖。</li>
</ul>
</li>
</ul>
<h4 id="设计字段"><a href="#设计字段" class="headerlink" title="设计字段"></a>设计字段</h4><ol>
<li>选择合适的数据类型<ul>
<li>尽量使用最小的满足需求的数据类型，以节省存储空间和提高性能。</li>
</ul>
</li>
<li>字段命名规范<ul>
<li>使用有意义的名称，采用下划线命名法，如 <code>user_name</code>、<code>created_at</code>。</li>
<li>避免使用 MySQL 的保留关键字，如 <code>order</code>、<code>group</code>等，若必须使用，需用反引号括起。</li>
<li>主键通常命名为 <code>id</code>，外键通常为 <code>xxx_id</code>。</li>
</ul>
</li>
</ol>
<h4 id="主键与索引设计"><a href="#主键与索引设计" class="headerlink" title="主键与索引设计"></a>主键与索引设计</h4><ol>
<li>主键设计<ul>
<li>每张表都应有一个主键，用于唯一标识一行。</li>
<li>推荐使用 <strong>自增整型（如 BIGINT AUTO_INCREMENT）</strong> 作为主键，简单高效，有利于索引组织。</li>
<li>如果使用业务字段作为主键（如手机号、身份证等），要确保其<strong>唯一、不变、简短</strong>。</li>
</ul>
</li>
<li>索引设计<ul>
<li><strong>索引不是越多越好</strong>，每个索引都会占用空间并影响写入性能。</li>
<li>为<strong>经常用于 WHERE、JOIN、ORDER BY、GROUP BY 的字段建立索引</strong>。</li>
<li>合理使用 <strong>复合索引（联合索引）</strong>，注意最左前缀原则。</li>
</ul>
</li>
</ol>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ol>
<li>索引的理解<ol>
<li>索引是数据库中一种特殊的数据结构，它可以帮助数据库系统快速定位到表中的特定数据行，<strong>类似于书籍的目录</strong>。</li>
<li>可以说，索引就是把无序的数据化为有序</li>
<li>没有索引时，查找一般要遍历全表。有索引之后可以降低时间复杂度。</li>
<li>索引也存储在硬盘中</li>
</ol>
</li>
<li>常见的索引<ol>
<li>B+树。详见《Java学习笔记》<ol>
<li>为什么用B+树？<ol>
<li><strong>树高更低，查询更快</strong>（减少磁盘 IO 次数，每次 IO 代价高）</li>
<li><strong>非叶子节点只存 key，能容纳更多索引，树更矮</strong></li>
<li><strong>叶子节点之间有链表，范围查询非常高效</strong></li>
<li><strong>查询稳定，所有查询都要走到叶子节点，性能可预测</strong></li>
<li><strong>适合写平衡（插入、删除也相对稳定）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><ol>
<li><p>选择合适的列建立索引</p>
<ul>
<li><p><strong>高选择性列优先</strong>：列中不同值越多（如用户ID、订单号），索引效果越好</p>
</li>
<li><p><strong>高频查询条件列</strong>：WHERE、JOIN、ORDER BY、GROUP BY中频繁使用的列</p>
</li>
<li><p><strong>等值查询列</strong>：精确匹配比范围查询更适合索引</p>
</li>
<li><p><strong>排序&#x2F;分组列</strong>：经常用于ORDER BY或GROUP BY的列</p>
</li>
</ul>
</li>
<li><p>避免过度索引</p>
<ul>
<li><p><strong>每个索引都有成本</strong>：占用存储空间，降低写入速度(INSERT&#x2F;UPDATE&#x2F;DELETE)</p>
</li>
<li><p><strong>监控索引使用率</strong>：定期检查未使用的索引并删除</p>
</li>
<li><p><strong>小表不需要索引</strong>：数据量小(如&lt;1000行)时全表扫描可能更快</p>
</li>
</ul>
</li>
</ol>
<h3 id="聚簇索引和非聚簇索引的区别是什么"><a href="#聚簇索引和非聚簇索引的区别是什么" class="headerlink" title="聚簇索引和非聚簇索引的区别是什么"></a>聚簇索引和非聚簇索引的区别是什么</h3><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>聚簇索引（Clustered Index）</strong></th>
<th align="left"><strong>非聚簇索引（Non-clustered Index &#x2F; 二级索引）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">索引的叶子节点 <strong>直接存储整行数据</strong>，即 <strong>数据即索引，索引即数据</strong></td>
<td align="left">索引的叶子节点 <strong>存储的是主键值（或指向数据的指针）</strong>，不是完整的数据行</td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left"><strong>数据按索引顺序物理存储</strong>（即表数据按聚簇索引的顺序存放）</td>
<td align="left"><strong>数据与索引分开存储</strong>，索引单独维护，指向数据的地址或主键</td>
</tr>
<tr>
<td align="left"><strong>数量</strong></td>
<td align="left"><strong>一个表只能有一个聚簇索引</strong>（通常是主键，如果没有主键则选唯一键，否则隐藏行 ID）</td>
<td align="left"><strong>一个表可以有多个非聚簇索引（二级索引）</strong></td>
</tr>
<tr>
<td align="left"><strong>查询效率</strong></td>
<td align="left">查询时 <strong>如果使用聚簇索引，通常只需一次查找即可定位到完整数据，效率很高</strong></td>
<td align="left">查询时可能需要 <strong>回表（先查索引，再根据主键查聚簇索引获取完整数据）</strong>，多一次 IO</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">主键查询、范围查询（如日期、ID 范围）非常高效</td>
<td align="left">适合根据非主键字段查询，但可能带来回表开销</td>
</tr>
<tr>
<td align="left"><strong>典型实现（MySQL）</strong></td>
<td align="left"><strong>InnoDB 的主键索引就是聚簇索引</strong></td>
<td align="left"><strong>InnoDB 的普通索引（如二级索引）就是非聚簇索引</strong></td>
</tr>
<tr>
<td align="left"><strong>物理顺序</strong></td>
<td align="left">数据按聚簇索引的键值顺序存储（物理有序）</td>
<td align="left">数据存储无序，索引单独组织（逻辑有序）</td>
</tr>
</tbody></table>
<h3 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h3><ol>
<li><p>基本特性：ACID</p>
<ol>
<li><p>原子性 (Atomicity)</p>
<p>通过 <strong>undo log（回滚日志）</strong> 实现：</p>
<ul>
<li>事务开始前，InnoDB 会记录修改前的数据到 undo log</li>
<li>如果事务需要回滚，可以根据 undo log 恢复到原始状态</li>
</ul>
</li>
<li><p>一致性 (Consistency)</p>
<p>通过以下机制共同保证：</p>
<ul>
<li>原子性、隔离性、持久性的组合</li>
<li>数据库的约束（如主键、外键、唯一约束等）</li>
<li>应用程序的业务逻辑</li>
</ul>
</li>
<li><p>隔离性 (Isolation)</p>
<p>通过 <strong>锁机制</strong> 和 <strong>MVCC（多版本并发控制）</strong> 实现：</p>
<ul>
<li><strong>锁机制</strong>：包括共享锁(S锁)、排他锁(X锁)、意向锁等</li>
<li><strong>MVCC</strong>：通过 read view 和版本链实现非锁定读，提高并发性能</li>
</ul>
</li>
<li><p>持久性 (Durability)</p>
<p>通过 <strong>redo log（重做日志）</strong> 实现：</p>
<ul>
<li>事务提交时，先将修改写入 redo log（预写日志），确保即使系统崩溃也能恢复数据</li>
<li>采用 WAL（Write-Ahead Logging）技术，先写日志再写磁盘</li>
</ul>
</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li><p>SQL标准定义了四种隔离级别。隔离级别越高，并发性能越低，但数据一致性越强。从低到高依次为：</p>
<ol>
<li>读未提交(Read Uncommitted)</li>
<li>读已提交(Read Committed)</li>
<li>可重复读(Repeatable Read) <em>(MySQL默认级别)</em></li>
<li>串行化(Serializable)</li>
</ol>
</li>
<li><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">并发性能</th>
<th align="left">实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读 未提交</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">最高</td>
<td align="left">最低</td>
</tr>
<tr>
<td align="left">读 已提交</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">MySQL中不可能*</td>
<td align="left">中等</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">串行化</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">最低</td>
<td align="left">最高</td>
</tr>
</tbody></table>
</li>
<li><p>并发问题详解</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li><strong>定义</strong>：读取到其他事务未提交的数据</li>
<li><strong>风险</strong>：如果事务回滚，读取到的数据就是无效的</li>
<li><strong>解决方案</strong>：至少使用读已提交隔离级别</li>
</ul>
</li>
<li>不可重复读(Non-repeatable Read)<ul>
<li><strong>定义</strong>：同一事务内多次读取同一数据，得到不同结果</li>
<li><strong>原因</strong>：其他事务提交了修改</li>
<li><strong>风险</strong>：基于第一次读取结果做出的决策可能失效</li>
<li><strong>解决方案</strong>：使用可重复读或更高隔离级别</li>
</ul>
</li>
<li>幻读(Phantom Read)<ul>
<li><strong>定义</strong>：同一事务内两次执行相同查询，返回不同行数(新增或删除的行)</li>
<li><strong>原因</strong>：其他事务插入或删除了符合查询条件的行</li>
<li><strong>风险</strong>：统计结果不准确，业务逻辑可能出错</li>
<li><strong>解决方案</strong>：使用串行化或MySQL的可重复读(通过间隙锁防止)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>什么是MVCC</p>
<ol>
<li><p>为了并发问题，数据库提供了 事务隔离级别（如 Read Committed、Repeatable Read、Serializable）。</p>
</li>
<li><p>但使用 悲观锁（如行锁、表锁） 去解决并发问题，虽然安全，但会 降低并发性能，导致读写互相阻塞。</p>
<blockquote>
<p>✅ MVCC 的出现，就是为了在不加锁（或减少加锁）的前提下，实现事务隔离，让读写可以并发执行，提高性能！</p>
</blockquote>
</li>
<li><p>MVCC：多版本并发控制。是一种并发控制机制，它<strong>允许事务在不互相阻塞的情况下同时读取和修改数据</strong>。与传统的基于锁的并发控制不同，MVCC通过为数据维护多个版本来实现这一目标。</p>
</li>
</ol>
</li>
<li><p>MVCC的核心思想</p>
<ul>
<li><p><strong>读不阻塞写，写不阻塞读</strong>：这是MVCC最大的优势</p>
</li>
<li><p><strong>数据多版本化</strong>：每行数据可能有多个版本同时存在</p>
</li>
<li><p><strong>一致性读</strong>：事务读取的是某个时间点的数据快照，而不是最新数据</p>
</li>
<li><p><strong>版本链管理</strong>：通过特殊的结构跟踪和管理数据的不同版本</p>
</li>
</ul>
</li>
<li><p>时间线示例</p>
<ol>
<li>T1 启动（事务 ID &#x3D; 101）</li>
<li>T2 启动（事务 ID &#x3D; 102）</li>
<li>T2 执行 UPDATE balance &#x3D; 200 WHERE id &#x3D; 1，未提交</li>
<li>T2 提交事务，此时 balance &#x3D; 200 的版本，事务 ID &#x3D; 102，变为“已提交”</li>
<li>T1 执行 SELECTT1 的 ReadView 是在 T2 提交前生成的，它依然 看不到 T2 的修改（因为 T2 在 T1 的 ReadView 中是“活跃的” 或 “在其后创建的”）T1 仍然读的是旧版本 balance &#x3D; 100。但如果 T1 提交后再开启一个新事务 T3 去读，T3 就能看到 balance &#x3D; 200（因为 T2 已提交）</li>
</ol>
</li>
<li><p>优势</p>
<ul>
<li><strong>高并发性能</strong>：读写操作互不阻塞，显著提高系统并发能力</li>
<li><strong>非阻塞读</strong>：读操作不需要等待写操作完成，也不会阻塞写操作</li>
<li><strong>一致性读</strong>：事务可以读取一致的数据快照，不受其他事务影响</li>
<li><strong>减少锁争用</strong>：降低了死锁发生的概率</li>
</ul>
</li>
<li><p>局限	</p>
<ul>
<li><p><strong>存储开销</strong>：需要存储多个数据版本，增加存储空间使用</p>
</li>
<li><p><strong>清理成本</strong>：需要定期清理不再需要的旧版本数据（purge操作）</p>
</li>
<li><p><strong>实现复杂</strong>：相比简单的锁机制，MVCC实现更加复杂</p>
</li>
<li><p><strong>不解决所有问题</strong>：如幻读问题需要结合其他机制解决（如InnoDB的间隙锁）</p>
</li>
</ul>
</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>思想：<ul>
<li>不是直接读最新数据，也不是直接修改原数据，而是：<ul>
<li>写操作：创建新版本，旧数据保留（通过 Undo Log）</li>
<li>读操作：根据事务的 ReadView，找到一个对当前事务“可见”的数据版本（可能是旧数据）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>多版本数据：每行记录有多个版本</p>
<ol>
<li><p>在 InnoDB 中，数据行（record）并不是一成不变的，而是会随着更新产生多个版本。每行数据包含几个关键的 隐藏字段（Metadata Fields）：</p>
<table>
<thead>
<tr>
<th align="left">隐藏字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DB_TRX_ID</strong></td>
<td align="left">最后一次修改（INSERT&#x2F;UPDATE）该行的事务 ID</td>
</tr>
<tr>
<td align="left"><strong>DB_ROLL_PTR</strong></td>
<td align="left">指向该行上一个版本（旧数据）的指针，存放在 Undo Log 中</td>
</tr>
<tr>
<td align="left"><strong>DB_ROW_ID</strong>（可选）</td>
<td align="left">如果表没有主键，InnoDB 会自动生成一个行 ID</td>
</tr>
</tbody></table>
<blockquote>
<p>每当一个事务对某行数据进行 更新（UPDATE） 时：</p>
<ul>
<li>不会直接覆盖原数据</li>
<li>而是先将旧数据写入 Undo Log（回滚日志）</li>
<li>然后插入新数据（或原地更新），并更新 DB_TRX_ID 为当前事务 ID</li>
<li>通过 DB_ROLL_PTR 可以找到该行的旧版本，形成版本链</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>Undo Log（回滚日志）：保存旧版本数据</strong></p>
<ol>
<li><p>Undo Log 是 InnoDB 用来支持事务回滚和 MVCC 的重要日志。</p>
</li>
<li><p>每当一个事务修改了某行数据，InnoDB 会：</p>
<ul>
<li>把修改前的旧数据（即被覆盖前的值）保存到 Undo Log</li>
<li>这些旧数据 不会被立即删除，而是会保留一段时间，用于：事务回滚（Rollback）MVCC 中为其他事务提供历史版本数据（读一致性）</li>
</ul>
<blockquote>
<p>MVCC 利用 Undo Log 实现了“数据的多版本存储”。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>ReadView（读视图）：决定事务能看见哪些版本</strong></p>
<ol>
<li><p>当一个事务执行 SELECT（读操作） 时，InnoDB 不会直接读取最新数据，而是根据一个叫 ReadView 的东西，决定当前事务应该看到哪个版本的数据。</p>
</li>
<li><p>什么时候生成 ReadView？</p>
</li>
</ol>
<blockquote>
<p>在事务执行读操作（如 SELECT）时生成，用于控制该事务的“数据可见性”。</p>
</blockquote>
<ol start="3">
<li>ReadView 包含的关键信息：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">m_ids</td>
<td align="left">当前 活跃的（未提交）事务 ID 列表（即还有哪些事务没提交，可能修改了数据）</td>
</tr>
<tr>
<td align="left">min_trx_id</td>
<td align="left">当前所有活跃事务中的最小事务 ID</td>
</tr>
<tr>
<td align="left">max_trx_id</td>
<td align="left">系统即将分配给下一个事务的 ID（当前最大事务 ID + 1）</td>
</tr>
<tr>
<td align="left">creator_trx_id</td>
<td align="left">当前事务自己的 ID</td>
</tr>
</tbody></table>
<hr>
<ol start="4">
<li><p>可见性判断规则（核心！）：</p>
<ol>
<li><p>当一个事务要读取某条数据时，InnoDB 不是直接读取磁盘上的最新数据，而是：</p>
<ol>
<li>找到该数据行的<strong>最新版本</strong>；</li>
<li>根据 <strong>Read View 的规则</strong>，判断这个版本是否对当前事务<strong>可见</strong>；</li>
<li>如果不可见，则顺着 <code>DB_ROLL_PTR</code>找上一个版本，再次判断，直到找到一个<strong>对当前事务可见的版本</strong>，或者没有更多版本可找。</li>
</ol>
<p>这个过程就是 <strong>“多版本读取”</strong>，也就是 MVCC 的核心。</p>
</li>
<li><p>对于某行数据的 DB_TRX_ID（最后修改它的事务 ID），InnoDB 通过以下规则判断当前事务是否能“看到”这个版本：</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">是否可见</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID &#x3D;&#x3D; creator_trx_id（是自己修改的）</td>
<td align="left">✅ 可见</td>
<td align="left">自己事务修改的数据，当然可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID &lt; min_trx_id（比所有活跃事务都早）</td>
<td align="left">✅ 可见</td>
<td align="left">该数据在事务开始前已提交</td>
</tr>
<tr>
<td align="left">min_trx_id ≤ DB_TRX_ID &lt; max_trx_id，且 DB_TRX_ID ∉ m_ids（已提交事务）</td>
<td align="left">✅ 可见</td>
<td align="left">该事务已提交，数据可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID ≥ max_trx_id 或 DB_TRX_ID ∈ m_ids（未提交或之后的事务）</td>
<td align="left">❌ 不可见</td>
<td align="left">该事务还未提交，或比当前事务晚，数据不可见</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 如果当前版本不可见，就通过 DB_ROLL_PTR 找到更早的版本，继续判断，直到找到一个可见的版本为止。</p>
</blockquote>
</li>
</ol>
<h4 id="Read-View-是什么时候生成的？"><a href="#Read-View-是什么时候生成的？" class="headerlink" title="Read View 是什么时候生成的？"></a>Read View 是什么时候生成的？</h4><ul>
<li><p>Read View 是在事务进行“快照读”（如普通 SELECT）时生成的，而不是所有的 SELECT 都会生成。</p>
<p>具体来说：</p>
<ul>
<li>对于普通的 SELECT（一致性非锁定读，快照读）：会生成一个 Read View，根据该视图去读取符合条件的“历史版本数据”。</li>
<li>对于加锁的 SELECT（如 SELECT … FOR UPDATE &#x2F; LOCK IN SHARE MODE）：属于当前读（锁定读），不会使用 MVCC，而是直接读最新的数据，并加锁。</li>
</ul>
</li>
</ul>
<h4 id="在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？"><a href="#在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？" class="headerlink" title="在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？"></a>在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？</h4><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">Read View 生成时机</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RC（Read Committed，读已提交）</strong></td>
<td align="left"><strong>每次执行快照读（普通 SELECT）时都会生成一个新的 Read View</strong></td>
<td align="left">因此每次读都基于<strong>当前最新已提交的数据</strong>，可能读到其他事务已提交的新数据，导致<strong>不可重复读</strong>。</td>
</tr>
<tr>
<td align="left"><strong>RR（Repeatable Read，可重复读）</strong></td>
<td align="left"><strong>仅在事务中第一次执行快照读时生成一个 Read View，后续复用该 View</strong></td>
<td align="left">因此在整个事务中，读到的数据都是基于事务开始时（或第一次读时）的快照，保证多次读取结果一致，解决<strong>不可重复读</strong>。</td>
</tr>
</tbody></table>
<h4 id="MySQL-的-RR-级别解决了幻读问题吗？"><a href="#MySQL-的-RR-级别解决了幻读问题吗？" class="headerlink" title="MySQL 的 RR 级别解决了幻读问题吗？"></a>MySQL 的 RR 级别解决了幻读问题吗？</h4><ol>
<li><p>RR 级别是否解决了幻读？</p>
<p><strong>答案是：MySQL 的 RR 级别，通过 MVCC + Gap Lock &#x2F; Next-Key Lock 的组合，实际上已经解决了幻读问题！</strong></p>
<p>但是要注意：</p>
<ul>
<li><strong>单纯依靠 MVCC（多版本控制）是无法解决幻读的！</strong></li>
<li><strong>真正解决幻读，靠的是 InnoDB 的锁机制：Gap Lock（间隙锁）和 Next-Key Lock（临键锁）！</strong></li>
</ul>
<hr>
</li>
<li><p>InnoDB 如何通过锁解决幻读？</p>
<p>在 <strong>RR 级别下</strong>，InnoDB 对于<strong>范围查询</strong>会使用：</p>
<ul>
<li><strong>Next-Key Lock &#x3D; Record Lock（记录锁） + Gap Lock（间隙锁）</strong></li>
</ul>
<ol>
<li>Record Lock（记录锁）：</li>
</ol>
<p>锁住<strong>索引记录本身</strong>，比如某条 id&#x3D;10 的记录。</p>
<ol start="2">
<li>Gap Lock（间隙锁）：</li>
</ol>
<p>锁住<strong>索引记录之间的间隙</strong>，防止其他事务在这个间隙中<strong>插入新的数据</strong>。</p>
<ol start="3">
<li>Next-Key Lock：</li>
</ol>
<p>是两者的组合，既锁住记录本身，也锁住该记录前面的间隙。例如，对索引范围 (5, 10] 加 Next-Key Lock，意味着：</p>
<ul>
<li>锁住了索引值 10 这条记录（Record Lock）</li>
<li>同时锁住了 (5, 10) 这个区间，防止插入 id&#x3D;6~9 的新数据（Gap Lock）</li>
</ul>
<hr>
</li>
<li><p>举例说明幻读的避免</p>
<p>假设表中有 id 为 1, 5, 10 的记录，事务 A 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id &gt; 5 AND id &lt; 15 FOR UPDATE;</span><br></pre></td></tr></table></figure>


<p>在 RR 级别下，InnoDB 会对 id &gt;5 且 &lt;15 的<strong>范围加上 Next-Key Lock</strong>，包括：</p>
<ul>
<li>记录锁：id&#x3D;10</li>
<li>间隙锁：(5,10), (10,15)</li>
</ul>
<p>此时，如果另一个事务 B 尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t (id) VALUES (7);   -- 会被阻塞，因为 (5,10) 被锁</span><br><span class="line">INSERT INTO t (id) VALUES (12);  -- 会被阻塞，因为 (10,15) 被锁</span><br></pre></td></tr></table></figure>


<p>这样就<strong>防止了其他事务插入“幻影行”</strong>，从而避免了幻读。</p>
</li>
</ol>
<h3 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a>索引覆盖是什么</h3><ol>
<li>索引覆盖：指的是当查询所需的所有列都包含在索引中时，数据库可以直接从索引中获取所需数据，而无需回表查询数据行。</li>
<li>索引覆盖的工作原理<ol>
<li>普通查询流程（无索引覆盖）<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行位置（如主键值）</li>
<li><strong>回表查询</strong>：根据索引提供的位置信息，再到数据表（聚簇索引）中查找完整的行数据</li>
<li><strong>返回结果</strong>：从完整行数据中提取所需的列<ul>
<li>这个过程需要<strong>两次查找操作</strong>：一次在索引上，一次在数据表上。</li>
</ul>
</li>
</ol>
</li>
<li>索引覆盖查询流程<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行</li>
<li><strong>直接从索引获取数据</strong>：因为所需的所有列都包含在索引中，直接从索引结构中提取数据</li>
<li><strong>返回结果</strong>：无需访问数据表<ul>
<li>这个过程只需要<strong>一次查找操作</strong>，且数据来源是更轻量的索引结构。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><ol>
<li><p>是什么</p>
<ol>
<li>EXPLAIN 是 MySQL 提供的一个 SQL 命令，<strong>用于显示 MySQL 如何执行 SQL 语句的执行计划</strong>。通过 EXPLAIN，你可以看到查询优化器选择的执行路径、使用的索引、连接类型、数据读取方式等关键信息。</li>
</ol>
</li>
<li><p>作用</p>
<ol>
<li>分析查询性能瓶颈</li>
<li>查看索引使用情况</li>
<li>理解查询执行策略</li>
<li>优化 SQL 语句</li>
<li>预测查询性能</li>
</ol>
</li>
<li><p>explain的基础列详解</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">数据类型</th>
<th align="left">说明</th>
<th align="left">重要解读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>id</strong></td>
<td align="left">int</td>
<td align="left">SELECT 查询的标识符</td>
<td align="left">表示查询中 SELECT 语句的执行顺序。id相同，执行顺序从上往下；id不同，数值越大越先执行</td>
</tr>
<tr>
<td align="left"><strong>select_type</strong></td>
<td align="left">varchar</td>
<td align="left">查询类型</td>
<td align="left">表明查询是简单查询还是复杂查询，如 SIMPLE(简单SELECT)、PRIMARY(最外层SELECT)、SUBQUERY(子查询)、DERIVED(派生表)等</td>
</tr>
<tr>
<td align="left"><strong>table</strong></td>
<td align="left">varchar</td>
<td align="left">访问的表名</td>
<td align="left">显示这一行数据是关于哪张表的，可能是表名、别名、派生表或临时表</td>
</tr>
<tr>
<td align="left"><strong>partitions</strong></td>
<td align="left">varchar</td>
<td align="left">匹配的分区</td>
<td align="left">对于分区表，显示查询访问了哪些分区，非分区表通常为NULL</td>
</tr>
<tr>
<td align="left"><strong>type</strong></td>
<td align="left">varchar</td>
<td align="left">访问类型</td>
<td align="left"><strong>查询性能关键指标</strong>，表示MySQL在表中找到所需行的方式，从好到坏：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td>
</tr>
<tr>
<td align="left"><strong>possible_keys</strong></td>
<td align="left">varchar</td>
<td align="left">可能使用的索引</td>
<td align="left">查询优化器可能考虑使用哪些索引来查找表中的行，但不一定实际使用，若为NULL表示没有可用索引</td>
</tr>
<tr>
<td align="left"><strong>key</strong></td>
<td align="left">varchar</td>
<td align="left">实际使用的索引</td>
<td align="left">查询优化器实际选择的索引，若为NULL则表示没有使用索引，显示的是索引名称</td>
</tr>
<tr>
<td align="left"><strong>key_len</strong></td>
<td align="left">int</td>
<td align="left">使用的索引长度(字节)</td>
<td align="left">显示使用的索引字段的长度，可以帮助判断使用了索引的哪些部分，数值越小通常越好</td>
</tr>
<tr>
<td align="left"><strong>ref</strong></td>
<td align="left">varchar</td>
<td align="left">索引参考列</td>
<td align="left">显示索引的哪一列被使用了，或者常量值，如 const、func、NULL 或列名</td>
</tr>
<tr>
<td align="left"><strong>rows</strong></td>
<td align="left">int</td>
<td align="left">预估扫描行数</td>
<td align="left"><strong>查询性能关键指标</strong>，MySQL估计为了找到所需的行而要读取的行数，数值越小越好，是优化器估算值</td>
</tr>
<tr>
<td align="left"><strong>filtered</strong></td>
<td align="left">decimal(5,2)</td>
<td align="left">过滤百分比</td>
<td align="left">存储引擎返回的数据在server层过滤后，还剩余多少比例(百分比)，值越高越好，MySQL 5.7+引入</td>
</tr>
<tr>
<td align="left"><strong>Extra</strong></td>
<td align="left">varchar</td>
<td align="left">额外信息</td>
<td align="left"><strong>查询性能关键信息</strong>，包含不适合在其他列中显示但十分重要的额外信息，如 Using index、Using where、Using temporary 等</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><ol>
<li>是什么<ol>
<li><strong>最左前缀原则</strong>指的是：<strong>对于复合索引（包含多个列的索引），查询必须使用索引的最左列（第一个列）才能使用该索引</strong>，并且查询条件中的列顺序必须与索引列定义顺序相匹配，从最左边的列开始连续使用。</li>
<li>换句话说，如果有一个复合索引是 <code>(A, B, C)</code>，那么：<ul>
<li>查询条件必须<strong>从A列开始</strong>使用并<strong>保持相对顺序</strong></li>
<li>可以使用 <ul>
<li><code>(A)</code>、<code>(A, B)</code>、<code>(A, B, C)</code>、<code>(A, C)</code></li>
</ul>
</li>
<li>不能使用<ul>
<li><code>(B, C)</code>、<code>(A, C, B)</code>、<code>(B, A)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h3><ul>
<li>MyISAM和InnoDB是MySQL数据库中两种最重要的存储引擎，它们在架构设计、功能特性和适用场景上有显著区别</li>
<li><strong>存储引擎（Storage Engine）<strong>是MySQL中用于</strong>管理数据存储和检索的底层软件组件</strong>。它负责数据的存储、读取、索引管理、事务处理等核心功能。MySQL采用<strong>插件式架构</strong>，允许使用不同的存储引擎来处理不同的表。</li>
<li>InnoDB是更先进的存储引擎。一般来说，只推荐用InnoDB。</li>
</ul>
<h3 id="为什么MySQL要用B-树而不用B树"><a href="#为什么MySQL要用B-树而不用B树" class="headerlink" title="为什么MySQL要用B+树而不用B树"></a>为什么MySQL要用B+树而不用B树</h3><ol>
<li><strong>更低的树高度</strong>：B+树通过只在非叶子节点存储索引键，可以容纳更多键值，大大减少树的高度，进而减少磁盘I&#x2F;O次数，提高查询效率</li>
<li><strong>更高效的范围查询</strong>：B+树的叶子节点通过指针连接形成有序链表，使得<strong>范围查询（如BETWEEN、&gt;、&lt;）和排序操作（ORDER BY）非常高效</strong></li>
<li>更高的存储密度：B+树的非叶子节点不存储实际数据，可以存储更多索引键，即更高的扇出，使得每个节点能容纳更多信息，进一步降低树的高度</li>
<li><strong>更稳定的查询性能</strong>：所有查询都必须到达叶子节点，使得查询路径长度完全一致，提供更稳定和可预测的查询性能</li>
<li>更适合数据库特性：B+树的结构与数据库的读多写少、需要高效范围查询、排序和稳定性能的需求高度契合</li>
<li>与InnoDB实现完美配合：特别是聚簇索引设计和磁盘页优化，使得B+树在MySQL中能够发挥最大效能</li>
</ol>
<h3 id="MySQL的锁有哪些"><a href="#MySQL的锁有哪些" class="headerlink" title="MySQL的锁有哪些"></a>MySQL的锁有哪些</h3><ol>
<li><p>按锁的粒度分类</p>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全局锁</strong></td>
<td align="left">锁定整个数据库实例</td>
<td align="left">简单粗暴，保证全局一致性</td>
<td align="left">性能影响极大，几乎锁住所有操作</td>
<td align="left">全库备份、全库数据迁移</td>
</tr>
<tr>
<td align="left"><strong>表级锁</strong></td>
<td align="left">锁定整张表</td>
<td align="left">实现简单，开销小，加锁快</td>
<td align="left">并发度低，锁冲突概率高</td>
<td align="left">MyISAM引擎、DDL操作、批量数据操作</td>
</tr>
<tr>
<td align="left"><strong>行级锁</strong></td>
<td align="left">只锁定需要操作的行</td>
<td align="left">并发度高，冲突概率低</td>
<td align="left">实现复杂，开销大，加锁慢</td>
<td align="left">InnoDB引擎、高并发OLTP系统</td>
</tr>
</tbody></table>
</li>
<li><p>按锁的性质分类</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>共享锁(S锁，Shared Lock)</strong></td>
<td align="left">读锁，多个事务可同时持有</td>
<td align="left">允许其他事务读取，但禁止写入</td>
<td align="left">读操作、需要数据不被修改的场景</td>
</tr>
<tr>
<td align="left"><strong>排他锁(X锁，Exclusive Lock)</strong></td>
<td align="left">写锁，一次只能由一个事务持有</td>
<td align="left">禁止其他事务读取和写入</td>
<td align="left">写操作、数据修改场景</td>
</tr>
<tr>
<td align="left"><strong>意向锁</strong></td>
<td align="left">表级锁，表明事务打算在表中的行上获取什么类型的锁</td>
<td align="left">提高表级锁和行级锁的兼容性判断效率</td>
<td align="left">InnoDB引擎内部使用</td>
</tr>
</tbody></table>
<ol>
<li>意向锁是表级锁。当读或写某一行时，会给对应的表加上IS或IX锁。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ol>
<li>惰性删除：<ol>
<li>原理：访问某个Key时检查是否过期</li>
<li>优点：CPU友好，节省了CPU资源</li>
<li>缺点：大量过期的Key没有被访问，占内存资源</li>
</ol>
</li>
<li>定期删除：<ol>
<li>原理：每隔一段时间，扫描一部分Key，删除过期键</li>
</ol>
</li>
<li>定时过期：<ol>
<li>原理：给Key设置定时过期删除的属性</li>
</ol>
</li>
</ol>
<h3 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h3><ol>
<li><p>实现流程</p>
<ol>
<li>事务开始<ol>
<li><code>MULTI</code>启动事务模式（flag属性打开REDIS_MULTI标识）</li>
</ol>
</li>
<li>命令入队<ol>
<li>除了<code>DISCADE</code>,<code>WATCH</code>,<code>EXEC</code>等少数命令会立即执行外，其他命令都是入队。</li>
<li>入队时会检查语法错误。如果有语法问题，则终止事务（flag属性关闭REDIS_MULTI标识）</li>
</ol>
</li>
<li>事务执行<ol>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性如何实现？Redis没有回滚机制，是否破坏了原子性？</p>
<ol>
<li><p>我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断</p>
</li>
<li><p>在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性</p>
</li>
<li><p>虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。</p>
</li>
<li><p>并且运行时错误多为编程错误，可以避免。</p>
</li>
<li><p>一致性如何实现？</p>
<ol>
<li><strong>内部一致性：</strong> Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。</li>
<li><strong>事务隔离性：</strong> <code>I</code> 的保证间接支撑了 <code>C</code>，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。</li>
</ol>
</li>
<li><p>隔离性如何实现？</p>
<ol>
<li>Redis 对隔离性的保证是<strong>非常强大</strong>的，因为它基于单线程模型。</li>
<li>保证方式： Redis 使用 <strong>单线程</strong> 模型处理所有客户端请求（除了后台的持久化操作）。</li>
<li>结果： <code>MULTI</code>&#x2F;<code>EXEC</code> 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。</li>
<li>总结： <strong>Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><p>持久性如何实现？</p>
<ol>
<li><p>Redis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，<strong>默认情况下持久性是有风险的</strong>。</p>
<ol>
<li><p>Redis 主要通过两种方式实现持久性：</p>
<ol>
<li><strong>AOF (Append Only File) 模式：</strong><ol>
<li>将所有写命令以日志形式追加到文件中。</li>
<li>如果配置了 <code>always</code> 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。</li>
<li>但为了性能，通常配置为 <code>everysec</code>（每秒同步一次），这意味着最近一秒内的数据可能会丢失。</li>
</ol>
</li>
<li><strong>RDB (Redis Database) 快照模式：</strong><ol>
<li>定期将内存中的数据生成一个二进制快照文件。</li>
<li>由于是<strong>定期</strong>快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>总结：</strong> Redis 的持久性是<strong>可配置的</strong>。只有在启用 AOF 并设置为 <code>always</code> 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h3><ul>
<li>RDB，AOF</li>
</ul>
<h3 id="分布式锁底层怎么实现的"><a href="#分布式锁底层怎么实现的" class="headerlink" title="分布式锁底层怎么实现的"></a>分布式锁底层怎么实现的</h3><ul>
<li><p>使用 Redis 的 <code>SET key value NX PX timeout</code>命令，来实现：</p>
<ul>
<li><strong>互斥性（Mutual Exclusion）</strong>：同一时刻只有一个客户端能成功设置锁</li>
<li><strong>避免死锁</strong>：锁必须要有过期时间，防止客户端崩溃后锁永远不释放</li>
<li><strong>锁的释放必须是原子的且只能由加锁者释放</strong>：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁</li>
</ul>
</li>
</ul>
<h3 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h3><ul>
<li>主从复制，哨兵模式，集群模式</li>
</ul>
<h3 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h3><h3 id="Redis与MySQL如何保证数据的一致性"><a href="#Redis与MySQL如何保证数据的一致性" class="headerlink" title="Redis与MySQL如何保证数据的一致性"></a>Redis与MySQL如何保证数据的一致性</h3><ol>
<li><p>为什么会不一致</p>
<ol>
<li><p>在常见的 <strong>“先更新数据库，再更新缓存” 或 “先删缓存，再更新数据库”</strong> 等策略中，如果操作顺序、并发控制不当，就可能出现以下情况：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">说明</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 程序 Bug 或异常</strong></td>
<td align="left">更新了数据库，但忘记更新&#x2F;删除缓存</td>
<td align="left">缓存是旧数据，与数据库不一致</td>
</tr>
<tr>
<td align="left"><strong>2. 并发读写</strong></td>
<td align="left">一个线程在更新数据库和缓存的过程中，另一个线程读了旧的缓存或写入了脏数据</td>
<td align="left">缓存与数据库数据出现偏差</td>
</tr>
<tr>
<td align="left"><strong>3. 崩溃或中断</strong></td>
<td align="left">在更新数据库和缓存之间服务崩溃，导致两者状态不一致</td>
<td align="left">缓存和数据库“数据分裂”</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>常用策略</p>
<ol>
<li><p>延时双删策略（Double Delete）</p>
<ol>
<li>为了解决 并发导致的脏数据回填问题，可以采用 双删策略，即在写操作的以下时机删除缓存：<ol>
<li>写操作之前，先删除一次缓存</li>
<li>更新数据库</li>
<li>延迟一段时间（如几百毫秒），再删除一次缓存</li>
</ol>
</li>
<li>为什么延迟删除？<ul>
<li>因为在更新数据库的过程中，可能有其他线程读了旧数据并回填了缓存，延迟删除可以尽量把这种脏缓存清除掉</li>
</ul>
</li>
<li>实现方式：<ul>
<li>可以使用 Java 的 <code>ScheduledExecutorService</code>、<code>Thread.sleep()</code>，或者消息队列延迟消费等方式实现“延迟删除”</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ 适合对一致性要求稍高一点的业务，但仍有 极小概率的不一致窗口期</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h3><ol>
<li><p><strong>基于内存操作（最重要原因）</strong></p>
<blockquote>
<p>Redis 的数据是存储在<strong>内存中的</strong>，内存的访问速度是纳秒级别（约 100ns），相比磁盘（毫秒级）快几个数量级。</p>
</blockquote>
<ul>
<li>操作内存比操作磁盘或数据库快得多，不需要磁盘 I&#x2F;O、不需要复杂的事务日志、不需要锁等待。</li>
<li>所有的读写操作几乎都是在内存中瞬间完成，这是 Redis 高性能的<strong>最核心原因</strong>。</li>
</ul>
<hr>
</li>
<li><p><strong>单线程避免了多线程的锁竞争和上下文切换</strong></p>
<ul>
<li>在多线程模型中，多个线程访问共享数据时需要加锁（如互斥锁、读写锁），这会带来：<ul>
<li>锁竞争</li>
<li>线程切换开销</li>
<li>死锁风险</li>
<li>编程复杂度高</li>
</ul>
</li>
<li>Redis 采用单线程模型，<strong>所有命令串行执行，无需考虑并发安全问题，没有锁竞争，也没有线程切换的开销</strong>，所以执行效率极高。</li>
</ul>
<blockquote>
<p>✅ 单线程 &#x3D; 无锁 &#x3D; 无竞争 &#x3D; 更简单、更高效</p>
</blockquote>
<hr>
</li>
<li><p><strong>优秀的数据结构与高性能底层实现</strong></p>
<p>Redis 提供了多种<strong>高效的数据结构</strong>（如 String、Hash、List、Set、ZSet 等），并且这些数据结构在底层使用了非常高效的实现方式，比如：</p>
<ul>
<li>ziplist、quicklist、哈希表优化、跳表（SkipList）等</li>
<li>所有数据结构的操作都经过高度优化，使得命令执行非常快速</li>
</ul>
<hr>
</li>
<li><p><strong>I&#x2F;O 多路复用模型（核心网络模型）</strong></p>
<ol>
<li><p>Redis 使用了 <strong>I&#x2F;O 多路复用技术（如 epoll、kqueue、select）</strong> 来处理大量的并发连接，这是它支撑高并发的关键。</p>
</li>
<li><p>什么是 I&#x2F;O 多路复用？</p>
<ul>
<li><p>允许 <strong>一个线程同时监听多个 Socket 连接</strong> 的读写事件</p>
</li>
<li><p>当某个连接有数据可读&#x2F;可写时，Redis 才去处理这个连接</p>
</li>
<li><p>避免了为每个连接创建一个线程，极大节省了系统资源</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ Redis 通过 <strong>单线程 + I&#x2F;O 多路复用</strong>，就能高效处理数万甚至数十万的并发连接，而不会线程爆炸。</p>
</blockquote>
<hr>
</li>
<li><p><strong>Redis 命令执行是原子性的，无需额外同步</strong></p>
<ul>
<li>每个 Redis 命令都是<strong>原子操作</strong>，比如 INCR、LPUSH 等，执行过程中不会被其他命令打断。</li>
<li>因为是单线程，所以也<strong>不需要加锁来保证原子性</strong>，执行效率高，逻辑简单。</li>
</ul>
<hr>
</li>
<li><p><strong>Redis 是专门为高性能场景设计的网络存储中间件</strong></p>
<ul>
<li>Redis 的代码是<strong>用 C 语言编写的，非常接近底层，运行效率极高</strong></li>
<li>没有复杂的企业级框架、没有冗余的中间层，整个系统非常轻量、高效</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>基于内存，读写极快</strong></td>
<td align="left">数据在内存中，访问速度是纳秒级</td>
</tr>
<tr>
<td align="left">✅ <strong>单线程，无锁，无竞争</strong></td>
<td align="left">不需要考虑并发安全，没有锁开销，执行路径简单</td>
</tr>
<tr>
<td align="left">✅ <strong>I&#x2F;O 多路复用，高并发支持好</strong></td>
<td align="left">单线程可处理几万甚至几十万的并发连接</td>
</tr>
<tr>
<td align="left">✅ <strong>命令执行是原子的</strong></td>
<td align="left">无需加锁，执行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>代码精简高效</strong></td>
<td align="left">C 语言实现，无复杂框架，运行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>扩展性强（Redis 6.0+ 多线程 I&#x2F;O）</strong></td>
<td align="left">网络读写利用多核，进一步提升性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">局限性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>CPU 密集型任务可能阻塞</strong></td>
<td align="left">如果某个命令执行特别耗时（如 KEYS *、大 Key 操作、复杂 Lua 脚本），会阻塞整个主线程，影响其他请求</td>
</tr>
<tr>
<td align="left">❌ <strong>无法充分利用多核 CPU（命令执行层面）</strong></td>
<td align="left">命令执行仍然是单线程的，不能发挥多核优势（但网络 I&#x2F;O 可以，Redis 6.0+）</td>
</tr>
<tr>
<td align="left">❌ <strong>对单个大 Key 或慢查询敏感</strong></td>
<td align="left">一个慢命令可能拖慢整个服务</td>
</tr>
</tbody></table>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><ol>
<li><p>三次握手</p>
<ol>
<li><p>确保客户端和服务器双方的 <strong>发送和接收能力正常</strong>，并 <strong>同步双方的初始序列号（ISN, Initial Sequence Number）</strong>，为后续可靠数据传输做准备。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>SYN &#x3D; 1, seq &#x3D; x</strong></td>
<td align="left">客户端向服务端发起连接请求，随机生成一个初始序列号 x，表示“我想和你建立连接”。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; y, ack &#x3D; x + 1</strong></td>
<td align="left">服务端收到请求后，同意建立连接，也随机生成一个初始序列号 y，并确认客户端的序号 x+1（ACK &#x3D; x + 1）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, seq &#x3D; x + 1, ack &#x3D; y + 1</strong></td>
<td align="left">客户端收到服务端的同意后，再发送一个确认报文，确认服务端的序号 y+1。此时连接建立成功。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>四次挥手</p>
<ol>
<li><p>由于 TCP 是<strong>全双工</strong>的（即双方可以同时发送和接收数据），因此<strong>每个方向上的数据传输都需要单独关闭</strong>，所以需要四次挥手来确保双方都完成数据发送并安全关闭连接。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; u</strong></td>
<td align="left">客户端 A 发送 FIN 报文，表示“我不再发送数据了，但还可以接收”。进入 <strong>FIN_WAIT_1</strong> 状态。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; u + 1</strong></td>
<td align="left">服务端 B 收到后，发送 ACK 确认，表示“我知道你不想发了，但我可能还有数据要发给你”。A 进入 <strong>FIN_WAIT_2</strong>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">B → A</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; v</strong></td>
<td align="left">服务端 B 处理完剩余数据后，也发送 FIN 报文，表示“我也不再发送数据了”。进入 <strong>LAST_ACK</strong> 状态。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; v + 1</strong></td>
<td align="left">客户端 A 收到后，发送最后的 ACK 确认。B 收到后关闭连接。A 等待一段时间（2MSL）后也关闭连接。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="浏览器发出一个请求到收到响应经历了那些过程"><a href="#浏览器发出一个请求到收到响应经历了那些过程" class="headerlink" title="浏览器发出一个请求到收到响应经历了那些过程"></a>浏览器发出一个请求到收到响应经历了那些过程</h3><ol>
<li>URL 解析</li>
<li>DNS 查询（域名 → IP 地址）</li>
<li>建立 TCP 连接（三次握手）</li>
<li>如果是 HTTPS，进行 TLS 握手（加密通道建立）</li>
<li>发送 HTTP 请求（浏览器 → 服务器）</li>
<li>服务器处理请求并返回 HTTP 响应</li>
<li>浏览器解析 HTML 内容</li>
<li>请求并加载外部资源</li>
<li>页面渲染与显示</li>
</ol>
<h3 id="跨域请求是什么？有什么问题？怎么解决？"><a href="#跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="跨域请求是什么？有什么问题？怎么解决？"></a>跨域请求是什么？有什么问题？怎么解决？</h3><ol>
<li><p>是什么</p>
<ol>
<li><p>跨域请求：<strong>当前网页</strong>的域名、协议、端口中的任意一个与<strong>请求</strong>的目标资源不一致，导致浏览器出于安全考虑阻止该请求。</p>
</li>
<li><p>什么是“同源”？</p>
<ol>
<li>两个 URL 如果满足以下 <strong>三者完全相同</strong>，就属于<strong>同源（Same Origin）</strong>，否则就是<strong>跨域（Cross-Origin）</strong>：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">组成部分</th>
<th align="left">是否必须相同</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议（Protocol）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>http</code>vs <code>https</code>就不同源</td>
</tr>
<tr>
<td align="left"><strong>域名（Host）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>www.example.com</code>vs <code>api.example.com</code>不同源</td>
</tr>
<tr>
<td align="left"><strong>端口（Port）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>80</code>（HTTP默认） vs <code>443</code>（HTTPS默认） 或 <code>8080</code>不同源</td>
</tr>
</tbody></table>
</li>
<li><p>用一个场景来理解</p>
<ol>
<li><p>场景 1：前端和后端运行在不同的端口（开发时最常见！）</p>
<ul>
<li>你用 <strong>React &#x2F; Vue</strong> 写了一个前端项目，运行在：<code>http://localhost:3000</code>（前端页面）</li>
<li>你的 <strong>后端 API 服务</strong>（比如 Node.js、Java Spring、Python Django）运行在：<code>http://localhost:8080</code>或 <code>http://localhost:3001</code></li>
</ul>
</li>
<li><p>你前端代码中发起请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;http://localhost:8080/api/data&#x27;)</span><br></pre></td></tr></table></figure>

</li>
<li><p>会发生什么？</p>
<ul>
<li>请求确实发到了后端（你可以在后端看到请求日志），</li>
<li>但浏览器收到响应后一看：“咦？你前端是 <code>localhost:3000</code>，却去访问 <code>localhost:8080</code>，<strong>端口不同，属于跨域！</strong>”</li>
<li>于是浏览器就把响应拦下来了，你的 JavaScript 拿不到返回的数据！</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>有什么问题？举个例子</p>
</li>
<li><p>怎么解决</p>
<ol>
<li><p><strong>CORS（跨域资源共享，主流推荐方案）</strong></p>
<ol>
<li>CORS（Cross-Origin Resource Sharing） 是 W3C 标准，通过后端设置一些 HTTP 响应头，告诉浏览器：“这个跨域请求我是允许的”。</li>
<li>后端需要设置的常见响应头：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Access-Control-Allow-Origin: *</code>或 <code>http://your-frontend-domain.com</code></td>
<td align="left">表示允许哪些来源的网站访问资源。 <code>*</code>表示允许所有（不推荐在生产用，尤其带 Cookie 时） 最好明确指定域名，如 <code>http://localhost:3000</code></td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</code></td>
<td align="left">允许的 HTTP 方法</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Headers: Content-Type, Authorization</code></td>
<td align="left">允许的请求头</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Credentials: true</code></td>
<td align="left">是否允许发送 Cookie（需前端也设置 <code>withCredentials: true</code>）</td>
</tr>
</tbody></table>
<ol start="3">
<li>后端示例（以 Node.js&#x2F;Express 为例）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:3000&quot;</span>); <span class="comment">// 或 *</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, PUT, DELETE&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type, Authorization&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 如需传 cookie</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>✅ 只要后端正确配置了 CORS 头，浏览器就允许跨域请求！</p>
</blockquote>
<ol start="2">
<li><p><strong>代理服务器（Proxy）【开发常用】</strong></p>
<ol>
<li><p>在开发环境中，前端代码和后端 API 往往不在一个域，但你可以：</p>
<ol>
<li>通过 webpack devServer、vite、nginx 等设置代理，将前端发出的请求转发到目标 API 服务器，从而<strong>避免浏览器直接跨域</strong></li>
<li>反向代理的核心作用就是：让前端和后端都使用同一个域名和端口（比如 <code>http://localhost:3000</code>或 <code>https://www.yoursite.com</code>），让浏览器认为它访问的就是同源的资源，从而避免跨域问题。</li>
</ol>
</li>
<li><p>例子：Vue&#x2F;React 开发时配置代理（以 vite &#x2F; webpack 为例）</p>
<p>vite.config.js 或 webpack.config.js 中配置代理：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line">export <span class="keyword">default</span> <span class="title function_">defineConfig</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">  server: &#123;</span></span><br><span class="line"><span class="params">    proxy: &#123;</span></span><br><span class="line"><span class="params">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span></span><br><span class="line"><span class="params">        target: <span class="string">&#x27;http://backend-api-server.com&#x27;</span>, // 后端真实地址</span></span><br><span class="line"><span class="params">        changeOrigin: <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">        rewrite: (path)</span> =&gt; path.replace(/^\/api/, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>这样，前端代码中请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;/api/user&#x27;)  // 不是跨域！代理服务器会转发到 http://backend-api-server.com/user</span><br></pre></td></tr></table></figure>


<p>优点：前端无需关心跨域，由代理服务器解决</p>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在讲 <strong>反向代理</strong> 之前，先简单了解一下什么是 <strong>代理（Proxy）</strong>。</p>
<ol>
<li><p><strong>正向代理（Forward Proxy）</strong></p>
<ol>
<li><p>正向代理 是位于 客户端（用户） 和 互联网 之间的代理，代表客户端去访问服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>访问被墙的网站（比如通过代理服务器访问 Google）</p>
</li>
<li><p>隐藏客户端的真实 IP</p>
</li>
<li><p>企业内网上网控制</p>
</li>
</ul>
</li>
<li><p>谁用代理：客户端（用户）主动设置代理</p>
</li>
<li><p>举例：</p>
<ol>
<li>你（客户端）想访问某个网站，但不想直接暴露自己，于是你通过一个代理服务器去访问，代理帮你请求网站，再将结果返回给你。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>反向代理（Reverse Proxy）</strong></p>
<ol>
<li><p>反向代理：是位于 客户端（用户） 和 后端服务器（如你的应用服务器） 之间的代理，代表服务器接收客户端的请求，并将其转发给内部的服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>保护后端服务，隐藏其真实 IP 和端口</p>
</li>
<li><p>实现 负载均衡</p>
</li>
<li><p>提供 统一入口（比如通过域名访问多个服务）</p>
</li>
<li><p>处理 SSL&#x2F;TLS 加密（HTTPS）</p>
</li>
<li><p>缓存、压缩、静态文件服务</p>
</li>
<li><p>实现 反向代理路由（如根据路径转发到不同后端）</p>
</li>
</ul>
</li>
<li><p>谁用代理：是服务器端设置的，对客户端透明（不可见）</p>
</li>
<li><p>意义</p>
<ol>
<li><p>隐藏后端服务的真实 IP 和端口</p>
<ul>
<li>用户只访问 <code>https://www.yourdomain.com</code>，不知道后端是运行在哪个端口或机器上的。</li>
<li>提升安全性，避免直接将后端服务暴露在公网。</li>
</ul>
</li>
<li><p>统一入口，多服务路由</p>
</li>
</ol>
<ul>
<li>你可以用 Nginx 将不同的请求路径转发到不同的后端服务，比如：<code>/api</code>→ Node.js 后端<code>/admin</code>→ Java 后台<code>/static</code>→ Nginx 直接返回静态文件</li>
</ul>
<ol start="3">
<li>负载均衡</li>
</ol>
<ul>
<li><p>将请求分发到多个后端实例，提高系统的可用性和性能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 127.0.0.1:3000;</span><br><span class="line">    server 127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>处理 HTTPS &#x2F; SSL 加密</li>
</ol>
<ul>
<li>你可以通过 Nginx 配置 SSL 证书，让用户通过 <code>https://</code>安全访问，而不用在后端服务里处理复杂的 HTTPS 配置。</li>
</ul>
<ol start="5">
<li>静态资源服务</li>
</ol>
<ul>
<li>Nginx 非常擅长快速返回 HTML、CSS、JS、图片等静态文件，比 Node.js 或 Java 服务效率更高。</li>
</ul>
<ol start="6">
<li>缓存、压缩、安全防护等高级功能</li>
</ol>
<ul>
<li>Nginx 还提供访问控制、防爬虫、GZIP 压缩、缓存、限流等能力。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><ol>
<li>为什么要了解零拷贝<ol>
<li>在传统的数据传输过程中，数据通常需要在 内存、CPU、内核缓冲区、用户缓冲区、网卡缓冲区 等多个地方多次 拷贝，并且伴随着多次 CPU 上下文切换，这样会带来很大的 性能开销。</li>
<li>而 零拷贝技术的核心目标就是：尽可能减少数据在内存中的拷贝次数，避免不必要的 CPU 拷贝和上下文切换，从而提升数据传输效率，降低延迟和 CPU 占用。</li>
</ol>
</li>
<li>什么是零拷贝<ol>
<li>零拷贝的核心思想是：<ol>
<li>尽量减少甚至避免数据在内存中的冗余拷贝，尤其是避免数据在 用户态 和 内核态 之间的 CPU 拷贝，从而提升性能</li>
<li>它并不一定意味着 完全没有数据拷贝（物理上可能还是会有 DMA 拷贝），而是 尽量减少 CPU 参与的拷贝次数，尤其是用户态与内核态之间的拷贝。</li>
</ol>
</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251025175854459.png" alt="image-20251025175854459"></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java开发生态学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li><p>目录结构：</p>
<ol>
<li><p><strong><code>/bin</code></strong></p>
<ul>
<li>存放常用的二进制可执行文件（命令），如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>cat</code>。</li>
<li>所有用户都可以使用。</li>
</ul>
</li>
<li><p><strong><code>/sbin</code></strong></p>
<ul>
<li>存放系统管理用的二进制程序，如 <code>reboot</code>、<code>ifconfig</code>。</li>
<li>一般由 root 管理员使用。</li>
</ul>
</li>
<li><p><strong><code>/boot</code></strong></p>
<ul>
<li>启动相关文件，比如内核 <code>vmlinuz</code>、引导程序 <code>grub</code> 配置。</li>
<li>系统开机时最先用到。</li>
</ul>
</li>
<li><p><strong><code>/dev</code></strong></p>
<ul>
<li>存放设备文件（不是实际的硬件，而是设备接口）。</li>
<li>比如 <code>/dev/sda</code>（硬盘）、<code>/dev/tty</code>（终端）、<code>/dev/null</code>。</li>
</ul>
</li>
<li><p><strong><code>/etc</code></strong></p>
<ul>
<li>存放系统配置文件，例如：<ul>
<li><code>/etc/passwd</code> 用户信息</li>
<li><code>/etc/fstab</code> 磁盘挂载</li>
<li><code>/etc/apt/</code> apt 软件源配置</li>
</ul>
</li>
<li>里面通常没有二进制程序，主要是文本配置文件。</li>
</ul>
</li>
<li><p><strong><code>/home</code></strong></p>
<ul>
<li>普通用户的主目录。</li>
<li>例如用户 <code>hua</code> 的主目录是 <code>/home/hua</code>，里面存放桌面、下载、配置等。</li>
</ul>
</li>
</ol>
</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SSM学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ul>
<li>不需要完整学习 Spring（特别是 XML 配置那一套）。</li>
<li>只需要补齐一些 Spring 的核心概念：<ul>
<li><strong>IoC&#x2F;DI（控制反转 &#x2F; 依赖注入）</strong></li>
<li><strong>Bean 生命周期与作用域</strong></li>
<li><strong>AOP（切面编程，事务、日志、权限）</strong></li>
<li><strong>Spring MVC 的基本原理（DispatcherServlet、HandlerMapping、Controller）</strong><br> 👉 这些都是 Spring Boot 底层依然在用的，你必须理解，不然看不懂它的自动装配。</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python核心库学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>NumPy（Numerical Python）是 Python 中一个强大的科学计算库，提供了高性能的多维数组对象（<code>ndarray</code>）以及大量的数学函数和操作工具，是许多其他科学计算库（如 SciPy、Pandas、Matplotlib 等）的基础。</p>
<p>下面是 NumPy 库的一些<strong>基本用法</strong>：</p>
<hr>
<h2 id="一、安装-NumPy"><a href="#一、安装-NumPy" class="headerlink" title="一、安装 NumPy"></a>一、安装 NumPy</h2><p>如果尚未安装 NumPy，可以使用 pip 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>


<hr>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">计算机网络八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">名称</th>
<th align="left">中文名</th>
<th align="left">主要功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>7</strong></td>
<td align="left">Application Layer</td>
<td align="left"><strong>应用层</strong></td>
<td align="left">直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）</td>
</tr>
<tr>
<td align="left"><strong>6</strong></td>
<td align="left">Presentation Layer</td>
<td align="left"><strong>表示层</strong></td>
<td align="left">数据格式转换、加密、解密、压缩、解压缩</td>
</tr>
<tr>
<td align="left"><strong>5</strong></td>
<td align="left">Session Layer</td>
<td align="left"><strong>会话层</strong></td>
<td align="left">建立、管理和终止会话（通信连接）</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">Transport Layer</td>
<td align="left"><strong>传输层</strong></td>
<td align="left">提供端到端的可靠传输（如 TCP、UDP，负责端口、分段、流量控制）</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left">Network Layer</td>
<td align="left"><strong>网络层</strong></td>
<td align="left">负责数据路由和转发（如 IP 协议，决定数据怎么走到目的地）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Data Link Layer</td>
<td align="left"><strong>数据链路层</strong></td>
<td align="left">负责相邻节点间可靠传输（如以太网，MAC 地址，帧同步）</td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left">Physical Layer</td>
<td align="left"><strong>物理层</strong></td>
<td align="left">物理介质上的比特流传输（如电缆、光纤、网卡、信号）</td>
</tr>
</tbody></table>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/03/life/%E4%BB%8A%E5%A4%A9%E7%9C%8B%E5%88%B0%E4%B8%80%E5%8F%A5%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/03/life/%E4%BB%8A%E5%A4%A9%E7%9C%8B%E5%88%B0%E4%B8%80%E5%8F%A5%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D/" class="post-title-link" itemprop="url">今天看到一句很喜欢的话，关于历史的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-03 01:00:00 / 修改时间：18:32:47" itemprop="dateCreated datePublished" datetime="2025-12-03T01:00:00+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/life/" itemprop="url" rel="index"><span itemprop="name">随记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>历史是一位很有耐心的老师，如果你听不懂，他愿意再讲一遍。<br>但是历史也是一位很严厉的老师，如果你学不会，那他永远不会翻篇。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
