<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"98f8cddec87decff88b20807b414767528f9bec3","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="kongshan&#39;s blog">
<meta property="og:url" content="https://kongshan.me/blog/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kongshan.me/blog/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"blog/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">kongshan's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/10/03/poem/%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span><a href="/2024/10/03/poem/%E7%99%BB%E6%B3%B0%E5%B1%B1%E8%AE%B0/" class="post-title-link" itemprop="url">登泰山记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 01:00:00" itemprop="dateCreated datePublished" datetime="2024-10-03T01:00:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 18:27:26" itemprop="dateModified" datetime="2025-12-03T18:27:26+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/poem/" itemprop="url" rel="index"><span itemprop="name">诗文</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="登泰山记"><a href="#登泰山记" class="headerlink" title="登泰山记"></a>登泰山记</h1><h3 id="写于公历二零二四年十月三日"><a href="#写于公历二零二四年十月三日" class="headerlink" title="写于公历二零二四年十月三日"></a>写于公历二零二四年十月三日</h3><p>去红门约莫百米，可窥泰山之峻。实乃拔地通天，造化神功，绝云擎日，横断南北，有如石屏缀之以青柏，刀峰砺之以白岩。及穿红门，入山口，侧柏林立，以至幽寒。左右皆有碑，多为明清民国文人所记。</p>
<p>前行约半时，过斗母宫及三官庙，有歧路至经石峪。一心登山者众而闲心赏景者寡。余取小道，过石桥，沸腾声远而清流音近。此径侧柏郁郁，幽邃寂寥，凄神寒骨。有石亭侧立，曰高山流水亭，盖文人常饮于此，举酒斗文，抚琴尽兴，而今不得也。至经石峪，豁然开朗。裸石居中，其上有文，想是千古奇篇，只惜山溪漱石，千风摩崖，而今已不可明鉴。环石有阶，可观四周名迹，皆彼时达官之笔，虽不细看亦饶有风趣。此宝地也，然四下无人，其距三官庙不过百米，不得见者实然可惜。</p>
<p>循路登山，约二时可至中天门。见主峰巍然，真所谓巇山锁玉顶，峦岳镇天关。岱宗压顶，心寒者不可视；王山遗威，胆怯者不可行。登十八盘，乱石嶙峋，枯木倒挂，路窄而崎岖，阶陡而不平。加之时值正午，金阳高照，以至余疲于登山，心绪杂陈。再约二时，可至山顶。</p>
<p>余尝闻不登高山不知天之高，实不然。今登泰山，方知天非不可及也。亲临穹顶，似有玉音漻漻，撼心涤尘，超凡脱俗。足下千峰攒聚，万壑凌历，险阻化平丘，大石作砂砾；决眦远眺，见巉石峦岳千转穀，万川湍流吞穹庐；至于颅顶，乃有星宫亹亹，天河毖流，紫薇环照，金乌射影。登临此地，吸则有高天灵气，呼则有浩然清风。真洋洋得意也，志盖五岳，气涤九江，快哉，快哉！</p>
<p>此美景赏心，不可骤得，快意平生有此观，故余作文以记之。</p>
<p>至中天门时，见主峰庄严，不禁感叹。心中灵动，偶得一诗。即兴之作，虽音律欠佳，不赞改。诗曰：</p>
<p>青柏画石屏，白岩镇天关。<br>四岳三俯首，两江一东流。<br>天子受命处，我今亦登临。<br>王山遗威在，浩气荡乾坤。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/20/tech/Git%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/20/tech/Git%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-20 15:30:00 / 修改时间：15:29:31" itemprop="dateCreated datePublished" datetime="2025-12-20T15:30:00+08:00">2025-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>是什么</p>
<ol>
<li>Git 是一个<strong>分布式版本控制系统</strong>，用于跟踪文件的变化，协调多人协作开发，管理项目的历史版本。</li>
<li>核心概念<ol>
<li>**仓库（Repository &#x2F; Repo）**一个 Git 仓库就是项目文件加上其版本历史记录的集合。可以是本地仓库（Local Repository），也可以是远程仓库（Remote Repository，如 GitHub、GitLab 等）。</li>
<li>**提交（Commit）**每次对文件的修改，当你觉得可以保存一个版本时，就可以做一个“提交”。每个提交都有一个唯一的 SHA-1 哈希值，记录了该版本的所有更改内容及提交信息。</li>
<li>**分支（Branch）**分支是独立开发线，允许你在不影响主线（通常是 <code>main</code>或 <code>master</code>）的情况下进行新功能开发或修复。默认分支通常是 <code>main</code>或 <code>master</code>。</li>
<li>**工作区、暂存区、版本库<ol>
<li><strong>工作区（Working Directory）</strong>：你直接编辑的文件区域。</li>
<li><strong>暂存区（Stage&#x2F;Index）</strong>：通过 <code>git add</code>将要提交的变更放入暂存区。</li>
<li><strong>版本库（Repository）</strong>：通过 <code>git commit</code>将暂存区的变更保存到本地仓库中。</li>
</ol>
</li>
<li>**远程仓库（Remote）**托管在网络上的仓库，比如 GitHub 上的项目，可以通过 <code>git remote</code>进行关联。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="配置-Config"><a href="#配置-Config" class="headerlink" title="配置 (Config)"></a>配置 (Config)</h3><p>在使用 Git 前的必要配置。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git config --global user.name &quot;你的名字&quot;</code></td>
<td align="left">设置全局用户名</td>
</tr>
<tr>
<td align="left"><code>git config --global user.email &quot;你的邮箱&quot;</code></td>
<td align="left">设置全局邮箱</td>
</tr>
<tr>
<td align="left"><code>git config --list</code></td>
<td align="left">查看当前所有配置</td>
</tr>
<tr>
<td align="left"><code>git config --global alias.st status</code></td>
<td align="left">设置别名（例如用 <code>git st</code> 代替 <code>git status</code>）</td>
</tr>
</tbody></table>
<h3 id="创建与获取-Init-Clone"><a href="#创建与获取-Init-Clone" class="headerlink" title="创建与获取 (Init &amp; Clone)"></a>创建与获取 (Init &amp; Clone)</h3><p>开始一个新项目。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git init</code></td>
<td align="left">在当前目录初始化一个新的 Git 仓库</td>
</tr>
<tr>
<td align="left"><code>git clone &lt;url&gt;</code></td>
<td align="left">克隆远程仓库到本地</td>
</tr>
</tbody></table>
<h3 id="代码提交-Basic-Snapshotting"><a href="#代码提交-Basic-Snapshotting" class="headerlink" title="代码提交 (Basic Snapshotting)"></a>代码提交 (Basic Snapshotting)</h3><p>日常最频繁使用的命令。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git status</code></td>
<td align="left"><strong>查看文件状态</strong>（最常用，建议时刻执行）</td>
</tr>
<tr>
<td align="left"><code>git add .</code></td>
<td align="left">将当前目录所有变动文件添加到<strong>暂存区</strong></td>
</tr>
<tr>
<td align="left"><code>git add &lt;file&gt;</code></td>
<td align="left">将指定文件添加到暂存区</td>
</tr>
<tr>
<td align="left"><code>git commit -m &quot;提交信息&quot;</code></td>
<td align="left">将暂存区内容提交到<strong>本地仓库</strong></td>
</tr>
<tr>
<td align="left"><code>git commit --amend</code></td>
<td align="left">修改最近一次提交（常用于修改写错的提交信息）</td>
</tr>
</tbody></table>
<h3 id="分支操作-Branching"><a href="#分支操作-Branching" class="headerlink" title="分支操作 (Branching)"></a>分支操作 (Branching)</h3><p>并行开发的核心。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git branch</code></td>
<td align="left">列出本地所有分支（带 <code>*</code> 号的是当前分支）</td>
</tr>
<tr>
<td align="left"><code>git branch -a</code></td>
<td align="left">列出本地和远程所有分支</td>
</tr>
<tr>
<td align="left"><code>git branch &lt;name&gt;</code></td>
<td align="left">新建分支，但<strong>不</strong>切换过去</td>
</tr>
<tr>
<td align="left"><code>git checkout &lt;name&gt;</code></td>
<td align="left">切换到指定分支</td>
</tr>
<tr>
<td align="left"><code>git switch &lt;name&gt;</code></td>
<td align="left"><strong>(新版)</strong> 切换分支（推荐使用）</td>
</tr>
<tr>
<td align="left"><code>git checkout -b &lt;name&gt;</code></td>
<td align="left">新建并切换到该分支</td>
</tr>
<tr>
<td align="left"><code>git merge &lt;name&gt;</code></td>
<td align="left">将指定分支合并到当前分支</td>
</tr>
<tr>
<td align="left"><code>git branch -d &lt;name&gt;</code></td>
<td align="left">删除已合并的分支</td>
</tr>
<tr>
<td align="left"><code>git branch -D &lt;name&gt;</code></td>
<td align="left">强制删除未合并的分支</td>
</tr>
</tbody></table>
<h3 id="远程同步-Remote"><a href="#远程同步-Remote" class="headerlink" title="远程同步 (Remote)"></a>远程同步 (Remote)</h3><p>与团队协作或备份代码。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote -v</code></td>
<td align="left">查看远程仓库地址信息</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">拉取远程代码并自动合并（相当于 <code>fetch</code> + <code>merge</code>）</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">将本地代码推送到远程仓库</td>
</tr>
<tr>
<td align="left"><code>git push origin &lt;branch&gt;</code></td>
<td align="left">推送指定分支到远程</td>
</tr>
<tr>
<td align="left"><code>git push -u origin &lt;branch&gt;</code></td>
<td align="left">推送并关联远程分支（第一次推送时用）</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">下载远程更新，但<strong>不</strong>合并到当前工作区</td>
</tr>
</tbody></table>
<h3 id="撤销与回退-Undo-Reset"><a href="#撤销与回退-Undo-Reset" class="headerlink" title="撤销与回退 (Undo &amp; Reset)"></a>撤销与回退 (Undo &amp; Reset)</h3><p><strong>注意：带 <code>--hard</code> 的命令需谨慎使用。</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git checkout -- &lt;file&gt;</code></td>
<td align="left">丢弃工作区的修改（回到最近一次 add 或 commit 的状态）</td>
</tr>
<tr>
<td align="left"><code>git restore &lt;file&gt;</code></td>
<td align="left"><strong>(新版)</strong> 丢弃工作区的修改</td>
</tr>
<tr>
<td align="left"><code>git reset HEAD &lt;file&gt;</code></td>
<td align="left">将文件从暂存区撤回到工作区（取消 <code>git add</code>）</td>
</tr>
<tr>
<td align="left"><code>git reset --soft HEAD^</code></td>
<td align="left">撤销最近一次 commit，但保留代码在暂存区</td>
</tr>
<tr>
<td align="left"><code>git reset --hard HEAD^</code></td>
<td align="left"><strong>彻底撤销</strong>最近一次 commit，代码全部丢失（回到上个版本）</td>
</tr>
<tr>
<td align="left"><code>git reset --hard &lt;commit_id&gt;</code></td>
<td align="left">强制回退到指定的 commit 版本</td>
</tr>
</tbody></table>
<h3 id="查看日志与差异-Log-Diff"><a href="#查看日志与差异-Log-Diff" class="headerlink" title="查看日志与差异 (Log &amp; Diff)"></a>查看日志与差异 (Log &amp; Diff)</h3><p>检查历史记录。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code></td>
<td align="left">查看提交历史详情</td>
</tr>
<tr>
<td align="left"><code>git log --oneline</code></td>
<td align="left">查看简洁的提交历史（一行显示）</td>
</tr>
<tr>
<td align="left"><code>git log --graph</code></td>
<td align="left">以图形化方式查看分支合并历史</td>
</tr>
<tr>
<td align="left"><code>git reflog</code></td>
<td align="left">查看所有操作记录（包括被回退的记录，救命用）</td>
</tr>
<tr>
<td align="left"><code>git diff</code></td>
<td align="left">查看<strong>工作区</strong>与<strong>暂存区</strong>的文件差异</td>
</tr>
<tr>
<td align="left"><code>git diff HEAD</code></td>
<td align="left">查看<strong>工作区</strong>与<strong>最新 commit</strong> 的差异</td>
</tr>
</tbody></table>
<h3 id="暂存-Stash"><a href="#暂存-Stash" class="headerlink" title="暂存 (Stash)"></a>暂存 (Stash)</h3><p>手头工作没做完，但需要切换分支修 Bug 时使用。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git stash</code></td>
<td align="left">暂时将工作区修改存储起来（清空工作区）</td>
</tr>
<tr>
<td align="left"><code>git stash list</code></td>
<td align="left">查看所有暂存记录</td>
</tr>
<tr>
<td align="left"><code>git stash pop</code></td>
<td align="left">恢复最近一次暂存的内容，并删除记录</td>
</tr>
<tr>
<td align="left"><code>git stash apply</code></td>
<td align="left">恢复最近一次暂存的内容，但不删除记录</td>
</tr>
<tr>
<td align="left"><code>git stash clear</code></td>
<td align="left">清空所有暂存记录</td>
</tr>
</tbody></table>
<h3 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 (Tag)"></a>标签 (Tag)</h3><p>用于发布版本（如 v1.0）。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git tag</code></td>
<td align="left">列出所有标签</td>
</tr>
<tr>
<td align="left"><code>git tag &lt;name&gt;</code></td>
<td align="left">在当前 commit 打标签</td>
</tr>
<tr>
<td align="left"><code>git tag -a &lt;name&gt; -m &quot;msg&quot;</code></td>
<td align="left">打附注标签</td>
</tr>
<tr>
<td align="left"><code>git push origin &lt;tagname&gt;</code></td>
<td align="left">推送某个标签到远程</td>
</tr>
</tbody></table>
<hr>
<h2 id="常见场景速查"><a href="#常见场景速查" class="headerlink" title="常见场景速查"></a>常见场景速查</h2><p>在使用 Git 的过程中，遇到报错是家常便饭。以下是开发者最常遇到的 <strong>Git 问题场景、原因分析及解决办法</strong>。</p>
<h3 id="提交被拒绝-Push-Rejected"><a href="#提交被拒绝-Push-Rejected" class="headerlink" title="提交被拒绝 (Push Rejected)"></a>提交被拒绝 (Push Rejected)</h3><p><strong>场景</strong>：执行 <code>git push</code> 时报错：<br><code>error: failed to push some refs to &#39;...&#39;</code><br><code>hint: Updates were rejected because the remote contains work that you do not have locally.</code></p>
<ul>
<li><p><strong>原因</strong>：远程仓库有别人提交的新代码，而你的本地仓库还没同步。</p>
</li>
<li><p><strong>解决办法</strong>：</p>
<ol>
<li>先拉取远程代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>如果自动合并成功，直接再次 push。</li>
<li>如果有冲突（Conflict），参照第 2 点解决冲突后，再 push。</li>
</ol>
</li>
<li><p><strong>进阶技巧</strong>：<br>如果你想保持提交记录是一条直线（没有分叉），可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码冲突-Merge-Conflict"><a href="#代码冲突-Merge-Conflict" class="headerlink" title="代码冲突 (Merge Conflict)"></a>代码冲突 (Merge Conflict)</h3><p><strong>场景</strong>：<code>git pull</code> 或 <code>git merge</code> 时提示 <code>CONFLICT (content): Merge conflict in...</code>，且自动合并失败。</p>
<ul>
<li><strong>原因</strong>：你和同事修改了<strong>同一个文件的同一行代码</strong>，Git 不知道该听谁的。</li>
<li><strong>解决办法</strong>：<ol>
<li>打开报错的文件。</li>
<li>你会看到类似这样的标记：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">你修改的代码</span><br><span class="line">=======</span><br><span class="line">远程拉下来的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</span><br></pre></td></tr></table></figure></li>
<li><strong>手动修改</strong>：删除 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些符号，保留你需要的代码（或者两者的结合）。</li>
<li><strong>重新提交</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;解决冲突&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="gitignore-不生效"><a href="#gitignore-不生效" class="headerlink" title=".gitignore 不生效"></a><code>.gitignore</code> 不生效</h3><p><strong>场景</strong>：明明在 <code>.gitignore</code> 里写了 <code>node_modules/</code> 或 <code>config.js</code>，但 Git 还是会把它们检测出来提示要提交。</p>
<ul>
<li><strong>原因</strong>：这个文件在加入 <code>.gitignore</code> 之前，已经被 <code>git add</code> 或 <code>git commit</code> 过了（已经被 Git 追踪了）。<code>.gitignore</code> <strong>只对未被追踪的文件有效</strong>。</li>
<li><strong>解决办法</strong>：<br>需要清除该文件的缓存（不会删除本地文件，只是从 Git 追踪中移除）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如要忽略 config.js</span></span><br><span class="line">git <span class="built_in">rm</span> --cached config.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是目录</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached node_modules/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新提交生效</span></span><br><span class="line">git commit -m <span class="string">&quot;修复gitignore不生效的问题&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="提交错分支了-Committed-to-wrong-branch"><a href="#提交错分支了-Committed-to-wrong-branch" class="headerlink" title="提交错分支了 (Committed to wrong branch)"></a>提交错分支了 (Committed to wrong branch)</h3><p><strong>场景</strong>：在 <code>master</code> 分支上写了一堆代码并提交了，结果发现应该在 <code>dev</code> 分支上开发。</p>
<ul>
<li><strong>解决办法</strong>：<ol>
<li><p><strong>撤销提交，保留代码</strong>（将 commit 回退到工作区）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure></li>
<li><p><strong>切换到正确分支</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure></li>
<li><p><strong>重新提交</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;在正确分支提交&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="提交信息写错了-Wrong-Commit-Message"><a href="#提交信息写错了-Wrong-Commit-Message" class="headerlink" title="提交信息写错了 (Wrong Commit Message)"></a>提交信息写错了 (Wrong Commit Message)</h3><p><strong>场景</strong>：刚刚执行完 <code>git commit -m &quot;修复bug&quot;</code>，发现错别字或者没写全。</p>
<ul>
<li><strong>解决办法</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m <span class="string">&quot;新的、正确的提交信息&quot;</span></span><br></pre></td></tr></table></figure>
<em>注意：如果该 commit 已经 push 到远程，修改后需要 <code>git push -f</code>（强制推送，多人协作时慎用）。</em></li>
</ul>
<h3 id="误删文件-Deleted-file-by-mistake"><a href="#误删文件-Deleted-file-by-mistake" class="headerlink" title="误删文件 (Deleted file by mistake)"></a>误删文件 (Deleted file by mistake)</h3><p><strong>场景</strong>：手抖把代码文件删了，还没提交。</p>
<ul>
<li><strong>解决办法</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复指定文件</span></span><br><span class="line">git restore &lt;文件名&gt;</span><br><span class="line"><span class="comment"># 或者旧命令</span></span><br><span class="line">git checkout -- &lt;文件名&gt;</span><br></pre></td></tr></table></figure>
<em>如果已经提交了删除操作，需要用 <code>git reset</code> 回退版本。</em></li>
</ul>
<h3 id="进入了-“Detached-HEAD”-状态"><a href="#进入了-“Detached-HEAD”-状态" class="headerlink" title="进入了 “Detached HEAD” 状态"></a>进入了 “Detached HEAD” 状态</h3><p><strong>场景</strong>：执行 <code>git checkout &lt;commit_id&gt;</code> 后，终端提示 <code>You are in &#39;detached HEAD&#39; state</code>。</p>
<ul>
<li><strong>原因</strong>：你现在的 HEAD 指针指向了一个具体的 commit，而不是一个分支。在这里修改代码如果不创建分支，很容易丢失。</li>
<li><strong>解决办法</strong>：<ul>
<li><strong>如果你只是看看</strong>：看完后切回主分支 <code>git checkout master</code> 即可。</li>
<li><strong>如果你想基于这个版本继续开发</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch -c &lt;新分支名&gt;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git checkout -b &lt;新分支名&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>“v5” 还在 Git 仓库里，但没有任何分支或标签指向它，你暂时“找不到”它了，Git 不会自动清理它，它目前是“悬空”的。</li>
<li>可以通过<code>git reflog</code>查看指针头的流动找到他。</li>
</ul>
<h3 id="Windows-Mac-换行符问题-CRLF-vs-LF"><a href="#Windows-Mac-换行符问题-CRLF-vs-LF" class="headerlink" title="Windows&#x2F;Mac 换行符问题 (CRLF vs LF)"></a>Windows&#x2F;Mac 换行符问题 (CRLF vs LF)</h3><p><strong>场景</strong>：代码没改动，但 <code>git status</code> 显示所有文件都被修改了，或者 diff 看到每一行都有差异。</p>
<ul>
<li><strong>原因</strong>：Windows 使用 <code>CRLF</code> 换行，Linux&#x2F;Mac 使用 <code>LF</code> 换行。</li>
<li><strong>解决办法</strong>：<br>设置 Git 在提交时自动转换：<ul>
<li><strong>Windows 用户</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
(提交时转换为 LF，检出时转换为 CRLF)</li>
<li><strong>Mac&#x2F;Linux 用户</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
(提交时转换为 LF，检出时不转换)</li>
</ul>
</li>
</ul>
<h3 id="文件名大小写不敏感-Case-Sensitivity"><a href="#文件名大小写不敏感-Case-Sensitivity" class="headerlink" title="文件名大小写不敏感 (Case Sensitivity)"></a>文件名大小写不敏感 (Case Sensitivity)</h3><p><strong>场景</strong>：将文件名从 <code>User.js</code> 改为 <code>user.js</code>，但 Git 没有任何反应（<code>git status</code> 显示无变化）。</p>
<ul>
<li><strong>原因</strong>：Windows 和 macOS 的文件系统默认不区分大小写，Git 默认配置也是如此。</li>
<li><strong>解决办法</strong>：<ol>
<li>手动开启 Git 的大小写敏感：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li>或者使用 <code>git mv</code> 命令重命名（推荐）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> User.js user.js</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="merge和rebase的区别"><a href="#merge和rebase的区别" class="headerlink" title="merge和rebase的区别"></a>merge和rebase的区别</h3><table>
<thead>
<tr>
<th>对比维度</th>
<th><strong>git merge</strong> 🔄</th>
<th><strong>git rebase</strong> 🧩</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本定义</strong></td>
<td>将两个分支的修改<strong>合并在一起</strong>，生成一个新的<strong>合并提交</strong></td>
<td>将当前分支的提交“<strong>变基</strong>”到目标分支的最新提交上，使历史更线性</td>
</tr>
<tr>
<td><strong>核心目的</strong></td>
<td><strong>整合分支</strong>，保留分支间的上下文和历史关系</td>
<td><strong>整理&#x2F;美化提交历史</strong>，让分支历史更清晰、线性</td>
</tr>
<tr>
<td><strong>是否生成新提交</strong></td>
<td>✅ 会生成一个<strong>新的合并提交（merge commit）</strong></td>
<td>❌ 通常不会生成新提交，而是<strong>将原提交“复制”到新位置</strong>（提交哈希改变）</td>
</tr>
<tr>
<td><strong>历史记录特点</strong></td>
<td>保留分支合并的<strong>完整历史</strong>，包括分支分叉与合并点</td>
<td>历史呈<strong>线性</strong>，看不到分支合并的过程，更简洁</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>- 团队协作中保留完整的合并历史 - 公共分支（如 <code>main</code>&#x2F;<code>master</code>）推荐使用</td>
<td>- 本地分支整理提交历史 - 想让提交历史更清晰、线性 （⚠️ 不要对公共分支使用！）</td>
</tr>
<tr>
<td><strong>命令基本用法</strong></td>
<td><code>git checkout 目标分支</code> <code>git merge 源分支</code></td>
<td><code>git checkout 当前分支</code> <code>git rebase 目标分支</code></td>
</tr>
<tr>
<td><strong>典型使用例子</strong></td>
<td><code>git checkout main</code> <code>git merge feature</code></td>
<td><code>git checkout feature</code> <code>git rebase main</code></td>
</tr>
<tr>
<td><strong>冲突处理</strong></td>
<td>合并时如果发生冲突，解决后 <code>git add</code>+ <code>git commit</code>（自动生成合并提交）</td>
<td>发生冲突时，解决后 <code>git add</code>，然后执行： <code>git rebase --continue</code></td>
</tr>
<tr>
<td><strong>是否改变提交历史</strong></td>
<td>❌ 不改变已有提交历史，只是新增一个合并节点</td>
<td>✅ <strong>会改变提交历史</strong>（原提交的哈希值会变，相当于“重新播放”提交）</td>
</tr>
<tr>
<td><strong>对公共分支安全性</strong></td>
<td>✅ 安全，推荐在公共分支（如 main）上使用</td>
<td>❌ <strong>不安全！不要在已推送的公共分支上使用</strong>，会重写历史，影响他人</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>- 简单安全，不改变历史 - 保留分支合并的上下文</td>
<td>- 历史更清晰、线性，便于查看代码变更流程 - 减少不必要的合并节点</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>- 历史可能显得杂乱（有多个分叉与合并记录）</td>
<td>- 改变提交历史，可能导致协作问题 - 冲突处理较繁琐（每个提交都可能冲突）</td>
</tr>
<tr>
<td><strong>推荐使用场合</strong></td>
<td>- 团队协作、公共仓库 - 合并功能分支到主分支时</td>
<td>- 本地分支整理、美化提交历史 - rebase 到最新代码后再合并</td>
</tr>
</tbody></table>
<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a><code>cherry-pick</code></h3><ol>
<li><p>是什么</p>
<ul>
<li><p><strong>v1 和 v2 是两次独立的 Git 提交</strong>（commit），它们可能： 是同一个分支上的连续提交（比如 <code>commit-v1</code>→ <code>commit-v2</code>） 或者是在不同分支&#x2F;合并中产生的提交</p>
</li>
<li><p>你<strong>不想保留 v1 的任何内容</strong>，只想要 <strong>v2 中的某个函数&#x2F;代码片段</strong>。</p>
</li>
<li><p>你希望以干净的方式获取 v2 的函数，不影响现有代码结构，也不会把 v1 的内容带入。</p>
</li>
</ul>
</li>
<li><p>用法：<code>git cherry-pick &lt;commit-id&gt;</code></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/20/tech/Redis%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/20/tech/Redis%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Redis笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-12-20 15:30:00 / 修改时间：15:29:31" itemprop="dateCreated datePublished" datetime="2025-12-20T15:30:00+08:00">2025-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis理论学习"><a href="#Redis理论学习" class="headerlink" title="Redis理论学习"></a>Redis理论学习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>数据库和服务之间的中间件，用以提高并发量。</li>
<li>本地缓存<ol>
<li>工作逻辑类比cache，工作原理K-V</li>
</ol>
</li>
<li>远程缓存<ol>
<li>业务逻辑需要多个实例。但是如果一个商品的多个实例都有缓存的话就浪费空间了。于是需要一个远程缓存。</li>
<li>并发问题：通过单线程避免。</li>
</ol>
</li>
<li>支持多种数据结构：不只是string&lt;&#x3D;&gt;string，允许先进先出的List，去重的Set，排序的ZSet</li>
<li>内存过期、内存淘汰：参考cache的淘汰策略</li>
<li>持久化：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250916142637090.png"><ol>
<li>需要避免当缓存重启后没有内存数据，让所有业务全部交给数据库导致崩溃。</li>
<li>定期将缓存数据转储到磁盘文件中。</li>
</ol>
</li>
<li>简化网络协议</li>
</ol>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li>是什么<ol>
<li>Redis（Remote Dictionary Server）是一个<strong>基于内存的键值存储系统</strong>，支持多种数据结构，可以用作：<ul>
<li><strong>缓存（最常见用途）</strong></li>
<li><strong>数据库（持久化场景）</strong></li>
<li><strong>消息中间件（如消息队列、事件发布订阅）</strong></li>
</ul>
</li>
<li>Redis 的特点回顾（简要）<ul>
<li>内存存储，读写速度极快（微秒级响应）</li>
<li>单线程模型（Redis 6.0 前完全单线程，之后部分模块如网络 IO 支持多线程）</li>
<li>支持丰富的数据结构：String、Hash、List、Set、Sorted Set（ZSet）</li>
<li>支持数据持久化（RDB、AOF）</li>
<li>支持主从复制、哨兵、集群等高可用方案</li>
<li>命令原子性，支持事务与 Lua 脚本</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p>String（字符串）</p>
<ol>
<li><p>概述</p>
<ol>
<li><strong>最基本的数据类型</strong>，一个 key 对应一个 value。</li>
<li>Value 可以是字符串、数字或二进制数据（如图片、序列化对象）。</li>
<li>最大支持 <strong>512MB</strong>。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br><span class="line">INCR key          # 数字自增，常用于计数器</span><br><span class="line">DECR</span><br><span class="line">INCRBY</span><br><span class="line">APPEND</span><br><span class="line">MSET / MGET       # 批量设置/获取</span><br><span class="line">EXPIRE key seconds  # 设置过期时间</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>缓存数据（如用户信息 JSON）</p>
</li>
<li><p>计数器（如文章阅读量、点赞数）</p>
</li>
<li><p>分布式锁（SETNX）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Hash（哈希表）</p>
<ol>
<li><p>概述</p>
<ol>
<li>类似于 Map 结构，<strong>一个 key 对应一个字段-值对的集合</strong>。</li>
<li>适合存储对象，比如用户信息、商品详情等。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET user:1 name &quot;Tom&quot; age 25</span><br><span class="line">HGET user:1 name</span><br><span class="line">HGETALL user:1</span><br><span class="line">HKEYS / HVALS</span><br><span class="line">HINCRBY</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>优点：</p>
<ul>
<li><p>相比将整个对象序列化为 String，Hash 可以<strong>只修改部分字段</strong>，更高效。</p>
</li>
<li><p>节省内存（Redis 对小 Hash 有特殊优化）。</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>List（列表）</p>
<ol>
<li><p>概述</p>
<ol>
<li>一个 key 对应一个<strong>双向链表</strong>，支持从头部或尾部插入&#x2F;删除元素。</li>
<li>适合实现：<strong>最新消息、消息队列、文章评论列表</strong>等。</li>
<li>既可以当做栈来用，也可以按照队列来用</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPUSH myList &quot;a&quot;  # 头部插入</span><br><span class="line">RPUSH myList &quot;b&quot;  # 尾部插入</span><br><span class="line">LPOP / RPOP       # 头/尾弹出</span><br><span class="line">LRANGE myList 0 -1  # 获取全部元素</span><br><span class="line">LLEN</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>消息队列（结合 LPOP&#x2F;RPOP 或 BRPOP）</p>
</li>
<li><p>最新 N 条记录（如最新评论、动态）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Set（集合）</p>
<ol>
<li><p>概述</p>
<ol>
<li>无序、<strong>唯一</strong>的字符串集合。</li>
<li>支持交集、并集、差集等操作，适合标签、共同关注等场景。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SADD tags &quot;redis&quot; &quot;db&quot;</span><br><span class="line">SMEMBERS tags</span><br><span class="line">SISMEMBER tags &quot;redis&quot;</span><br><span class="line">SINTER set1 set2  # 交集</span><br><span class="line">SUNION</span><br><span class="line">SDIFF</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>标签系统</p>
</li>
<li><p>好友共同关注</p>
</li>
<li><p>去重统计（结合客户端）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Sorted Set（ZSet，有序集合）</p>
<ol>
<li><p>概述</p>
<ol>
<li>集合的升级版，每个元素都关联一个 <strong>score（分数）</strong>，根据 score 排序。</li>
<li>元素唯一，但 score 可重复。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZADD leaderboard 100 &quot;Alice&quot; 200 &quot;Bob&quot;</span><br><span class="line">ZRANGE leaderboard 0 -1          # 按 score 升序获取</span><br><span class="line">ZREVRANGE leaderboard 0 -1       # 降序</span><br><span class="line">ZSCORE leaderboard &quot;Alice&quot;</span><br><span class="line">ZINCRBY leaderboard 10 &quot;Alice&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>排行榜（游戏、热搜榜）</p>
</li>
<li><p>优先级队列</p>
</li>
<li><p>延迟队列（结合 score 为时间戳）</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><ul>
<li><strong>Redis 6.0 之前：完全单线程</strong>（主线程处理所有客户端请求、命令执行、持久化等）</li>
<li><strong>Redis 6.0 之后：引入多线程 I&#x2F;O（处理网络读写），但命令执行仍然是单线程</strong>目的是提高网络吞吐，缓解高并发下的网络瓶颈，但核心数据操作依旧保持原子性。</li>
</ul>
<blockquote>
<p>✅ 所以，Redis 依然可以认为是<strong>单线程模型（命令执行层面）</strong>，无需考虑锁竞争，执行效率高。</p>
</blockquote>
<h3 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h3><p>Redis 默认是内存数据库，但支持将数据保存到磁盘，避免重启后数据丢失。</p>
<ol>
<li><p>RDB（Redis DataBase）</p>
<ol>
<li><p>RDB 触发方式</p>
<ol>
<li><p><strong>手动触发（主动保存）</strong></p>
<ol>
<li>命令：<code>SAVE</code>或 <code>BGSAVE``SAVE</code>：<strong>同步</strong>执行，会阻塞 Redis 主线程，不推荐生产使用</li>
<li><code>BGSAVE</code>：<strong>异步</strong>执行，Redis 会 fork 一个子进程在后台生成 RDB 文件，<strong>主线程不受影响（推荐）</strong></li>
</ol>
</li>
<li><p><strong>自动触发（通过配置规则）</strong></p>
</li>
</ol>
<p>Redis 允许通过配置文件设置<strong>自动快照规则</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1       # 900秒内至少有1个key被修改，就触发一次 RDB</span><br><span class="line">save 300 10      # 300秒内至少10个key被修改</span><br><span class="line">save 60 10000    # 60秒内至少10000个key被修改</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要满足其中任意一条规则，Redis 就会在后台通过 <code>BGSAVE</code>自动保存一次 RDB 快照。</p>
</blockquote>
<hr>
</li>
<li><p>RDB 的优点</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>恢复速度快</strong></td>
<td align="left">RDB 是数据快照，文件小，Redis 启动时加载 RDB 比 AOF 快很多</td>
</tr>
<tr>
<td align="left">✅ <strong>文件体积小</strong></td>
<td align="left">只保存某一时刻的数据，而非所有操作命令</td>
</tr>
<tr>
<td align="left">✅ <strong>适合备份与灾难恢复</strong></td>
<td align="left">可以定期将 RDB 文件拷贝到其他服务器或云存储，用于容灾</td>
</tr>
</tbody></table>
<hr>
</li>
<li><p>RDB 的缺点</p>
<table>
<thead>
<tr>
<th align="left">缺点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>可能丢失数据</strong></td>
<td align="left">RDB 是<strong>定时快照</strong>，如果 Redis 在两次快照之间宕机，这段时间的数据会丢失</td>
</tr>
<tr>
<td align="left">❌ <strong>fork 子进程开销</strong></td>
<td align="left">BGSAVE 会 fork 一个子进程，如果数据量很大，fork 可能会阻塞主线程（特别是大内存实例）</td>
</tr>
<tr>
<td align="left">❌ <strong>不适合实时性要求极高的场景</strong></td>
<td align="left">不如 AOF 安全</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>AOF（Append Only File）</p>
<ol>
<li><p>AOF 工作流程</p>
<ol>
<li>客户端执行一个写命令（如 SET key value）</li>
<li>Redis 不仅将数据写入内存，还会将该命令<strong>追加到 AOF 缓冲区</strong></li>
<li>根据配置的同步策略，将缓冲区内容写入磁盘的 AOF 文件</li>
<li>Redis 重启时，会<strong>重新加载并执行 AOF 文件中的命令</strong>，恢复数据</li>
</ol>
</li>
<li><p>AOF 配置选项（同步频率）</p>
<p>在 redis.conf 中，可以通过以下参数控制 AOF 的写入磁盘策略（即命令同步到磁盘的时机）：</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">安全性</th>
<th align="left">性能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>appendfsync always</code></td>
<td align="left">每个写命令都同步到磁盘</td>
<td align="left">✅ 最安全，几乎不丢数据</td>
<td align="left">❌ 性能最差</td>
</tr>
<tr>
<td align="left"><code>appendfsync everysec</code>（默认）</td>
<td align="left">每秒同步一次</td>
<td align="left">⚠️ 最多丢失 1 秒的数据</td>
<td align="left">✅ 性能较好，推荐</td>
</tr>
<tr>
<td align="left"><code>appendfsync no</code></td>
<td align="left">由操作系统决定何时同步</td>
<td align="left">❌ 可能丢失较多数据</td>
<td align="left">✅ 性能最好</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>生产环境推荐使用：appendfsync everysec（折中方案，安全且性能较好）</strong></p>
</blockquote>
</li>
<li><p>AOF 的优点</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>数据安全性更高</strong></td>
<td align="left">记录了所有写操作，最多只丢失 1 秒的数据（取决于配置）</td>
</tr>
<tr>
<td align="left">✅ <strong>可修复</strong></td>
<td align="left">AOF 文件损坏时，Redis 提供 <code>redis-check-aof</code>工具可以尝试修复</td>
</tr>
<tr>
<td align="left">✅ <strong>更适合数据重要性高的场景</strong></td>
<td align="left">比 RDB 更可靠</td>
</tr>
</tbody></table>
</li>
<li><p>AOF 的缺点</p>
<table>
<thead>
<tr>
<th align="left">缺点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>文件体积大</strong></td>
<td align="left">记录了所有写命令，尤其是数据量大或频繁更新时，AOF 文件会膨胀</td>
</tr>
<tr>
<td align="left">❌ <strong>恢复速度慢</strong></td>
<td align="left">启动时要<strong>重新执行所有命令</strong>，比加载 RDB 慢</td>
</tr>
<tr>
<td align="left">❌ <strong>写放大</strong></td>
<td align="left">同一个数据多次修改会产生多条命令</td>
</tr>
</tbody></table>
<hr>
</li>
<li><p>AOF 重写（AOF Rewrite）</p>
<p>随着时间推移，AOF 文件会越来越大。为了解决这个问题，Redis 提供了 <strong>AOF 重写机制</strong>：</p>
<ul>
<li><p><strong>作用：</strong> 对 AOF 文件进行“瘦身”，去掉冗余命令，用<strong>最终的数据状态</strong>重写一个新的、更小的 AOF 文件</p>
</li>
<li><p><strong>命令：</strong> <code>BGREWRITEAOF</code>（后台异步执行）</p>
</li>
<li><p><strong>触发方式：</strong> 可配置自动触发策略，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 当前 AOF 文件比上次重写后增长了 100%</span><br><span class="line">auto-aof-rewrite-min-size 64mb   # AOF 文件至少达到 64MB 才触发</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="高可用与扩展（集群策略）"><a href="#高可用与扩展（集群策略）" class="headerlink" title="高可用与扩展（集群策略）"></a>高可用与扩展（集群策略）</h3><ol>
<li><strong>主从复制（Master-Slave Replication）</strong><ol>
<li><p>核心思想：</p>
<ol>
<li>允许一个 <strong>Master（主节点）</strong> 可以有多个 <strong>Slave（从节点）</strong>，<strong>从节点会异步复制主节点上的数据</strong>，实现数据的<strong>备份、读写分离、负载均衡</strong>。</li>
</ol>
</li>
<li><p>架构与原理</p>
<ol>
<li><p><strong>Master</strong>：负责写操作（也可读），数据变更后<strong>异步同步</strong>给 Slave。</p>
</li>
<li><p><strong>Slave</strong>：只读（也可配置为可写，但不推荐），从 Master 拉取数据，保持同步。</p>
</li>
<li><p>数据同步方式：</p>
<ul>
<li><p><strong>全量同步（初次同步）</strong>：Slave 第一次连接 Master 时，Master 会生成 RDB 快照并发送给 Slave，然后同步增量命令。</p>
</li>
<li><p><strong>增量同步</strong>：后续 Master 的写操作会以命令的方式发送给 Slave，保持数据一致。</p>
</li>
</ul>
</li>
<li><p>特点与作用</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 读写分离</td>
<td>Master 写，Slave 读，分担读压力</td>
</tr>
<tr>
<td>✅ 数据备份</td>
<td>Slave 是 Master 的数据副本，可用于容灾</td>
</tr>
<tr>
<td>❌ 无自动故障转移</td>
<td>如果 Master 宕机，需要手动切换 Slave 为 Master</td>
</tr>
<tr>
<td>❌ 无自动负载均衡</td>
<td>需要客户端或代理层实现读请求分发</td>
</tr>
</tbody></table>
<pre><code>  5. 优点

     1. 简单易用，配置方便

     1. 数据冗余，提高可用性

     1. 支持读扩展（多个 Slave 分担读负载）

  6. 缺点

     - **不具备高可用性**：Master 宕机后，整个集群不可写，需人工干预

     - **数据一致性是最终一致**（异步复制，Slave 数据可能有延迟）

     - **无自动 Failover（故障切换）能力**
</code></pre>
<ol start="2">
<li><p><strong>哨兵模式（Sentinel）</strong></p>
<ol>
<li><p>核心思想：</p>
<ol>
<li>在 <strong>主从复制的基础上，引入 Sentinel（哨兵）进程</strong>，用于 监控 Redis 主从节点的健康状态，并在 <strong>Master 宕机时自动进行故障转移（Failover），选举新的 Master</strong>，实现高可用性。</li>
</ol>
</li>
<li><p>架构组成</p>
<ol>
<li><strong>Master</strong>：主节点，负责写操作</li>
<li><strong>Slave</strong>：从节点，复制 Master 数据</li>
<li><strong>Sentinel（哨兵）</strong>：独立的 Redis 进程（或线程），<strong>不存储数据</strong>，用于监控 + 故障转移</li>
</ol>
</li>
</ol>
<blockquote>
<p>通常部署 <strong>至少 3 个 Sentinel 节点（避免脑裂）</strong>，它们共同监控 Redis 节点并协作决策。</p>
</blockquote>
<ol start="3">
<li>Sentinel 做了什么？</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 监控</td>
<td>持续检查 Master 和 Slave 是否正常运行</td>
</tr>
<tr>
<td>✅ 自动故障转移</td>
<td>当 Master 宕机，Sentinel 会<strong>选举出一个 Slave 作为新 Master</strong>，并通知其他 Slave 复制新 Master</td>
</tr>
<tr>
<td>✅ 通知</td>
<td>通过 API 或消息告知客户端 Master 发生了变更</td>
</tr>
<tr>
<td>✅ 配置提供者</td>
<td>客户端可以从 Sentinel 获取最新的 Master 地址</td>
</tr>
</tbody></table>
<hr>
<pre><code>  4.  优点：

      - **自动故障转移**（High Availability）

      - **自动发现与通知**（客户端可感知新 Master）

      - 仍然支持 **读写分离 &amp; 读扩展**

  5.  缺点：

      - 不支持自动扩容 / 数据分片：数据仍然全部存在一个 Master 上，无法解决大数据量存储问题

      - Sentinel 本身不存储数据，只是协调者

      - 客户端需要支持 Sentinel 感知机制，或使用支持 Sentinel 的 Redis 客户端 SDK
</code></pre>
<ol start="3">
<li><strong>集群模式（Redis Cluster）</strong><ol>
<li>核心思想：<ol>
<li>Redis 官方推出的<strong>分布式集群解决方案</strong>，支持 <strong>数据自动分片（Sharding）、高可用、多主多从、横向扩展</strong>，是生产环境 <strong>大规模数据 + 高并发 + 高可用</strong> 场景下的首选架构。</li>
</ol>
</li>
<li>核心特性</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 数据分片（Sharding）</td>
<td>数据按哈希槽（16384 个 slot）分片，分散存储在多个主节点上</td>
</tr>
<tr>
<td>✅ 多主多从</td>
<td>每个分片是一个 <strong>主从结构</strong>，主节点负责写，从节点负责备份与故障切换</td>
</tr>
<tr>
<td>✅ 高可用</td>
<td>如果某个主节点宕机，其从节点会被 <strong>自动提升为主节点</strong></td>
</tr>
<tr>
<td>✅ 客户端直连</td>
<td>客户端可以直接连接集群节点，支持智能路由</td>
</tr>
<tr>
<td>✅ 横向扩展</td>
<td>可通过增加节点来扩展存储容量与并发能力</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>数据分片原理（16384 个 Slot）</p>
<ul>
<li><p>Redis Cluster 将所有的数据分成 <strong>16384 个哈希槽（hash slot）</strong></p>
</li>
<li><p>每个 <strong>Key 通过 CRC16(key) % 16384 计算出所属的 Slot</strong></p>
</li>
<li><p>每个 <strong>主节点负责一部分 Slot（比如节点 A 负责 0<del>5000，节点 B 负责 5001</del>10000…）</strong></p>
</li>
<li><p>客户端访问时，Redis 会告诉客户端应该去哪个节点操作</p>
</li>
</ul>
</li>
<li><p>高可用实现</p>
<ul>
<li><p>每个主节点可以有 <strong>1 个或多个从节点</strong></p>
</li>
<li><p>如果某个主节点宕机，其对应的 <strong>从节点会通过选举成为新的主节点</strong>（类似哨兵的故障转移，但是集群内置）</p>
</li>
<li><p>如果某个节点完全宕机且无从节点，则对应的 Slot 不可用</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ol>
<li>支持海量数据存储（通过分片）</li>
<li>支持高并发（多节点共同承担）</li>
<li>自动故障转移（内置，无需 Sentinel）</li>
<li>横向可扩展（可动态增加节点）</li>
<li>官方原生支持，无需第三方组件</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>架构复杂，部署和运维成本较高</li>
<li>不支持多 Key 操作（除非这些 Key 在同一个 Slot，可使用 Hash Tag</li>
<li>事务操作受限（跨节点事务不支持）</li>
<li>需要客户端支持 Cluster 协议（或使用代理）</li>
</ol>
</li>
</ol>
<p>三种集群策略 对比总结</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>主从复制</th>
<th>哨兵模式</th>
<th>Redis Cluster（集群）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据复制</strong></td>
<td>✅ Master → Slave</td>
<td>✅ Master → Slave</td>
<td>✅ 每个主节点有从节点，支持复制</td>
</tr>
<tr>
<td><strong>读写分离</strong></td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>✅ 支持（主写从读）</td>
</tr>
<tr>
<td><strong>高可用（自动 Failover）</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持（Sentinel）</td>
<td>✅ 支持（内置）</td>
</tr>
<tr>
<td><strong>数据分片 &#x2F; 扩展性</strong></td>
<td>❌ 不支持</td>
<td>❌ 不支持</td>
<td>✅ 支持（16384 slots，多主多从）</td>
</tr>
<tr>
<td><strong>数据存储能力</strong></td>
<td>❌ 单机限制</td>
<td>❌ 单机限制</td>
<td>✅ 海量数据，可扩展</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>中等</td>
<td>高（需理解分片、路由等）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少、简单备份</td>
<td>中小应用、要求高可用</td>
<td>大数据、高并发、生产级集群</td>
</tr>
</tbody></table>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol>
<li><p>事务（Transaction）</p>
<ol>
<li><p>使用 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>实现。</p>
<ol>
<li>将多个命令打包，按顺序执行，但<strong>不保证原子性（中间可能被其他客户端打断）</strong></li>
<li>WATCH 可以实现乐观锁。</li>
</ol>
</li>
<li><p>实现原理</p>
<ol>
<li><p>Redis 的事务提供了一种将多个命令打包，然后一次性、按顺序执行的机制。它的实现主要依赖三个核心命令：<code>MULTI</code>、<code>EXEC</code> 和 <code>DISCARD</code>。</p>
<ol>
<li><p>启动事务：<code>MULTI</code></p>
<ol>
<li>当客户端发送 <code>MULTI</code> 命令时，Redis 会将该客户端的状态从<strong>非事务模式</strong>切换到<strong>事务模式</strong>。</li>
<li>在此之后，客户端发送的任何命令（除了 <code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 等少数几个命令）都不会立即执行。</li>
<li>相反，这些命令会被放入一个<strong>命令队列</strong>中，等待后续执行。</li>
<li>Redis 只是简单地回复 <code>QUEUED</code>，表示命令已成功入队。</li>
</ol>
</li>
<li><p>执行事务：<code>EXEC</code></p>
<ol>
<li>当客户端发送 <code>EXEC</code> 命令时，Redis 事务正式开始执行。</li>
<li>Redis 会将命令队列中的所有命令<strong>按顺序、原子性地一次性执行完毕</strong>。</li>
<li>执行完后，Redis 会将每个命令的执行结果按顺序打包成一个列表（Array）返回给客户端。</li>
<li>客户端退出事务模式。</li>
</ol>
</li>
<li><p>取消事务：<code>DISCARD</code></p>
<ol>
<li>如果客户端在 <code>MULTI</code> 之后，但在 <code>EXEC</code> 之前发送 <code>DISCARD</code> 命令，Redis 会清空命令队列。</li>
<li>客户端退出事务模式，所有已入队的命令都不会被执行。</li>
</ol>
</li>
<li><p>监控键值：<code>WATCH</code> </p>
<ol>
<li>命令用于监视（Watch）一个或多个键。它的核心机制可以概括为一句话：</li>
<li>如果在 <code>WATCH</code> 之后，到 <code>EXEC</code> 执行之前，任何被监视的键发生了修改，那么整个事务将被取消（EXEC 返回空）。</li>
<li>当 <code>EXEC</code> 失败（返回空响应）时，客户端程序就知道事务执行失败了，因为它依赖的底层数据已经被修改，必须：<ol>
<li>清除监视： 自动或手动（通过 <code>UNWATCH</code> 命令）清除当前的监视状态。</li>
<li>重试： 从第 1 步重新开始整个操作流程（重新 <code>WATCH</code>，重新读取数据，重新计算，重新 <code>EXEC</code>）。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>错误处理</p>
<ol>
<li>入队时发现的错误（Syntax Error）<ul>
<li>如果在 <code>MULTI</code> 和 <code>EXEC</code> 之间，客户端发送了一个<strong>格式错误</strong>（如拼写错误、参数数量错误等）的命令，Redis 会在入队时就发现这个错误。</li>
<li>在这种情况下，Redis 会拒绝执行整个事务队列，当执行 <code>EXEC</code> 时，<strong>所有</strong>命令都不会被执行。</li>
</ul>
</li>
<li>执行时发现的错误（Runtime Error）***<ul>
<li>如果在 <code>EXEC</code> 执行过程中，某个命令因为<strong>操作了错误的数据类型</strong>等原因而执行失败（Runtime Error），<strong>Redis 不会回滚（Rollback）</strong> 已经执行成功的命令。</li>
<li>事务中其他<strong>执行成功的命令仍然会生效</strong>，只有失败的命令返回错误信息。</li>
<li><strong>这是 Redis 事务与关系型数据库事务最大的区别之一。</strong> Redis 强调的是简单和高性能，它不会为了支持回滚而引入额外的复杂性。</li>
</ul>
</li>
</ol>
</li>
<li><p>并发控制</p>
<ol>
<li>为了解决事务过程中数据被其他客户端修改的问题，Redis 引入了 <code>WATCH</code> 命令，实现了<strong>乐观锁（Optimistic Locking）</strong>：<ol>
<li><strong><code>WATCH key [key ...]</code></strong>: 客户端在 <code>MULTI</code> 之前使用 <code>WATCH</code> 监视一个或多个键。</li>
<li><strong>执行事务</strong>: 客户端执行 <code>MULTI</code>，然后发送命令入队。</li>
<li><strong>检查</strong>: 当客户端执行 <code>EXEC</code> 时，Redis 会检查所有被 <code>WATCH</code> 监视的键。</li>
<li><strong>失败</strong>: 如果在 <code>WATCH</code> 之后到 <code>EXEC</code> 之前，<strong>任何一个</strong>被监视的键被其他客户端修改了，那么整个事务将被<strong>中断和取消</strong>，<code>EXEC</code> 命令会返回一个空结果（Null Reply）。</li>
<li><strong>重试</strong>: 客户端需要重新 <code>WATCH</code> 键，并重新执行整个事务流程。</li>
</ol>
</li>
</ol>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性如何实现？Redis没有回滚机制，是否破坏了原子性？</p>
<ol>
<li>我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断</li>
<li>在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性</li>
<li>虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。</li>
<li>并且运行时错误多为编程错误，可以避免。</li>
</ol>
</li>
<li><p>一致性如何实现？</p>
<ol>
<li><strong>内部一致性：</strong> Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。</li>
<li><strong>事务隔离性：</strong> <code>I</code> 的保证间接支撑了 <code>C</code>，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。</li>
</ol>
</li>
<li><p>隔离性如何实现？</p>
<ol>
<li>Redis 对隔离性的保证是<strong>非常强大</strong>的，因为它基于单线程模型。</li>
<li>保证方式： Redis 使用 <strong>单线程</strong> 模型处理所有客户端请求（除了后台的持久化操作）。</li>
<li>结果： <code>MULTI</code>&#x2F;<code>EXEC</code> 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。</li>
<li>总结： <strong>Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离</strong>。</li>
</ol>
</li>
<li><p>持久性如何实现？</p>
<ol>
<li><p>Redis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，<strong>默认情况下持久性是有风险的</strong>。</p>
</li>
<li><p>Redis 主要通过两种方式实现持久性：</p>
<ol>
<li><strong>AOF (Append Only File) 模式：</strong><ul>
<li>将所有写命令以日志形式追加到文件中。</li>
<li>如果配置了 <code>always</code> 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。</li>
<li>但为了性能，通常配置为 <code>everysec</code>（每秒同步一次），这意味着最近一秒内的数据可能会丢失。</li>
</ul>
</li>
<li><strong>RDB (Redis Database) 快照模式：</strong><ul>
<li>定期将内存中的数据生成一个二进制快照文件。</li>
<li>由于是<strong>定期</strong>快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>总结：</strong> Redis 的持久性是<strong>可配置的</strong>。只有在启用 AOF 并设置为 <code>always</code> 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h3><ol>
<li>是什么<ol>
<li><strong>Lua</strong> 是一种轻量级、高效、可嵌入的脚本语言，可作为编程语言的扩展语言，被广泛的运用到Redis脚本中</li>
</ol>
</li>
<li>在Redis中的应用<ol>
<li>原子性操作<ul>
<li>Redis 执行 单个命令是原子性的，但多个命令组合在一起 默认不是原子性 的（中间可能被其他客户端的命令插入）。</li>
<li>把多个命令封装进一个 Lua 脚本，Redis 会<strong>一次性、按顺序执行脚本里的所有命令，不会被其他操作打断</strong>，保证原子性。</li>
</ul>
</li>
<li>减少网络开销<ul>
<li>如果你要执行多个 Redis 命令，通常需要多次网络往返。</li>
<li>使用 Lua 脚本，可以把多个命令一次性发送到 Redis 服务端执行，<strong>只需一次网络通信</strong>，提高效率。</li>
</ul>
</li>
<li>复杂业务逻辑<ul>
<li>有些业务逻辑比较复杂，比如“先判断再修改”、“循环操作”、“带条件的多键操作”等，用 Lua 脚本可以在服务端高效完成。</li>
</ul>
</li>
<li>实现分布式锁、计数器、限流等高级功能<ul>
<li>像 Redis 分布式锁的正确释放（判断 value 一致再 DEL）</li>
<li>限流算法（如令牌桶、漏桶）</li>
<li>排行榜加分、扣分逻辑都可以用 Lua 脚本优雅地实现。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="过期策略与内存淘汰机制"><a href="#过期策略与内存淘汰机制" class="headerlink" title="过期策略与内存淘汰机制"></a>过期策略与内存淘汰机制</h3><ol>
<li>过期策略<ol>
<li><p>可以给 Key 设置过期时间：<code>EXPIRE key seconds</code></p>
</li>
<li><p>Redis 采用以下两种方式清理过期 Key：</p>
<ol>
<li><strong>定期删除</strong>：每隔一段时间随机抽取一些 key 检查是否过期</li>
<li><strong>惰性删除</strong>：当访问某个 key 时，检查是否过期，如果过期则删除</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>⚠️ 过期不会立即释放内存，而是惰性或定期清理。</p>
</blockquote>
<ol start="2">
<li>内存淘汰机制（maxmemory-policy）</li>
</ol>
<p>当 Redis 内存达到上限时，根据策略删除部分 key，常见策略包括：</p>
<ul>
<li>noeviction（默认）：不删除，写入报错</li>
<li>allkeys-lru：从所有 key 中淘汰最近最少使用的</li>
<li>volatile-lru：只从设置了过期时间的 key 中淘汰</li>
<li>allkeys-random &#x2F; volatile-random：随机淘汰</li>
<li>allkeys-ttl：优先淘汰快过期的</li>
</ul>
<blockquote>
<p>生产环境推荐使用：allkeys-lru 或 volatile-lru</p>
</blockquote>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><ol>
<li><p>概述</p>
<ol>
<li>在分布式系统中，多个进程或服务（可能运行在不同的服务器上）可能会同时尝试访问共享资源（如数据库、文件、缓存等），为了保证数据一致性，我们需要一种跨进程&#x2F;服务的互斥机制，这就是 分布式锁（Distributed Lock）。</li>
<li>在分布式系统中，传统的线程锁（如 Java 的 synchronized、ReentrantLock）<strong>只能在单个 JVM 内起作用</strong>，无法跨进程、跨服务器工作。而 <strong>Redis 是一个高性能的、支持网络访问的、内存数据库，天生适合用来实现跨服务的锁机制。</strong></li>
<li>注意是用Redis实现一个分布式锁，而不是Redis内部机制（毕竟Redis是单线程的，不用考虑分布式锁）</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>使用 Redis 的 <code>SET key value NX PX timeout</code>命令，来实现：</p>
<ul>
<li><strong>互斥性（Mutual Exclusion）</strong>：同一时刻只有一个客户端能成功设置锁</li>
<li><strong>避免死锁</strong>：锁必须要有过期时间，防止客户端崩溃后锁永远不释放</li>
<li><strong>锁的释放必须是原子的且只能由加锁者释放</strong>：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁</li>
</ul>
</li>
<li><p>释放锁（<strong>必须验证锁是自己的！！</strong>）</p>
<ol>
<li>不能直接用 <code>DEL lockKey</code>，因为：<ol>
<li>如果 A 加了锁，但锁过期了，B 获取到了锁</li>
<li>此时 A 的业务还没执行完，但锁已经失效，A 还去执行 <code>DEL</code>，就会把 B 的锁删掉 ❌</li>
</ol>
</li>
<li>正确做法：使用 Lua 脚本保证原子性，校验 value 一致才删除<ol>
<li>Lua 脚本如下：</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>KEYS[1]</code>是锁的 key，比如 <code>order_lock_123</code></li>
<li><code>ARGV[1]</code>是加锁时设置的唯一标识（requestId &#x2F; UUID）</li>
</ul>
</li>
</ol>
</li>
<li><p>实现方式</p>
<ol>
<li><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 30000</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解释：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>lock_key</code></td>
<td align="left">锁的名称，比如 <code>order_lock_123</code></td>
</tr>
<tr>
<td align="left"><code>unique_value</code></td>
<td align="left">唯一标识，通常是 UUID 或 客户端生成的随机字符串，用于标识锁的持有者</td>
</tr>
<tr>
<td align="left"><code>NX</code></td>
<td align="left">仅当 key 不存在时才设置成功（保证互斥）</td>
</tr>
<tr>
<td align="left"><code>PX 30000</code></td>
<td align="left">设置锁的过期时间，单位毫秒（这里是 30 秒），防止死锁</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="常见问题与优化建议"><a href="#常见问题与优化建议" class="headerlink" title="常见问题与优化建议"></a>常见问题与优化建议</h3><table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">本质</th>
<th align="left">原因</th>
<th align="left">解决方案关键词</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>缓存穿透</strong></td>
<td align="left">查询了不存在的数据，每次都访问 DB</td>
<td align="left">恶意&#x2F;错误查询、缓存没有拦截</td>
<td align="left">布隆过滤器、缓存空对象</td>
</tr>
<tr>
<td align="left"><strong>缓存击穿</strong></td>
<td align="left">热点 key 突然失效，大量请求直达 DB</td>
<td align="left">单个热点 key 过期，高并发访问</td>
<td align="left">永不过期（逻辑过期）、互斥锁</td>
</tr>
<tr>
<td align="left"><strong>缓存雪崩</strong></td>
<td align="left">大量 key 同时失效 &#x2F; Redis 宕机，DB 崩溃</td>
<td align="left">过期时间集中、Redis 故障</td>
<td align="left">随机过期、多级缓存、高可用、熔断</td>
</tr>
</tbody></table>
<ol>
<li><p>缓存穿透</p>
<ol>
<li><p>查询一个<strong>不存在的数据</strong>，导致每次都访问数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>布隆过滤器</p>
<ol>
<li><p>布隆过滤器是一种空间效率极高、用于判断某个元素是否可能存在于集合中的数据结构。</p>
<ul>
<li>在缓存层或应用启动时，将所有合法的数据 key 提前加载到布隆过滤器中</li>
<li>当用户查询某个 key 时，先经过布隆过滤器判断：这个 key 是否可能存在如果布隆过滤器判断 “不存在” → 直接返回，不去查缓存和数据库如果判断 “可能存在” → 再去查缓存&#x2F;数据库</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><p>对于大量不存在的 key 请求，在第一层就拦截掉</p>
</li>
<li><p>占用内存极小，效率高</p>
</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li><p>适合ID类查询、提前已知所有合法 key 的业务（如商品 ID、用户 ID）</p>
</li>
<li><p>常用于防止恶意或错误查询穿透到数据库</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>缓存空对象</p>
<ol>
<li>即使数据库查询结果为空（比如 ID 为 999 的用户不存在），也把这个 <strong>空结果进行缓存</strong>，并设置一个较短的过期时间（如 30~60 秒）。</li>
<li>下次同样查询时，缓存中能命中这个“空值”，就不再查数据库。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>缓存击穿</p>
<ol>
<li><p>某个<strong>热点 key 突然失效</strong>，大量请求直接打到数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>设置热点 key 永不过期（逻辑过期）</p>
<ol>
<li><p>对于特别热点的 key，不设置真正的过期时间（或者设置一个非常长的时间）</p>
</li>
<li><p>但数据本身可以设置一个 “逻辑过期时间”（比如在 value 中保存一个过期时间戳）</p>
</li>
<li><p>后台启动一个 定时任务或异步线程，在数据即将过期时，异步更新缓存</p>
</li>
<li><p><strong>优点：</strong> 避免大量请求同时击穿缓存</p>
</li>
<li><p><strong>缺点：</strong> 数据更新可能有一定延迟，需要维护逻辑过期时间</p>
</li>
</ol>
</li>
<li><p>使用互斥锁（Mutex Lock） &#x2F; 分布式锁重建缓存</p>
<ol>
<li><p>当缓存未命中时，不是所有请求都去查数据库，而是：</p>
<ol>
<li>第一个请求去查库，并重建缓存，同时对其他请求加锁（互斥）</li>
<li>其它请求发现锁存在，就 等待或短暂休眠后重试，或者直接返回旧数据 &#x2F; 默认值</li>
<li>锁释放后，其它请求再尝试从缓存获取</li>
</ol>
</li>
<li><p>实现方式：</p>
<ul>
<li><p>使用 Redis 的 <code>SETNX</code>或 <code>RedLock</code>等实现分布式锁</p>
</li>
<li><p>或者使用本地锁（单机情况下）</p>
</li>
</ul>
</li>
<li><p>关键点： 只让 一个请求去查库并重建缓存，其他请求等待或重试</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>缓存雪崩</p>
<ol>
<li><p>大量 key <strong>在同一时间过期</strong>，导致请求全部压到数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>设置不同的过期时间（随机过期）</p>
<ul>
<li><p>为每个缓存 key 的过期时间添加一个 随机值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基础过期时间：3600 秒（1小时）</span><br><span class="line">随机值：± 300 秒（5分钟）</span><br><span class="line">=&gt; 最终过期时间在 3300 ~ 3900 秒之间</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免大量 key 同时失效，错开缓存刷新时间</p>
</li>
</ul>
</li>
<li><p>使用多级缓存</p>
<ul>
<li><p>不止依赖 Redis，还可以引入本地缓存（如 Caffeine、Guava Cache）作为一级缓存</p>
</li>
<li><p>Redis 作为二级缓存</p>
</li>
<li><p>即使 Redis 缓存失效，本地缓存还能挡一波请求</p>
<p>优点： 多层防护，即使某一层失效，也有兜底</p>
</li>
</ul>
</li>
<li><p>Redis 高可用（主从 + 哨兵 &#x2F; 集群）</p>
<ul>
<li>避免因为 Redis 宕机 导致所有缓存不可用</li>
<li>通过 Redis Sentinel 或 Cluster 提高 Redis 自身的可用性</li>
</ul>
</li>
<li><p>熔断降级 &amp; 请求限流</p>
<ul>
<li>当数据库压力过大时，可使用 熔断机制（如 Hystrix、Sentinel、Resilience4j）</li>
<li>或对请求进行 限流（如令牌桶、漏桶算法），保护数据库</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>性能优化建议</p>
<ul>
<li><p>避免大 Key（如大 Hash、大 List）、热 Key</p>
</li>
<li><p>合理使用 Pipeline 批量操作，减少网络往返</p>
</li>
<li><p>根据业务选择合适的数据结构</p>
</li>
<li><p>监控慢查询、内存使用、命中率等指标</p>
</li>
</ul>
</li>
</ol>
<h3 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h3><ol>
<li><p>是什么</p>
<ol>
<li>Redis 的 <strong>Pub&#x2F;Sub（发布&#x2F;订阅）</strong> 是一种<strong>消息通信模式</strong>，它允许：<ul>
<li><strong>发送者（Publisher）</strong> 向 <strong>指定的频道（Channel）发送消息</strong>；</li>
<li><strong>接收者（Subscriber）</strong> 可以<strong>订阅一个或多个频道</strong>，从而<strong>接收发送到这些频道的消息</strong>；</li>
</ul>
</li>
<li>关键点：<ul>
<li>发布者和订阅者之间<strong>没有直接的连接或耦合</strong>；</li>
<li>消息传递是<strong>实时的、广播式的</strong>；</li>
<li>Redis Pub&#x2F;Sub 是<strong>基于内存的、即发即弃（fire-and-forget）的消息系统</strong>，<strong>不提供消息持久化</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><strong>订阅者（Subscriber）</strong> 通过命令订阅一个或多个频道；</li>
<li><strong>发布者（Publisher）</strong> 向某个频道发送消息；</li>
<li><strong>Redis 服务器</strong> 将该消息<strong>实时推送给所有订阅了该频道的订阅者</strong>；</li>
<li>如果某个客户端<strong>没有订阅该频道，则不会收到任何消息</strong>。</li>
</ol>
</li>
<li><p>命令</p>
<ol>
<li><p>订阅频道（Subscribe）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel1 [channel2 ...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE news sports</span><br></pre></td></tr></table></figure>

<p>订阅者会进入监听模式，等待消息。此时 Redis CLI 会阻塞，等待发布消息。</p>
</li>
<li><p>发布消息（Publish）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH news &quot;Hello, this is a news update!&quot;</span><br></pre></td></tr></table></figure>

<p>这条消息会被推送给所有订阅了 <code>news</code>频道的客户端。</p>
</li>
<li><p>取消订阅（Unsubscribe）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE [channel1 channel2 ...]</span><br></pre></td></tr></table></figure>

<p>如果不指定频道，则取消所有订阅。</p>
</li>
<li><p>查看活跃的频道（可选，用于监控）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB CHANNELS [pattern]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB CHANNELS news *</span><br></pre></td></tr></table></figure>

<p>可以查看当前有哪些频道正被订阅（支持通配符）。</p>
</li>
</ol>
</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h1 id="Redis-开发实战"><a href="#Redis-开发实战" class="headerlink" title="Redis 开发实战"></a>Redis 开发实战</h1><h2 id="环境配置与初始化"><a href="#环境配置与初始化" class="headerlink" title="环境配置与初始化"></a>环境配置与初始化</h2><h3 id="RedisConnectionFactory-无法自动装配"><a href="#RedisConnectionFactory-无法自动装配" class="headerlink" title="RedisConnectionFactory 无法自动装配"></a>RedisConnectionFactory 无法自动装配</h3><ul>
<li><p><strong>现象</strong>：<code>无法自动装配。找不到 &#39;RedisConnectionFactory&#39; 类型的 Bean。</code></p>
</li>
<li><p><strong>根源</strong>：Spring Boot 2.x&#x2F;3.x 默认使用 <strong>Lettuce</strong> 客户端，它依赖 <code>commons-pool2</code> 来实现连接池，若缺少该依赖，自动配置类 <code>RedisAutoConfiguration</code> 将不会生效。</p>
</li>
<li><p><strong>解决</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="序列化器-API-升级"><a href="#序列化器-API-升级" class="headerlink" title="序列化器 API 升级"></a>序列化器 API 升级</h3><ul>
<li><p><strong>现象</strong>：<code>GenericJackson2JsonRedisSerializer</code> 在新版本中被标记为弃用。</p>
</li>
<li><p><strong>最佳实践</strong>：使用统一的 <code>RedisSerializer.json()</code>。</p>
</li>
<li><p><strong>配置要点</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代化的 RedisTemplate 配置</span></span><br><span class="line">template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">template.setValueSerializer(RedisSerializer.json());</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="键值对规范"><a href="#键值对规范" class="headerlink" title="键值对规范"></a>键值对规范</h2><h3 id="RequestBody-引发的“脏键”问题"><a href="#RequestBody-引发的“脏键”问题" class="headerlink" title="@RequestBody 引发的“脏键”问题"></a>@RequestBody 引发的“脏键”问题</h3><ul>
<li><strong>现象</strong>：Redis 中出现的 Key 包含 <code>\r\n</code>、大括号和引号，例如：<code>&quot;verificationCodes::{\r\n \&quot;phoneNumber\&quot;: \&quot;191...\&quot; \r\n}&quot;</code>。</li>
<li><strong>原因分析</strong>：<ul>
<li>在 Controller 中错误使用了 <code>@RequestBody String phoneNumber</code>。</li>
<li><strong>陷阱</strong>：Spring 不会自动解析 JSON 字段，而是将<strong>整个请求体字符串</strong>（含换行符、空格）赋值给了变量，导致生成 Key 时包含了原始 JSON 源码。</li>
</ul>
</li>
<li><strong>正确方案</strong>：<ol>
<li><strong>定义 DTO</strong>：使用 <code>VerifyCodeRequest</code> 接收参数。</li>
<li><strong>显式传参</strong>：<code>service.generateCode(request.getPhoneNumber())</code>。</li>
</ol>
</li>
</ul>
<h3 id="Redis-CLI-查询不到数据"><a href="#Redis-CLI-查询不到数据" class="headerlink" title="Redis CLI 查询不到数据"></a>Redis CLI 查询不到数据</h3><ul>
<li><strong>现象</strong>：代码里存成功了，但 <code>GET</code> 结果为 <code>(nil)</code>。</li>
<li><strong>排查清单</strong>：<ul>
<li><strong>前缀检查</strong>：Spring Cache 注解默认会加 <code>cacheName::</code> 前缀（如 <code>verificationCodes::191...</code>）。</li>
<li><strong>引号问题</strong>：JSON 序列化器会在 String 两端加上双引号。在 CLI 查询时需尝试：<code>GET &quot;verificationCodes::19151213369&quot;</code>。</li>
<li><strong>序列化器一致性</strong>：存的时候用 JSON 序列化，查的时候必须用同样的序列化器。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="业务场景：验证码实战"><a href="#业务场景：验证码实战" class="headerlink" title="业务场景：验证码实战"></a>业务场景：验证码实战</h2><h3 id="验证码为何不推荐使用注解（-Cacheable）？"><a href="#验证码为何不推荐使用注解（-Cacheable）？" class="headerlink" title="验证码为何不推荐使用注解（@Cacheable）？"></a>验证码为何不推荐使用注解（@Cacheable）？</h3><ul>
<li><strong>对比结论</strong>：验证码业务属于**“复杂逻辑”**，推荐使用 <code>StringRedisTemplate</code>。</li>
<li><strong>原因</strong>：<ol>
<li><strong>精细控制</strong>：验证码需要精确的 TTL（如 5 分钟），注解通常只能设置全局过期。</li>
<li><strong>原子性操作</strong>：验证码“验证成功即删除”的操作，手动代码比注解更容易实现。</li>
<li><strong>Key 的纯净度</strong>：<code>StringRedisTemplate</code> 强制 Key&#x2F;Value 均为纯字符串，避免了 JSON 序列化带来的额外引号干扰。</li>
</ol>
</li>
</ul>
<h3 id="验证码服务标准实现模式"><a href="#验证码服务标准实现模式" class="headerlink" title="验证码服务标准实现模式"></a>验证码服务标准实现模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VerificationCodeService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate; <span class="comment">// 推荐使用 String 专用模板</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateCode</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>; <span class="comment">// 随机逻辑</span></span><br><span class="line">        <span class="comment">// 显式指定 Key 格式和过期时间</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;vcode:&quot;</span> + phone, code, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="架构选择：注解-vs-手动"><a href="#架构选择：注解-vs-手动" class="headerlink" title="架构选择：注解 vs 手动"></a>架构选择：注解 vs 手动</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring Cache (@Cacheable)</th>
<th align="left">RedisTemplate (手动)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定位</strong></td>
<td align="left"><strong>减轻数据库查询压力</strong></td>
<td align="left"><strong>实现复杂业务逻辑</strong></td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">学生详情、商品信息、分页列表</td>
<td align="left">验证码、分布式锁、计数器、Token</td>
</tr>
<tr>
<td align="left"><strong>优点</strong></td>
<td align="left">代码零侵入，只需在 Service 加注解</td>
<td align="left">极度灵活，支持所有 Redis 数据结构</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left">对 TTL 和局部更新支持较弱</td>
<td align="left">需要编写重复的模板代码</td>
</tr>
</tbody></table>
<hr>
<h2 id="调试与排障-Troubleshooting"><a href="#调试与排障-Troubleshooting" class="headerlink" title="调试与排障 (Troubleshooting)"></a>调试与排障 (Troubleshooting)</h2><h3 id="常用调试指令"><a href="#常用调试指令" class="headerlink" title="常用调试指令"></a>常用调试指令</h3><ul>
<li><strong>监控实时操作</strong>：<code>redis-cli monitor</code>（排查 Key 到底长什么样的神器）。</li>
<li><strong>查看 Key 的细节</strong>：<ul>
<li><code>TTL key</code>：查看剩余秒数。</li>
<li><code>TYPE key</code>：查看数据类型（String&#x2F;Hash&#x2F;List）。</li>
</ul>
</li>
<li><strong>清空环境</strong>：<code>FLUSHDB</code>（开发阶段解决序列化冲突最快的方法）。</li>
</ul>
<h3 id="排查清单-Checklist"><a href="#排查清单-Checklist" class="headerlink" title="排查清单 (Checklist)"></a>排查清单 (Checklist)</h3><ol>
<li><strong>Key 对吗？</strong> 是否有意外的前缀或 JSON 结构？</li>
<li><strong>过期了吗？</strong> TTL 是否设置过短？</li>
<li><strong>序列化对吗？</strong> 存的是 JSON 字符串还是纯字符串？</li>
<li><strong>参数对吗？</strong> Controller 接收的是整个 JSON 块还是具体的字段？</li>
</ol>
<hr>
<h3 id="总结感悟"><a href="#总结感悟" class="headerlink" title="总结感悟"></a>总结感悟</h3><ul>
<li><strong>简单数据走注解，业务数据走 Template。</strong></li>
<li><strong>永远不要信任 <code>@RequestBody String</code>，请务必使用 DTO。</strong></li>
<li><strong>Redis CLI 看到的 Key 才是真相，不要被 Java 代码里的变量名迷惑。</strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java与JVM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:30:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:30:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java生命周期"><a href="#Java生命周期" class="headerlink" title="Java生命周期"></a>Java生命周期</h2><ol>
<li>编码阶段（Writing Code）</li>
</ol>
<ul>
<li><strong>开发者编写源代码</strong>，文件后缀为 <code>.java</code>。<br>比如：<code>HelloWorld.java</code>。</li>
<li>源代码中包含类（<code>class</code>）、方法（<code>method</code>）等，使用 <strong>Java 语法</strong>。</li>
</ul>
<hr>
<ol start="2">
<li>编译阶段（Compiling）</li>
</ol>
<ul>
<li><p>使用 <strong>Java 编译器 <code>javac</code></strong> 将 <code>.java</code> 文件编译成 <strong>字节码文件</strong>（<code>.class</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>

</li>
<li><p>编译后生成 <code>HelloWorld.class</code> 文件。</p>
</li>
<li><p>注意：字节码不是机器码，而是一种中间形式，跨平台。</p>
</li>
</ul>
<hr>
<ol start="3">
<li>类加载阶段（Class Loading）</li>
</ol>
<ul>
<li>当运行程序时（<code>java HelloWorld</code>），<strong>类加载器（ClassLoader）</strong> 会把需要的 <code>.class</code> 文件加载进内存。</li>
<li>类加载过程分为三个小步骤：<ol>
<li><strong>加载（Loading）</strong>：把字节码读到内存。</li>
<li><strong>连接（Linking）</strong>：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。</li>
<li><strong>初始化（Initialization）</strong>：执行静态代码块、给静态变量赋初值。</li>
</ol>
</li>
</ul>
<hr>
<ol start="4">
<li>字节码执行阶段（Execution）</li>
</ol>
<ul>
<li><p><strong>Java 虚拟机（JVM）解释执行字节码</strong>，也可能使用 <strong>JIT（即时编译器）</strong> 把热点代码编译成本地机器码，以提高运行效率。</p>
</li>
<li><p>执行的起点是程序入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="5">
<li>程序运行时（Runtime）</li>
</ol>
<ul>
<li>JVM 在运行时会：<ul>
<li><strong>内存管理</strong>：使用 <strong>堆、栈、方法区、运行时常量池</strong> 等。</li>
<li><strong>垃圾回收（GC）</strong>：回收不再使用的对象内存。</li>
<li><strong>异常处理</strong>：执行过程中出现异常时，JVM 按照异常机制处理。</li>
</ul>
</li>
</ul>
<hr>
<ol start="6">
<li>程序终止（Termination）</li>
</ol>
<ul>
<li>当 <code>main</code> 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。</li>
<li>在退出前，可能会执行 <code>finally</code> 块、<code>shutdown hook</code>（关闭钩子）。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java开发生态学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li><p>目录结构：</p>
<ol>
<li><p><strong><code>/bin</code></strong></p>
<ul>
<li>存放常用的二进制可执行文件（命令），如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>cat</code>。</li>
<li>所有用户都可以使用。</li>
</ul>
</li>
<li><p><strong><code>/sbin</code></strong></p>
<ul>
<li>存放系统管理用的二进制程序，如 <code>reboot</code>、<code>ifconfig</code>。</li>
<li>一般由 root 管理员使用。</li>
</ul>
</li>
<li><p><strong><code>/boot</code></strong></p>
<ul>
<li>启动相关文件，比如内核 <code>vmlinuz</code>、引导程序 <code>grub</code> 配置。</li>
<li>系统开机时最先用到。</li>
</ul>
</li>
<li><p><strong><code>/dev</code></strong></p>
<ul>
<li>存放设备文件（不是实际的硬件，而是设备接口）。</li>
<li>比如 <code>/dev/sda</code>（硬盘）、<code>/dev/tty</code>（终端）、<code>/dev/null</code>。</li>
</ul>
</li>
<li><p><strong><code>/etc</code></strong></p>
<ul>
<li>存放系统配置文件，例如：<ul>
<li><code>/etc/passwd</code> 用户信息</li>
<li><code>/etc/fstab</code> 磁盘挂载</li>
<li><code>/etc/apt/</code> apt 软件源配置</li>
</ul>
</li>
<li>里面通常没有二进制程序，主要是文本配置文件。</li>
</ul>
</li>
<li><p><strong><code>/home</code></strong></p>
<ul>
<li>普通用户的主目录。</li>
<li>例如用户 <code>hua</code> 的主目录是 <code>/home/hua</code>，里面存放桌面、下载、配置等。</li>
</ul>
</li>
</ol>
</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SSM学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ul>
<li>不需要完整学习 Spring（特别是 XML 配置那一套）。</li>
<li>只需要补齐一些 Spring 的核心概念：<ul>
<li><strong>IoC&#x2F;DI（控制反转 &#x2F; 依赖注入）</strong></li>
<li><strong>Bean 生命周期与作用域</strong></li>
<li><strong>AOP（切面编程，事务、日志、权限）</strong></li>
<li><strong>Spring MVC 的基本原理（DispatcherServlet、HandlerMapping、Controller）</strong><br> 👉 这些都是 Spring Boot 底层依然在用的，你必须理解，不然看不懂它的自动装配。</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/Java%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">Java八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><h3 id="Java中有哪些创建线程的方式？"><a href="#Java中有哪些创建线程的方式？" class="headerlink" title="Java中有哪些创建线程的方式？"></a>Java中有哪些创建线程的方式？</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1️⃣ 继承 <code>Thread</code>类</strong></td>
<td align="left">自定义类继承 <code>Thread</code>，并重写 <code>run()</code>方法，然后调用 <code>start()</code>启动线程</td>
<td align="left">实现简单，直观易懂</td>
<td align="left">Java 是单继承，继承了 <code>Thread</code>后不能再继承其他类；耦合性高，不够灵活</td>
<td align="left">适用于简单的示例代码、初学者理解线程基本概念</td>
</tr>
<tr>
<td align="left"><strong>2️⃣ 实现 <code>Runnable</code>接口</strong></td>
<td align="left">自定义类实现 <code>Runnable</code>接口，实现 <code>run()</code>方法，将实例作为参数传给 <code>Thread</code>对象，再调用 <code>start()</code></td>
<td align="left">实现接口，不占用继承名额，更灵活；适合多个线程共享同一个 Runnable 实例；面向接口编程</td>
<td align="left">依然需要显式创建 Thread 对象，不能直接获取返回值</td>
<td align="left">适用于大多数异步任务、线程任务无返回值的场景，是主流推荐方式之一</td>
</tr>
<tr>
<td align="left"><strong>3️⃣ 实现 <code>Callable&lt;V&gt;</code>接口 + 线程池&#x2F;Future</strong></td>
<td align="left">实现 <code>Callable&lt;V&gt;</code>接口，重写 <code>call()</code>方法（有返回值，可抛异常），通过 <code>ExecutorService.submit(Callable)</code>提交，返回 <code>Future&lt;V&gt;</code>对象获取结果</td>
<td align="left">可以<strong>返回执行结果</strong>，支持抛出异常，功能更强大</td>
<td align="left">使用稍复杂，需要依赖线程池和 Future 机制</td>
<td align="left">适用于需要获取线程执行结果、处理异常、并发计算等复杂任务</td>
</tr>
<tr>
<td align="left"><strong>4️⃣ 使用线程池（Executor 框架）</strong></td>
<td align="left">通过 <code>Executors</code>或 <code>ThreadPoolExecutor</code>创建线程池，提交 <code>Runnable</code>或 <code>Callable</code>任务，由线程池管理线程的创建与调度</td>
<td align="left">线程复用，避免频繁创建&#x2F;销毁线程的开销；统一管理线程生命周期；提高性能与资源利用率</td>
<td align="left">需要对线程池有一定了解，使用不当可能引发资源耗尽等问题</td>
<td align="left">生产环境、高并发、需要高效管理线程的场景，是业界最佳实践</td>
</tr>
</tbody></table>
<ol>
<li><p>继承 <code>Thread</code>类</p>
<ol>
<li><p>继承Thread类并重写run方法</p>
</li>
<li><pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println(&quot;线程运行中（继承Thread类）：&quot; + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程，调用run()
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 实现 `Runnable`接口</span><br><span class="line"></span><br><span class="line">   1. 重写（实现）run方法</span><br><span class="line"></span><br><span class="line">   2. ```java</span><br><span class="line">      class MyRunnable implements Runnable &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              System.out.println(&quot;线程运行中（实现Runnable接口）：&quot; + Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              Thread thread = new Thread(new MyRunnable());</span><br><span class="line">              thread.start();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>基于runnable的lambda表达式</p>
<ol>
<li><pre><code class="language-java">new Thread(() -&gt; {
    System.out.println(&quot;线程运行中（Lambda表达式）：&quot; + Thread.currentThread().getName());
}).start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">3. 实现 `Callable&lt;V&gt;`接口 + `FutureTask`</span><br><span class="line"></span><br><span class="line">   1. 类似 Runnable，但可以**有返回值**，能抛异常</span><br><span class="line"></span><br><span class="line">   2. ```JAVA</span><br><span class="line">      import java.util.concurrent.*;</span><br><span class="line">      </span><br><span class="line">      class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public String call() throws Exception &#123;</span><br><span class="line">              return &quot;线程返回值（实现Callable接口）：&quot; + Thread.currentThread().getName();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) throws Exception &#123;</span><br><span class="line">              // 创建线程池</span><br><span class="line">              ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">      </span><br><span class="line">              // 提交 Callable 任务，返回 Future</span><br><span class="line">              Future&lt;String&gt; future = executor.submit(new MyCallable());</span><br><span class="line">      </span><br><span class="line">              // 获取返回值（会阻塞直到任务完成）</span><br><span class="line">              String result = future.get();</span><br><span class="line">              System.out.println(result);</span><br><span class="line">      </span><br><span class="line">              // 关闭线程池</span><br><span class="line">              executor.shutdown();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用线程池（Executor 框架）</p>
<ol>
<li><p>通过线程池（如 <code>Executors</code>）管理线程的创建和执行</p>
</li>
<li><pre><code class="language-java">import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建 ThreadPoolExecutor
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,                      // 核心线程数（corePoolSize）
            4,                      // 最大线程数（maximumPoolSize）
            60,                     // 空闲线程存活时间
            TimeUnit.SECONDS,       // 时间单位
            new LinkedBlockingQueue&lt;&gt;(2),  // 任务队列（容量为2）
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：直接抛出异常
        );

        // 提交 8 个任务，观察线程池行为
        for (int i = 1; i &lt;= 8; i++) {
            final int taskId = i;
            executor.execute(() -&gt; {
                System.out.println(&quot;正在执行任务 &quot; + taskId + &quot;，线程：&quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // 模拟任务执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;任务 &quot; + taskId + &quot; 执行完毕&quot;);
            });
        }

        // 关闭线程池（不再接受新任务，等待已提交任务完成）
        executor.shutdown();
        System.out.println(&quot;所有任务已提交，线程池准备关闭...&quot;);
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">### 为什么不建议使用Excutors创建线程池？</span><br><span class="line"></span><br><span class="line">1. `Executors`是 Java 并发包 `java.util.concurrent`中的一个**工具类**，提供了几个静态工厂方法，用于**快速创建常见类型的线程池**。</span><br><span class="line">2. 不建议直接使用 `Executors`工具类提供的快捷方法（如 `newFixedThreadPool`、`newCachedThreadPool`等）来创建线程池，是因为这些方法在某些场景下可能导致资源耗尽、线程爆炸、任务堆积、内存溢出（OOM）等严重问题，存在潜在风险。</span><br><span class="line">   1. 原因：</span><br><span class="line">      1. 底层其实都是调用了 `ThreadPoolExecutor`或 `ScheduledThreadPoolExecutor`，但是对参数进行了**封装和默认设置**</span><br><span class="line">      2. 使用的是**无界队列** `LinkedBlockingQueue`，队列容量为 Integer.MAX_VALUE（约 2^31-1，非常大）</span><br><span class="line">      3. 如果任务提交速度 &gt; 线程处理速度，任务会不断堆积在队列中</span><br><span class="line">      4. 最终可能导致 **内存耗尽（OOM，OutOfMemoryError）**，因为任务对象、数据不断累积，队列无限增长</span><br><span class="line">3. 推荐使用 `ThreadPoolExecutor`手动构造线程池，以精确控制线程池行为，提高稳定性和可控性。</span><br><span class="line"></span><br><span class="line">### 线程池有哪几种状态？</span><br><span class="line"></span><br><span class="line">5种。</span><br><span class="line"></span><br><span class="line">| 状态名         | 值（高 3 位）                          | 含义                     | 说明                                                         |</span><br><span class="line">| :------------- | :------------------------------------- | :----------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **RUNNING**    | 111 （二进制） 即 -536870912（十进制） | **运行中**               | **接受新任务，并处理队列中的任务**                           |</span><br><span class="line">| **SHUTDOWN**   | 000 （二进制） 即 0（十进制）          | **关闭（不接受新任务）** | **不再接受新任务，但会继续处理队列中的任务**                 |</span><br><span class="line">| **STOP**       | 001 （二进制） 即 1（十进制）          | **停止**                 | **不再接受新任务，也不处理队列中的任务，并中断正在执行的任务** |</span><br><span class="line">| **TIDYING**    | 010 （二进制） 即 2（十进制）          | **整理中**               | **所有任务都已终止，workerCount = 0，线程池即将执行 terminated() 钩子方法** |</span><br><span class="line">| **TERMINATED** | 011 （二进制） 即 3（十进制）          | **已终止**               | **terminated() 方法已经执行完毕，线程池完全停止**            |</span><br><span class="line"></span><br><span class="line">### ThreadLocal</span><br><span class="line"></span><br><span class="line">详见笔记《ThreadLocal》</span><br><span class="line"></span><br><span class="line">### Tomcat为什么要用自定义类加载器？</span><br><span class="line"></span><br><span class="line">1. 在Tomcat中可能存在同名类。为了避免冲突和隔离资源，应该使用自定义类加载器。</span><br><span class="line"></span><br><span class="line">2. **Tomcat 是一个 Servlet 容器**，它负责运行多个独立的 Web 应用。每个 Web 应用可能有自己依赖的库，甚至可能用到相同库的不同版本。为了实现：</span><br><span class="line"></span><br><span class="line">   - **应用间类隔离**</span><br><span class="line">   - **核心库与用户库的区分加载**</span><br><span class="line">   - **支持热部署和灵活管理**</span><br><span class="line"></span><br><span class="line">   Tomcat **不得不打破双亲委派模型**。</span><br><span class="line"></span><br><span class="line">3. Tomcat 的类加载器架构（简化版）</span><br><span class="line"></span><br><span class="line">   1. Tomcat 设计了多种类加载器，典型的类加载器层次结构如下（从上到下）：</span><br><span class="line">      1. Bootstrap ClassLoader（JVM 提供，加载核心 Java 类，如 `java.*`）</span><br><span class="line">      2. Extension ClassLoader（加载扩展库，如 `javax.*`或 `$JAVA_HOME/lib/ext`下的类）</span><br><span class="line">      3. Application ClassLoader（即系统类加载器，加载 `classpath`下的类，通常是你的工程依赖）</span><br><span class="line">      4. **Common ClassLoader**（Tomcat 提供，加载 `CATALINA_HOME/lib`下的类，如 `servlet-api.jar`，这些是所有 Web 应用共享的）</span><br><span class="line">      5. **Webapp ClassLoader**（每个 Web 应用独有，加载该应用 `WEB-INF/classes`和 `WEB-INF/lib`下的类）</span><br><span class="line"></span><br><span class="line">4. Tomcat 如何打破双亲委派？</span><br><span class="line"></span><br><span class="line">   1. 关键点在于 **WebappClassLoader（Web 应用类加载器）** 的加载行为</span><br><span class="line"></span><br><span class="line">      1. 默认情况下（即标准双亲委派）：</span><br><span class="line"></span><br><span class="line">      - 当加载一个类时，类加载器会先委派给父加载器去加载，只有在父加载器找不到时，自己才尝试加载。</span><br><span class="line"></span><br><span class="line">   2. 但 Tomcat 的 WebappClassLoader **刻意颠倒了这一逻辑（部分打破双亲委派）**：对于 **Web 应用私有的类（如 WEB-INF 下的类）**，**WebappClassLoader 会优先尝试自己加载，而不是先委派给父加载器！*</span><br><span class="line"></span><br><span class="line">      1. 换句话说：</span><br><span class="line"></span><br><span class="line">      - 当 Web 应用需要加载一个类时，Tomcat 的 WebappClassLoader 会首先从当前应用的 `WEB-INF/classes`和 `WEB-INF/lib`中查找并加载类；</span><br><span class="line"></span><br><span class="line">      - 只有当找不到时，才会委派给父类加载器（如 CommonClassLoader 或更上层）去加载；</span><br><span class="line"></span><br><span class="line">5. 意义：</span><br><span class="line"></span><br><span class="line">   1. 不同 Web 应用可以拥有相同类库的不同版本，因为它们各自用自己的 WebappClassLoader 加载，互不干扰；</span><br><span class="line">   2. 核心类（如 Servlet API）仍然由 CommonClassLoader 或更上层加载，保证一致性；</span><br><span class="line">   3. **实现了类隔离与应用独立性**；</span><br><span class="line"></span><br><span class="line">6. 但 Tomcat 并没有完全抛弃双亲委派！</span><br><span class="line"></span><br><span class="line">   1. 对于一些 关键的、应该由全局统一管理的类（如 Servlet API、JSP 相关类等），Tomcat 仍然希望它们由公共的类加载器（如 CommonClassLoader）加载，而不是由每个 Web 应用自己的加载器加载，以避免混乱和冲突。</span><br><span class="line">   2. 因此，Tomcat 在实现 WebappClassLoader 时，对于 一些指定的包名（如 `javax.\*`, `org.apache.tomcat.\*`, `java.\*`等），仍然会优先走双亲委派，确保这些类由上层加载器加载，而不是由 Web 应用私自提供。</span><br><span class="line"></span><br><span class="line">### hashCode（）和 equals（）的联系</span><br><span class="line"></span><br><span class="line">1. 如果两个对象通过 `equals()`方法比较是相等的，那么它们的 `hashCode()`**必须相同**！</span><br><span class="line">2. 如果两个对象的 `hashCode()`相同，它们 **不一定** `equals()`为 true！</span><br><span class="line">   1. 这被称为 **哈希碰撞（Hash Collision）**，即不同的对象可能计算出相同的哈希值。这是 **允许的，并且很常见**，好的 hashCode 方法应尽量减少碰撞，但不能完全避免。</span><br><span class="line">3. 一定要同时重写 hashCode() 和 equals()</span><br><span class="line"></span><br><span class="line">### String，StringBuffer，StringBuilder</span><br><span class="line"></span><br><span class="line">1. String是常量，不可变</span><br><span class="line">2. StringBuilder可变，线程不安全。</span><br><span class="line">3. StringBuffer可变，线程安全（有synchronized修饰）</span><br><span class="line"></span><br><span class="line">### &quot;==&quot;和equals()的区别</span><br><span class="line"></span><br><span class="line">1. ==：如果比较的是基础数据类型，则比较值；如果是引用类型，则比较引用地址</span><br><span class="line">2. equals（）有比较逻辑</span><br><span class="line"></span><br><span class="line">### 重载和重写的区别（细节）</span><br><span class="line"></span><br><span class="line">1. 重载：发生在同一个类中，**方法名必须相同，必须要求参数列表不同**，如类型、个数、顺序不同。与返回值类型、访问修饰符、抛出的异常等无关。发生在编译时。</span><br><span class="line">2. 重写：发生在父子类中，方法名、参数列表必须相同。返回值、抛出异常的范围不大于父类，访问修饰符范围不小于父类（所以父类的private方法不可重写）。发生在运行时。</span><br><span class="line"></span><br><span class="line">### List和Set的区别</span><br><span class="line"></span><br><span class="line">1. ## </span><br><span class="line"></span><br><span class="line">2. | 区别维度             | **List（列表）**                                             | **Set（集合）**                                              |</span><br><span class="line">   | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">   | **是否允许重复元素** | **允许重复**                                                 | **不允许重复**（如果试图添加已存在的元素，添加失败，返回 false） |</span><br><span class="line">   | **是否有序**         | **有序**（按照元素的插入顺序保存，遍历时按插入顺序输出）     | **默认无序**（不保证顺序，但某些实现如 `LinkedHashSet`和 `TreeSet`有特定顺序） |</span><br><span class="line">   | **访问方式**         | 允许下标访问和迭代器遍历。                                   | 不允许下表访问，可以用迭代器访问。                           |</span><br><span class="line">   | **底层常用实现类**   | `ArrayList`、`LinkedList`、`Vector`                          | `HashSet`、`LinkedHashSet`、`TreeSet`                        |</span><br><span class="line">   | **主要用途**         | 适合存储 **有序的、可能重复的数据列表**，比如用户列表、商品列表等 | 适合存储 **唯一值的集合**，比如标签、黑名单、不重复的用户 ID 等 |</span><br><span class="line">   | **接口继承自**       | `Collection`                                                 | `Collection`                                                 |</span><br><span class="line">   | **元素排序**         | 按插入顺序                                                   | 默认无序，但： • `TreeSet`：**自然排序 或 自定义排序** • `LinkedHashSet`：**按插入顺序** |</span><br><span class="line"></span><br><span class="line">### HashMap 是线程安全的吗？不是的话，多线程操作会导致什么问题？</span><br><span class="line"></span><br><span class="line">- （1.7 的死循环问题了解吗？1.8 数据覆盖问题了解吗？）</span><br><span class="line"></span><br><span class="line">1. **JDK 1.7 中 HashMap 的并发问题（经典死循环问题！）**</span><br><span class="line"></span><br><span class="line">   1. 问题背景：</span><br><span class="line"></span><br><span class="line">   在 JDK 1.7 的 HashMap 中，多线程并发执行 put 操作，并且触发了扩容（rehash），可能会导致链表形成环形结构（环形链表），进而导致后续 get() 操作时 CPU 100%、死循环！</span><br><span class="line"></span><br><span class="line">   2. 问题原因（核心）：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容机制是：创建新数组，然后对原数组每个桶上的 Entry 链表进行头插法迁移</span><br><span class="line"></span><br><span class="line">      - 头插法：新节点插入链表头部</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，多个线程同时对同一个链表进行头插，可能导致链表节点互相引用，形成环</span><br><span class="line"></span><br><span class="line">   3. 举例说明（简化版）：</span><br><span class="line"></span><br><span class="line">      1. 假设线程 A 和线程 B 同时触发扩容，都操作同一个链表：</span><br><span class="line"></span><br><span class="line">         - 原链表：A → B → C</span><br><span class="line"></span><br><span class="line">         - 线程 A 执行了一半，链表变成了 B → A</span><br><span class="line"></span><br><span class="line">         - 线程 B 也执行，可能把链表改成了 C → B → A → C → …（形成环）</span><br><span class="line"></span><br><span class="line">         - 当你后续调用 `get(key)`，遍历这个链表时，就会 陷入死循环，CPU 飙升！</span><br><span class="line"></span><br><span class="line">   4. 根本原因：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容是头插法 + 单线程逐个迁移 + 没有同步机制</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，链表可能倒置、成环，造成死循环</span><br><span class="line"></span><br><span class="line">   &gt; **这是 JDK 1.7 HashMap 最著名、最严重的并发 Bug 之一，在生产环境中出现过多次事故！**</span><br><span class="line"></span><br><span class="line">2. **JDK 1.8 中 HashMap 的并发问题**</span><br><span class="line"></span><br><span class="line">   1. JDK 1.8 对 HashMap 做了重大优化，包括：</span><br><span class="line"></span><br><span class="line">      1. 改用 尾插法（解决了 1.7 头插法导致的链表倒置与死循环问题）</span><br><span class="line">      2. 引入 红黑树（优化查询效率）</span><br><span class="line">      3. 优化了 hash 计算与扩容机制</span><br><span class="line"></span><br><span class="line">      - 但！**JDK 1.8 的 HashMap 仍然是线程不安全的！**</span><br><span class="line"></span><br><span class="line">   2. 在多线程环境下，JDK 1.8 的 HashMap 可能出现以下问题：</span><br><span class="line"></span><br><span class="line">      1. **数据覆盖（Lost Update）**</span><br><span class="line"></span><br><span class="line">         - 多个线程同时 put 同一个 key，后写入的线程可能覆盖先写入的线程的值</span><br><span class="line"></span><br><span class="line">         - 因为 put 操作没有加锁，没有原子性保证</span><br><span class="line"></span><br><span class="line">      2. **数据丢失**</span><br><span class="line">         - 多线程同时执行 put，某些线程的 put 可能因为并发问题没有成功写入</span><br><span class="line"></span><br><span class="line">      3. **扩容时的数据错乱**</span><br><span class="line"></span><br><span class="line">         - 虽然 1.8 改用 尾插法，不再容易形成环形链表，但多线程并发扩容时，仍然可能导致链表或树结构混乱，数据错乱或丢失</span><br><span class="line"></span><br><span class="line">         - 比如多个线程同时迁移数据，可能没有正确链接节点</span><br><span class="line"></span><br><span class="line">      4. **仍然是非原子操作**</span><br><span class="line">         - 比如 **putIfAbsent、computeIfAbsent** 等复合逻辑，在多线程下也可能有问题，除非使用 ConcurrentHashMap 提供的对应原子方法</span><br><span class="line"></span><br><span class="line">### hashMap的扩容机制</span><br><span class="line"></span><br><span class="line">详见下面的ConcurrentHashMap的扩容机制。只不过线程不安全且不能多线程扩容。</span><br><span class="line"></span><br><span class="line">### 谈谈ConcurrentHashMap的扩容机制</span><br><span class="line"></span><br><span class="line">1. 为什么要扩容</span><br><span class="line"></span><br><span class="line">   1. 和 `HashMap`一样，`ConcurrentHashMap`也是基于 **哈希表（数组 + 链表/红黑树）** 实现的。</span><br><span class="line"></span><br><span class="line">      随着不断向 `ConcurrentHashMap`中 添加元素（put），哈希冲突可能增多，当某个桶（bucket）中的元素越来越多时：</span><br><span class="line"></span><br><span class="line">      - 如果是链表形式，查询效率会从 O(1) 退化为 O(n)；</span><br><span class="line">      - 如果链表长度超过阈值（默认为 8），并且数组长度达到一定大小，链表会转为 红黑树（O(log n)）；</span><br><span class="line">      - 但即便有了红黑树，如果 整个哈希表中的数据量很大，而底层数组（table）容量较小，依然会导致 哈希冲突严重，性能下降。</span><br><span class="line"></span><br><span class="line">      👉 因此，为了保证查询、插入的高效性，当元素数量达到一定阈值时，ConcurrentHashMap 会进行扩容（resize），即扩大底层数组的大小，重新分配元素，降低哈希冲突。</span><br><span class="line"></span><br><span class="line">2. 以Java 8为主，讲解扩容机制</span><br><span class="line"></span><br><span class="line">   1. 扩容触发条件</span><br><span class="line"></span><br><span class="line">      1. 当 **元素的总数量（默认16）超过 负载因子（默认 0.75） × 当前容量（capacity）** 时，即：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
size &gt;= capacity * loadFactor（默认 0.75）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">      也就是说，当 哈希表中的元素数量“过密”时，就会触发扩容。</span><br><span class="line"></span><br><span class="line">      2. **链表长度超过阈值（8），但数组长度较小（&lt; 64）时，也可能先触发扩容而非树化**</span><br><span class="line">         1. 链表转红黑树之前，可能先触发扩容</span><br><span class="line"></span><br><span class="line">   2. 扩容目标</span><br><span class="line"></span><br><span class="line">      - 扩容就是将 原数组（table）的容量扩大为原来的 2 倍（即 newCapacity = oldCapacity &lt;&lt; 1）。</span><br><span class="line">      - 扩容过程中，需要将旧数组中的每个 桶（bucket）中的元素，重新计算在新数组中的位置，并迁移到新数组中。</span><br><span class="line"></span><br><span class="line">   3. 扩容的核心思想：**多线程协同扩容（协助迁移）**</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容机制中一个非常 **厉害且高效的设计** 👇：</span><br><span class="line"></span><br><span class="line">      &gt; **扩容不再由某一个线程全权负责，而是支持多个线程并发地协助进行数据迁移，大大提升了扩容效率，避免了单线程扩容成为瓶颈。**</span><br><span class="line"></span><br><span class="line">      - **table**：当前正在使用的哈希桶数组。</span><br><span class="line">      - **nextTable**：扩容时创建的新数组，大小是原数组的两倍。</span><br><span class="line">      - **transferIndex**：表示当前迁移进度，从高位（数组末尾）开始，逐步向低位（数组开头）迁移。</span><br><span class="line">      - **sizeCtl**：控制标识符，用于表示当前容器的状态，比如是否正在初始化、是否正在扩容等。当 `sizeCtl &lt; 0`时，可能表示正在初始化或扩容。扩容时，它还用于控制并发扩容的线程数等。</span><br><span class="line"></span><br><span class="line">   4. 扩容大致流程（简化版）</span><br><span class="line"></span><br><span class="line">      1. **检测是否需要扩容**：当插入新元素后，总元素数超过 `capacity * loadFactor`，或者某个桶太满时，触发扩容检查。</span><br><span class="line">      2. **初始化 nextTable（新数组）**：创建一个新的数组，容量是原数组的 **2 倍**。</span><br><span class="line">      3. **多线程协同迁移（transfer）**：将原数组（table）中的每个 bucket 上的节点，**重新计算在新数组（nextTable）中的位置，并迁移过去**。每个线程会负责迁移一部分 bucket，通过 `transferIndex`控制迁移区间，避免冲突。每个 bucket 的迁移是通过 **锁住当前桶（synchronized 锁住链表头/树根节点）** 来进行的，保证线程安全。</span><br><span class="line">      4. **迁移完成后切换引用**：当所有 bucket 都迁移完成后，将 `table`指向 `nextTable`，`nextTable`成为新的主表，完成扩容。</span><br><span class="line"></span><br><span class="line">   5. 为什么能支持多线程协助扩容？</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容最牛的地方之一 ✨：</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，如果某个线程 put 时发现正在扩容，**它不会等待，而是主动参与迁移工作（协助扩容）**。</span><br><span class="line">      - 每个线程会分配到一部分 bucket 去迁移，通过 CAS 和 `transferIndex`控制各自负责的范围，避免重复和冲突。</span><br><span class="line">      - 这种 **“众人拾柴火焰高”** 的设计，极大地提升了大容量情况下的扩容速度，充分利用了多核 CPU 的能力。</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   6. 扩容期间访问怎么办？</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，**读操作（get）可以正常进行**，即使数据正在迁移。</span><br><span class="line">      - 如果读线程访问的 bucket **尚未迁移**，则从旧数组 table 中读取；</span><br><span class="line">      - 如果 **已经迁移**，则从新数组 nextTable 中读取；</span><br><span class="line">      - 写操作（put/remove）如果发现正在扩容，也可能 **协助迁移或等待迁移完成后再操作**。</span><br><span class="line"></span><br><span class="line">3. Java7是怎么实现的呢</span><br><span class="line"></span><br><span class="line">   1. 分段锁（Segment 继承 ReentrantLock）</span><br><span class="line">   2. 数据结构：</span><br><span class="line">      - ConcurrentHashMap 由多个 Segment 组成（默认是 16 个）</span><br><span class="line">      - 每个 Segment 继承自 ReentrantLock，是一个小的 HashMap（数组 + 链表）</span><br><span class="line">      - 每个 Segment 内部维护了一个 HashEntry&lt;K,V&gt;[] table</span><br><span class="line">   3.  线程安全如何保证？</span><br><span class="line">      - 对某个 Segment 的操作（如 put、get），只需要锁住该 Segment</span><br><span class="line">      - 不同 Segment 之间的操作是 并发安全且互不阻塞 的</span><br><span class="line">   4. 优点：</span><br><span class="line">      - 相比 Hashtable 的全表锁，并发度更高（默认支持 16 个线程并发写）</span><br><span class="line">      - 细化锁粒度，提升吞吐量</span><br><span class="line">   5. 缺点：</span><br><span class="line">      - 结构复杂：外层是 Segment 数组，内层是 HashEntry 数组</span><br><span class="line">      - 锁的粒度仍然较粗（一个 Segment 内还是锁整个桶）</span><br><span class="line">      - 不支持链表转红黑树，链表过长时性能下降明显</span><br><span class="line">      - 代码可维护性较差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 深拷贝和浅拷贝</span><br><span class="line"></span><br><span class="line">1. 浅拷贝会复制基本数据类型，但是对于引用对象只会复制一个地址。即，引用对象还是指向同一个。</span><br><span class="line">2. 深拷贝既会复制基本数据类型，也会复制引用对象。即，引用对象不是同一个。</span><br><span class="line"></span><br><span class="line">### 引用类型</span><br><span class="line"></span><br><span class="line">Java 主要提供了 **4 种引用类型**，按强度从强到弱依次为：</span><br><span class="line"></span><br><span class="line">1. **强引用（Strong Reference）** —— 默认的引用类型</span><br><span class="line">   1. 强引用是 Java 中最常见、默认的引用类型。只要强引用存在，对象就绝对不会被垃圾回收器回收。</span><br><span class="line">2. **软引用（Soft Reference）**</span><br><span class="line">   1. 软引用是一种比强引用弱、但比弱引用强的引用类型。如果一个对象只被软引用指向，在内存不足时，它才会被垃圾回收。</span><br><span class="line">3. **弱引用（Weak Reference）**</span><br><span class="line">   1. 弱引用比软引用更弱。只要发生垃圾回收，无论内存是否充足，只要对象只被弱引用指向，它就会被回收。</span><br><span class="line">4. **虚引用（Phantom Reference）**</span><br><span class="line">   1. get() 方法永远返回 null！</span><br><span class="line">   2. 无法通过虚引用来获取对象</span><br><span class="line">   3. 虚引用唯一的作用，是通过 ReferenceQueue 监听对象是否已被回收</span><br><span class="line"></span><br><span class="line">### Java中的异常体系</span><br><span class="line"></span><br><span class="line">详见笔记《异常处理》</span><br><span class="line"></span><br><span class="line">### 什么时候应该抛出异常，什么时候捕获异常</span><br><span class="line"></span><br><span class="line">1. **抛出异常（throw / throws）：** 是 **发现问题、抛出问题**，通常由 **底层方法、工具类、数据校验模块** 完成，表示 “这里可能出错了，我处理不了，交给调用者决定”。</span><br><span class="line">2. **捕获异常（try-catch）：** 是 **处理问题、解决问题**，通常由 **调用方、业务逻辑层、UI 层、控制器层** 完成，表示 “我知道这里可能出错，我来处理”。</span><br><span class="line"></span><br><span class="line">### JVM中那些是线程共享区</span><br><span class="line"></span><br><span class="line">| 区域                                       | 是否线程共享   | 说明                                                         |</span><br><span class="line">| :----------------------------------------- | :------------- | :----------------------------------------------------------- |</span><br><span class="line">| **堆（Heap）**                             | ✅ **线程共享** | 所有对象实例和数组都在这里分配，是 GC 主要管理的区域         |</span><br><span class="line">| **方法区（Method Area）**                  | ✅ **线程共享** | 存储已被虚拟机加载的 **类信息、常量、静态变量、即时编译器编译后的代码等** |</span><br><span class="line">| **Java 虚拟机栈（JVM Stack）**             | ❌ **线程私有** | 每个线程私有，存储 **栈帧（局部变量表、操作数栈、动态链接、方法出口等）** |</span><br><span class="line">| **本地方法栈（Native Method Stack）**      | ❌ **线程私有** | 为 JVM 调用的 **Native 方法服务**                            |</span><br><span class="line">| **程序计数器（Program Counter Register）** | ❌ **线程私有** | 当前线程执行的字节码行号指示器（线程切换时能恢复执行位置）   |</span><br><span class="line"></span><br><span class="line">### 如何排查JVM的问题？（待学习）</span><br><span class="line"></span><br><span class="line">- 我会去问LLM</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- | 步骤 | 操作                 | 工具/命令                                        | 目的                             |</span><br><span class="line">  | :--- | :------------------- | :----------------------------------------------- | :------------------------------- |</span><br><span class="line">  | 1    | 查看 OOM 错误日志    | 控制台 / 日志文件                                | 确定 OOM 类型（堆、元空间等）    |</span><br><span class="line">  | 2    | 生成 Heap Dump       | `jmap -dump`或 `-XX:+HeapDumpOnOutOfMemoryError` | 获取堆内存快照                   |</span><br><span class="line">  | 3    | 分析 Heap Dump       | Eclipse MAT / VisualVM                           | 找到大对象、内存泄漏、对象引用链 |</span><br><span class="line">  | 4    | 查看线程状态（可选） | `jstack &lt;pid&gt;`                                   | 分析线程死锁、线程数过多等问题   |</span><br><span class="line">  | 5    | 定位代码问题         | 结合 dump 分析 + 业务代码                        | 修复内存泄漏、优化对象使用       |</span><br><span class="line"></span><br><span class="line">1. 一般而言，排查问题可以从以下方面入手</span><br><span class="line">   1. 对于还在运行的系统，通过jmap, jstack, jstat等工具查看系统信息。</span><br><span class="line">   2. 对于已经发生OOM的系统，可以去看日志</span><br><span class="line">2. 常见类型：</span><br><span class="line">   1. 内存溢出，CPU使用率过高，线程问题，GC问题</span><br><span class="line"></span><br><span class="line">3. OOM怎么解决</span><br><span class="line"></span><br><span class="line">### 一个对象从加载到JVM，再到被GC处理，经历了什么？</span><br><span class="line"></span><br><span class="line">1. 类加载：把字节码（.class）加载到方法区</span><br><span class="line">2. 创建对象：在堆中分配内存</span><br><span class="line">3. 在堆中E区、S区、O区流转</span><br><span class="line">4. 被GC清理</span><br><span class="line"></span><br><span class="line">### 怎么确定一个对象是不是垃圾？</span><br><span class="line"></span><br><span class="line">1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。</span><br><span class="line">2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。</span><br><span class="line">   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。</span><br><span class="line">   2. 有多个根对象，但是只会选用一个。</span><br><span class="line"></span><br><span class="line">### 有哪些GC算法</span><br><span class="line"></span><br><span class="line">1. **标记清除算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。</span><br><span class="line">      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 不需要移动对象，实现相对简单</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 内存碎片化严重</span><br><span class="line">      2. 效率问题</span><br><span class="line">2. **复制算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）</span><br><span class="line">      2. 每次只使用其中一块（如 From 区）来分配对象</span><br><span class="line">      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）</span><br><span class="line">      4. 交换角色：原来的 To 区成为新的 From 区，继续使用</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！</span><br><span class="line">      2. 分配效率高</span><br><span class="line">      3. 适合对象存活率低的场景</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 浪费了一半的内存空间</span><br><span class="line">      2. 不适合存活对象多的场景</span><br><span class="line">3. **标记压缩算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象</span><br><span class="line">      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）</span><br><span class="line">      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）</span><br><span class="line">      2. 内存利用率高，适合大对象和长期存活对象分配</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 移动对象成本高！</span><br><span class="line"></span><br><span class="line">### 什么是STW</span><br><span class="line"></span><br><span class="line">1. 全称Stop-The-World</span><br><span class="line">2. 在垃圾回收（GC）过程中，Java 虚拟机（JVM）为了保证垃圾回收的正确性，会暂停所有的应用线程（也就是用户线程 / 业务线程），只让垃圾回收线程运行。</span><br><span class="line"></span><br><span class="line">### 什么是反射</span><br><span class="line"></span><br><span class="line">- **反射（Reflection）** 是一种强大的机制，它允许程序在**运行时**（而不是编译时）获取类的信息，并且可以动态地操作类或对象的属性、方法和构造器等。</span><br><span class="line">-  反射使得程序可以在运行时“发现”和“操作”类，而不需要在编译期明确知道这些类的具体信息</span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">### 线程安全</span><br><span class="line"></span><br><span class="line">1. 线程安全（Thread Safety） 是指：当一个类、方法或代码块在多线程环境下被多个线程同时访问时，仍然能正确地工作，不会导致数据错误、逻辑混乱或程序崩溃，那么它就是线程安全的。</span><br><span class="line"></span><br><span class="line">2. 针对某一段代码，多线程同时执行时，不会造成混乱</span><br><span class="line"></span><br><span class="line">3. 举例：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class UnsafeCounter &#123;</span><br><span class="line">          private int count = 0;</span><br><span class="line">      </span><br><span class="line">          public void increment() &#123;</span><br><span class="line">              count++; // 实际上是 read -&gt; add -&gt; write，非原子！</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上面的代码，如果有两个线程执行，那么应该一个结果是1，一个结果是2。如果不是，就说明造成了混乱。</p>
</li>
</ol>
</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>守护线程（Daemon Thread） 是 Java 线程中的一种特殊线程，它的作用通常是 为其他线程（用户线程 &#x2F; 非守护线程）提供后台服务支持</p>
</li>
<li><p>守护线程和用户线程对比</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>守护线程（Daemon Thread）</strong></th>
<th align="left"><strong>用户线程（User Thread &#x2F; 非守护线程）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用</strong></td>
<td align="left">为其他线程提供<strong>后台服务</strong></td>
<td align="left">执行<strong>主要任务</strong>，是程序的核心逻辑</td>
</tr>
<tr>
<td align="left"><strong>JVM 是否会等待其结束</strong></td>
<td align="left"><strong>不会</strong>，只要用户线程结束，JVM 就会退出，不管守护线程是否还在运行</td>
<td align="left"><strong>会</strong>，JVM 会等待所有用户线程执行完毕才会退出</td>
</tr>
<tr>
<td align="left"><strong>默认情况</strong></td>
<td align="left">线程默认是<strong>用户线程</strong></td>
<td align="left">是</td>
</tr>
<tr>
<td align="left"><strong>如何设置</strong></td>
<td align="left">通过 <code>setDaemon(true)</code>设置</td>
<td align="left">不设置或设置为 false</td>
</tr>
<tr>
<td align="left"><strong>典型例子</strong></td>
<td align="left">垃圾回收线程、日志线程、监控线程</td>
<td align="left">主线程、业务逻辑线程、用户交互线程</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="并发、并行、串行"><a href="#并发、并行、串行" class="headerlink" title="并发、并行、串行"></a>并发、并行、串行</h3><ol>
<li>串行：一个一个执行</li>
<li>并行：物理世界，同时进行。比如一边跑步一遍听歌。</li>
<li>并发：两个任务轮流执行，但是轮转很快。比如CPU分时的处理两个请求</li>
</ol>
<h3 id="死锁如何解决"><a href="#死锁如何解决" class="headerlink" title="死锁如何解决"></a>死锁如何解决</h3><ol>
<li><p>产生的必要条件</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">说明</th>
<th align="left">是否必须</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 互斥条件（Mutual Exclusion）</strong></td>
<td align="left">某资源一次只能被一个线程占用（如锁、对象、文件等）</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>2. 占有并等待（Hold and Wait）</strong></td>
<td align="left">线程持有至少一个资源，并等待获取其他被占用的资源</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>3. 不可剥夺（No Preemption）</strong></td>
<td align="left">线程已获得的资源，在未使用完之前，<strong>不能被其他线程强行夺取</strong>，只能由自己释放</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>4. 循环依赖（Circular Wait）</strong></td>
<td align="left">存在一个线程的循环等待链，比如 T1 等 T2 的资源，T2 等 T1 的资源，形成一个闭环</td>
<td align="left">✅ 必须</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>如何排查？</p>
<ol>
<li>用<code>jstack</code>到处堆内存快照，然后分析文件。jastack会为你分析出是否存在死锁。</li>
</ol>
</li>
<li><p>如何避免</p>
<ol>
<li>破坏循环依赖（推荐）—— 按固定顺序获取锁</li>
<li>破坏循环依赖占有并等待——使用超时机制（tryLock）</li>
<li>检测与恢复（高级 &#x2F; 系统级，预防措施）</li>
</ol>
</li>
</ol>
<h3 id="CountDownLatch和Semaphore的区别和底层实现"><a href="#CountDownLatch和Semaphore的区别和底层实现" class="headerlink" title="CountDownLatch和Semaphore的区别和底层实现"></a>CountDownLatch和Semaphore的区别和底层实现</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized的偏向锁，轻量级锁，重量级锁"><a href="#synchronized的偏向锁，轻量级锁，重量级锁" class="headerlink" title="synchronized的偏向锁，轻量级锁，重量级锁"></a>synchronized的偏向锁，轻量级锁，重量级锁</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>synchronized（内置锁）</strong></th>
<th align="left"><strong>ReentrantLock（可重入锁）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">Java 关键字（语法层面，JVM 实现）</td>
<td align="left">Java 类（<code>java.util.concurrent.locks.ReentrantLock</code>，API 层面）</td>
</tr>
<tr>
<td align="left"><strong>使用方式</strong></td>
<td align="left">直接修饰方法或代码块，语法简洁</td>
<td align="left">需要手动加锁 <code>lock()</code>和解锁 <code>unlock()</code>，通常配合 <code>try-finally</code>使用</td>
</tr>
<tr>
<td align="left"><strong>锁的获取与释放</strong></td>
<td align="left"><strong>自动加锁与释放</strong>（进入同步块加锁，退出时释放）</td>
<td align="left"><strong>手动加锁与释放</strong>，必须显式调用 <code>lock()</code>和 <code>unlock()</code>，推荐在 <code>finally</code>块中释放</td>
</tr>
<tr>
<td align="left"><strong>可重入性</strong></td>
<td align="left">✅ 支持（同一个线程可重复获取同一把锁）</td>
<td align="left">✅ 支持（同一个线程可多次获取锁，必须释放同样次数）</td>
</tr>
<tr>
<td align="left"><strong>公平性</strong></td>
<td align="left">❌ 非公平锁（不保证等待顺序）</td>
<td align="left">✅ <strong>可选择公平或非公平（构造方法传参）</strong></td>
</tr>
<tr>
<td align="left"><strong>是否可中断</strong></td>
<td align="left">❌ 不支持中断等待锁</td>
<td align="left">✅ 支持 <code>lockInterruptibly()</code>，可响应中断</td>
</tr>
<tr>
<td align="left"><strong>是否可设置超时</strong></td>
<td align="left">❌ 不支持尝试获取锁的超时机制</td>
<td align="left">✅ 支持 <code>tryLock(long time, TimeUnit unit)</code>，可以设置超时等待</td>
</tr>
<tr>
<td align="left"><strong>是否支持多个条件变量（Condition）</strong></td>
<td align="left">❌ 只有一个隐式的等待队列（通过 <code>wait/notify</code>）</td>
<td align="left">✅ 支持多个 <code>Condition</code>，可精细控制线程等待&#x2F;唤醒（如不同条件队列）</td>
</tr>
</tbody></table>
<h3 id="谈谈你对AQS的理解"><a href="#谈谈你对AQS的理解" class="headerlink" title="谈谈你对AQS的理解"></a>谈谈你对AQS的理解</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="如何保证操作的原子性"><a href="#如何保证操作的原子性" class="headerlink" title="如何保证操作的原子性"></a>如何保证操作的原子性</h3><ol>
<li><p>使用AotmicXXX类</p>
<ol>
<li><pre><code class="language-java">// 使用 AtomicInteger 代替 int
private static AtomicInteger i = new AtomicInteger(0);

i.incrementAndGet()就是 // 原子版本的 i++
getAndIncrement() // 相当于 i++
addAndGet(1) // 加一个指定的值
get() // 获取当前值
set(int newValue) // 设置值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   2. 这是推荐做法，性能好，线程安全。</span><br><span class="line"></span><br><span class="line">2. `AtomicInteger`的核心实现依赖于：</span><br><span class="line"></span><br><span class="line">   - **CAS（Compare-And-Swap）**：一种硬件级别的原子操作</span><br><span class="line">   - 利用循环 + CAS 的方式实现 **无锁的线程安全操作（乐观锁）**</span><br><span class="line"></span><br><span class="line">3. CAS</span><br><span class="line">   1. CAS 是一种原子操作，它的功能是：比较某个内存位置的值与预期值，如果匹配，则将该内存位置的值更新为新值；如果不匹配，则不修改值。整个操作是原子的（不可中断），由 CPU 硬件保证。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Spring</span><br><span class="line"></span><br><span class="line">### 谈谈你对IOC的理解</span><br><span class="line"></span><br><span class="line">- IoC：控制反转</span><br><span class="line"></span><br><span class="line">1. 什么是控制？控制了什么？</span><br><span class="line"></span><br><span class="line">   1. 具体来说，控制了以下内容：</span><br><span class="line"></span><br><span class="line">      | 控制的内容         | 说明                                                        |</span><br><span class="line">      | :----------------- | :---------------------------------------------------------- |</span><br><span class="line">      | 对象的创建         | 谁负责 new 一个对象出来（比如 `new UserService()`）         |</span><br><span class="line">      | 依赖关系的组装     | 比如一个 Service 依赖一个 DAO，谁来把 DAO 注入到 Service 中 |</span><br><span class="line">      | 对象之间的耦合关系 | 对象之间如何关联、谁依赖谁、怎么管理这些依赖                |</span><br><span class="line">      | **对象的生命周期** | 比如对象什么时候创建、什么时候销毁、是否单例等              |</span><br><span class="line"></span><br><span class="line">      在传统编程中，这些控制都是由程序员在代码中显式完成的。</span><br><span class="line"></span><br><span class="line">2. 什么是反转？反转前是谁控制？反转后呢？如何控制的？</span><br><span class="line"></span><br><span class="line">   1. 反转前（传统方式）—— “正序控制” / “主动控制”</span><br><span class="line">      - 谁控制？ → 由程序员 / 开发者控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖关系的手动组装</span><br><span class="line">      - 如何实现的？ → 通过 new 关键字、手动赋值、层层构造</span><br><span class="line">   2. 反转后（IoC 方式）—— **“控制权反转给容器”**</span><br><span class="line">      - 谁控制？ → 由外部容器（比如 Spring IoC 容器）控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖注入、生命周期管理</span><br><span class="line">      - 如何实现的？ → 通过依赖注入（DI）、配置文件 / 注解，让容器来管理对象和依赖关系</span><br><span class="line"></span><br><span class="line">3. 为什么要反转？有什么好处？</span><br><span class="line"></span><br><span class="line">   1. 控制反转（IoC）的主要目的是为了解耦、提高代码的灵活性、可测试性和可维护性。</span><br><span class="line"></span><br><span class="line">### IoC和DI怎么通过反射实现的？</span><br><span class="line"></span><br><span class="line">1. **扫描类路径，找到需要管理的 Bean（使用反射）**</span><br><span class="line"></span><br><span class="line">   Spring 启动时，会扫描你指定的包路径（比如 `com.example`），找出所有带有 `@Component`、`@Service`、`@RestController`等注解的类。</span><br><span class="line"></span><br><span class="line">   &gt; 这一步是通过 **反射机制** 去**读取类上的注解信息**，判断哪些类需要由 Spring 管理，变成一个个 Bean。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">2. **实例化 Bean（通过反射创建对象）**</span><br><span class="line"></span><br><span class="line">   对于每一个需要管理的类（比如 `UserService`和 `UserController`），Spring 会：</span><br><span class="line"></span><br><span class="line">   - 通过反射调用其构造器（通常是默认的无参构造器，或有参构造器），</span><br><span class="line">   - 动态地创建出一个对象实例，</span><br><span class="line"></span><br><span class="line">   比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>Class&lt;?&gt; clazz &#x3D; Class.forName(“com.example.UserService”);<br>Object userServiceObj &#x3D; clazz.getDeclaredConstructor().newInstance(); &#x2F;&#x2F; 反射创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   &gt; 这一步就是用反射来代替你手动写 `new UserService()`。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">3. **依赖注入（通过反射实现 @Autowired 等注入）**</span><br><span class="line"></span><br><span class="line">   如果一个类中有依赖其它 Bean 的字段（比如 `@Autowired private UserService userService;`），Spring 会：</span><br><span class="line"></span><br><span class="line">   1. 找到这个字段，</span><br><span class="line">   2. 知道它需要注入一个 `UserService`类型的 Bean，</span><br><span class="line">   3. 从容器中找出已经创建好的 `UserService`对象，</span><br><span class="line">   4. **通过反射调用 `Field.set(对象, 值)`，把这个依赖注入到目标字段中。**</span><br><span class="line"></span><br><span class="line">   即使这个字段是 `private`的，Spring 也会通过 `field.setAccessible(true)`来绕过访问限制，然后进行赋值。</span><br><span class="line"></span><br><span class="line">   &gt; 这就是通过反射实现的 **依赖注入（DI）**，而依赖注入是 IoC 的一种实现方式。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">4. **管理 Bean 的生命周期、作用域等**</span><br><span class="line"></span><br><span class="line">   Spring 还会通过反射调用一些初始化方法（比如 `@PostConstruct`标记的方法）、销毁方法等，也是依赖反射来动态调用的。</span><br><span class="line"></span><br><span class="line">### 单例Bean和单例模式</span><br><span class="line"></span><br><span class="line">一定条件下，可以认为单利Bean是单例模式。</span><br><span class="line"></span><br><span class="line">1. 在单例模式下，一个类只能有一个对象。</span><br><span class="line">2. 但是单例Bean不一样。一个类可以有多个对象，但是通过同一个名字只能获得一个对象。</span><br><span class="line">3. 所以说，在Sping的范围内，如果只有一个Bean的话，我们可以认为单利Bean是单例模式</span><br><span class="line"></span><br><span class="line">### Spring事务传播机制</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事物传播就是指事务被调用时，还是不是事务，是嵌套事务还是合并事务等等</span><br><span class="line"></span><br><span class="line">### Spring事务什么时候会失效</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 跟AOP、事务管理器相关</span><br><span class="line"></span><br><span class="line">### Spring事务如何实现的</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的</span><br><span class="line">- 两种调用方式：声明式事务（@Transactional）或编程式事务（TransactionTemplate）</span><br><span class="line"></span><br><span class="line">### Bean是线程安全的吗</span><br><span class="line"></span><br><span class="line">1. Bean的本质还是类</span><br><span class="line">2. 如果Bean是无状态的，那就是线程安全的。否则反之。</span><br><span class="line"></span><br><span class="line">### Bean的生命周期</span><br><span class="line"></span><br><span class="line">1. **实例化**：Spring 创建对象（相当于 `new`）</span><br><span class="line">2. **属性赋值 / 依赖注入**：给 Bean 注入依赖（DI, Dependency Injection）</span><br><span class="line">3. **初始化**：执行初始化方法（`@PostConstruct` / `InitializingBean.afterPropertiesSet()`）</span><br><span class="line">4. **使用**：在应用中被调用</span><br><span class="line">5. **销毁**：应用关闭时销毁 Bean（`@PreDestroy` / `DisposableBean.destroy()`）</span><br><span class="line"></span><br><span class="line">### ApplicationContext和BeanFactory的区别</span><br><span class="line"></span><br><span class="line">| 概念                   | 一句话解释                                                   |</span><br><span class="line">| :--------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **BeanFactory**        | 是 Spring **最底层、最核心的 IoC 容器接口**，**负责管理 Bean 的创建与依赖注入，但功能相对基础，懒加载为主** |</span><br><span class="line">| **ApplicationContext** | 是 **BeanFactory 的高级扩展接口**，不仅具备 BeanFactory 的所有功能，还提供了 **更多企业级特性，比如国际化、事件机制、AOP 支持、自动装配等**，是 Spring 应用中最常用的容器 |</span><br><span class="line"></span><br><span class="line">### Spring容器的启动流程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">SpringApplication.run()</span><br><span class="line">       ↓</span><br><span class="line">创建 ApplicationContext（如 AnnotationConfigApplicationContext）</span><br><span class="line">       ↓</span><br><span class="line">扫描 @ComponentScan 包路径，解析 @Component、@Service、@Configuration 等</span><br><span class="line">       ↓</span><br><span class="line">生成 BeanDefinition（Bean 的定义信息）</span><br><span class="line">       ↓</span><br><span class="line">将 BeanDefinition 注册到容器中（BeanDefinitionRegistry）</span><br><span class="line">       ↓</span><br><span class="line">根据 BeanDefinition 实例化 Bean（创建对象，比如通过反射调用构造方法）// 这里只有急加载的Bean会实例化</span><br><span class="line">       ↓</span><br><span class="line">进行依赖注入（DI，比如 @Autowired 字段注入）</span><br><span class="line">       ↓</span><br><span class="line">执行初始化回调（@PostConstruct、InitializingBean、init-method）</span><br><span class="line">       ↓</span><br><span class="line">发布 ContextRefreshedEvent 事件（容器初始化完成）</span><br><span class="line">       ↓</span><br><span class="line">✅ Spring 容器启动完成，应用可正常运行</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Spring用了哪些设计模式"><a href="#Spring用了哪些设计模式" class="headerlink" title="Spring用了哪些设计模式"></a>Spring用了哪些设计模式</h3><table>
<thead>
<tr>
<th align="left">设计模式</th>
<th align="left">应用场景</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工厂模式</strong></td>
<td align="left">BeanFactory &#x2F; ApplicationContext</td>
<td align="left">管理 Bean 的创建</td>
</tr>
<tr>
<td align="left"><strong>单例模式</strong></td>
<td align="left">默认的 Bean Scope</td>
<td align="left">一个 Bean 只有一个实例</td>
</tr>
<tr>
<td align="left"><strong>代理模式</strong></td>
<td align="left">Spring AOP</td>
<td align="left">实现方法拦截与增强</td>
</tr>
<tr>
<td align="left"><strong>模板方法模式</strong></td>
<td align="left">JdbcTemplate、RestTemplate</td>
<td align="left">封装固定流程</td>
</tr>
<tr>
<td align="left"><strong>观察者模式</strong></td>
<td align="left">ApplicationEvent &#x2F; Listener</td>
<td align="left">事件发布与订阅</td>
</tr>
<tr>
<td align="left"><strong>适配器模式</strong></td>
<td align="left">HandlerAdapter、AdvisorAdapter</td>
<td align="left">接口转换与兼容</td>
</tr>
<tr>
<td align="left"><strong>装饰器模式</strong></td>
<td align="left">BeanPostProcessor</td>
<td align="left">增强 Bean 功能</td>
</tr>
<tr>
<td align="left"><strong>策略模式</strong></td>
<td align="left">事务管理器、视图解析器</td>
<td align="left">多种实现动态选择</td>
</tr>
<tr>
<td align="left"><strong>责任链模式</strong></td>
<td align="left">过滤器链、拦截器链</td>
<td align="left">多个处理器依次处理请求</td>
</tr>
<tr>
<td align="left"><strong>原型模式</strong></td>
<td align="left">Bean Scope 为 prototype</td>
<td align="left">每次获取新实例</td>
</tr>
<tr>
<td align="left"><strong>组合模式</strong></td>
<td align="left">树形结构数据（非核心）</td>
<td align="left">组合对象与叶子对象统一处理</td>
</tr>
<tr>
<td align="left"><strong>外观模式</strong></td>
<td align="left">高级封装（如 JdbcTemplate）</td>
<td align="left">简化复杂 API</td>
</tr>
<tr>
<td align="left"><strong>建造者模式</strong></td>
<td align="left">SpringApplicationBuilder</td>
<td align="left">分步骤构建复杂对象</td>
</tr>
</tbody></table>
<h3 id="Spring常用的注解及其底层实现"><a href="#Spring常用的注解及其底层实现" class="headerlink" title="Spring常用的注解及其底层实现"></a>Spring常用的注解及其底层实现</h3><p>详见《SSM学习笔记》</p>
<h3 id="SpringBoot怎么启动Tomcat的"><a href="#SpringBoot怎么启动Tomcat的" class="headerlink" title="SpringBoot怎么启动Tomcat的"></a>SpringBoot怎么启动Tomcat的</h3><ol>
<li>先启动Spring容器</li>
<li>自动配置： @EnableAutoConfiguration（包含在 @SpringBootApplication 中）启用自动配置。它会根据你的 classpath 下的依赖（比如 tomcat-embed-core.jar），自动加载一系列自动配置类。生成一个启动Tomcat的Bean。</li>
<li>Spring容器创建完之后，启动Tomcat的Bean，创建对象，并绑定端口。</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li><strong>MyBatis 是一个优秀的 Java 持久层框架，它简化了 JDBC 的操作，通过 XML 或注解的方式，将 Java 对象与 SQL 语句进行映射，让开发者可以更灵活、更高效地操作数据库，而不用过多关心底层的 JDBC 细节。</strong></li>
</ul>
<h3 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h3><h3 id="Mybatis中-和-的区别是什么？"><a href="#Mybatis中-和-的区别是什么？" class="headerlink" title="Mybatis中#{}和${}的区别是什么？"></a>Mybatis中#{}和${}的区别是什么？</h3><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="设计MySQL表时应该注意什么"><a href="#设计MySQL表时应该注意什么" class="headerlink" title="设计MySQL表时应该注意什么"></a>设计MySQL表时应该注意什么</h3><h4 id="遵循第三范式（3NF）"><a href="#遵循第三范式（3NF）" class="headerlink" title="遵循第三范式（3NF）"></a>遵循第三范式（3NF）</h4><ul>
<li><strong>第一范式（1NF）</strong>：字段不可再分，每列都是原子的。</li>
<li><strong>第二范式（2NF）</strong>：满足1NF，且非主键字段完全依赖于完整主键（针对联合主键的情况）。<ul>
<li>2NF 消除了<strong>部分函数依赖</strong>，即非主键字段不能只依赖主键的一部分。</li>
</ul>
</li>
<li><strong>第三范式（3NF）</strong>：满足2NF，且非主键字段不传递依赖于主键。<ul>
<li>消除了<strong>传递依赖</strong>，不能通过其他非主键字段间接依赖。</li>
</ul>
</li>
</ul>
<h4 id="设计字段"><a href="#设计字段" class="headerlink" title="设计字段"></a>设计字段</h4><ol>
<li>选择合适的数据类型<ul>
<li>尽量使用最小的满足需求的数据类型，以节省存储空间和提高性能。</li>
</ul>
</li>
<li>字段命名规范<ul>
<li>使用有意义的名称，采用下划线命名法，如 <code>user_name</code>、<code>created_at</code>。</li>
<li>避免使用 MySQL 的保留关键字，如 <code>order</code>、<code>group</code>等，若必须使用，需用反引号括起。</li>
<li>主键通常命名为 <code>id</code>，外键通常为 <code>xxx_id</code>。</li>
</ul>
</li>
</ol>
<h4 id="主键与索引设计"><a href="#主键与索引设计" class="headerlink" title="主键与索引设计"></a>主键与索引设计</h4><ol>
<li>主键设计<ul>
<li>每张表都应有一个主键，用于唯一标识一行。</li>
<li>推荐使用 <strong>自增整型（如 BIGINT AUTO_INCREMENT）</strong> 作为主键，简单高效，有利于索引组织。</li>
<li>如果使用业务字段作为主键（如手机号、身份证等），要确保其<strong>唯一、不变、简短</strong>。</li>
</ul>
</li>
<li>索引设计<ul>
<li><strong>索引不是越多越好</strong>，每个索引都会占用空间并影响写入性能。</li>
<li>为<strong>经常用于 WHERE、JOIN、ORDER BY、GROUP BY 的字段建立索引</strong>。</li>
<li>合理使用 <strong>复合索引（联合索引）</strong>，注意最左前缀原则。</li>
</ul>
</li>
</ol>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ol>
<li>索引的理解<ol>
<li>索引是数据库中一种特殊的数据结构，它可以帮助数据库系统快速定位到表中的特定数据行，<strong>类似于书籍的目录</strong>。</li>
<li>可以说，索引就是把无序的数据化为有序</li>
<li>没有索引时，查找一般要遍历全表。有索引之后可以降低时间复杂度。</li>
<li>索引也存储在硬盘中</li>
</ol>
</li>
<li>常见的索引<ol>
<li>B+树。详见《Java学习笔记》<ol>
<li>为什么用B+树？<ol>
<li><strong>树高更低，查询更快</strong>（减少磁盘 IO 次数，每次 IO 代价高）</li>
<li><strong>非叶子节点只存 key，能容纳更多索引，树更矮</strong></li>
<li><strong>叶子节点之间有链表，范围查询非常高效</strong></li>
<li><strong>查询稳定，所有查询都要走到叶子节点，性能可预测</strong></li>
<li><strong>适合写平衡（插入、删除也相对稳定）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><ol>
<li><p>选择合适的列建立索引</p>
<ul>
<li><p><strong>高选择性列优先</strong>：列中不同值越多（如用户ID、订单号），索引效果越好</p>
</li>
<li><p><strong>高频查询条件列</strong>：WHERE、JOIN、ORDER BY、GROUP BY中频繁使用的列</p>
</li>
<li><p><strong>等值查询列</strong>：精确匹配比范围查询更适合索引</p>
</li>
<li><p><strong>排序&#x2F;分组列</strong>：经常用于ORDER BY或GROUP BY的列</p>
</li>
</ul>
</li>
<li><p>避免过度索引</p>
<ul>
<li><p><strong>每个索引都有成本</strong>：占用存储空间，降低写入速度(INSERT&#x2F;UPDATE&#x2F;DELETE)</p>
</li>
<li><p><strong>监控索引使用率</strong>：定期检查未使用的索引并删除</p>
</li>
<li><p><strong>小表不需要索引</strong>：数据量小(如&lt;1000行)时全表扫描可能更快</p>
</li>
</ul>
</li>
</ol>
<h3 id="聚簇索引和非聚簇索引的区别是什么"><a href="#聚簇索引和非聚簇索引的区别是什么" class="headerlink" title="聚簇索引和非聚簇索引的区别是什么"></a>聚簇索引和非聚簇索引的区别是什么</h3><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>聚簇索引（Clustered Index）</strong></th>
<th align="left"><strong>非聚簇索引（Non-clustered Index &#x2F; 二级索引）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">索引的叶子节点 <strong>直接存储整行数据</strong>，即 <strong>数据即索引，索引即数据</strong></td>
<td align="left">索引的叶子节点 <strong>存储的是主键值（或指向数据的指针）</strong>，不是完整的数据行</td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left"><strong>数据按索引顺序物理存储</strong>（即表数据按聚簇索引的顺序存放）</td>
<td align="left"><strong>数据与索引分开存储</strong>，索引单独维护，指向数据的地址或主键</td>
</tr>
<tr>
<td align="left"><strong>数量</strong></td>
<td align="left"><strong>一个表只能有一个聚簇索引</strong>（通常是主键，如果没有主键则选唯一键，否则隐藏行 ID）</td>
<td align="left"><strong>一个表可以有多个非聚簇索引（二级索引）</strong></td>
</tr>
<tr>
<td align="left"><strong>查询效率</strong></td>
<td align="left">查询时 <strong>如果使用聚簇索引，通常只需一次查找即可定位到完整数据，效率很高</strong></td>
<td align="left">查询时可能需要 <strong>回表（先查索引，再根据主键查聚簇索引获取完整数据）</strong>，多一次 IO</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">主键查询、范围查询（如日期、ID 范围）非常高效</td>
<td align="left">适合根据非主键字段查询，但可能带来回表开销</td>
</tr>
<tr>
<td align="left"><strong>典型实现（MySQL）</strong></td>
<td align="left"><strong>InnoDB 的主键索引就是聚簇索引</strong></td>
<td align="left"><strong>InnoDB 的普通索引（如二级索引）就是非聚簇索引</strong></td>
</tr>
<tr>
<td align="left"><strong>物理顺序</strong></td>
<td align="left">数据按聚簇索引的键值顺序存储（物理有序）</td>
<td align="left">数据存储无序，索引单独组织（逻辑有序）</td>
</tr>
</tbody></table>
<h3 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h3><ol>
<li><p>基本特性：ACID</p>
<ol>
<li><p>原子性 (Atomicity)</p>
<p>通过 <strong>undo log（回滚日志）</strong> 实现：</p>
<ul>
<li>事务开始前，InnoDB 会记录修改前的数据到 undo log</li>
<li>如果事务需要回滚，可以根据 undo log 恢复到原始状态</li>
</ul>
</li>
<li><p>一致性 (Consistency)</p>
<p>通过以下机制共同保证：</p>
<ul>
<li>原子性、隔离性、持久性的组合</li>
<li>数据库的约束（如主键、外键、唯一约束等）</li>
<li>应用程序的业务逻辑</li>
</ul>
</li>
<li><p>隔离性 (Isolation)</p>
<p>通过 <strong>锁机制</strong> 和 <strong>MVCC（多版本并发控制）</strong> 实现：</p>
<ul>
<li><strong>锁机制</strong>：包括共享锁(S锁)、排他锁(X锁)、意向锁等</li>
<li><strong>MVCC</strong>：通过 read view 和版本链实现非锁定读，提高并发性能</li>
</ul>
</li>
<li><p>持久性 (Durability)</p>
<p>通过 <strong>redo log（重做日志）</strong> 实现：</p>
<ul>
<li>事务提交时，先将修改写入 redo log（预写日志），确保即使系统崩溃也能恢复数据</li>
<li>采用 WAL（Write-Ahead Logging）技术，先写日志再写磁盘</li>
</ul>
</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li><p>SQL标准定义了四种隔离级别。隔离级别越高，并发性能越低，但数据一致性越强。从低到高依次为：</p>
<ol>
<li>读未提交(Read Uncommitted)</li>
<li>读已提交(Read Committed)</li>
<li>可重复读(Repeatable Read) <em>(MySQL默认级别)</em></li>
<li>串行化(Serializable)</li>
</ol>
</li>
<li><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">并发性能</th>
<th align="left">实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读 未提交</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">最高</td>
<td align="left">最低</td>
</tr>
<tr>
<td align="left">读 已提交</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">MySQL中不可能*</td>
<td align="left">中等</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">串行化</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">最低</td>
<td align="left">最高</td>
</tr>
</tbody></table>
</li>
<li><p>并发问题详解</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li><strong>定义</strong>：读取到其他事务未提交的数据</li>
<li><strong>风险</strong>：如果事务回滚，读取到的数据就是无效的</li>
<li><strong>解决方案</strong>：至少使用读已提交隔离级别</li>
</ul>
</li>
<li>不可重复读(Non-repeatable Read)<ul>
<li><strong>定义</strong>：同一事务内多次读取同一数据，得到不同结果</li>
<li><strong>原因</strong>：其他事务提交了修改</li>
<li><strong>风险</strong>：基于第一次读取结果做出的决策可能失效</li>
<li><strong>解决方案</strong>：使用可重复读或更高隔离级别</li>
</ul>
</li>
<li>幻读(Phantom Read)<ul>
<li><strong>定义</strong>：同一事务内两次执行相同查询，返回不同行数(新增或删除的行)</li>
<li><strong>原因</strong>：其他事务插入或删除了符合查询条件的行</li>
<li><strong>风险</strong>：统计结果不准确，业务逻辑可能出错</li>
<li><strong>解决方案</strong>：使用串行化或MySQL的可重复读(通过间隙锁防止)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>什么是MVCC</p>
<ol>
<li><p>为了并发问题，数据库提供了 事务隔离级别（如 Read Committed、Repeatable Read、Serializable）。</p>
</li>
<li><p>但使用 悲观锁（如行锁、表锁） 去解决并发问题，虽然安全，但会 降低并发性能，导致读写互相阻塞。</p>
<blockquote>
<p>✅ MVCC 的出现，就是为了在不加锁（或减少加锁）的前提下，实现事务隔离，让读写可以并发执行，提高性能！</p>
</blockquote>
</li>
<li><p>MVCC：多版本并发控制。是一种并发控制机制，它<strong>允许事务在不互相阻塞的情况下同时读取和修改数据</strong>。与传统的基于锁的并发控制不同，MVCC通过为数据维护多个版本来实现这一目标。</p>
</li>
</ol>
</li>
<li><p>MVCC的核心思想</p>
<ul>
<li><p><strong>读不阻塞写，写不阻塞读</strong>：这是MVCC最大的优势</p>
</li>
<li><p><strong>数据多版本化</strong>：每行数据可能有多个版本同时存在</p>
</li>
<li><p><strong>一致性读</strong>：事务读取的是某个时间点的数据快照，而不是最新数据</p>
</li>
<li><p><strong>版本链管理</strong>：通过特殊的结构跟踪和管理数据的不同版本</p>
</li>
</ul>
</li>
<li><p>时间线示例</p>
<ol>
<li>T1 启动（事务 ID &#x3D; 101）</li>
<li>T2 启动（事务 ID &#x3D; 102）</li>
<li>T2 执行 UPDATE balance &#x3D; 200 WHERE id &#x3D; 1，未提交</li>
<li>T2 提交事务，此时 balance &#x3D; 200 的版本，事务 ID &#x3D; 102，变为“已提交”</li>
<li>T1 执行 SELECTT1 的 ReadView 是在 T2 提交前生成的，它依然 看不到 T2 的修改（因为 T2 在 T1 的 ReadView 中是“活跃的” 或 “在其后创建的”）T1 仍然读的是旧版本 balance &#x3D; 100。但如果 T1 提交后再开启一个新事务 T3 去读，T3 就能看到 balance &#x3D; 200（因为 T2 已提交）</li>
</ol>
</li>
<li><p>优势</p>
<ul>
<li><strong>高并发性能</strong>：读写操作互不阻塞，显著提高系统并发能力</li>
<li><strong>非阻塞读</strong>：读操作不需要等待写操作完成，也不会阻塞写操作</li>
<li><strong>一致性读</strong>：事务可以读取一致的数据快照，不受其他事务影响</li>
<li><strong>减少锁争用</strong>：降低了死锁发生的概率</li>
</ul>
</li>
<li><p>局限	</p>
<ul>
<li><p><strong>存储开销</strong>：需要存储多个数据版本，增加存储空间使用</p>
</li>
<li><p><strong>清理成本</strong>：需要定期清理不再需要的旧版本数据（purge操作）</p>
</li>
<li><p><strong>实现复杂</strong>：相比简单的锁机制，MVCC实现更加复杂</p>
</li>
<li><p><strong>不解决所有问题</strong>：如幻读问题需要结合其他机制解决（如InnoDB的间隙锁）</p>
</li>
</ul>
</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>思想：<ul>
<li>不是直接读最新数据，也不是直接修改原数据，而是：<ul>
<li>写操作：创建新版本，旧数据保留（通过 Undo Log）</li>
<li>读操作：根据事务的 ReadView，找到一个对当前事务“可见”的数据版本（可能是旧数据）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>多版本数据：每行记录有多个版本</p>
<ol>
<li><p>在 InnoDB 中，数据行（record）并不是一成不变的，而是会随着更新产生多个版本。每行数据包含几个关键的 隐藏字段（Metadata Fields）：</p>
<table>
<thead>
<tr>
<th align="left">隐藏字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DB_TRX_ID</strong></td>
<td align="left">最后一次修改（INSERT&#x2F;UPDATE）该行的事务 ID</td>
</tr>
<tr>
<td align="left"><strong>DB_ROLL_PTR</strong></td>
<td align="left">指向该行上一个版本（旧数据）的指针，存放在 Undo Log 中</td>
</tr>
<tr>
<td align="left"><strong>DB_ROW_ID</strong>（可选）</td>
<td align="left">如果表没有主键，InnoDB 会自动生成一个行 ID</td>
</tr>
</tbody></table>
<blockquote>
<p>每当一个事务对某行数据进行 更新（UPDATE） 时：</p>
<ul>
<li>不会直接覆盖原数据</li>
<li>而是先将旧数据写入 Undo Log（回滚日志）</li>
<li>然后插入新数据（或原地更新），并更新 DB_TRX_ID 为当前事务 ID</li>
<li>通过 DB_ROLL_PTR 可以找到该行的旧版本，形成版本链</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>Undo Log（回滚日志）：保存旧版本数据</strong></p>
<ol>
<li><p>Undo Log 是 InnoDB 用来支持事务回滚和 MVCC 的重要日志。</p>
</li>
<li><p>每当一个事务修改了某行数据，InnoDB 会：</p>
<ul>
<li>把修改前的旧数据（即被覆盖前的值）保存到 Undo Log</li>
<li>这些旧数据 不会被立即删除，而是会保留一段时间，用于：事务回滚（Rollback）MVCC 中为其他事务提供历史版本数据（读一致性）</li>
</ul>
<blockquote>
<p>MVCC 利用 Undo Log 实现了“数据的多版本存储”。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>ReadView（读视图）：决定事务能看见哪些版本</strong></p>
<ol>
<li><p>当一个事务执行 SELECT（读操作） 时，InnoDB 不会直接读取最新数据，而是根据一个叫 ReadView 的东西，决定当前事务应该看到哪个版本的数据。</p>
</li>
<li><p>什么时候生成 ReadView？</p>
</li>
</ol>
<blockquote>
<p>在事务执行读操作（如 SELECT）时生成，用于控制该事务的“数据可见性”。</p>
</blockquote>
<ol start="3">
<li>ReadView 包含的关键信息：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">m_ids</td>
<td align="left">当前 活跃的（未提交）事务 ID 列表（即还有哪些事务没提交，可能修改了数据）</td>
</tr>
<tr>
<td align="left">min_trx_id</td>
<td align="left">当前所有活跃事务中的最小事务 ID</td>
</tr>
<tr>
<td align="left">max_trx_id</td>
<td align="left">系统即将分配给下一个事务的 ID（当前最大事务 ID + 1）</td>
</tr>
<tr>
<td align="left">creator_trx_id</td>
<td align="left">当前事务自己的 ID</td>
</tr>
</tbody></table>
<hr>
<ol start="4">
<li><p>可见性判断规则（核心！）：</p>
<ol>
<li><p>当一个事务要读取某条数据时，InnoDB 不是直接读取磁盘上的最新数据，而是：</p>
<ol>
<li>找到该数据行的<strong>最新版本</strong>；</li>
<li>根据 <strong>Read View 的规则</strong>，判断这个版本是否对当前事务<strong>可见</strong>；</li>
<li>如果不可见，则顺着 <code>DB_ROLL_PTR</code>找上一个版本，再次判断，直到找到一个<strong>对当前事务可见的版本</strong>，或者没有更多版本可找。</li>
</ol>
<p>这个过程就是 <strong>“多版本读取”</strong>，也就是 MVCC 的核心。</p>
</li>
<li><p>对于某行数据的 DB_TRX_ID（最后修改它的事务 ID），InnoDB 通过以下规则判断当前事务是否能“看到”这个版本：</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">是否可见</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID &#x3D;&#x3D; creator_trx_id（是自己修改的）</td>
<td align="left">✅ 可见</td>
<td align="left">自己事务修改的数据，当然可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID &lt; min_trx_id（比所有活跃事务都早）</td>
<td align="left">✅ 可见</td>
<td align="left">该数据在事务开始前已提交</td>
</tr>
<tr>
<td align="left">min_trx_id ≤ DB_TRX_ID &lt; max_trx_id，且 DB_TRX_ID ∉ m_ids（已提交事务）</td>
<td align="left">✅ 可见</td>
<td align="left">该事务已提交，数据可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID ≥ max_trx_id 或 DB_TRX_ID ∈ m_ids（未提交或之后的事务）</td>
<td align="left">❌ 不可见</td>
<td align="left">该事务还未提交，或比当前事务晚，数据不可见</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 如果当前版本不可见，就通过 DB_ROLL_PTR 找到更早的版本，继续判断，直到找到一个可见的版本为止。</p>
</blockquote>
</li>
</ol>
<h4 id="Read-View-是什么时候生成的？"><a href="#Read-View-是什么时候生成的？" class="headerlink" title="Read View 是什么时候生成的？"></a>Read View 是什么时候生成的？</h4><ul>
<li><p>Read View 是在事务进行“快照读”（如普通 SELECT）时生成的，而不是所有的 SELECT 都会生成。</p>
<p>具体来说：</p>
<ul>
<li>对于普通的 SELECT（一致性非锁定读，快照读）：会生成一个 Read View，根据该视图去读取符合条件的“历史版本数据”。</li>
<li>对于加锁的 SELECT（如 SELECT … FOR UPDATE &#x2F; LOCK IN SHARE MODE）：属于当前读（锁定读），不会使用 MVCC，而是直接读最新的数据，并加锁。</li>
</ul>
</li>
</ul>
<h4 id="在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？"><a href="#在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？" class="headerlink" title="在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？"></a>在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？</h4><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">Read View 生成时机</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RC（Read Committed，读已提交）</strong></td>
<td align="left"><strong>每次执行快照读（普通 SELECT）时都会生成一个新的 Read View</strong></td>
<td align="left">因此每次读都基于<strong>当前最新已提交的数据</strong>，可能读到其他事务已提交的新数据，导致<strong>不可重复读</strong>。</td>
</tr>
<tr>
<td align="left"><strong>RR（Repeatable Read，可重复读）</strong></td>
<td align="left"><strong>仅在事务中第一次执行快照读时生成一个 Read View，后续复用该 View</strong></td>
<td align="left">因此在整个事务中，读到的数据都是基于事务开始时（或第一次读时）的快照，保证多次读取结果一致，解决<strong>不可重复读</strong>。</td>
</tr>
</tbody></table>
<h4 id="MySQL-的-RR-级别解决了幻读问题吗？"><a href="#MySQL-的-RR-级别解决了幻读问题吗？" class="headerlink" title="MySQL 的 RR 级别解决了幻读问题吗？"></a>MySQL 的 RR 级别解决了幻读问题吗？</h4><ol>
<li><p>RR 级别是否解决了幻读？</p>
<p><strong>答案是：MySQL 的 RR 级别，通过 MVCC + Gap Lock &#x2F; Next-Key Lock 的组合，实际上已经解决了幻读问题！</strong></p>
<p>但是要注意：</p>
<ul>
<li><strong>单纯依靠 MVCC（多版本控制）是无法解决幻读的！</strong></li>
<li><strong>真正解决幻读，靠的是 InnoDB 的锁机制：Gap Lock（间隙锁）和 Next-Key Lock（临键锁）！</strong></li>
</ul>
<hr>
</li>
<li><p>InnoDB 如何通过锁解决幻读？</p>
<p>在 <strong>RR 级别下</strong>，InnoDB 对于<strong>范围查询</strong>会使用：</p>
<ul>
<li><strong>Next-Key Lock &#x3D; Record Lock（记录锁） + Gap Lock（间隙锁）</strong></li>
</ul>
<ol>
<li>Record Lock（记录锁）：</li>
</ol>
<p>锁住<strong>索引记录本身</strong>，比如某条 id&#x3D;10 的记录。</p>
<ol start="2">
<li>Gap Lock（间隙锁）：</li>
</ol>
<p>锁住<strong>索引记录之间的间隙</strong>，防止其他事务在这个间隙中<strong>插入新的数据</strong>。</p>
<ol start="3">
<li>Next-Key Lock：</li>
</ol>
<p>是两者的组合，既锁住记录本身，也锁住该记录前面的间隙。例如，对索引范围 (5, 10] 加 Next-Key Lock，意味着：</p>
<ul>
<li>锁住了索引值 10 这条记录（Record Lock）</li>
<li>同时锁住了 (5, 10) 这个区间，防止插入 id&#x3D;6~9 的新数据（Gap Lock）</li>
</ul>
<hr>
</li>
<li><p>举例说明幻读的避免</p>
<p>假设表中有 id 为 1, 5, 10 的记录，事务 A 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id &gt; 5 AND id &lt; 15 FOR UPDATE;</span><br></pre></td></tr></table></figure>


<p>在 RR 级别下，InnoDB 会对 id &gt;5 且 &lt;15 的<strong>范围加上 Next-Key Lock</strong>，包括：</p>
<ul>
<li>记录锁：id&#x3D;10</li>
<li>间隙锁：(5,10), (10,15)</li>
</ul>
<p>此时，如果另一个事务 B 尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t (id) VALUES (7);   -- 会被阻塞，因为 (5,10) 被锁</span><br><span class="line">INSERT INTO t (id) VALUES (12);  -- 会被阻塞，因为 (10,15) 被锁</span><br></pre></td></tr></table></figure>


<p>这样就<strong>防止了其他事务插入“幻影行”</strong>，从而避免了幻读。</p>
</li>
</ol>
<h3 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a>索引覆盖是什么</h3><ol>
<li>索引覆盖：指的是当查询所需的所有列都包含在索引中时，数据库可以直接从索引中获取所需数据，而无需回表查询数据行。</li>
<li>索引覆盖的工作原理<ol>
<li>普通查询流程（无索引覆盖）<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行位置（如主键值）</li>
<li><strong>回表查询</strong>：根据索引提供的位置信息，再到数据表（聚簇索引）中查找完整的行数据</li>
<li><strong>返回结果</strong>：从完整行数据中提取所需的列<ul>
<li>这个过程需要<strong>两次查找操作</strong>：一次在索引上，一次在数据表上。</li>
</ul>
</li>
</ol>
</li>
<li>索引覆盖查询流程<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行</li>
<li><strong>直接从索引获取数据</strong>：因为所需的所有列都包含在索引中，直接从索引结构中提取数据</li>
<li><strong>返回结果</strong>：无需访问数据表<ul>
<li>这个过程只需要<strong>一次查找操作</strong>，且数据来源是更轻量的索引结构。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><ol>
<li><p>是什么</p>
<ol>
<li>EXPLAIN 是 MySQL 提供的一个 SQL 命令，<strong>用于显示 MySQL 如何执行 SQL 语句的执行计划</strong>。通过 EXPLAIN，你可以看到查询优化器选择的执行路径、使用的索引、连接类型、数据读取方式等关键信息。</li>
</ol>
</li>
<li><p>作用</p>
<ol>
<li>分析查询性能瓶颈</li>
<li>查看索引使用情况</li>
<li>理解查询执行策略</li>
<li>优化 SQL 语句</li>
<li>预测查询性能</li>
</ol>
</li>
<li><p>explain的基础列详解</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">数据类型</th>
<th align="left">说明</th>
<th align="left">重要解读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>id</strong></td>
<td align="left">int</td>
<td align="left">SELECT 查询的标识符</td>
<td align="left">表示查询中 SELECT 语句的执行顺序。id相同，执行顺序从上往下；id不同，数值越大越先执行</td>
</tr>
<tr>
<td align="left"><strong>select_type</strong></td>
<td align="left">varchar</td>
<td align="left">查询类型</td>
<td align="left">表明查询是简单查询还是复杂查询，如 SIMPLE(简单SELECT)、PRIMARY(最外层SELECT)、SUBQUERY(子查询)、DERIVED(派生表)等</td>
</tr>
<tr>
<td align="left"><strong>table</strong></td>
<td align="left">varchar</td>
<td align="left">访问的表名</td>
<td align="left">显示这一行数据是关于哪张表的，可能是表名、别名、派生表或临时表</td>
</tr>
<tr>
<td align="left"><strong>partitions</strong></td>
<td align="left">varchar</td>
<td align="left">匹配的分区</td>
<td align="left">对于分区表，显示查询访问了哪些分区，非分区表通常为NULL</td>
</tr>
<tr>
<td align="left"><strong>type</strong></td>
<td align="left">varchar</td>
<td align="left">访问类型</td>
<td align="left"><strong>查询性能关键指标</strong>，表示MySQL在表中找到所需行的方式，从好到坏：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td>
</tr>
<tr>
<td align="left"><strong>possible_keys</strong></td>
<td align="left">varchar</td>
<td align="left">可能使用的索引</td>
<td align="left">查询优化器可能考虑使用哪些索引来查找表中的行，但不一定实际使用，若为NULL表示没有可用索引</td>
</tr>
<tr>
<td align="left"><strong>key</strong></td>
<td align="left">varchar</td>
<td align="left">实际使用的索引</td>
<td align="left">查询优化器实际选择的索引，若为NULL则表示没有使用索引，显示的是索引名称</td>
</tr>
<tr>
<td align="left"><strong>key_len</strong></td>
<td align="left">int</td>
<td align="left">使用的索引长度(字节)</td>
<td align="left">显示使用的索引字段的长度，可以帮助判断使用了索引的哪些部分，数值越小通常越好</td>
</tr>
<tr>
<td align="left"><strong>ref</strong></td>
<td align="left">varchar</td>
<td align="left">索引参考列</td>
<td align="left">显示索引的哪一列被使用了，或者常量值，如 const、func、NULL 或列名</td>
</tr>
<tr>
<td align="left"><strong>rows</strong></td>
<td align="left">int</td>
<td align="left">预估扫描行数</td>
<td align="left"><strong>查询性能关键指标</strong>，MySQL估计为了找到所需的行而要读取的行数，数值越小越好，是优化器估算值</td>
</tr>
<tr>
<td align="left"><strong>filtered</strong></td>
<td align="left">decimal(5,2)</td>
<td align="left">过滤百分比</td>
<td align="left">存储引擎返回的数据在server层过滤后，还剩余多少比例(百分比)，值越高越好，MySQL 5.7+引入</td>
</tr>
<tr>
<td align="left"><strong>Extra</strong></td>
<td align="left">varchar</td>
<td align="left">额外信息</td>
<td align="left"><strong>查询性能关键信息</strong>，包含不适合在其他列中显示但十分重要的额外信息，如 Using index、Using where、Using temporary 等</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><ol>
<li>是什么<ol>
<li><strong>最左前缀原则</strong>指的是：<strong>对于复合索引（包含多个列的索引），查询必须使用索引的最左列（第一个列）才能使用该索引</strong>，并且查询条件中的列顺序必须与索引列定义顺序相匹配，从最左边的列开始连续使用。</li>
<li>换句话说，如果有一个复合索引是 <code>(A, B, C)</code>，那么：<ul>
<li>查询条件必须<strong>从A列开始</strong>使用并<strong>保持相对顺序</strong></li>
<li>可以使用 <ul>
<li><code>(A)</code>、<code>(A, B)</code>、<code>(A, B, C)</code>、<code>(A, C)</code></li>
</ul>
</li>
<li>不能使用<ul>
<li><code>(B, C)</code>、<code>(A, C, B)</code>、<code>(B, A)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h3><ul>
<li>MyISAM和InnoDB是MySQL数据库中两种最重要的存储引擎，它们在架构设计、功能特性和适用场景上有显著区别</li>
<li><strong>存储引擎（Storage Engine）<strong>是MySQL中用于</strong>管理数据存储和检索的底层软件组件</strong>。它负责数据的存储、读取、索引管理、事务处理等核心功能。MySQL采用<strong>插件式架构</strong>，允许使用不同的存储引擎来处理不同的表。</li>
<li>InnoDB是更先进的存储引擎。一般来说，只推荐用InnoDB。</li>
</ul>
<h3 id="为什么MySQL要用B-树而不用B树"><a href="#为什么MySQL要用B-树而不用B树" class="headerlink" title="为什么MySQL要用B+树而不用B树"></a>为什么MySQL要用B+树而不用B树</h3><ol>
<li><strong>更低的树高度</strong>：B+树通过只在非叶子节点存储索引键，可以容纳更多键值，大大减少树的高度，进而减少磁盘I&#x2F;O次数，提高查询效率</li>
<li><strong>更高效的范围查询</strong>：B+树的叶子节点通过指针连接形成有序链表，使得<strong>范围查询（如BETWEEN、&gt;、&lt;）和排序操作（ORDER BY）非常高效</strong></li>
<li>更高的存储密度：B+树的非叶子节点不存储实际数据，可以存储更多索引键，即更高的扇出，使得每个节点能容纳更多信息，进一步降低树的高度</li>
<li><strong>更稳定的查询性能</strong>：所有查询都必须到达叶子节点，使得查询路径长度完全一致，提供更稳定和可预测的查询性能</li>
<li>更适合数据库特性：B+树的结构与数据库的读多写少、需要高效范围查询、排序和稳定性能的需求高度契合</li>
<li>与InnoDB实现完美配合：特别是聚簇索引设计和磁盘页优化，使得B+树在MySQL中能够发挥最大效能</li>
</ol>
<h3 id="MySQL的锁有哪些"><a href="#MySQL的锁有哪些" class="headerlink" title="MySQL的锁有哪些"></a>MySQL的锁有哪些</h3><ol>
<li><p>按锁的粒度分类</p>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全局锁</strong></td>
<td align="left">锁定整个数据库实例</td>
<td align="left">简单粗暴，保证全局一致性</td>
<td align="left">性能影响极大，几乎锁住所有操作</td>
<td align="left">全库备份、全库数据迁移</td>
</tr>
<tr>
<td align="left"><strong>表级锁</strong></td>
<td align="left">锁定整张表</td>
<td align="left">实现简单，开销小，加锁快</td>
<td align="left">并发度低，锁冲突概率高</td>
<td align="left">MyISAM引擎、DDL操作、批量数据操作</td>
</tr>
<tr>
<td align="left"><strong>行级锁</strong></td>
<td align="left">只锁定需要操作的行</td>
<td align="left">并发度高，冲突概率低</td>
<td align="left">实现复杂，开销大，加锁慢</td>
<td align="left">InnoDB引擎、高并发OLTP系统</td>
</tr>
</tbody></table>
</li>
<li><p>按锁的性质分类</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>共享锁(S锁，Shared Lock)</strong></td>
<td align="left">读锁，多个事务可同时持有</td>
<td align="left">允许其他事务读取，但禁止写入</td>
<td align="left">读操作、需要数据不被修改的场景</td>
</tr>
<tr>
<td align="left"><strong>排他锁(X锁，Exclusive Lock)</strong></td>
<td align="left">写锁，一次只能由一个事务持有</td>
<td align="left">禁止其他事务读取和写入</td>
<td align="left">写操作、数据修改场景</td>
</tr>
<tr>
<td align="left"><strong>意向锁</strong></td>
<td align="left">表级锁，表明事务打算在表中的行上获取什么类型的锁</td>
<td align="left">提高表级锁和行级锁的兼容性判断效率</td>
<td align="left">InnoDB引擎内部使用</td>
</tr>
</tbody></table>
<ol>
<li>意向锁是表级锁。当读或写某一行时，会给对应的表加上IS或IX锁。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ol>
<li>惰性删除：<ol>
<li>原理：访问某个Key时检查是否过期</li>
<li>优点：CPU友好，节省了CPU资源</li>
<li>缺点：大量过期的Key没有被访问，占内存资源</li>
</ol>
</li>
<li>定期删除：<ol>
<li>原理：每隔一段时间，扫描一部分Key，删除过期键</li>
</ol>
</li>
<li>定时过期：<ol>
<li>原理：给Key设置定时过期删除的属性</li>
</ol>
</li>
</ol>
<h3 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h3><ol>
<li><p>实现流程</p>
<ol>
<li>事务开始<ol>
<li><code>MULTI</code>启动事务模式（flag属性打开REDIS_MULTI标识）</li>
</ol>
</li>
<li>命令入队<ol>
<li>除了<code>DISCADE</code>,<code>WATCH</code>,<code>EXEC</code>等少数命令会立即执行外，其他命令都是入队。</li>
<li>入队时会检查语法错误。如果有语法问题，则终止事务（flag属性关闭REDIS_MULTI标识）</li>
</ol>
</li>
<li>事务执行<ol>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性如何实现？Redis没有回滚机制，是否破坏了原子性？</p>
<ol>
<li><p>我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断</p>
</li>
<li><p>在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性</p>
</li>
<li><p>虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。</p>
</li>
<li><p>并且运行时错误多为编程错误，可以避免。</p>
</li>
<li><p>一致性如何实现？</p>
<ol>
<li><strong>内部一致性：</strong> Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。</li>
<li><strong>事务隔离性：</strong> <code>I</code> 的保证间接支撑了 <code>C</code>，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。</li>
</ol>
</li>
<li><p>隔离性如何实现？</p>
<ol>
<li>Redis 对隔离性的保证是<strong>非常强大</strong>的，因为它基于单线程模型。</li>
<li>保证方式： Redis 使用 <strong>单线程</strong> 模型处理所有客户端请求（除了后台的持久化操作）。</li>
<li>结果： <code>MULTI</code>&#x2F;<code>EXEC</code> 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。</li>
<li>总结： <strong>Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><p>持久性如何实现？</p>
<ol>
<li><p>Redis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，<strong>默认情况下持久性是有风险的</strong>。</p>
<ol>
<li><p>Redis 主要通过两种方式实现持久性：</p>
<ol>
<li><strong>AOF (Append Only File) 模式：</strong><ol>
<li>将所有写命令以日志形式追加到文件中。</li>
<li>如果配置了 <code>always</code> 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。</li>
<li>但为了性能，通常配置为 <code>everysec</code>（每秒同步一次），这意味着最近一秒内的数据可能会丢失。</li>
</ol>
</li>
<li><strong>RDB (Redis Database) 快照模式：</strong><ol>
<li>定期将内存中的数据生成一个二进制快照文件。</li>
<li>由于是<strong>定期</strong>快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>总结：</strong> Redis 的持久性是<strong>可配置的</strong>。只有在启用 AOF 并设置为 <code>always</code> 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h3><ul>
<li>RDB，AOF</li>
</ul>
<h3 id="分布式锁底层怎么实现的"><a href="#分布式锁底层怎么实现的" class="headerlink" title="分布式锁底层怎么实现的"></a>分布式锁底层怎么实现的</h3><ul>
<li><p>使用 Redis 的 <code>SET key value NX PX timeout</code>命令，来实现：</p>
<ul>
<li><strong>互斥性（Mutual Exclusion）</strong>：同一时刻只有一个客户端能成功设置锁</li>
<li><strong>避免死锁</strong>：锁必须要有过期时间，防止客户端崩溃后锁永远不释放</li>
<li><strong>锁的释放必须是原子的且只能由加锁者释放</strong>：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁</li>
</ul>
</li>
</ul>
<h3 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h3><ul>
<li>主从复制，哨兵模式，集群模式</li>
</ul>
<h3 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h3><h3 id="Redis与MySQL如何保证数据的一致性"><a href="#Redis与MySQL如何保证数据的一致性" class="headerlink" title="Redis与MySQL如何保证数据的一致性"></a>Redis与MySQL如何保证数据的一致性</h3><ol>
<li><p>为什么会不一致</p>
<ol>
<li><p>在常见的 <strong>“先更新数据库，再更新缓存” 或 “先删缓存，再更新数据库”</strong> 等策略中，如果操作顺序、并发控制不当，就可能出现以下情况：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">说明</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 程序 Bug 或异常</strong></td>
<td align="left">更新了数据库，但忘记更新&#x2F;删除缓存</td>
<td align="left">缓存是旧数据，与数据库不一致</td>
</tr>
<tr>
<td align="left"><strong>2. 并发读写</strong></td>
<td align="left">一个线程在更新数据库和缓存的过程中，另一个线程读了旧的缓存或写入了脏数据</td>
<td align="left">缓存与数据库数据出现偏差</td>
</tr>
<tr>
<td align="left"><strong>3. 崩溃或中断</strong></td>
<td align="left">在更新数据库和缓存之间服务崩溃，导致两者状态不一致</td>
<td align="left">缓存和数据库“数据分裂”</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>常用策略</p>
<ol>
<li><p>延时双删策略（Double Delete）</p>
<ol>
<li>为了解决 并发导致的脏数据回填问题，可以采用 双删策略，即在写操作的以下时机删除缓存：<ol>
<li>写操作之前，先删除一次缓存</li>
<li>更新数据库</li>
<li>延迟一段时间（如几百毫秒），再删除一次缓存</li>
</ol>
</li>
<li>为什么延迟删除？<ul>
<li>因为在更新数据库的过程中，可能有其他线程读了旧数据并回填了缓存，延迟删除可以尽量把这种脏缓存清除掉</li>
</ul>
</li>
<li>实现方式：<ul>
<li>可以使用 Java 的 <code>ScheduledExecutorService</code>、<code>Thread.sleep()</code>，或者消息队列延迟消费等方式实现“延迟删除”</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ 适合对一致性要求稍高一点的业务，但仍有 极小概率的不一致窗口期</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h3><ol>
<li><p><strong>基于内存操作（最重要原因）</strong></p>
<blockquote>
<p>Redis 的数据是存储在<strong>内存中的</strong>，内存的访问速度是纳秒级别（约 100ns），相比磁盘（毫秒级）快几个数量级。</p>
</blockquote>
<ul>
<li>操作内存比操作磁盘或数据库快得多，不需要磁盘 I&#x2F;O、不需要复杂的事务日志、不需要锁等待。</li>
<li>所有的读写操作几乎都是在内存中瞬间完成，这是 Redis 高性能的<strong>最核心原因</strong>。</li>
</ul>
<hr>
</li>
<li><p><strong>单线程避免了多线程的锁竞争和上下文切换</strong></p>
<ul>
<li>在多线程模型中，多个线程访问共享数据时需要加锁（如互斥锁、读写锁），这会带来：<ul>
<li>锁竞争</li>
<li>线程切换开销</li>
<li>死锁风险</li>
<li>编程复杂度高</li>
</ul>
</li>
<li>Redis 采用单线程模型，<strong>所有命令串行执行，无需考虑并发安全问题，没有锁竞争，也没有线程切换的开销</strong>，所以执行效率极高。</li>
</ul>
<blockquote>
<p>✅ 单线程 &#x3D; 无锁 &#x3D; 无竞争 &#x3D; 更简单、更高效</p>
</blockquote>
<hr>
</li>
<li><p><strong>优秀的数据结构与高性能底层实现</strong></p>
<p>Redis 提供了多种<strong>高效的数据结构</strong>（如 String、Hash、List、Set、ZSet 等），并且这些数据结构在底层使用了非常高效的实现方式，比如：</p>
<ul>
<li>ziplist、quicklist、哈希表优化、跳表（SkipList）等</li>
<li>所有数据结构的操作都经过高度优化，使得命令执行非常快速</li>
</ul>
<hr>
</li>
<li><p><strong>I&#x2F;O 多路复用模型（核心网络模型）</strong></p>
<ol>
<li><p>Redis 使用了 <strong>I&#x2F;O 多路复用技术（如 epoll、kqueue、select）</strong> 来处理大量的并发连接，这是它支撑高并发的关键。</p>
</li>
<li><p>什么是 I&#x2F;O 多路复用？</p>
<ul>
<li><p>允许 <strong>一个线程同时监听多个 Socket 连接</strong> 的读写事件</p>
</li>
<li><p>当某个连接有数据可读&#x2F;可写时，Redis 才去处理这个连接</p>
</li>
<li><p>避免了为每个连接创建一个线程，极大节省了系统资源</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ Redis 通过 <strong>单线程 + I&#x2F;O 多路复用</strong>，就能高效处理数万甚至数十万的并发连接，而不会线程爆炸。</p>
</blockquote>
<hr>
</li>
<li><p><strong>Redis 命令执行是原子性的，无需额外同步</strong></p>
<ul>
<li>每个 Redis 命令都是<strong>原子操作</strong>，比如 INCR、LPUSH 等，执行过程中不会被其他命令打断。</li>
<li>因为是单线程，所以也<strong>不需要加锁来保证原子性</strong>，执行效率高，逻辑简单。</li>
</ul>
<hr>
</li>
<li><p><strong>Redis 是专门为高性能场景设计的网络存储中间件</strong></p>
<ul>
<li>Redis 的代码是<strong>用 C 语言编写的，非常接近底层，运行效率极高</strong></li>
<li>没有复杂的企业级框架、没有冗余的中间层，整个系统非常轻量、高效</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>基于内存，读写极快</strong></td>
<td align="left">数据在内存中，访问速度是纳秒级</td>
</tr>
<tr>
<td align="left">✅ <strong>单线程，无锁，无竞争</strong></td>
<td align="left">不需要考虑并发安全，没有锁开销，执行路径简单</td>
</tr>
<tr>
<td align="left">✅ <strong>I&#x2F;O 多路复用，高并发支持好</strong></td>
<td align="left">单线程可处理几万甚至几十万的并发连接</td>
</tr>
<tr>
<td align="left">✅ <strong>命令执行是原子的</strong></td>
<td align="left">无需加锁，执行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>代码精简高效</strong></td>
<td align="left">C 语言实现，无复杂框架，运行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>扩展性强（Redis 6.0+ 多线程 I&#x2F;O）</strong></td>
<td align="left">网络读写利用多核，进一步提升性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">局限性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>CPU 密集型任务可能阻塞</strong></td>
<td align="left">如果某个命令执行特别耗时（如 KEYS *、大 Key 操作、复杂 Lua 脚本），会阻塞整个主线程，影响其他请求</td>
</tr>
<tr>
<td align="left">❌ <strong>无法充分利用多核 CPU（命令执行层面）</strong></td>
<td align="left">命令执行仍然是单线程的，不能发挥多核优势（但网络 I&#x2F;O 可以，Redis 6.0+）</td>
</tr>
<tr>
<td align="left">❌ <strong>对单个大 Key 或慢查询敏感</strong></td>
<td align="left">一个慢命令可能拖慢整个服务</td>
</tr>
</tbody></table>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><ol>
<li><p>三次握手</p>
<ol>
<li><p>确保客户端和服务器双方的 <strong>发送和接收能力正常</strong>，并 <strong>同步双方的初始序列号（ISN, Initial Sequence Number）</strong>，为后续可靠数据传输做准备。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>SYN &#x3D; 1, seq &#x3D; x</strong></td>
<td align="left">客户端向服务端发起连接请求，随机生成一个初始序列号 x，表示“我想和你建立连接”。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; y, ack &#x3D; x + 1</strong></td>
<td align="left">服务端收到请求后，同意建立连接，也随机生成一个初始序列号 y，并确认客户端的序号 x+1（ACK &#x3D; x + 1）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, seq &#x3D; x + 1, ack &#x3D; y + 1</strong></td>
<td align="left">客户端收到服务端的同意后，再发送一个确认报文，确认服务端的序号 y+1。此时连接建立成功。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>四次挥手</p>
<ol>
<li><p>由于 TCP 是<strong>全双工</strong>的（即双方可以同时发送和接收数据），因此<strong>每个方向上的数据传输都需要单独关闭</strong>，所以需要四次挥手来确保双方都完成数据发送并安全关闭连接。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; u</strong></td>
<td align="left">客户端 A 发送 FIN 报文，表示“我不再发送数据了，但还可以接收”。进入 <strong>FIN_WAIT_1</strong> 状态。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; u + 1</strong></td>
<td align="left">服务端 B 收到后，发送 ACK 确认，表示“我知道你不想发了，但我可能还有数据要发给你”。A 进入 <strong>FIN_WAIT_2</strong>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">B → A</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; v</strong></td>
<td align="left">服务端 B 处理完剩余数据后，也发送 FIN 报文，表示“我也不再发送数据了”。进入 <strong>LAST_ACK</strong> 状态。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; v + 1</strong></td>
<td align="left">客户端 A 收到后，发送最后的 ACK 确认。B 收到后关闭连接。A 等待一段时间（2MSL）后也关闭连接。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="浏览器发出一个请求到收到响应经历了那些过程"><a href="#浏览器发出一个请求到收到响应经历了那些过程" class="headerlink" title="浏览器发出一个请求到收到响应经历了那些过程"></a>浏览器发出一个请求到收到响应经历了那些过程</h3><ol>
<li>URL 解析</li>
<li>DNS 查询（域名 → IP 地址）</li>
<li>建立 TCP 连接（三次握手）</li>
<li>如果是 HTTPS，进行 TLS 握手（加密通道建立）</li>
<li>发送 HTTP 请求（浏览器 → 服务器）</li>
<li>服务器处理请求并返回 HTTP 响应</li>
<li>浏览器解析 HTML 内容</li>
<li>请求并加载外部资源</li>
<li>页面渲染与显示</li>
</ol>
<h3 id="跨域请求是什么？有什么问题？怎么解决？"><a href="#跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="跨域请求是什么？有什么问题？怎么解决？"></a>跨域请求是什么？有什么问题？怎么解决？</h3><ol>
<li><p>是什么</p>
<ol>
<li><p>跨域请求：<strong>当前网页</strong>的域名、协议、端口中的任意一个与<strong>请求</strong>的目标资源不一致，导致浏览器出于安全考虑阻止该请求。</p>
</li>
<li><p>什么是“同源”？</p>
<ol>
<li>两个 URL 如果满足以下 <strong>三者完全相同</strong>，就属于<strong>同源（Same Origin）</strong>，否则就是<strong>跨域（Cross-Origin）</strong>：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">组成部分</th>
<th align="left">是否必须相同</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议（Protocol）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>http</code>vs <code>https</code>就不同源</td>
</tr>
<tr>
<td align="left"><strong>域名（Host）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>www.example.com</code>vs <code>api.example.com</code>不同源</td>
</tr>
<tr>
<td align="left"><strong>端口（Port）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>80</code>（HTTP默认） vs <code>443</code>（HTTPS默认） 或 <code>8080</code>不同源</td>
</tr>
</tbody></table>
</li>
<li><p>用一个场景来理解</p>
<ol>
<li><p>场景 1：前端和后端运行在不同的端口（开发时最常见！）</p>
<ul>
<li>你用 <strong>React &#x2F; Vue</strong> 写了一个前端项目，运行在：<code>http://localhost:3000</code>（前端页面）</li>
<li>你的 <strong>后端 API 服务</strong>（比如 Node.js、Java Spring、Python Django）运行在：<code>http://localhost:8080</code>或 <code>http://localhost:3001</code></li>
</ul>
</li>
<li><p>你前端代码中发起请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;http://localhost:8080/api/data&#x27;)</span><br></pre></td></tr></table></figure>

</li>
<li><p>会发生什么？</p>
<ul>
<li>请求确实发到了后端（你可以在后端看到请求日志），</li>
<li>但浏览器收到响应后一看：“咦？你前端是 <code>localhost:3000</code>，却去访问 <code>localhost:8080</code>，<strong>端口不同，属于跨域！</strong>”</li>
<li>于是浏览器就把响应拦下来了，你的 JavaScript 拿不到返回的数据！</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>有什么问题？举个例子</p>
</li>
<li><p>怎么解决</p>
<ol>
<li><p><strong>CORS（跨域资源共享，主流推荐方案）</strong></p>
<ol>
<li>CORS（Cross-Origin Resource Sharing） 是 W3C 标准，通过后端设置一些 HTTP 响应头，告诉浏览器：“这个跨域请求我是允许的”。</li>
<li>后端需要设置的常见响应头：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Access-Control-Allow-Origin: *</code>或 <code>http://your-frontend-domain.com</code></td>
<td align="left">表示允许哪些来源的网站访问资源。 <code>*</code>表示允许所有（不推荐在生产用，尤其带 Cookie 时） 最好明确指定域名，如 <code>http://localhost:3000</code></td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</code></td>
<td align="left">允许的 HTTP 方法</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Headers: Content-Type, Authorization</code></td>
<td align="left">允许的请求头</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Credentials: true</code></td>
<td align="left">是否允许发送 Cookie（需前端也设置 <code>withCredentials: true</code>）</td>
</tr>
</tbody></table>
<ol start="3">
<li>后端示例（以 Node.js&#x2F;Express 为例）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:3000&quot;</span>); <span class="comment">// 或 *</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, PUT, DELETE&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type, Authorization&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 如需传 cookie</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>✅ 只要后端正确配置了 CORS 头，浏览器就允许跨域请求！</p>
</blockquote>
<ol start="2">
<li><p><strong>代理服务器（Proxy）【开发常用】</strong></p>
<ol>
<li><p>在开发环境中，前端代码和后端 API 往往不在一个域，但你可以：</p>
<ol>
<li>通过 webpack devServer、vite、nginx 等设置代理，将前端发出的请求转发到目标 API 服务器，从而<strong>避免浏览器直接跨域</strong></li>
<li>反向代理的核心作用就是：让前端和后端都使用同一个域名和端口（比如 <code>http://localhost:3000</code>或 <code>https://www.yoursite.com</code>），让浏览器认为它访问的就是同源的资源，从而避免跨域问题。</li>
</ol>
</li>
<li><p>例子：Vue&#x2F;React 开发时配置代理（以 vite &#x2F; webpack 为例）</p>
<p>vite.config.js 或 webpack.config.js 中配置代理：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line">export <span class="keyword">default</span> <span class="title function_">defineConfig</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">  server: &#123;</span></span><br><span class="line"><span class="params">    proxy: &#123;</span></span><br><span class="line"><span class="params">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span></span><br><span class="line"><span class="params">        target: <span class="string">&#x27;http://backend-api-server.com&#x27;</span>, // 后端真实地址</span></span><br><span class="line"><span class="params">        changeOrigin: <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">        rewrite: (path)</span> =&gt; path.replace(/^\/api/, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>这样，前端代码中请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;/api/user&#x27;)  // 不是跨域！代理服务器会转发到 http://backend-api-server.com/user</span><br></pre></td></tr></table></figure>


<p>优点：前端无需关心跨域，由代理服务器解决</p>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在讲 <strong>反向代理</strong> 之前，先简单了解一下什么是 <strong>代理（Proxy）</strong>。</p>
<ol>
<li><p><strong>正向代理（Forward Proxy）</strong></p>
<ol>
<li><p>正向代理 是位于 客户端（用户） 和 互联网 之间的代理，代表客户端去访问服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>访问被墙的网站（比如通过代理服务器访问 Google）</p>
</li>
<li><p>隐藏客户端的真实 IP</p>
</li>
<li><p>企业内网上网控制</p>
</li>
</ul>
</li>
<li><p>谁用代理：客户端（用户）主动设置代理</p>
</li>
<li><p>举例：</p>
<ol>
<li>你（客户端）想访问某个网站，但不想直接暴露自己，于是你通过一个代理服务器去访问，代理帮你请求网站，再将结果返回给你。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>反向代理（Reverse Proxy）</strong></p>
<ol>
<li><p>反向代理：是位于 客户端（用户） 和 后端服务器（如你的应用服务器） 之间的代理，代表服务器接收客户端的请求，并将其转发给内部的服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>保护后端服务，隐藏其真实 IP 和端口</p>
</li>
<li><p>实现 负载均衡</p>
</li>
<li><p>提供 统一入口（比如通过域名访问多个服务）</p>
</li>
<li><p>处理 SSL&#x2F;TLS 加密（HTTPS）</p>
</li>
<li><p>缓存、压缩、静态文件服务</p>
</li>
<li><p>实现 反向代理路由（如根据路径转发到不同后端）</p>
</li>
</ul>
</li>
<li><p>谁用代理：是服务器端设置的，对客户端透明（不可见）</p>
</li>
<li><p>意义</p>
<ol>
<li><p>隐藏后端服务的真实 IP 和端口</p>
<ul>
<li>用户只访问 <code>https://www.yourdomain.com</code>，不知道后端是运行在哪个端口或机器上的。</li>
<li>提升安全性，避免直接将后端服务暴露在公网。</li>
</ul>
</li>
<li><p>统一入口，多服务路由</p>
</li>
</ol>
<ul>
<li>你可以用 Nginx 将不同的请求路径转发到不同的后端服务，比如：<code>/api</code>→ Node.js 后端<code>/admin</code>→ Java 后台<code>/static</code>→ Nginx 直接返回静态文件</li>
</ul>
<ol start="3">
<li>负载均衡</li>
</ol>
<ul>
<li><p>将请求分发到多个后端实例，提高系统的可用性和性能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 127.0.0.1:3000;</span><br><span class="line">    server 127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>处理 HTTPS &#x2F; SSL 加密</li>
</ol>
<ul>
<li>你可以通过 Nginx 配置 SSL 证书，让用户通过 <code>https://</code>安全访问，而不用在后端服务里处理复杂的 HTTPS 配置。</li>
</ul>
<ol start="5">
<li>静态资源服务</li>
</ol>
<ul>
<li>Nginx 非常擅长快速返回 HTML、CSS、JS、图片等静态文件，比 Node.js 或 Java 服务效率更高。</li>
</ul>
<ol start="6">
<li>缓存、压缩、安全防护等高级功能</li>
</ol>
<ul>
<li>Nginx 还提供访问控制、防爬虫、GZIP 压缩、缓存、限流等能力。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><ol>
<li>为什么要了解零拷贝<ol>
<li>在传统的数据传输过程中，数据通常需要在 内存、CPU、内核缓冲区、用户缓冲区、网卡缓冲区 等多个地方多次 拷贝，并且伴随着多次 CPU 上下文切换，这样会带来很大的 性能开销。</li>
<li>而 零拷贝技术的核心目标就是：尽可能减少数据在内存中的拷贝次数，避免不必要的 CPU 拷贝和上下文切换，从而提升数据传输效率，降低延迟和 CPU 占用。</li>
</ol>
</li>
<li>什么是零拷贝<ol>
<li>零拷贝的核心思想是：<ol>
<li>尽量减少甚至避免数据在内存中的冗余拷贝，尤其是避免数据在 用户态 和 内核态 之间的 CPU 拷贝，从而提升性能</li>
<li>它并不一定意味着 完全没有数据拷贝（物理上可能还是会有 DMA 拷贝），而是 尽量减少 CPU 参与的拷贝次数，尤其是用户态与内核态之间的拷贝。</li>
</ol>
</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251025175854459.png" alt="image-20251025175854459"></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python核心库学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>NumPy（Numerical Python）是 Python 中一个强大的科学计算库，提供了高性能的多维数组对象（<code>ndarray</code>）以及大量的数学函数和操作工具，是许多其他科学计算库（如 SciPy、Pandas、Matplotlib 等）的基础。</p>
<p>下面是 NumPy 库的一些<strong>基本用法</strong>：</p>
<hr>
<h2 id="一、安装-NumPy"><a href="#一、安装-NumPy" class="headerlink" title="一、安装 NumPy"></a>一、安装 NumPy</h2><p>如果尚未安装 NumPy，可以使用 pip 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>


<hr>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">计算机网络八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">名称</th>
<th align="left">中文名</th>
<th align="left">主要功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>7</strong></td>
<td align="left">Application Layer</td>
<td align="left"><strong>应用层</strong></td>
<td align="left">直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）</td>
</tr>
<tr>
<td align="left"><strong>6</strong></td>
<td align="left">Presentation Layer</td>
<td align="left"><strong>表示层</strong></td>
<td align="left">数据格式转换、加密、解密、压缩、解压缩</td>
</tr>
<tr>
<td align="left"><strong>5</strong></td>
<td align="left">Session Layer</td>
<td align="left"><strong>会话层</strong></td>
<td align="left">建立、管理和终止会话（通信连接）</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">Transport Layer</td>
<td align="left"><strong>传输层</strong></td>
<td align="left">提供端到端的可靠传输（如 TCP、UDP，负责端口、分段、流量控制）</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left">Network Layer</td>
<td align="left"><strong>网络层</strong></td>
<td align="left">负责数据路由和转发（如 IP 协议，决定数据怎么走到目的地）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Data Link Layer</td>
<td align="left"><strong>数据链路层</strong></td>
<td align="left">负责相邻节点间可靠传输（如以太网，MAC 地址，帧同步）</td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left">Physical Layer</td>
<td align="left"><strong>物理层</strong></td>
<td align="left">物理介质上的比特流传输（如电缆、光纤、网卡、信号）</td>
</tr>
</tbody></table>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="机器学习四大问题"><a href="#机器学习四大问题" class="headerlink" title="机器学习四大问题"></a>机器学习四大问题</h1><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul>
<li><strong>定义</strong>：一种 <strong>无监督学习方法</strong>，目标是把样本自动划分为若干组（簇），同一簇内的样本相似度高，不同簇间的相似度低。</li>
<li><strong>常见算法</strong><ul>
<li><strong>K-means</strong>：基于中心点迭代优化，快速但对初始值和簇数敏感。</li>
<li><strong>层次聚类</strong>（Hierarchical Clustering）：逐层合并或拆分，得到树状聚类结构。</li>
<li><strong>DBSCAN</strong>：基于密度，能发现任意形状的簇，并识别噪声。</li>
<li><strong>高斯混合模型 (GMM)</strong>：用概率分布来建模簇。</li>
</ul>
</li>
<li><strong>应用</strong>：用户分群、市场细分、异常检测、推荐系统。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
