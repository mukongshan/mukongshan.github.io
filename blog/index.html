<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"ebc5f2cd8493752a92129fa16b4bf1635308b0d6","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="kongshan&#39;s blog">
<meta property="og:url" content="https://kongshan.me/blog/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kongshan.me/blog/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"blog/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">kongshan's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/C++%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/C++%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:40:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:40:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-02 23:08:42" itemprop="dateModified" datetime="2025-12-02T23:08:42+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="第一章（C1、C2）-·-介绍"><a href="#第一章（C1、C2）-·-介绍" class="headerlink" title="第一章（C1、C2） · 介绍"></a>第一章（C1、C2） · 介绍</h2><h3 id="主流编程范式对比"><a href="#主流编程范式对比" class="headerlink" title="主流编程范式对比"></a>主流编程范式对比</h3><ol>
<li>面向对象编程（OOP）<ul>
<li>起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言</li>
<li>核心概念：类&#x2F;对象、继承、多态、垃圾回收</li>
<li>设计哲学：自底向上程序设计，虚拟过程机制</li>
</ul>
</li>
<li>函数式编程（FP）<ul>
<li>理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑</li>
<li>核心特性：数据不可变性、无副作用、函数一等公民引用透明性：相同输入始终产生相同输出</li>
<li>应用场景：实时游戏状态管理、高频交易系统</li>
<li>局限：学习曲线陡峭，调试复杂，不适合状态密集型场景</li>
</ul>
</li>
<li>逻辑编程<ul>
<li>代表语言：Prolog</li>
<li>特点：基于公理、推理规则和查询的自动证明</li>
<li>经典案例：专家系统诊断、鸡兔同笼问题、斑马逻辑谜题</li>
</ul>
</li>
<li>并发编程与泛型编程</li>
</ol>
<ul>
<li>并发编程：程序分解为可独立运行部分的能力</li>
<li>泛型编程：通过抽象找到算法实现的共性，提高代码复用性</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/C++%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java与JVM</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:30:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:30:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-02 23:08:42" itemprop="dateModified" datetime="2025-12-02T23:08:42+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java生命周期"><a href="#Java生命周期" class="headerlink" title="Java生命周期"></a>Java生命周期</h2><ol>
<li>编码阶段（Writing Code）</li>
</ol>
<ul>
<li><strong>开发者编写源代码</strong>，文件后缀为 <code>.java</code>。<br>比如：<code>HelloWorld.java</code>。</li>
<li>源代码中包含类（<code>class</code>）、方法（<code>method</code>）等，使用 <strong>Java 语法</strong>。</li>
</ul>
<hr>
<ol start="2">
<li>编译阶段（Compiling）</li>
</ol>
<ul>
<li><p>使用 <strong>Java 编译器 <code>javac</code></strong> 将 <code>.java</code> 文件编译成 <strong>字节码文件</strong>（<code>.class</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译后生成 <code>HelloWorld.class</code> 文件。</p>
</li>
<li><p>注意：字节码不是机器码，而是一种中间形式，跨平台。</p>
</li>
</ul>
<hr>
<ol start="3">
<li>类加载阶段（Class Loading）</li>
</ol>
<ul>
<li>当运行程序时（<code>java HelloWorld</code>），<strong>类加载器（ClassLoader）</strong> 会把需要的 <code>.class</code> 文件加载进内存。</li>
<li>类加载过程分为三个小步骤：<ol>
<li><strong>加载（Loading）</strong>：把字节码读到内存。</li>
<li><strong>连接（Linking）</strong>：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。</li>
<li><strong>初始化（Initialization）</strong>：执行静态代码块、给静态变量赋初值。</li>
</ol>
</li>
</ul>
<hr>
<ol start="4">
<li>字节码执行阶段（Execution）</li>
</ol>
<ul>
<li><p><strong>Java 虚拟机（JVM）解释执行字节码</strong>，也可能使用 <strong>JIT（即时编译器）</strong> 把热点代码编译成本地机器码，以提高运行效率。</p>
</li>
<li><p>执行的起点是程序入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="5">
<li>程序运行时（Runtime）</li>
</ol>
<ul>
<li>JVM 在运行时会：<ul>
<li><strong>内存管理</strong>：使用 <strong>堆、栈、方法区、运行时常量池</strong> 等。</li>
<li><strong>垃圾回收（GC）</strong>：回收不再使用的对象内存。</li>
<li><strong>异常处理</strong>：执行过程中出现异常时，JVM 按照异常机制处理。</li>
</ul>
</li>
</ul>
<hr>
<ol start="6">
<li>程序终止（Termination）</li>
</ol>
<ul>
<li>当 <code>main</code> 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。</li>
<li>在退出前，可能会执行 <code>finally</code> 块、<code>shutdown hook</code>（关闭钩子）。</li>
</ul>
<ol>
<li>程序生命</li>
</ol>
<p>$$<br>.java(源码) \underset{\text{decompile}}{\overset{\text{compile}}{\longleftrightarrow}} .class(字节码)\xrightarrow{\text{load}}class类\xrightarrow{\text{execution}}机器码\xrightarrow{\text{run}}结果<br>$$</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/Java%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/Java%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">Java八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:05:34" itemprop="dateModified" datetime="2025-12-03T17:05:34+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><h3 id="Java中有哪些创建线程的方式？"><a href="#Java中有哪些创建线程的方式？" class="headerlink" title="Java中有哪些创建线程的方式？"></a>Java中有哪些创建线程的方式？</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1️⃣ 继承 <code>Thread</code>类</strong></td>
<td align="left">自定义类继承 <code>Thread</code>，并重写 <code>run()</code>方法，然后调用 <code>start()</code>启动线程</td>
<td align="left">实现简单，直观易懂</td>
<td align="left">Java 是单继承，继承了 <code>Thread</code>后不能再继承其他类；耦合性高，不够灵活</td>
<td align="left">适用于简单的示例代码、初学者理解线程基本概念</td>
</tr>
<tr>
<td align="left"><strong>2️⃣ 实现 <code>Runnable</code>接口</strong></td>
<td align="left">自定义类实现 <code>Runnable</code>接口，实现 <code>run()</code>方法，将实例作为参数传给 <code>Thread</code>对象，再调用 <code>start()</code></td>
<td align="left">实现接口，不占用继承名额，更灵活；适合多个线程共享同一个 Runnable 实例；面向接口编程</td>
<td align="left">依然需要显式创建 Thread 对象，不能直接获取返回值</td>
<td align="left">适用于大多数异步任务、线程任务无返回值的场景，是主流推荐方式之一</td>
</tr>
<tr>
<td align="left"><strong>3️⃣ 实现 <code>Callable&lt;V&gt;</code>接口 + 线程池&#x2F;Future</strong></td>
<td align="left">实现 <code>Callable&lt;V&gt;</code>接口，重写 <code>call()</code>方法（有返回值，可抛异常），通过 <code>ExecutorService.submit(Callable)</code>提交，返回 <code>Future&lt;V&gt;</code>对象获取结果</td>
<td align="left">可以<strong>返回执行结果</strong>，支持抛出异常，功能更强大</td>
<td align="left">使用稍复杂，需要依赖线程池和 Future 机制</td>
<td align="left">适用于需要获取线程执行结果、处理异常、并发计算等复杂任务</td>
</tr>
<tr>
<td align="left"><strong>4️⃣ 使用线程池（Executor 框架）</strong></td>
<td align="left">通过 <code>Executors</code>或 <code>ThreadPoolExecutor</code>创建线程池，提交 <code>Runnable</code>或 <code>Callable</code>任务，由线程池管理线程的创建与调度</td>
<td align="left">线程复用，避免频繁创建&#x2F;销毁线程的开销；统一管理线程生命周期；提高性能与资源利用率</td>
<td align="left">需要对线程池有一定了解，使用不当可能引发资源耗尽等问题</td>
<td align="left">生产环境、高并发、需要高效管理线程的场景，是业界最佳实践</td>
</tr>
</tbody></table>
<ol>
<li><p>继承 <code>Thread</code>类</p>
<ol>
<li><p>继承Thread类并重写run方法</p>
</li>
<li><pre><code class="language-java">class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println(&quot;线程运行中（继承Thread类）：&quot; + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程，调用run()
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 实现 `Runnable`接口</span><br><span class="line"></span><br><span class="line">   1. 重写（实现）run方法</span><br><span class="line"></span><br><span class="line">   2. ```java</span><br><span class="line">      class MyRunnable implements Runnable &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              System.out.println(&quot;线程运行中（实现Runnable接口）：&quot; + Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              Thread thread = new Thread(new MyRunnable());</span><br><span class="line">              thread.start();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>基于runnable的lambda表达式</p>
<ol>
<li><pre><code class="language-java">new Thread(() -&gt; {
    System.out.println(&quot;线程运行中（Lambda表达式）：&quot; + Thread.currentThread().getName());
}).start();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">3. 实现 `Callable&lt;V&gt;`接口 + `FutureTask`</span><br><span class="line"></span><br><span class="line">   1. 类似 Runnable，但可以**有返回值**，能抛异常</span><br><span class="line"></span><br><span class="line">   2. ```JAVA</span><br><span class="line">      import java.util.concurrent.*;</span><br><span class="line">      </span><br><span class="line">      class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public String call() throws Exception &#123;</span><br><span class="line">              return &quot;线程返回值（实现Callable接口）：&quot; + Thread.currentThread().getName();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public class Main &#123;</span><br><span class="line">          public static void main(String[] args) throws Exception &#123;</span><br><span class="line">              // 创建线程池</span><br><span class="line">              ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">      </span><br><span class="line">              // 提交 Callable 任务，返回 Future</span><br><span class="line">              Future&lt;String&gt; future = executor.submit(new MyCallable());</span><br><span class="line">      </span><br><span class="line">              // 获取返回值（会阻塞直到任务完成）</span><br><span class="line">              String result = future.get();</span><br><span class="line">              System.out.println(result);</span><br><span class="line">      </span><br><span class="line">              // 关闭线程池</span><br><span class="line">              executor.shutdown();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用线程池（Executor 框架）</p>
<ol>
<li><p>通过线程池（如 <code>Executors</code>）管理线程的创建和执行</p>
</li>
<li><pre><code class="language-java">import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建 ThreadPoolExecutor
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,                      // 核心线程数（corePoolSize）
            4,                      // 最大线程数（maximumPoolSize）
            60,                     // 空闲线程存活时间
            TimeUnit.SECONDS,       // 时间单位
            new LinkedBlockingQueue&lt;&gt;(2),  // 任务队列（容量为2）
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：直接抛出异常
        );

        // 提交 8 个任务，观察线程池行为
        for (int i = 1; i &lt;= 8; i++) {
            final int taskId = i;
            executor.execute(() -&gt; {
                System.out.println(&quot;正在执行任务 &quot; + taskId + &quot;，线程：&quot; + Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // 模拟任务执行
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;任务 &quot; + taskId + &quot; 执行完毕&quot;);
            });
        }

        // 关闭线程池（不再接受新任务，等待已提交任务完成）
        executor.shutdown();
        System.out.println(&quot;所有任务已提交，线程池准备关闭...&quot;);
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 为什么不建议使用Excutors创建线程池？</span><br><span class="line"></span><br><span class="line">1. `Executors`是 Java 并发包 `java.util.concurrent`中的一个**工具类**，提供了几个静态工厂方法，用于**快速创建常见类型的线程池**。</span><br><span class="line">2. 不建议直接使用 `Executors`工具类提供的快捷方法（如 `newFixedThreadPool`、`newCachedThreadPool`等）来创建线程池，是因为这些方法在某些场景下可能导致资源耗尽、线程爆炸、任务堆积、内存溢出（OOM）等严重问题，存在潜在风险。</span><br><span class="line">   1. 原因：</span><br><span class="line">      1. 底层其实都是调用了 `ThreadPoolExecutor`或 `ScheduledThreadPoolExecutor`，但是对参数进行了**封装和默认设置**</span><br><span class="line">      2. 使用的是**无界队列** `LinkedBlockingQueue`，队列容量为 Integer.MAX_VALUE（约 2^31-1，非常大）</span><br><span class="line">      3. 如果任务提交速度 &gt; 线程处理速度，任务会不断堆积在队列中</span><br><span class="line">      4. 最终可能导致 **内存耗尽（OOM，OutOfMemoryError）**，因为任务对象、数据不断累积，队列无限增长</span><br><span class="line">3. 推荐使用 `ThreadPoolExecutor`手动构造线程池，以精确控制线程池行为，提高稳定性和可控性。</span><br><span class="line"></span><br><span class="line">### 线程池有哪几种状态？</span><br><span class="line"></span><br><span class="line">5种。</span><br><span class="line"></span><br><span class="line">| 状态名         | 值（高 3 位）                          | 含义                     | 说明                                                         |</span><br><span class="line">| :------------- | :------------------------------------- | :----------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **RUNNING**    | 111 （二进制） 即 -536870912（十进制） | **运行中**               | **接受新任务，并处理队列中的任务**                           |</span><br><span class="line">| **SHUTDOWN**   | 000 （二进制） 即 0（十进制）          | **关闭（不接受新任务）** | **不再接受新任务，但会继续处理队列中的任务**                 |</span><br><span class="line">| **STOP**       | 001 （二进制） 即 1（十进制）          | **停止**                 | **不再接受新任务，也不处理队列中的任务，并中断正在执行的任务** |</span><br><span class="line">| **TIDYING**    | 010 （二进制） 即 2（十进制）          | **整理中**               | **所有任务都已终止，workerCount = 0，线程池即将执行 terminated() 钩子方法** |</span><br><span class="line">| **TERMINATED** | 011 （二进制） 即 3（十进制）          | **已终止**               | **terminated() 方法已经执行完毕，线程池完全停止**            |</span><br><span class="line"></span><br><span class="line">### ThreadLocal</span><br><span class="line"></span><br><span class="line">详见笔记《ThreadLocal》</span><br><span class="line"></span><br><span class="line">### Tomcat为什么要用自定义类加载器？</span><br><span class="line"></span><br><span class="line">1. 在Tomcat中可能存在同名类。为了避免冲突和隔离资源，应该使用自定义类加载器。</span><br><span class="line"></span><br><span class="line">2. **Tomcat 是一个 Servlet 容器**，它负责运行多个独立的 Web 应用。每个 Web 应用可能有自己依赖的库，甚至可能用到相同库的不同版本。为了实现：</span><br><span class="line"></span><br><span class="line">   - **应用间类隔离**</span><br><span class="line">   - **核心库与用户库的区分加载**</span><br><span class="line">   - **支持热部署和灵活管理**</span><br><span class="line"></span><br><span class="line">   Tomcat **不得不打破双亲委派模型**。</span><br><span class="line"></span><br><span class="line">3. Tomcat 的类加载器架构（简化版）</span><br><span class="line"></span><br><span class="line">   1. Tomcat 设计了多种类加载器，典型的类加载器层次结构如下（从上到下）：</span><br><span class="line">      1. Bootstrap ClassLoader（JVM 提供，加载核心 Java 类，如 `java.*`）</span><br><span class="line">      2. Extension ClassLoader（加载扩展库，如 `javax.*`或 `$JAVA_HOME/lib/ext`下的类）</span><br><span class="line">      3. Application ClassLoader（即系统类加载器，加载 `classpath`下的类，通常是你的工程依赖）</span><br><span class="line">      4. **Common ClassLoader**（Tomcat 提供，加载 `CATALINA_HOME/lib`下的类，如 `servlet-api.jar`，这些是所有 Web 应用共享的）</span><br><span class="line">      5. **Webapp ClassLoader**（每个 Web 应用独有，加载该应用 `WEB-INF/classes`和 `WEB-INF/lib`下的类）</span><br><span class="line"></span><br><span class="line">4. Tomcat 如何打破双亲委派？</span><br><span class="line"></span><br><span class="line">   1. 关键点在于 **WebappClassLoader（Web 应用类加载器）** 的加载行为</span><br><span class="line"></span><br><span class="line">      1. 默认情况下（即标准双亲委派）：</span><br><span class="line"></span><br><span class="line">      - 当加载一个类时，类加载器会先委派给父加载器去加载，只有在父加载器找不到时，自己才尝试加载。</span><br><span class="line"></span><br><span class="line">   2. 但 Tomcat 的 WebappClassLoader **刻意颠倒了这一逻辑（部分打破双亲委派）**：对于 **Web 应用私有的类（如 WEB-INF 下的类）**，**WebappClassLoader 会优先尝试自己加载，而不是先委派给父加载器！*</span><br><span class="line"></span><br><span class="line">      1. 换句话说：</span><br><span class="line"></span><br><span class="line">      - 当 Web 应用需要加载一个类时，Tomcat 的 WebappClassLoader 会首先从当前应用的 `WEB-INF/classes`和 `WEB-INF/lib`中查找并加载类；</span><br><span class="line"></span><br><span class="line">      - 只有当找不到时，才会委派给父类加载器（如 CommonClassLoader 或更上层）去加载；</span><br><span class="line"></span><br><span class="line">5. 意义：</span><br><span class="line"></span><br><span class="line">   1. 不同 Web 应用可以拥有相同类库的不同版本，因为它们各自用自己的 WebappClassLoader 加载，互不干扰；</span><br><span class="line">   2. 核心类（如 Servlet API）仍然由 CommonClassLoader 或更上层加载，保证一致性；</span><br><span class="line">   3. **实现了类隔离与应用独立性**；</span><br><span class="line"></span><br><span class="line">6. 但 Tomcat 并没有完全抛弃双亲委派！</span><br><span class="line"></span><br><span class="line">   1. 对于一些 关键的、应该由全局统一管理的类（如 Servlet API、JSP 相关类等），Tomcat 仍然希望它们由公共的类加载器（如 CommonClassLoader）加载，而不是由每个 Web 应用自己的加载器加载，以避免混乱和冲突。</span><br><span class="line">   2. 因此，Tomcat 在实现 WebappClassLoader 时，对于 一些指定的包名（如 `javax.\*`, `org.apache.tomcat.\*`, `java.\*`等），仍然会优先走双亲委派，确保这些类由上层加载器加载，而不是由 Web 应用私自提供。</span><br><span class="line"></span><br><span class="line">### hashCode（）和 equals（）的联系</span><br><span class="line"></span><br><span class="line">1. 如果两个对象通过 `equals()`方法比较是相等的，那么它们的 `hashCode()`**必须相同**！</span><br><span class="line">2. 如果两个对象的 `hashCode()`相同，它们 **不一定** `equals()`为 true！</span><br><span class="line">   1. 这被称为 **哈希碰撞（Hash Collision）**，即不同的对象可能计算出相同的哈希值。这是 **允许的，并且很常见**，好的 hashCode 方法应尽量减少碰撞，但不能完全避免。</span><br><span class="line">3. 一定要同时重写 hashCode() 和 equals()</span><br><span class="line"></span><br><span class="line">### String，StringBuffer，StringBuilder</span><br><span class="line"></span><br><span class="line">1. String是常量，不可变</span><br><span class="line">2. StringBuilder可变，线程不安全。</span><br><span class="line">3. StringBuffer可变，线程安全（有synchronized修饰）</span><br><span class="line"></span><br><span class="line">### &quot;==&quot;和equals()的区别</span><br><span class="line"></span><br><span class="line">1. ==：如果比较的是基础数据类型，则比较值；如果是引用类型，则比较引用地址</span><br><span class="line">2. equals（）有比较逻辑</span><br><span class="line"></span><br><span class="line">### 重载和重写的区别（细节）</span><br><span class="line"></span><br><span class="line">1. 重载：发生在同一个类中，**方法名必须相同，必须要求参数列表不同**，如类型、个数、顺序不同。与返回值类型、访问修饰符、抛出的异常等无关。发生在编译时。</span><br><span class="line">2. 重写：发生在父子类中，方法名、参数列表必须相同。返回值、抛出异常的范围不大于父类，访问修饰符范围不小于父类（所以父类的private方法不可重写）。发生在运行时。</span><br><span class="line"></span><br><span class="line">### List和Set的区别</span><br><span class="line"></span><br><span class="line">1. ## </span><br><span class="line"></span><br><span class="line">2. | 区别维度             | **List（列表）**                                             | **Set（集合）**                                              |</span><br><span class="line">   | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">   | **是否允许重复元素** | **允许重复**                                                 | **不允许重复**（如果试图添加已存在的元素，添加失败，返回 false） |</span><br><span class="line">   | **是否有序**         | **有序**（按照元素的插入顺序保存，遍历时按插入顺序输出）     | **默认无序**（不保证顺序，但某些实现如 `LinkedHashSet`和 `TreeSet`有特定顺序） |</span><br><span class="line">   | **访问方式**         | 允许下标访问和迭代器遍历。                                   | 不允许下表访问，可以用迭代器访问。                           |</span><br><span class="line">   | **底层常用实现类**   | `ArrayList`、`LinkedList`、`Vector`                          | `HashSet`、`LinkedHashSet`、`TreeSet`                        |</span><br><span class="line">   | **主要用途**         | 适合存储 **有序的、可能重复的数据列表**，比如用户列表、商品列表等 | 适合存储 **唯一值的集合**，比如标签、黑名单、不重复的用户 ID 等 |</span><br><span class="line">   | **接口继承自**       | `Collection`                                                 | `Collection`                                                 |</span><br><span class="line">   | **元素排序**         | 按插入顺序                                                   | 默认无序，但： • `TreeSet`：**自然排序 或 自定义排序** • `LinkedHashSet`：**按插入顺序** |</span><br><span class="line"></span><br><span class="line">### HashMap 是线程安全的吗？不是的话，多线程操作会导致什么问题？</span><br><span class="line"></span><br><span class="line">- （1.7 的死循环问题了解吗？1.8 数据覆盖问题了解吗？）</span><br><span class="line"></span><br><span class="line">1. **JDK 1.7 中 HashMap 的并发问题（经典死循环问题！）**</span><br><span class="line"></span><br><span class="line">   1. 问题背景：</span><br><span class="line"></span><br><span class="line">   在 JDK 1.7 的 HashMap 中，多线程并发执行 put 操作，并且触发了扩容（rehash），可能会导致链表形成环形结构（环形链表），进而导致后续 get() 操作时 CPU 100%、死循环！</span><br><span class="line"></span><br><span class="line">   2. 问题原因（核心）：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容机制是：创建新数组，然后对原数组每个桶上的 Entry 链表进行头插法迁移</span><br><span class="line"></span><br><span class="line">      - 头插法：新节点插入链表头部</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，多个线程同时对同一个链表进行头插，可能导致链表节点互相引用，形成环</span><br><span class="line"></span><br><span class="line">   3. 举例说明（简化版）：</span><br><span class="line"></span><br><span class="line">      1. 假设线程 A 和线程 B 同时触发扩容，都操作同一个链表：</span><br><span class="line"></span><br><span class="line">         - 原链表：A → B → C</span><br><span class="line"></span><br><span class="line">         - 线程 A 执行了一半，链表变成了 B → A</span><br><span class="line"></span><br><span class="line">         - 线程 B 也执行，可能把链表改成了 C → B → A → C → …（形成环）</span><br><span class="line"></span><br><span class="line">         - 当你后续调用 `get(key)`，遍历这个链表时，就会 陷入死循环，CPU 飙升！</span><br><span class="line"></span><br><span class="line">   4. 根本原因：</span><br><span class="line"></span><br><span class="line">      - JDK 1.7 的扩容是头插法 + 单线程逐个迁移 + 没有同步机制</span><br><span class="line"></span><br><span class="line">      - 多线程并发扩容时，链表可能倒置、成环，造成死循环</span><br><span class="line"></span><br><span class="line">   &gt; **这是 JDK 1.7 HashMap 最著名、最严重的并发 Bug 之一，在生产环境中出现过多次事故！**</span><br><span class="line"></span><br><span class="line">2. **JDK 1.8 中 HashMap 的并发问题**</span><br><span class="line"></span><br><span class="line">   1. JDK 1.8 对 HashMap 做了重大优化，包括：</span><br><span class="line"></span><br><span class="line">      1. 改用 尾插法（解决了 1.7 头插法导致的链表倒置与死循环问题）</span><br><span class="line">      2. 引入 红黑树（优化查询效率）</span><br><span class="line">      3. 优化了 hash 计算与扩容机制</span><br><span class="line"></span><br><span class="line">      - 但！**JDK 1.8 的 HashMap 仍然是线程不安全的！**</span><br><span class="line"></span><br><span class="line">   2. 在多线程环境下，JDK 1.8 的 HashMap 可能出现以下问题：</span><br><span class="line"></span><br><span class="line">      1. **数据覆盖（Lost Update）**</span><br><span class="line"></span><br><span class="line">         - 多个线程同时 put 同一个 key，后写入的线程可能覆盖先写入的线程的值</span><br><span class="line"></span><br><span class="line">         - 因为 put 操作没有加锁，没有原子性保证</span><br><span class="line"></span><br><span class="line">      2. **数据丢失**</span><br><span class="line">         - 多线程同时执行 put，某些线程的 put 可能因为并发问题没有成功写入</span><br><span class="line"></span><br><span class="line">      3. **扩容时的数据错乱**</span><br><span class="line"></span><br><span class="line">         - 虽然 1.8 改用 尾插法，不再容易形成环形链表，但多线程并发扩容时，仍然可能导致链表或树结构混乱，数据错乱或丢失</span><br><span class="line"></span><br><span class="line">         - 比如多个线程同时迁移数据，可能没有正确链接节点</span><br><span class="line"></span><br><span class="line">      4. **仍然是非原子操作**</span><br><span class="line">         - 比如 **putIfAbsent、computeIfAbsent** 等复合逻辑，在多线程下也可能有问题，除非使用 ConcurrentHashMap 提供的对应原子方法</span><br><span class="line"></span><br><span class="line">### hashMap的扩容机制</span><br><span class="line"></span><br><span class="line">详见下面的ConcurrentHashMap的扩容机制。只不过线程不安全且不能多线程扩容。</span><br><span class="line"></span><br><span class="line">### 谈谈ConcurrentHashMap的扩容机制</span><br><span class="line"></span><br><span class="line">1. 为什么要扩容</span><br><span class="line"></span><br><span class="line">   1. 和 `HashMap`一样，`ConcurrentHashMap`也是基于 **哈希表（数组 + 链表/红黑树）** 实现的。</span><br><span class="line"></span><br><span class="line">      随着不断向 `ConcurrentHashMap`中 添加元素（put），哈希冲突可能增多，当某个桶（bucket）中的元素越来越多时：</span><br><span class="line"></span><br><span class="line">      - 如果是链表形式，查询效率会从 O(1) 退化为 O(n)；</span><br><span class="line">      - 如果链表长度超过阈值（默认为 8），并且数组长度达到一定大小，链表会转为 红黑树（O(log n)）；</span><br><span class="line">      - 但即便有了红黑树，如果 整个哈希表中的数据量很大，而底层数组（table）容量较小，依然会导致 哈希冲突严重，性能下降。</span><br><span class="line"></span><br><span class="line">      👉 因此，为了保证查询、插入的高效性，当元素数量达到一定阈值时，ConcurrentHashMap 会进行扩容（resize），即扩大底层数组的大小，重新分配元素，降低哈希冲突。</span><br><span class="line"></span><br><span class="line">2. 以Java 8为主，讲解扩容机制</span><br><span class="line"></span><br><span class="line">   1. 扩容触发条件</span><br><span class="line"></span><br><span class="line">      1. 当 **元素的总数量（默认16）超过 负载因子（默认 0.75） × 当前容量（capacity）** 时，即：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
size &gt;= capacity * loadFactor（默认 0.75）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      也就是说，当 哈希表中的元素数量“过密”时，就会触发扩容。</span><br><span class="line"></span><br><span class="line">      2. **链表长度超过阈值（8），但数组长度较小（&lt; 64）时，也可能先触发扩容而非树化**</span><br><span class="line">         1. 链表转红黑树之前，可能先触发扩容</span><br><span class="line"></span><br><span class="line">   2. 扩容目标</span><br><span class="line"></span><br><span class="line">      - 扩容就是将 原数组（table）的容量扩大为原来的 2 倍（即 newCapacity = oldCapacity &lt;&lt; 1）。</span><br><span class="line">      - 扩容过程中，需要将旧数组中的每个 桶（bucket）中的元素，重新计算在新数组中的位置，并迁移到新数组中。</span><br><span class="line"></span><br><span class="line">   3. 扩容的核心思想：**多线程协同扩容（协助迁移）**</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容机制中一个非常 **厉害且高效的设计** 👇：</span><br><span class="line"></span><br><span class="line">      &gt; **扩容不再由某一个线程全权负责，而是支持多个线程并发地协助进行数据迁移，大大提升了扩容效率，避免了单线程扩容成为瓶颈。**</span><br><span class="line"></span><br><span class="line">      - **table**：当前正在使用的哈希桶数组。</span><br><span class="line">      - **nextTable**：扩容时创建的新数组，大小是原数组的两倍。</span><br><span class="line">      - **transferIndex**：表示当前迁移进度，从高位（数组末尾）开始，逐步向低位（数组开头）迁移。</span><br><span class="line">      - **sizeCtl**：控制标识符，用于表示当前容器的状态，比如是否正在初始化、是否正在扩容等。当 `sizeCtl &lt; 0`时，可能表示正在初始化或扩容。扩容时，它还用于控制并发扩容的线程数等。</span><br><span class="line"></span><br><span class="line">   4. 扩容大致流程（简化版）</span><br><span class="line"></span><br><span class="line">      1. **检测是否需要扩容**：当插入新元素后，总元素数超过 `capacity * loadFactor`，或者某个桶太满时，触发扩容检查。</span><br><span class="line">      2. **初始化 nextTable（新数组）**：创建一个新的数组，容量是原数组的 **2 倍**。</span><br><span class="line">      3. **多线程协同迁移（transfer）**：将原数组（table）中的每个 bucket 上的节点，**重新计算在新数组（nextTable）中的位置，并迁移过去**。每个线程会负责迁移一部分 bucket，通过 `transferIndex`控制迁移区间，避免冲突。每个 bucket 的迁移是通过 **锁住当前桶（synchronized 锁住链表头/树根节点）** 来进行的，保证线程安全。</span><br><span class="line">      4. **迁移完成后切换引用**：当所有 bucket 都迁移完成后，将 `table`指向 `nextTable`，`nextTable`成为新的主表，完成扩容。</span><br><span class="line"></span><br><span class="line">   5. 为什么能支持多线程协助扩容？</span><br><span class="line"></span><br><span class="line">      这是 Java 8 `ConcurrentHashMap`扩容最牛的地方之一 ✨：</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，如果某个线程 put 时发现正在扩容，**它不会等待，而是主动参与迁移工作（协助扩容）**。</span><br><span class="line">      - 每个线程会分配到一部分 bucket 去迁移，通过 CAS 和 `transferIndex`控制各自负责的范围，避免重复和冲突。</span><br><span class="line">      - 这种 **“众人拾柴火焰高”** 的设计，极大地提升了大容量情况下的扩容速度，充分利用了多核 CPU 的能力。</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">   6. 扩容期间访问怎么办？</span><br><span class="line"></span><br><span class="line">      - 在扩容过程中，**读操作（get）可以正常进行**，即使数据正在迁移。</span><br><span class="line">      - 如果读线程访问的 bucket **尚未迁移**，则从旧数组 table 中读取；</span><br><span class="line">      - 如果 **已经迁移**，则从新数组 nextTable 中读取；</span><br><span class="line">      - 写操作（put/remove）如果发现正在扩容，也可能 **协助迁移或等待迁移完成后再操作**。</span><br><span class="line"></span><br><span class="line">3. Java7是怎么实现的呢</span><br><span class="line"></span><br><span class="line">   1. 分段锁（Segment 继承 ReentrantLock）</span><br><span class="line">   2. 数据结构：</span><br><span class="line">      - ConcurrentHashMap 由多个 Segment 组成（默认是 16 个）</span><br><span class="line">      - 每个 Segment 继承自 ReentrantLock，是一个小的 HashMap（数组 + 链表）</span><br><span class="line">      - 每个 Segment 内部维护了一个 HashEntry&lt;K,V&gt;[] table</span><br><span class="line">   3.  线程安全如何保证？</span><br><span class="line">      - 对某个 Segment 的操作（如 put、get），只需要锁住该 Segment</span><br><span class="line">      - 不同 Segment 之间的操作是 并发安全且互不阻塞 的</span><br><span class="line">   4. 优点：</span><br><span class="line">      - 相比 Hashtable 的全表锁，并发度更高（默认支持 16 个线程并发写）</span><br><span class="line">      - 细化锁粒度，提升吞吐量</span><br><span class="line">   5. 缺点：</span><br><span class="line">      - 结构复杂：外层是 Segment 数组，内层是 HashEntry 数组</span><br><span class="line">      - 锁的粒度仍然较粗（一个 Segment 内还是锁整个桶）</span><br><span class="line">      - 不支持链表转红黑树，链表过长时性能下降明显</span><br><span class="line">      - 代码可维护性较差</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 深拷贝和浅拷贝</span><br><span class="line"></span><br><span class="line">1. 浅拷贝会复制基本数据类型，但是对于引用对象只会复制一个地址。即，引用对象还是指向同一个。</span><br><span class="line">2. 深拷贝既会复制基本数据类型，也会复制引用对象。即，引用对象不是同一个。</span><br><span class="line"></span><br><span class="line">### 引用类型</span><br><span class="line"></span><br><span class="line">Java 主要提供了 **4 种引用类型**，按强度从强到弱依次为：</span><br><span class="line"></span><br><span class="line">1. **强引用（Strong Reference）** —— 默认的引用类型</span><br><span class="line">   1. 强引用是 Java 中最常见、默认的引用类型。只要强引用存在，对象就绝对不会被垃圾回收器回收。</span><br><span class="line">2. **软引用（Soft Reference）**</span><br><span class="line">   1. 软引用是一种比强引用弱、但比弱引用强的引用类型。如果一个对象只被软引用指向，在内存不足时，它才会被垃圾回收。</span><br><span class="line">3. **弱引用（Weak Reference）**</span><br><span class="line">   1. 弱引用比软引用更弱。只要发生垃圾回收，无论内存是否充足，只要对象只被弱引用指向，它就会被回收。</span><br><span class="line">4. **虚引用（Phantom Reference）**</span><br><span class="line">   1. get() 方法永远返回 null！</span><br><span class="line">   2. 无法通过虚引用来获取对象</span><br><span class="line">   3. 虚引用唯一的作用，是通过 ReferenceQueue 监听对象是否已被回收</span><br><span class="line"></span><br><span class="line">### Java中的异常体系</span><br><span class="line"></span><br><span class="line">详见笔记《异常处理》</span><br><span class="line"></span><br><span class="line">### 什么时候应该抛出异常，什么时候捕获异常</span><br><span class="line"></span><br><span class="line">1. **抛出异常（throw / throws）：** 是 **发现问题、抛出问题**，通常由 **底层方法、工具类、数据校验模块** 完成，表示 “这里可能出错了，我处理不了，交给调用者决定”。</span><br><span class="line">2. **捕获异常（try-catch）：** 是 **处理问题、解决问题**，通常由 **调用方、业务逻辑层、UI 层、控制器层** 完成，表示 “我知道这里可能出错，我来处理”。</span><br><span class="line"></span><br><span class="line">### JVM中那些是线程共享区</span><br><span class="line"></span><br><span class="line">| 区域                                       | 是否线程共享   | 说明                                                         |</span><br><span class="line">| :----------------------------------------- | :------------- | :----------------------------------------------------------- |</span><br><span class="line">| **堆（Heap）**                             | ✅ **线程共享** | 所有对象实例和数组都在这里分配，是 GC 主要管理的区域         |</span><br><span class="line">| **方法区（Method Area）**                  | ✅ **线程共享** | 存储已被虚拟机加载的 **类信息、常量、静态变量、即时编译器编译后的代码等** |</span><br><span class="line">| **Java 虚拟机栈（JVM Stack）**             | ❌ **线程私有** | 每个线程私有，存储 **栈帧（局部变量表、操作数栈、动态链接、方法出口等）** |</span><br><span class="line">| **本地方法栈（Native Method Stack）**      | ❌ **线程私有** | 为 JVM 调用的 **Native 方法服务**                            |</span><br><span class="line">| **程序计数器（Program Counter Register）** | ❌ **线程私有** | 当前线程执行的字节码行号指示器（线程切换时能恢复执行位置）   |</span><br><span class="line"></span><br><span class="line">### 如何排查JVM的问题？（待学习）</span><br><span class="line"></span><br><span class="line">- 我会去问LLM</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- | 步骤 | 操作                 | 工具/命令                                        | 目的                             |</span><br><span class="line">  | :--- | :------------------- | :----------------------------------------------- | :------------------------------- |</span><br><span class="line">  | 1    | 查看 OOM 错误日志    | 控制台 / 日志文件                                | 确定 OOM 类型（堆、元空间等）    |</span><br><span class="line">  | 2    | 生成 Heap Dump       | `jmap -dump`或 `-XX:+HeapDumpOnOutOfMemoryError` | 获取堆内存快照                   |</span><br><span class="line">  | 3    | 分析 Heap Dump       | Eclipse MAT / VisualVM                           | 找到大对象、内存泄漏、对象引用链 |</span><br><span class="line">  | 4    | 查看线程状态（可选） | `jstack &lt;pid&gt;`                                   | 分析线程死锁、线程数过多等问题   |</span><br><span class="line">  | 5    | 定位代码问题         | 结合 dump 分析 + 业务代码                        | 修复内存泄漏、优化对象使用       |</span><br><span class="line"></span><br><span class="line">1. 一般而言，排查问题可以从以下方面入手</span><br><span class="line">   1. 对于还在运行的系统，通过jmap, jstack, jstat等工具查看系统信息。</span><br><span class="line">   2. 对于已经发生OOM的系统，可以去看日志</span><br><span class="line">2. 常见类型：</span><br><span class="line">   1. 内存溢出，CPU使用率过高，线程问题，GC问题</span><br><span class="line"></span><br><span class="line">3. OOM怎么解决</span><br><span class="line"></span><br><span class="line">### 一个对象从加载到JVM，再到被GC处理，经历了什么？</span><br><span class="line"></span><br><span class="line">1. 类加载：把字节码（.class）加载到方法区</span><br><span class="line">2. 创建对象：在堆中分配内存</span><br><span class="line">3. 在堆中E区、S区、O区流转</span><br><span class="line">4. 被GC清理</span><br><span class="line"></span><br><span class="line">### 怎么确定一个对象是不是垃圾？</span><br><span class="line"></span><br><span class="line">1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。</span><br><span class="line">2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。</span><br><span class="line">   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。</span><br><span class="line">   2. 有多个根对象，但是只会选用一个。</span><br><span class="line"></span><br><span class="line">### 有哪些GC算法</span><br><span class="line"></span><br><span class="line">1. **标记清除算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。</span><br><span class="line">      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 不需要移动对象，实现相对简单</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 内存碎片化严重</span><br><span class="line">      2. 效率问题</span><br><span class="line">2. **复制算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）</span><br><span class="line">      2. 每次只使用其中一块（如 From 区）来分配对象</span><br><span class="line">      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）</span><br><span class="line">      4. 交换角色：原来的 To 区成为新的 From 区，继续使用</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！</span><br><span class="line">      2. 分配效率高</span><br><span class="line">      3. 适合对象存活率低的场景</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 浪费了一半的内存空间</span><br><span class="line">      2. 不适合存活对象多的场景</span><br><span class="line">3. **标记压缩算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象</span><br><span class="line">      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）</span><br><span class="line">      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）</span><br><span class="line">      2. 内存利用率高，适合大对象和长期存活对象分配</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 移动对象成本高！</span><br><span class="line"></span><br><span class="line">### 什么是STW</span><br><span class="line"></span><br><span class="line">1. 全称Stop-The-World</span><br><span class="line">2. 在垃圾回收（GC）过程中，Java 虚拟机（JVM）为了保证垃圾回收的正确性，会暂停所有的应用线程（也就是用户线程 / 业务线程），只让垃圾回收线程运行。</span><br><span class="line"></span><br><span class="line">### 什么是反射</span><br><span class="line"></span><br><span class="line">- **反射（Reflection）** 是一种强大的机制，它允许程序在**运行时**（而不是编译时）获取类的信息，并且可以动态地操作类或对象的属性、方法和构造器等。</span><br><span class="line">-  反射使得程序可以在运行时“发现”和“操作”类，而不需要在编译期明确知道这些类的具体信息</span><br><span class="line"></span><br><span class="line">## 线程</span><br><span class="line"></span><br><span class="line">### 线程安全</span><br><span class="line"></span><br><span class="line">1. 线程安全（Thread Safety） 是指：当一个类、方法或代码块在多线程环境下被多个线程同时访问时，仍然能正确地工作，不会导致数据错误、逻辑混乱或程序崩溃，那么它就是线程安全的。</span><br><span class="line"></span><br><span class="line">2. 针对某一段代码，多线程同时执行时，不会造成混乱</span><br><span class="line"></span><br><span class="line">3. 举例：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class UnsafeCounter &#123;</span><br><span class="line">          private int count = 0;</span><br><span class="line">      </span><br><span class="line">          public void increment() &#123;</span><br><span class="line">              count++; // 实际上是 read -&gt; add -&gt; write，非原子！</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上面的代码，如果有两个线程执行，那么应该一个结果是1，一个结果是2。如果不是，就说明造成了混乱。</p>
</li>
</ol>
</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>守护线程（Daemon Thread） 是 Java 线程中的一种特殊线程，它的作用通常是 为其他线程（用户线程 &#x2F; 非守护线程）提供后台服务支持</p>
</li>
<li><p>守护线程和用户线程对比</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>守护线程（Daemon Thread）</strong></th>
<th align="left"><strong>用户线程（User Thread &#x2F; 非守护线程）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用</strong></td>
<td align="left">为其他线程提供<strong>后台服务</strong></td>
<td align="left">执行<strong>主要任务</strong>，是程序的核心逻辑</td>
</tr>
<tr>
<td align="left"><strong>JVM 是否会等待其结束</strong></td>
<td align="left"><strong>不会</strong>，只要用户线程结束，JVM 就会退出，不管守护线程是否还在运行</td>
<td align="left"><strong>会</strong>，JVM 会等待所有用户线程执行完毕才会退出</td>
</tr>
<tr>
<td align="left"><strong>默认情况</strong></td>
<td align="left">线程默认是<strong>用户线程</strong></td>
<td align="left">是</td>
</tr>
<tr>
<td align="left"><strong>如何设置</strong></td>
<td align="left">通过 <code>setDaemon(true)</code>设置</td>
<td align="left">不设置或设置为 false</td>
</tr>
<tr>
<td align="left"><strong>典型例子</strong></td>
<td align="left">垃圾回收线程、日志线程、监控线程</td>
<td align="left">主线程、业务逻辑线程、用户交互线程</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="并发、并行、串行"><a href="#并发、并行、串行" class="headerlink" title="并发、并行、串行"></a>并发、并行、串行</h3><ol>
<li>串行：一个一个执行</li>
<li>并行：物理世界，同时进行。比如一边跑步一遍听歌。</li>
<li>并发：两个任务轮流执行，但是轮转很快。比如CPU分时的处理两个请求</li>
</ol>
<h3 id="死锁如何解决"><a href="#死锁如何解决" class="headerlink" title="死锁如何解决"></a>死锁如何解决</h3><ol>
<li><p>产生的必要条件</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">说明</th>
<th align="left">是否必须</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 互斥条件（Mutual Exclusion）</strong></td>
<td align="left">某资源一次只能被一个线程占用（如锁、对象、文件等）</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>2. 占有并等待（Hold and Wait）</strong></td>
<td align="left">线程持有至少一个资源，并等待获取其他被占用的资源</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>3. 不可剥夺（No Preemption）</strong></td>
<td align="left">线程已获得的资源，在未使用完之前，<strong>不能被其他线程强行夺取</strong>，只能由自己释放</td>
<td align="left">✅ 必须</td>
</tr>
<tr>
<td align="left"><strong>4. 循环依赖（Circular Wait）</strong></td>
<td align="left">存在一个线程的循环等待链，比如 T1 等 T2 的资源，T2 等 T1 的资源，形成一个闭环</td>
<td align="left">✅ 必须</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>如何排查？</p>
<ol>
<li>用<code>jstack</code>到处堆内存快照，然后分析文件。jastack会为你分析出是否存在死锁。</li>
</ol>
</li>
<li><p>如何避免</p>
<ol>
<li>破坏循环依赖（推荐）—— 按固定顺序获取锁</li>
<li>破坏循环依赖占有并等待——使用超时机制（tryLock）</li>
<li>检测与恢复（高级 &#x2F; 系统级，预防措施）</li>
</ol>
</li>
</ol>
<h3 id="CountDownLatch和Semaphore的区别和底层实现"><a href="#CountDownLatch和Semaphore的区别和底层实现" class="headerlink" title="CountDownLatch和Semaphore的区别和底层实现"></a>CountDownLatch和Semaphore的区别和底层实现</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized的偏向锁，轻量级锁，重量级锁"><a href="#synchronized的偏向锁，轻量级锁，重量级锁" class="headerlink" title="synchronized的偏向锁，轻量级锁，重量级锁"></a>synchronized的偏向锁，轻量级锁，重量级锁</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>synchronized（内置锁）</strong></th>
<th align="left"><strong>ReentrantLock（可重入锁）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">Java 关键字（语法层面，JVM 实现）</td>
<td align="left">Java 类（<code>java.util.concurrent.locks.ReentrantLock</code>，API 层面）</td>
</tr>
<tr>
<td align="left"><strong>使用方式</strong></td>
<td align="left">直接修饰方法或代码块，语法简洁</td>
<td align="left">需要手动加锁 <code>lock()</code>和解锁 <code>unlock()</code>，通常配合 <code>try-finally</code>使用</td>
</tr>
<tr>
<td align="left"><strong>锁的获取与释放</strong></td>
<td align="left"><strong>自动加锁与释放</strong>（进入同步块加锁，退出时释放）</td>
<td align="left"><strong>手动加锁与释放</strong>，必须显式调用 <code>lock()</code>和 <code>unlock()</code>，推荐在 <code>finally</code>块中释放</td>
</tr>
<tr>
<td align="left"><strong>可重入性</strong></td>
<td align="left">✅ 支持（同一个线程可重复获取同一把锁）</td>
<td align="left">✅ 支持（同一个线程可多次获取锁，必须释放同样次数）</td>
</tr>
<tr>
<td align="left"><strong>公平性</strong></td>
<td align="left">❌ 非公平锁（不保证等待顺序）</td>
<td align="left">✅ <strong>可选择公平或非公平（构造方法传参）</strong></td>
</tr>
<tr>
<td align="left"><strong>是否可中断</strong></td>
<td align="left">❌ 不支持中断等待锁</td>
<td align="left">✅ 支持 <code>lockInterruptibly()</code>，可响应中断</td>
</tr>
<tr>
<td align="left"><strong>是否可设置超时</strong></td>
<td align="left">❌ 不支持尝试获取锁的超时机制</td>
<td align="left">✅ 支持 <code>tryLock(long time, TimeUnit unit)</code>，可以设置超时等待</td>
</tr>
<tr>
<td align="left"><strong>是否支持多个条件变量（Condition）</strong></td>
<td align="left">❌ 只有一个隐式的等待队列（通过 <code>wait/notify</code>）</td>
<td align="left">✅ 支持多个 <code>Condition</code>，可精细控制线程等待&#x2F;唤醒（如不同条件队列）</td>
</tr>
</tbody></table>
<h3 id="谈谈你对AQS的理解"><a href="#谈谈你对AQS的理解" class="headerlink" title="谈谈你对AQS的理解"></a>谈谈你对AQS的理解</h3><p>详见笔记《Java学习笔记》</p>
<h3 id="如何保证操作的原子性"><a href="#如何保证操作的原子性" class="headerlink" title="如何保证操作的原子性"></a>如何保证操作的原子性</h3><ol>
<li><p>使用AotmicXXX类</p>
<ol>
<li><pre><code class="language-java">// 使用 AtomicInteger 代替 int
private static AtomicInteger i = new AtomicInteger(0);

i.incrementAndGet()就是 // 原子版本的 i++
getAndIncrement() // 相当于 i++
addAndGet(1) // 加一个指定的值
get() // 获取当前值
set(int newValue) // 设置值
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 这是推荐做法，性能好，线程安全。</span><br><span class="line"></span><br><span class="line">2. `AtomicInteger`的核心实现依赖于：</span><br><span class="line"></span><br><span class="line">   - **CAS（Compare-And-Swap）**：一种硬件级别的原子操作</span><br><span class="line">   - 利用循环 + CAS 的方式实现 **无锁的线程安全操作（乐观锁）**</span><br><span class="line"></span><br><span class="line">3. CAS</span><br><span class="line">   1. CAS 是一种原子操作，它的功能是：比较某个内存位置的值与预期值，如果匹配，则将该内存位置的值更新为新值；如果不匹配，则不修改值。整个操作是原子的（不可中断），由 CPU 硬件保证。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Spring</span><br><span class="line"></span><br><span class="line">### 谈谈你对IOC的理解</span><br><span class="line"></span><br><span class="line">- IoC：控制反转</span><br><span class="line"></span><br><span class="line">1. 什么是控制？控制了什么？</span><br><span class="line"></span><br><span class="line">   1. 具体来说，控制了以下内容：</span><br><span class="line"></span><br><span class="line">      | 控制的内容         | 说明                                                        |</span><br><span class="line">      | :----------------- | :---------------------------------------------------------- |</span><br><span class="line">      | 对象的创建         | 谁负责 new 一个对象出来（比如 `new UserService()`）         |</span><br><span class="line">      | 依赖关系的组装     | 比如一个 Service 依赖一个 DAO，谁来把 DAO 注入到 Service 中 |</span><br><span class="line">      | 对象之间的耦合关系 | 对象之间如何关联、谁依赖谁、怎么管理这些依赖                |</span><br><span class="line">      | **对象的生命周期** | 比如对象什么时候创建、什么时候销毁、是否单例等              |</span><br><span class="line"></span><br><span class="line">      在传统编程中，这些控制都是由程序员在代码中显式完成的。</span><br><span class="line"></span><br><span class="line">2. 什么是反转？反转前是谁控制？反转后呢？如何控制的？</span><br><span class="line"></span><br><span class="line">   1. 反转前（传统方式）—— “正序控制” / “主动控制”</span><br><span class="line">      - 谁控制？ → 由程序员 / 开发者控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖关系的手动组装</span><br><span class="line">      - 如何实现的？ → 通过 new 关键字、手动赋值、层层构造</span><br><span class="line">   2. 反转后（IoC 方式）—— **“控制权反转给容器”**</span><br><span class="line">      - 谁控制？ → 由外部容器（比如 Spring IoC 容器）控制</span><br><span class="line">      - 控制什么？ → 对象的创建、依赖注入、生命周期管理</span><br><span class="line">      - 如何实现的？ → 通过依赖注入（DI）、配置文件 / 注解，让容器来管理对象和依赖关系</span><br><span class="line"></span><br><span class="line">3. 为什么要反转？有什么好处？</span><br><span class="line"></span><br><span class="line">   1. 控制反转（IoC）的主要目的是为了解耦、提高代码的灵活性、可测试性和可维护性。</span><br><span class="line"></span><br><span class="line">### IoC和DI怎么通过反射实现的？</span><br><span class="line"></span><br><span class="line">1. **扫描类路径，找到需要管理的 Bean（使用反射）**</span><br><span class="line"></span><br><span class="line">   Spring 启动时，会扫描你指定的包路径（比如 `com.example`），找出所有带有 `@Component`、`@Service`、`@RestController`等注解的类。</span><br><span class="line"></span><br><span class="line">   &gt; 这一步是通过 **反射机制** 去**读取类上的注解信息**，判断哪些类需要由 Spring 管理，变成一个个 Bean。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">2. **实例化 Bean（通过反射创建对象）**</span><br><span class="line"></span><br><span class="line">   对于每一个需要管理的类（比如 `UserService`和 `UserController`），Spring 会：</span><br><span class="line"></span><br><span class="line">   - 通过反射调用其构造器（通常是默认的无参构造器，或有参构造器），</span><br><span class="line">   - 动态地创建出一个对象实例，</span><br><span class="line"></span><br><span class="line">   比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>Class&lt;?&gt; clazz &#x3D; Class.forName(“com.example.UserService”);<br>Object userServiceObj &#x3D; clazz.getDeclaredConstructor().newInstance(); &#x2F;&#x2F; 反射创建对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 这一步就是用反射来代替你手动写 `new UserService()`。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">3. **依赖注入（通过反射实现 @Autowired 等注入）**</span><br><span class="line"></span><br><span class="line">   如果一个类中有依赖其它 Bean 的字段（比如 `@Autowired private UserService userService;`），Spring 会：</span><br><span class="line"></span><br><span class="line">   1. 找到这个字段，</span><br><span class="line">   2. 知道它需要注入一个 `UserService`类型的 Bean，</span><br><span class="line">   3. 从容器中找出已经创建好的 `UserService`对象，</span><br><span class="line">   4. **通过反射调用 `Field.set(对象, 值)`，把这个依赖注入到目标字段中。**</span><br><span class="line"></span><br><span class="line">   即使这个字段是 `private`的，Spring 也会通过 `field.setAccessible(true)`来绕过访问限制，然后进行赋值。</span><br><span class="line"></span><br><span class="line">   &gt; 这就是通过反射实现的 **依赖注入（DI）**，而依赖注入是 IoC 的一种实现方式。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">4. **管理 Bean 的生命周期、作用域等**</span><br><span class="line"></span><br><span class="line">   Spring 还会通过反射调用一些初始化方法（比如 `@PostConstruct`标记的方法）、销毁方法等，也是依赖反射来动态调用的。</span><br><span class="line"></span><br><span class="line">### 单例Bean和单例模式</span><br><span class="line"></span><br><span class="line">一定条件下，可以认为单利Bean是单例模式。</span><br><span class="line"></span><br><span class="line">1. 在单例模式下，一个类只能有一个对象。</span><br><span class="line">2. 但是单例Bean不一样。一个类可以有多个对象，但是通过同一个名字只能获得一个对象。</span><br><span class="line">3. 所以说，在Sping的范围内，如果只有一个Bean的话，我们可以认为单利Bean是单例模式</span><br><span class="line"></span><br><span class="line">### Spring事务传播机制</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事物传播就是指事务被调用时，还是不是事务，是嵌套事务还是合并事务等等</span><br><span class="line"></span><br><span class="line">### Spring事务什么时候会失效</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 跟AOP、事务管理器相关</span><br><span class="line"></span><br><span class="line">### Spring事务如何实现的</span><br><span class="line"></span><br><span class="line">详见《SSM学习笔记》</span><br><span class="line"></span><br><span class="line">- 事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的</span><br><span class="line">- 两种调用方式：声明式事务（@Transactional）或编程式事务（TransactionTemplate）</span><br><span class="line"></span><br><span class="line">### Bean是线程安全的吗</span><br><span class="line"></span><br><span class="line">1. Bean的本质还是类</span><br><span class="line">2. 如果Bean是无状态的，那就是线程安全的。否则反之。</span><br><span class="line"></span><br><span class="line">### Bean的生命周期</span><br><span class="line"></span><br><span class="line">1. **实例化**：Spring 创建对象（相当于 `new`）</span><br><span class="line">2. **属性赋值 / 依赖注入**：给 Bean 注入依赖（DI, Dependency Injection）</span><br><span class="line">3. **初始化**：执行初始化方法（`@PostConstruct` / `InitializingBean.afterPropertiesSet()`）</span><br><span class="line">4. **使用**：在应用中被调用</span><br><span class="line">5. **销毁**：应用关闭时销毁 Bean（`@PreDestroy` / `DisposableBean.destroy()`）</span><br><span class="line"></span><br><span class="line">### ApplicationContext和BeanFactory的区别</span><br><span class="line"></span><br><span class="line">| 概念                   | 一句话解释                                                   |</span><br><span class="line">| :--------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **BeanFactory**        | 是 Spring **最底层、最核心的 IoC 容器接口**，**负责管理 Bean 的创建与依赖注入，但功能相对基础，懒加载为主** |</span><br><span class="line">| **ApplicationContext** | 是 **BeanFactory 的高级扩展接口**，不仅具备 BeanFactory 的所有功能，还提供了 **更多企业级特性，比如国际化、事件机制、AOP 支持、自动装配等**，是 Spring 应用中最常用的容器 |</span><br><span class="line"></span><br><span class="line">### Spring容器的启动流程</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">SpringApplication.run()</span><br><span class="line">       ↓</span><br><span class="line">创建 ApplicationContext（如 AnnotationConfigApplicationContext）</span><br><span class="line">       ↓</span><br><span class="line">扫描 @ComponentScan 包路径，解析 @Component、@Service、@Configuration 等</span><br><span class="line">       ↓</span><br><span class="line">生成 BeanDefinition（Bean 的定义信息）</span><br><span class="line">       ↓</span><br><span class="line">将 BeanDefinition 注册到容器中（BeanDefinitionRegistry）</span><br><span class="line">       ↓</span><br><span class="line">根据 BeanDefinition 实例化 Bean（创建对象，比如通过反射调用构造方法）// 这里只有急加载的Bean会实例化</span><br><span class="line">       ↓</span><br><span class="line">进行依赖注入（DI，比如 @Autowired 字段注入）</span><br><span class="line">       ↓</span><br><span class="line">执行初始化回调（@PostConstruct、InitializingBean、init-method）</span><br><span class="line">       ↓</span><br><span class="line">发布 ContextRefreshedEvent 事件（容器初始化完成）</span><br><span class="line">       ↓</span><br><span class="line">✅ Spring 容器启动完成，应用可正常运行</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Spring用了哪些设计模式"><a href="#Spring用了哪些设计模式" class="headerlink" title="Spring用了哪些设计模式"></a>Spring用了哪些设计模式</h3><table>
<thead>
<tr>
<th align="left">设计模式</th>
<th align="left">应用场景</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工厂模式</strong></td>
<td align="left">BeanFactory &#x2F; ApplicationContext</td>
<td align="left">管理 Bean 的创建</td>
</tr>
<tr>
<td align="left"><strong>单例模式</strong></td>
<td align="left">默认的 Bean Scope</td>
<td align="left">一个 Bean 只有一个实例</td>
</tr>
<tr>
<td align="left"><strong>代理模式</strong></td>
<td align="left">Spring AOP</td>
<td align="left">实现方法拦截与增强</td>
</tr>
<tr>
<td align="left"><strong>模板方法模式</strong></td>
<td align="left">JdbcTemplate、RestTemplate</td>
<td align="left">封装固定流程</td>
</tr>
<tr>
<td align="left"><strong>观察者模式</strong></td>
<td align="left">ApplicationEvent &#x2F; Listener</td>
<td align="left">事件发布与订阅</td>
</tr>
<tr>
<td align="left"><strong>适配器模式</strong></td>
<td align="left">HandlerAdapter、AdvisorAdapter</td>
<td align="left">接口转换与兼容</td>
</tr>
<tr>
<td align="left"><strong>装饰器模式</strong></td>
<td align="left">BeanPostProcessor</td>
<td align="left">增强 Bean 功能</td>
</tr>
<tr>
<td align="left"><strong>策略模式</strong></td>
<td align="left">事务管理器、视图解析器</td>
<td align="left">多种实现动态选择</td>
</tr>
<tr>
<td align="left"><strong>责任链模式</strong></td>
<td align="left">过滤器链、拦截器链</td>
<td align="left">多个处理器依次处理请求</td>
</tr>
<tr>
<td align="left"><strong>原型模式</strong></td>
<td align="left">Bean Scope 为 prototype</td>
<td align="left">每次获取新实例</td>
</tr>
<tr>
<td align="left"><strong>组合模式</strong></td>
<td align="left">树形结构数据（非核心）</td>
<td align="left">组合对象与叶子对象统一处理</td>
</tr>
<tr>
<td align="left"><strong>外观模式</strong></td>
<td align="left">高级封装（如 JdbcTemplate）</td>
<td align="left">简化复杂 API</td>
</tr>
<tr>
<td align="left"><strong>建造者模式</strong></td>
<td align="left">SpringApplicationBuilder</td>
<td align="left">分步骤构建复杂对象</td>
</tr>
</tbody></table>
<h3 id="Spring常用的注解及其底层实现"><a href="#Spring常用的注解及其底层实现" class="headerlink" title="Spring常用的注解及其底层实现"></a>Spring常用的注解及其底层实现</h3><p>详见《SSM学习笔记》</p>
<h3 id="SpringBoot怎么启动Tomcat的"><a href="#SpringBoot怎么启动Tomcat的" class="headerlink" title="SpringBoot怎么启动Tomcat的"></a>SpringBoot怎么启动Tomcat的</h3><ol>
<li>先启动Spring容器</li>
<li>自动配置： @EnableAutoConfiguration（包含在 @SpringBootApplication 中）启用自动配置。它会根据你的 classpath 下的依赖（比如 tomcat-embed-core.jar），自动加载一系列自动配置类。生成一个启动Tomcat的Bean。</li>
<li>Spring容器创建完之后，启动Tomcat的Bean，创建对象，并绑定端口。</li>
</ol>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul>
<li><strong>MyBatis 是一个优秀的 Java 持久层框架，它简化了 JDBC 的操作，通过 XML 或注解的方式，将 Java 对象与 SQL 语句进行映射，让开发者可以更灵活、更高效地操作数据库，而不用过多关心底层的 JDBC 细节。</strong></li>
</ul>
<h3 id="Mybatis的优缺点"><a href="#Mybatis的优缺点" class="headerlink" title="Mybatis的优缺点"></a>Mybatis的优缺点</h3><h3 id="Mybatis中-和-的区别是什么？"><a href="#Mybatis中-和-的区别是什么？" class="headerlink" title="Mybatis中#{}和${}的区别是什么？"></a>Mybatis中#{}和${}的区别是什么？</h3><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="设计MySQL表时应该注意什么"><a href="#设计MySQL表时应该注意什么" class="headerlink" title="设计MySQL表时应该注意什么"></a>设计MySQL表时应该注意什么</h3><h4 id="遵循第三范式（3NF）"><a href="#遵循第三范式（3NF）" class="headerlink" title="遵循第三范式（3NF）"></a>遵循第三范式（3NF）</h4><ul>
<li><strong>第一范式（1NF）</strong>：字段不可再分，每列都是原子的。</li>
<li><strong>第二范式（2NF）</strong>：满足1NF，且非主键字段完全依赖于完整主键（针对联合主键的情况）。<ul>
<li>2NF 消除了<strong>部分函数依赖</strong>，即非主键字段不能只依赖主键的一部分。</li>
</ul>
</li>
<li><strong>第三范式（3NF）</strong>：满足2NF，且非主键字段不传递依赖于主键。<ul>
<li>消除了<strong>传递依赖</strong>，不能通过其他非主键字段间接依赖。</li>
</ul>
</li>
</ul>
<h4 id="设计字段"><a href="#设计字段" class="headerlink" title="设计字段"></a>设计字段</h4><ol>
<li>选择合适的数据类型<ul>
<li>尽量使用最小的满足需求的数据类型，以节省存储空间和提高性能。</li>
</ul>
</li>
<li>字段命名规范<ul>
<li>使用有意义的名称，采用下划线命名法，如 <code>user_name</code>、<code>created_at</code>。</li>
<li>避免使用 MySQL 的保留关键字，如 <code>order</code>、<code>group</code>等，若必须使用，需用反引号括起。</li>
<li>主键通常命名为 <code>id</code>，外键通常为 <code>xxx_id</code>。</li>
</ul>
</li>
</ol>
<h4 id="主键与索引设计"><a href="#主键与索引设计" class="headerlink" title="主键与索引设计"></a>主键与索引设计</h4><ol>
<li>主键设计<ul>
<li>每张表都应有一个主键，用于唯一标识一行。</li>
<li>推荐使用 <strong>自增整型（如 BIGINT AUTO_INCREMENT）</strong> 作为主键，简单高效，有利于索引组织。</li>
<li>如果使用业务字段作为主键（如手机号、身份证等），要确保其<strong>唯一、不变、简短</strong>。</li>
</ul>
</li>
<li>索引设计<ul>
<li><strong>索引不是越多越好</strong>，每个索引都会占用空间并影响写入性能。</li>
<li>为<strong>经常用于 WHERE、JOIN、ORDER BY、GROUP BY 的字段建立索引</strong>。</li>
<li>合理使用 <strong>复合索引（联合索引）</strong>，注意最左前缀原则。</li>
</ul>
</li>
</ol>
<h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><ol>
<li>索引的理解<ol>
<li>索引是数据库中一种特殊的数据结构，它可以帮助数据库系统快速定位到表中的特定数据行，<strong>类似于书籍的目录</strong>。</li>
<li>可以说，索引就是把无序的数据化为有序</li>
<li>没有索引时，查找一般要遍历全表。有索引之后可以降低时间复杂度。</li>
<li>索引也存储在硬盘中</li>
</ol>
</li>
<li>常见的索引<ol>
<li>B+树。详见《Java学习笔记》<ol>
<li>为什么用B+树？<ol>
<li><strong>树高更低，查询更快</strong>（减少磁盘 IO 次数，每次 IO 代价高）</li>
<li><strong>非叶子节点只存 key，能容纳更多索引，树更矮</strong></li>
<li><strong>叶子节点之间有链表，范围查询非常高效</strong></li>
<li><strong>查询稳定，所有查询都要走到叶子节点，性能可预测</strong></li>
<li><strong>适合写平衡（插入、删除也相对稳定）</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><ol>
<li><p>选择合适的列建立索引</p>
<ul>
<li><p><strong>高选择性列优先</strong>：列中不同值越多（如用户ID、订单号），索引效果越好</p>
</li>
<li><p><strong>高频查询条件列</strong>：WHERE、JOIN、ORDER BY、GROUP BY中频繁使用的列</p>
</li>
<li><p><strong>等值查询列</strong>：精确匹配比范围查询更适合索引</p>
</li>
<li><p><strong>排序&#x2F;分组列</strong>：经常用于ORDER BY或GROUP BY的列</p>
</li>
</ul>
</li>
<li><p>避免过度索引</p>
<ul>
<li><p><strong>每个索引都有成本</strong>：占用存储空间，降低写入速度(INSERT&#x2F;UPDATE&#x2F;DELETE)</p>
</li>
<li><p><strong>监控索引使用率</strong>：定期检查未使用的索引并删除</p>
</li>
<li><p><strong>小表不需要索引</strong>：数据量小(如&lt;1000行)时全表扫描可能更快</p>
</li>
</ul>
</li>
</ol>
<h3 id="聚簇索引和非聚簇索引的区别是什么"><a href="#聚簇索引和非聚簇索引的区别是什么" class="headerlink" title="聚簇索引和非聚簇索引的区别是什么"></a>聚簇索引和非聚簇索引的区别是什么</h3><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>聚簇索引（Clustered Index）</strong></th>
<th align="left"><strong>非聚簇索引（Non-clustered Index &#x2F; 二级索引）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">索引的叶子节点 <strong>直接存储整行数据</strong>，即 <strong>数据即索引，索引即数据</strong></td>
<td align="left">索引的叶子节点 <strong>存储的是主键值（或指向数据的指针）</strong>，不是完整的数据行</td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left"><strong>数据按索引顺序物理存储</strong>（即表数据按聚簇索引的顺序存放）</td>
<td align="left"><strong>数据与索引分开存储</strong>，索引单独维护，指向数据的地址或主键</td>
</tr>
<tr>
<td align="left"><strong>数量</strong></td>
<td align="left"><strong>一个表只能有一个聚簇索引</strong>（通常是主键，如果没有主键则选唯一键，否则隐藏行 ID）</td>
<td align="left"><strong>一个表可以有多个非聚簇索引（二级索引）</strong></td>
</tr>
<tr>
<td align="left"><strong>查询效率</strong></td>
<td align="left">查询时 <strong>如果使用聚簇索引，通常只需一次查找即可定位到完整数据，效率很高</strong></td>
<td align="left">查询时可能需要 <strong>回表（先查索引，再根据主键查聚簇索引获取完整数据）</strong>，多一次 IO</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">主键查询、范围查询（如日期、ID 范围）非常高效</td>
<td align="left">适合根据非主键字段查询，但可能带来回表开销</td>
</tr>
<tr>
<td align="left"><strong>典型实现（MySQL）</strong></td>
<td align="left"><strong>InnoDB 的主键索引就是聚簇索引</strong></td>
<td align="left"><strong>InnoDB 的普通索引（如二级索引）就是非聚簇索引</strong></td>
</tr>
<tr>
<td align="left"><strong>物理顺序</strong></td>
<td align="left">数据按聚簇索引的键值顺序存储（物理有序）</td>
<td align="left">数据存储无序，索引单独组织（逻辑有序）</td>
</tr>
</tbody></table>
<h3 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h3><ol>
<li><p>基本特性：ACID</p>
<ol>
<li><p>原子性 (Atomicity)</p>
<p>通过 <strong>undo log（回滚日志）</strong> 实现：</p>
<ul>
<li>事务开始前，InnoDB 会记录修改前的数据到 undo log</li>
<li>如果事务需要回滚，可以根据 undo log 恢复到原始状态</li>
</ul>
</li>
<li><p>一致性 (Consistency)</p>
<p>通过以下机制共同保证：</p>
<ul>
<li>原子性、隔离性、持久性的组合</li>
<li>数据库的约束（如主键、外键、唯一约束等）</li>
<li>应用程序的业务逻辑</li>
</ul>
</li>
<li><p>隔离性 (Isolation)</p>
<p>通过 <strong>锁机制</strong> 和 <strong>MVCC（多版本并发控制）</strong> 实现：</p>
<ul>
<li><strong>锁机制</strong>：包括共享锁(S锁)、排他锁(X锁)、意向锁等</li>
<li><strong>MVCC</strong>：通过 read view 和版本链实现非锁定读，提高并发性能</li>
</ul>
</li>
<li><p>持久性 (Durability)</p>
<p>通过 <strong>redo log（重做日志）</strong> 实现：</p>
<ul>
<li>事务提交时，先将修改写入 redo log（预写日志），确保即使系统崩溃也能恢复数据</li>
<li>采用 WAL（Write-Ahead Logging）技术，先写日志再写磁盘</li>
</ul>
</li>
</ol>
</li>
<li><p>隔离级别</p>
<ol>
<li><p>SQL标准定义了四种隔离级别。隔离级别越高，并发性能越低，但数据一致性越强。从低到高依次为：</p>
<ol>
<li>读未提交(Read Uncommitted)</li>
<li>读已提交(Read Committed)</li>
<li>可重复读(Repeatable Read) <em>(MySQL默认级别)</em></li>
<li>串行化(Serializable)</li>
</ol>
</li>
<li><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">并发性能</th>
<th align="left">实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读 未提交</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">最高</td>
<td align="left">最低</td>
</tr>
<tr>
<td align="left">读 已提交</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">可重复读</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">MySQL中不可能*</td>
<td align="left">中等</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">串行化</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">最低</td>
<td align="left">最高</td>
</tr>
</tbody></table>
</li>
<li><p>并发问题详解</p>
<ol>
<li>脏读(Dirty Read)<ul>
<li><strong>定义</strong>：读取到其他事务未提交的数据</li>
<li><strong>风险</strong>：如果事务回滚，读取到的数据就是无效的</li>
<li><strong>解决方案</strong>：至少使用读已提交隔离级别</li>
</ul>
</li>
<li>不可重复读(Non-repeatable Read)<ul>
<li><strong>定义</strong>：同一事务内多次读取同一数据，得到不同结果</li>
<li><strong>原因</strong>：其他事务提交了修改</li>
<li><strong>风险</strong>：基于第一次读取结果做出的决策可能失效</li>
<li><strong>解决方案</strong>：使用可重复读或更高隔离级别</li>
</ul>
</li>
<li>幻读(Phantom Read)<ul>
<li><strong>定义</strong>：同一事务内两次执行相同查询，返回不同行数(新增或删除的行)</li>
<li><strong>原因</strong>：其他事务插入或删除了符合查询条件的行</li>
<li><strong>风险</strong>：统计结果不准确，业务逻辑可能出错</li>
<li><strong>解决方案</strong>：使用串行化或MySQL的可重复读(通过间隙锁防止)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>什么是MVCC</p>
<ol>
<li><p>为了并发问题，数据库提供了 事务隔离级别（如 Read Committed、Repeatable Read、Serializable）。</p>
</li>
<li><p>但使用 悲观锁（如行锁、表锁） 去解决并发问题，虽然安全，但会 降低并发性能，导致读写互相阻塞。</p>
<blockquote>
<p>✅ MVCC 的出现，就是为了在不加锁（或减少加锁）的前提下，实现事务隔离，让读写可以并发执行，提高性能！</p>
</blockquote>
</li>
<li><p>MVCC：多版本并发控制。是一种并发控制机制，它<strong>允许事务在不互相阻塞的情况下同时读取和修改数据</strong>。与传统的基于锁的并发控制不同，MVCC通过为数据维护多个版本来实现这一目标。</p>
</li>
</ol>
</li>
<li><p>MVCC的核心思想</p>
<ul>
<li><p><strong>读不阻塞写，写不阻塞读</strong>：这是MVCC最大的优势</p>
</li>
<li><p><strong>数据多版本化</strong>：每行数据可能有多个版本同时存在</p>
</li>
<li><p><strong>一致性读</strong>：事务读取的是某个时间点的数据快照，而不是最新数据</p>
</li>
<li><p><strong>版本链管理</strong>：通过特殊的结构跟踪和管理数据的不同版本</p>
</li>
</ul>
</li>
<li><p>时间线示例</p>
<ol>
<li>T1 启动（事务 ID &#x3D; 101）</li>
<li>T2 启动（事务 ID &#x3D; 102）</li>
<li>T2 执行 UPDATE balance &#x3D; 200 WHERE id &#x3D; 1，未提交</li>
<li>T2 提交事务，此时 balance &#x3D; 200 的版本，事务 ID &#x3D; 102，变为“已提交”</li>
<li>T1 执行 SELECTT1 的 ReadView 是在 T2 提交前生成的，它依然 看不到 T2 的修改（因为 T2 在 T1 的 ReadView 中是“活跃的” 或 “在其后创建的”）T1 仍然读的是旧版本 balance &#x3D; 100。但如果 T1 提交后再开启一个新事务 T3 去读，T3 就能看到 balance &#x3D; 200（因为 T2 已提交）</li>
</ol>
</li>
<li><p>优势</p>
<ul>
<li><strong>高并发性能</strong>：读写操作互不阻塞，显著提高系统并发能力</li>
<li><strong>非阻塞读</strong>：读操作不需要等待写操作完成，也不会阻塞写操作</li>
<li><strong>一致性读</strong>：事务可以读取一致的数据快照，不受其他事务影响</li>
<li><strong>减少锁争用</strong>：降低了死锁发生的概率</li>
</ul>
</li>
<li><p>局限	</p>
<ul>
<li><p><strong>存储开销</strong>：需要存储多个数据版本，增加存储空间使用</p>
</li>
<li><p><strong>清理成本</strong>：需要定期清理不再需要的旧版本数据（purge操作）</p>
</li>
<li><p><strong>实现复杂</strong>：相比简单的锁机制，MVCC实现更加复杂</p>
</li>
<li><p><strong>不解决所有问题</strong>：如幻读问题需要结合其他机制解决（如InnoDB的间隙锁）</p>
</li>
</ul>
</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>思想：<ul>
<li>不是直接读最新数据，也不是直接修改原数据，而是：<ul>
<li>写操作：创建新版本，旧数据保留（通过 Undo Log）</li>
<li>读操作：根据事务的 ReadView，找到一个对当前事务“可见”的数据版本（可能是旧数据）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>多版本数据：每行记录有多个版本</p>
<ol>
<li><p>在 InnoDB 中，数据行（record）并不是一成不变的，而是会随着更新产生多个版本。每行数据包含几个关键的 隐藏字段（Metadata Fields）：</p>
<table>
<thead>
<tr>
<th align="left">隐藏字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DB_TRX_ID</strong></td>
<td align="left">最后一次修改（INSERT&#x2F;UPDATE）该行的事务 ID</td>
</tr>
<tr>
<td align="left"><strong>DB_ROLL_PTR</strong></td>
<td align="left">指向该行上一个版本（旧数据）的指针，存放在 Undo Log 中</td>
</tr>
<tr>
<td align="left"><strong>DB_ROW_ID</strong>（可选）</td>
<td align="left">如果表没有主键，InnoDB 会自动生成一个行 ID</td>
</tr>
</tbody></table>
<blockquote>
<p>每当一个事务对某行数据进行 更新（UPDATE） 时：</p>
<ul>
<li>不会直接覆盖原数据</li>
<li>而是先将旧数据写入 Undo Log（回滚日志）</li>
<li>然后插入新数据（或原地更新），并更新 DB_TRX_ID 为当前事务 ID</li>
<li>通过 DB_ROLL_PTR 可以找到该行的旧版本，形成版本链</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>Undo Log（回滚日志）：保存旧版本数据</strong></p>
<ol>
<li><p>Undo Log 是 InnoDB 用来支持事务回滚和 MVCC 的重要日志。</p>
</li>
<li><p>每当一个事务修改了某行数据，InnoDB 会：</p>
<ul>
<li>把修改前的旧数据（即被覆盖前的值）保存到 Undo Log</li>
<li>这些旧数据 不会被立即删除，而是会保留一段时间，用于：事务回滚（Rollback）MVCC 中为其他事务提供历史版本数据（读一致性）</li>
</ul>
<blockquote>
<p>MVCC 利用 Undo Log 实现了“数据的多版本存储”。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>ReadView（读视图）：决定事务能看见哪些版本</strong></p>
<ol>
<li><p>当一个事务执行 SELECT（读操作） 时，InnoDB 不会直接读取最新数据，而是根据一个叫 ReadView 的东西，决定当前事务应该看到哪个版本的数据。</p>
</li>
<li><p>什么时候生成 ReadView？</p>
</li>
</ol>
<blockquote>
<p>在事务执行读操作（如 SELECT）时生成，用于控制该事务的“数据可见性”。</p>
</blockquote>
<ol start="3">
<li>ReadView 包含的关键信息：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">m_ids</td>
<td align="left">当前 活跃的（未提交）事务 ID 列表（即还有哪些事务没提交，可能修改了数据）</td>
</tr>
<tr>
<td align="left">min_trx_id</td>
<td align="left">当前所有活跃事务中的最小事务 ID</td>
</tr>
<tr>
<td align="left">max_trx_id</td>
<td align="left">系统即将分配给下一个事务的 ID（当前最大事务 ID + 1）</td>
</tr>
<tr>
<td align="left">creator_trx_id</td>
<td align="left">当前事务自己的 ID</td>
</tr>
</tbody></table>
<hr>
<ol start="4">
<li><p>可见性判断规则（核心！）：</p>
<ol>
<li><p>当一个事务要读取某条数据时，InnoDB 不是直接读取磁盘上的最新数据，而是：</p>
<ol>
<li>找到该数据行的<strong>最新版本</strong>；</li>
<li>根据 <strong>Read View 的规则</strong>，判断这个版本是否对当前事务<strong>可见</strong>；</li>
<li>如果不可见，则顺着 <code>DB_ROLL_PTR</code>找上一个版本，再次判断，直到找到一个<strong>对当前事务可见的版本</strong>，或者没有更多版本可找。</li>
</ol>
<p>这个过程就是 <strong>“多版本读取”</strong>，也就是 MVCC 的核心。</p>
</li>
<li><p>对于某行数据的 DB_TRX_ID（最后修改它的事务 ID），InnoDB 通过以下规则判断当前事务是否能“看到”这个版本：</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">是否可见</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID &#x3D;&#x3D; creator_trx_id（是自己修改的）</td>
<td align="left">✅ 可见</td>
<td align="left">自己事务修改的数据，当然可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID &lt; min_trx_id（比所有活跃事务都早）</td>
<td align="left">✅ 可见</td>
<td align="left">该数据在事务开始前已提交</td>
</tr>
<tr>
<td align="left">min_trx_id ≤ DB_TRX_ID &lt; max_trx_id，且 DB_TRX_ID ∉ m_ids（已提交事务）</td>
<td align="left">✅ 可见</td>
<td align="left">该事务已提交，数据可见</td>
</tr>
<tr>
<td align="left">DB_TRX_ID ≥ max_trx_id 或 DB_TRX_ID ∈ m_ids（未提交或之后的事务）</td>
<td align="left">❌ 不可见</td>
<td align="left">该事务还未提交，或比当前事务晚，数据不可见</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 如果当前版本不可见，就通过 DB_ROLL_PTR 找到更早的版本，继续判断，直到找到一个可见的版本为止。</p>
</blockquote>
</li>
</ol>
<h4 id="Read-View-是什么时候生成的？"><a href="#Read-View-是什么时候生成的？" class="headerlink" title="Read View 是什么时候生成的？"></a>Read View 是什么时候生成的？</h4><ul>
<li><p>Read View 是在事务进行“快照读”（如普通 SELECT）时生成的，而不是所有的 SELECT 都会生成。</p>
<p>具体来说：</p>
<ul>
<li>对于普通的 SELECT（一致性非锁定读，快照读）：会生成一个 Read View，根据该视图去读取符合条件的“历史版本数据”。</li>
<li>对于加锁的 SELECT（如 SELECT … FOR UPDATE &#x2F; LOCK IN SHARE MODE）：属于当前读（锁定读），不会使用 MVCC，而是直接读最新的数据，并加锁。</li>
</ul>
</li>
</ul>
<h4 id="在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？"><a href="#在-RC（读已提交）和-RR（可重复读）级别下，Read-View-的生成时机有什么不同？" class="headerlink" title="在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？"></a>在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？</h4><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">Read View 生成时机</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>RC（Read Committed，读已提交）</strong></td>
<td align="left"><strong>每次执行快照读（普通 SELECT）时都会生成一个新的 Read View</strong></td>
<td align="left">因此每次读都基于<strong>当前最新已提交的数据</strong>，可能读到其他事务已提交的新数据，导致<strong>不可重复读</strong>。</td>
</tr>
<tr>
<td align="left"><strong>RR（Repeatable Read，可重复读）</strong></td>
<td align="left"><strong>仅在事务中第一次执行快照读时生成一个 Read View，后续复用该 View</strong></td>
<td align="left">因此在整个事务中，读到的数据都是基于事务开始时（或第一次读时）的快照，保证多次读取结果一致，解决<strong>不可重复读</strong>。</td>
</tr>
</tbody></table>
<h4 id="MySQL-的-RR-级别解决了幻读问题吗？"><a href="#MySQL-的-RR-级别解决了幻读问题吗？" class="headerlink" title="MySQL 的 RR 级别解决了幻读问题吗？"></a>MySQL 的 RR 级别解决了幻读问题吗？</h4><ol>
<li><p>RR 级别是否解决了幻读？</p>
<p><strong>答案是：MySQL 的 RR 级别，通过 MVCC + Gap Lock &#x2F; Next-Key Lock 的组合，实际上已经解决了幻读问题！</strong></p>
<p>但是要注意：</p>
<ul>
<li><strong>单纯依靠 MVCC（多版本控制）是无法解决幻读的！</strong></li>
<li><strong>真正解决幻读，靠的是 InnoDB 的锁机制：Gap Lock（间隙锁）和 Next-Key Lock（临键锁）！</strong></li>
</ul>
<hr>
</li>
<li><p>InnoDB 如何通过锁解决幻读？</p>
<p>在 <strong>RR 级别下</strong>，InnoDB 对于<strong>范围查询</strong>会使用：</p>
<ul>
<li><strong>Next-Key Lock &#x3D; Record Lock（记录锁） + Gap Lock（间隙锁）</strong></li>
</ul>
<ol>
<li>Record Lock（记录锁）：</li>
</ol>
<p>锁住<strong>索引记录本身</strong>，比如某条 id&#x3D;10 的记录。</p>
<ol start="2">
<li>Gap Lock（间隙锁）：</li>
</ol>
<p>锁住<strong>索引记录之间的间隙</strong>，防止其他事务在这个间隙中<strong>插入新的数据</strong>。</p>
<ol start="3">
<li>Next-Key Lock：</li>
</ol>
<p>是两者的组合，既锁住记录本身，也锁住该记录前面的间隙。例如，对索引范围 (5, 10] 加 Next-Key Lock，意味着：</p>
<ul>
<li>锁住了索引值 10 这条记录（Record Lock）</li>
<li>同时锁住了 (5, 10) 这个区间，防止插入 id&#x3D;6~9 的新数据（Gap Lock）</li>
</ul>
<hr>
</li>
<li><p>举例说明幻读的避免</p>
<p>假设表中有 id 为 1, 5, 10 的记录，事务 A 执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE id &gt; 5 AND id &lt; 15 FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>在 RR 级别下，InnoDB 会对 id &gt;5 且 &lt;15 的<strong>范围加上 Next-Key Lock</strong>，包括：</p>
<ul>
<li>记录锁：id&#x3D;10</li>
<li>间隙锁：(5,10), (10,15)</li>
</ul>
<p>此时，如果另一个事务 B 尝试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t (id) VALUES (7);   -- 会被阻塞，因为 (5,10) 被锁</span><br><span class="line">INSERT INTO t (id) VALUES (12);  -- 会被阻塞，因为 (10,15) 被锁</span><br></pre></td></tr></table></figure>

<p>这样就<strong>防止了其他事务插入“幻影行”</strong>，从而避免了幻读。</p>
</li>
</ol>
<h3 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a>索引覆盖是什么</h3><ol>
<li>索引覆盖：指的是当查询所需的所有列都包含在索引中时，数据库可以直接从索引中获取所需数据，而无需回表查询数据行。</li>
<li>索引覆盖的工作原理<ol>
<li>普通查询流程（无索引覆盖）<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行位置（如主键值）</li>
<li><strong>回表查询</strong>：根据索引提供的位置信息，再到数据表（聚簇索引）中查找完整的行数据</li>
<li><strong>返回结果</strong>：从完整行数据中提取所需的列<ul>
<li>这个过程需要<strong>两次查找操作</strong>：一次在索引上，一次在数据表上。</li>
</ul>
</li>
</ol>
</li>
<li>索引覆盖查询流程<ol>
<li><strong>通过索引定位数据</strong>：使用索引找到满足条件的行</li>
<li><strong>直接从索引获取数据</strong>：因为所需的所有列都包含在索引中，直接从索引结构中提取数据</li>
<li><strong>返回结果</strong>：无需访问数据表<ul>
<li>这个过程只需要<strong>一次查找操作</strong>，且数据来源是更轻量的索引结构。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><ol>
<li><p>是什么</p>
<ol>
<li>EXPLAIN 是 MySQL 提供的一个 SQL 命令，<strong>用于显示 MySQL 如何执行 SQL 语句的执行计划</strong>。通过 EXPLAIN，你可以看到查询优化器选择的执行路径、使用的索引、连接类型、数据读取方式等关键信息。</li>
</ol>
</li>
<li><p>作用</p>
<ol>
<li>分析查询性能瓶颈</li>
<li>查看索引使用情况</li>
<li>理解查询执行策略</li>
<li>优化 SQL 语句</li>
<li>预测查询性能</li>
</ol>
</li>
<li><p>explain的基础列详解</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">数据类型</th>
<th align="left">说明</th>
<th align="left">重要解读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>id</strong></td>
<td align="left">int</td>
<td align="left">SELECT 查询的标识符</td>
<td align="left">表示查询中 SELECT 语句的执行顺序。id相同，执行顺序从上往下；id不同，数值越大越先执行</td>
</tr>
<tr>
<td align="left"><strong>select_type</strong></td>
<td align="left">varchar</td>
<td align="left">查询类型</td>
<td align="left">表明查询是简单查询还是复杂查询，如 SIMPLE(简单SELECT)、PRIMARY(最外层SELECT)、SUBQUERY(子查询)、DERIVED(派生表)等</td>
</tr>
<tr>
<td align="left"><strong>table</strong></td>
<td align="left">varchar</td>
<td align="left">访问的表名</td>
<td align="left">显示这一行数据是关于哪张表的，可能是表名、别名、派生表或临时表</td>
</tr>
<tr>
<td align="left"><strong>partitions</strong></td>
<td align="left">varchar</td>
<td align="left">匹配的分区</td>
<td align="left">对于分区表，显示查询访问了哪些分区，非分区表通常为NULL</td>
</tr>
<tr>
<td align="left"><strong>type</strong></td>
<td align="left">varchar</td>
<td align="left">访问类型</td>
<td align="left"><strong>查询性能关键指标</strong>，表示MySQL在表中找到所需行的方式，从好到坏：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td>
</tr>
<tr>
<td align="left"><strong>possible_keys</strong></td>
<td align="left">varchar</td>
<td align="left">可能使用的索引</td>
<td align="left">查询优化器可能考虑使用哪些索引来查找表中的行，但不一定实际使用，若为NULL表示没有可用索引</td>
</tr>
<tr>
<td align="left"><strong>key</strong></td>
<td align="left">varchar</td>
<td align="left">实际使用的索引</td>
<td align="left">查询优化器实际选择的索引，若为NULL则表示没有使用索引，显示的是索引名称</td>
</tr>
<tr>
<td align="left"><strong>key_len</strong></td>
<td align="left">int</td>
<td align="left">使用的索引长度(字节)</td>
<td align="left">显示使用的索引字段的长度，可以帮助判断使用了索引的哪些部分，数值越小通常越好</td>
</tr>
<tr>
<td align="left"><strong>ref</strong></td>
<td align="left">varchar</td>
<td align="left">索引参考列</td>
<td align="left">显示索引的哪一列被使用了，或者常量值，如 const、func、NULL 或列名</td>
</tr>
<tr>
<td align="left"><strong>rows</strong></td>
<td align="left">int</td>
<td align="left">预估扫描行数</td>
<td align="left"><strong>查询性能关键指标</strong>，MySQL估计为了找到所需的行而要读取的行数，数值越小越好，是优化器估算值</td>
</tr>
<tr>
<td align="left"><strong>filtered</strong></td>
<td align="left">decimal(5,2)</td>
<td align="left">过滤百分比</td>
<td align="left">存储引擎返回的数据在server层过滤后，还剩余多少比例(百分比)，值越高越好，MySQL 5.7+引入</td>
</tr>
<tr>
<td align="left"><strong>Extra</strong></td>
<td align="left">varchar</td>
<td align="left">额外信息</td>
<td align="left"><strong>查询性能关键信息</strong>，包含不适合在其他列中显示但十分重要的额外信息，如 Using index、Using where、Using temporary 等</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><ol>
<li>是什么<ol>
<li><strong>最左前缀原则</strong>指的是：<strong>对于复合索引（包含多个列的索引），查询必须使用索引的最左列（第一个列）才能使用该索引</strong>，并且查询条件中的列顺序必须与索引列定义顺序相匹配，从最左边的列开始连续使用。</li>
<li>换句话说，如果有一个复合索引是 <code>(A, B, C)</code>，那么：<ul>
<li>查询条件必须<strong>从A列开始</strong>使用并<strong>保持相对顺序</strong></li>
<li>可以使用 <ul>
<li><code>(A)</code>、<code>(A, B)</code>、<code>(A, B, C)</code>、<code>(A, C)</code></li>
</ul>
</li>
<li>不能使用<ul>
<li><code>(B, C)</code>、<code>(A, C, B)</code>、<code>(B, A)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h3><ul>
<li>MyISAM和InnoDB是MySQL数据库中两种最重要的存储引擎，它们在架构设计、功能特性和适用场景上有显著区别</li>
<li><strong>存储引擎（Storage Engine）<strong>是MySQL中用于</strong>管理数据存储和检索的底层软件组件</strong>。它负责数据的存储、读取、索引管理、事务处理等核心功能。MySQL采用<strong>插件式架构</strong>，允许使用不同的存储引擎来处理不同的表。</li>
<li>InnoDB是更先进的存储引擎。一般来说，只推荐用InnoDB。</li>
</ul>
<h3 id="为什么MySQL要用B-树而不用B树"><a href="#为什么MySQL要用B-树而不用B树" class="headerlink" title="为什么MySQL要用B+树而不用B树"></a>为什么MySQL要用B+树而不用B树</h3><ol>
<li><strong>更低的树高度</strong>：B+树通过只在非叶子节点存储索引键，可以容纳更多键值，大大减少树的高度，进而减少磁盘I&#x2F;O次数，提高查询效率</li>
<li><strong>更高效的范围查询</strong>：B+树的叶子节点通过指针连接形成有序链表，使得<strong>范围查询（如BETWEEN、&gt;、&lt;）和排序操作（ORDER BY）非常高效</strong></li>
<li>更高的存储密度：B+树的非叶子节点不存储实际数据，可以存储更多索引键，即更高的扇出，使得每个节点能容纳更多信息，进一步降低树的高度</li>
<li><strong>更稳定的查询性能</strong>：所有查询都必须到达叶子节点，使得查询路径长度完全一致，提供更稳定和可预测的查询性能</li>
<li>更适合数据库特性：B+树的结构与数据库的读多写少、需要高效范围查询、排序和稳定性能的需求高度契合</li>
<li>与InnoDB实现完美配合：特别是聚簇索引设计和磁盘页优化，使得B+树在MySQL中能够发挥最大效能</li>
</ol>
<h3 id="MySQL的锁有哪些"><a href="#MySQL的锁有哪些" class="headerlink" title="MySQL的锁有哪些"></a>MySQL的锁有哪些</h3><ol>
<li><p>按锁的粒度分类</p>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全局锁</strong></td>
<td align="left">锁定整个数据库实例</td>
<td align="left">简单粗暴，保证全局一致性</td>
<td align="left">性能影响极大，几乎锁住所有操作</td>
<td align="left">全库备份、全库数据迁移</td>
</tr>
<tr>
<td align="left"><strong>表级锁</strong></td>
<td align="left">锁定整张表</td>
<td align="left">实现简单，开销小，加锁快</td>
<td align="left">并发度低，锁冲突概率高</td>
<td align="left">MyISAM引擎、DDL操作、批量数据操作</td>
</tr>
<tr>
<td align="left"><strong>行级锁</strong></td>
<td align="left">只锁定需要操作的行</td>
<td align="left">并发度高，冲突概率低</td>
<td align="left">实现复杂，开销大，加锁慢</td>
<td align="left">InnoDB引擎、高并发OLTP系统</td>
</tr>
</tbody></table>
</li>
<li><p>按锁的性质分类</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">说明</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>共享锁(S锁，Shared Lock)</strong></td>
<td align="left">读锁，多个事务可同时持有</td>
<td align="left">允许其他事务读取，但禁止写入</td>
<td align="left">读操作、需要数据不被修改的场景</td>
</tr>
<tr>
<td align="left"><strong>排他锁(X锁，Exclusive Lock)</strong></td>
<td align="left">写锁，一次只能由一个事务持有</td>
<td align="left">禁止其他事务读取和写入</td>
<td align="left">写操作、数据修改场景</td>
</tr>
<tr>
<td align="left"><strong>意向锁</strong></td>
<td align="left">表级锁，表明事务打算在表中的行上获取什么类型的锁</td>
<td align="left">提高表级锁和行级锁的兼容性判断效率</td>
<td align="left">InnoDB引擎内部使用</td>
</tr>
</tbody></table>
<ol>
<li>意向锁是表级锁。当读或写某一行时，会给对应的表加上IS或IX锁。</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ol>
<li>惰性删除：<ol>
<li>原理：访问某个Key时检查是否过期</li>
<li>优点：CPU友好，节省了CPU资源</li>
<li>缺点：大量过期的Key没有被访问，占内存资源</li>
</ol>
</li>
<li>定期删除：<ol>
<li>原理：每隔一段时间，扫描一部分Key，删除过期键</li>
</ol>
</li>
<li>定时过期：<ol>
<li>原理：给Key设置定时过期删除的属性</li>
</ol>
</li>
</ol>
<h3 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h3><ol>
<li><p>实现流程</p>
<ol>
<li>事务开始<ol>
<li><code>MULTI</code>启动事务模式（flag属性打开REDIS_MULTI标识）</li>
</ol>
</li>
<li>命令入队<ol>
<li>除了<code>DISCADE</code>,<code>WATCH</code>,<code>EXEC</code>等少数命令会立即执行外，其他命令都是入队。</li>
<li>入队时会检查语法错误。如果有语法问题，则终止事务（flag属性关闭REDIS_MULTI标识）</li>
</ol>
</li>
<li>事务执行<ol>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性如何实现？Redis没有回滚机制，是否破坏了原子性？</p>
<ol>
<li><p>我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断</p>
</li>
<li><p>在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性</p>
</li>
<li><p>虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。</p>
</li>
<li><p>并且运行时错误多为编程错误，可以避免。</p>
</li>
<li><p>一致性如何实现？</p>
<ol>
<li><strong>内部一致性：</strong> Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。</li>
<li><strong>事务隔离性：</strong> <code>I</code> 的保证间接支撑了 <code>C</code>，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。</li>
</ol>
</li>
<li><p>隔离性如何实现？</p>
<ol>
<li>Redis 对隔离性的保证是<strong>非常强大</strong>的，因为它基于单线程模型。</li>
<li>保证方式： Redis 使用 <strong>单线程</strong> 模型处理所有客户端请求（除了后台的持久化操作）。</li>
<li>结果： <code>MULTI</code>&#x2F;<code>EXEC</code> 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。</li>
<li>总结： <strong>Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><p>持久性如何实现？</p>
<ol>
<li><p>Redis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，<strong>默认情况下持久性是有风险的</strong>。</p>
<ol>
<li><p>Redis 主要通过两种方式实现持久性：</p>
<ol>
<li><strong>AOF (Append Only File) 模式：</strong><ol>
<li>将所有写命令以日志形式追加到文件中。</li>
<li>如果配置了 <code>always</code> 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。</li>
<li>但为了性能，通常配置为 <code>everysec</code>（每秒同步一次），这意味着最近一秒内的数据可能会丢失。</li>
</ol>
</li>
<li><strong>RDB (Redis Database) 快照模式：</strong><ol>
<li>定期将内存中的数据生成一个二进制快照文件。</li>
<li>由于是<strong>定期</strong>快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。</li>
</ol>
</li>
</ol>
<ul>
<li><strong>总结：</strong> Redis 的持久性是<strong>可配置的</strong>。只有在启用 AOF 并设置为 <code>always</code> 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h3><ul>
<li>RDB，AOF</li>
</ul>
<h3 id="分布式锁底层怎么实现的"><a href="#分布式锁底层怎么实现的" class="headerlink" title="分布式锁底层怎么实现的"></a>分布式锁底层怎么实现的</h3><ul>
<li><p>使用 Redis 的 <code>SET key value NX PX timeout</code>命令，来实现：</p>
<ul>
<li><strong>互斥性（Mutual Exclusion）</strong>：同一时刻只有一个客户端能成功设置锁</li>
<li><strong>避免死锁</strong>：锁必须要有过期时间，防止客户端崩溃后锁永远不释放</li>
<li><strong>锁的释放必须是原子的且只能由加锁者释放</strong>：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁</li>
</ul>
</li>
</ul>
<h3 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h3><ul>
<li>主从复制，哨兵模式，集群模式</li>
</ul>
<h3 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h3><h3 id="Redis与MySQL如何保证数据的一致性"><a href="#Redis与MySQL如何保证数据的一致性" class="headerlink" title="Redis与MySQL如何保证数据的一致性"></a>Redis与MySQL如何保证数据的一致性</h3><ol>
<li><p>为什么会不一致</p>
<ol>
<li><p>在常见的 <strong>“先更新数据库，再更新缓存” 或 “先删缓存，再更新数据库”</strong> 等策略中，如果操作顺序、并发控制不当，就可能出现以下情况：</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">说明</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 程序 Bug 或异常</strong></td>
<td align="left">更新了数据库，但忘记更新&#x2F;删除缓存</td>
<td align="left">缓存是旧数据，与数据库不一致</td>
</tr>
<tr>
<td align="left"><strong>2. 并发读写</strong></td>
<td align="left">一个线程在更新数据库和缓存的过程中，另一个线程读了旧的缓存或写入了脏数据</td>
<td align="left">缓存与数据库数据出现偏差</td>
</tr>
<tr>
<td align="left"><strong>3. 崩溃或中断</strong></td>
<td align="left">在更新数据库和缓存之间服务崩溃，导致两者状态不一致</td>
<td align="left">缓存和数据库“数据分裂”</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>常用策略</p>
<ol>
<li><p>延时双删策略（Double Delete）</p>
<ol>
<li>为了解决 并发导致的脏数据回填问题，可以采用 双删策略，即在写操作的以下时机删除缓存：<ol>
<li>写操作之前，先删除一次缓存</li>
<li>更新数据库</li>
<li>延迟一段时间（如几百毫秒），再删除一次缓存</li>
</ol>
</li>
<li>为什么延迟删除？<ul>
<li>因为在更新数据库的过程中，可能有其他线程读了旧数据并回填了缓存，延迟删除可以尽量把这种脏缓存清除掉</li>
</ul>
</li>
<li>实现方式：<ul>
<li>可以使用 Java 的 <code>ScheduledExecutorService</code>、<code>Thread.sleep()</code>，或者消息队列延迟消费等方式实现“延迟删除”</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ 适合对一致性要求稍高一点的业务，但仍有 极小概率的不一致窗口期</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h3><ol>
<li><p><strong>基于内存操作（最重要原因）</strong></p>
<blockquote>
<p>Redis 的数据是存储在<strong>内存中的</strong>，内存的访问速度是纳秒级别（约 100ns），相比磁盘（毫秒级）快几个数量级。</p>
</blockquote>
<ul>
<li>操作内存比操作磁盘或数据库快得多，不需要磁盘 I&#x2F;O、不需要复杂的事务日志、不需要锁等待。</li>
<li>所有的读写操作几乎都是在内存中瞬间完成，这是 Redis 高性能的<strong>最核心原因</strong>。</li>
</ul>
<hr>
</li>
<li><p><strong>单线程避免了多线程的锁竞争和上下文切换</strong></p>
<ul>
<li>在多线程模型中，多个线程访问共享数据时需要加锁（如互斥锁、读写锁），这会带来：<ul>
<li>锁竞争</li>
<li>线程切换开销</li>
<li>死锁风险</li>
<li>编程复杂度高</li>
</ul>
</li>
<li>Redis 采用单线程模型，<strong>所有命令串行执行，无需考虑并发安全问题，没有锁竞争，也没有线程切换的开销</strong>，所以执行效率极高。</li>
</ul>
<blockquote>
<p>✅ 单线程 &#x3D; 无锁 &#x3D; 无竞争 &#x3D; 更简单、更高效</p>
</blockquote>
<hr>
</li>
<li><p><strong>优秀的数据结构与高性能底层实现</strong></p>
<p>Redis 提供了多种<strong>高效的数据结构</strong>（如 String、Hash、List、Set、ZSet 等），并且这些数据结构在底层使用了非常高效的实现方式，比如：</p>
<ul>
<li>ziplist、quicklist、哈希表优化、跳表（SkipList）等</li>
<li>所有数据结构的操作都经过高度优化，使得命令执行非常快速</li>
</ul>
<hr>
</li>
<li><p><strong>I&#x2F;O 多路复用模型（核心网络模型）</strong></p>
<ol>
<li><p>Redis 使用了 <strong>I&#x2F;O 多路复用技术（如 epoll、kqueue、select）</strong> 来处理大量的并发连接，这是它支撑高并发的关键。</p>
</li>
<li><p>什么是 I&#x2F;O 多路复用？</p>
<ul>
<li><p>允许 <strong>一个线程同时监听多个 Socket 连接</strong> 的读写事件</p>
</li>
<li><p>当某个连接有数据可读&#x2F;可写时，Redis 才去处理这个连接</p>
</li>
<li><p>避免了为每个连接创建一个线程，极大节省了系统资源</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>✅ Redis 通过 <strong>单线程 + I&#x2F;O 多路复用</strong>，就能高效处理数万甚至数十万的并发连接，而不会线程爆炸。</p>
</blockquote>
<hr>
</li>
<li><p><strong>Redis 命令执行是原子性的，无需额外同步</strong></p>
<ul>
<li>每个 Redis 命令都是<strong>原子操作</strong>，比如 INCR、LPUSH 等，执行过程中不会被其他命令打断。</li>
<li>因为是单线程，所以也<strong>不需要加锁来保证原子性</strong>，执行效率高，逻辑简单。</li>
</ul>
<hr>
</li>
<li><p><strong>Redis 是专门为高性能场景设计的网络存储中间件</strong></p>
<ul>
<li>Redis 的代码是<strong>用 C 语言编写的，非常接近底层，运行效率极高</strong></li>
<li>没有复杂的企业级框架、没有冗余的中间层，整个系统非常轻量、高效</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>基于内存，读写极快</strong></td>
<td align="left">数据在内存中，访问速度是纳秒级</td>
</tr>
<tr>
<td align="left">✅ <strong>单线程，无锁，无竞争</strong></td>
<td align="left">不需要考虑并发安全，没有锁开销，执行路径简单</td>
</tr>
<tr>
<td align="left">✅ <strong>I&#x2F;O 多路复用，高并发支持好</strong></td>
<td align="left">单线程可处理几万甚至几十万的并发连接</td>
</tr>
<tr>
<td align="left">✅ <strong>命令执行是原子的</strong></td>
<td align="left">无需加锁，执行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>代码精简高效</strong></td>
<td align="left">C 语言实现，无复杂框架，运行效率高</td>
</tr>
<tr>
<td align="left">✅ <strong>扩展性强（Redis 6.0+ 多线程 I&#x2F;O）</strong></td>
<td align="left">网络读写利用多核，进一步提升性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">局限性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>CPU 密集型任务可能阻塞</strong></td>
<td align="left">如果某个命令执行特别耗时（如 KEYS *、大 Key 操作、复杂 Lua 脚本），会阻塞整个主线程，影响其他请求</td>
</tr>
<tr>
<td align="left">❌ <strong>无法充分利用多核 CPU（命令执行层面）</strong></td>
<td align="left">命令执行仍然是单线程的，不能发挥多核优势（但网络 I&#x2F;O 可以，Redis 6.0+）</td>
</tr>
<tr>
<td align="left">❌ <strong>对单个大 Key 或慢查询敏感</strong></td>
<td align="left">一个慢命令可能拖慢整个服务</td>
</tr>
</tbody></table>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><ol>
<li><p>三次握手</p>
<ol>
<li><p>确保客户端和服务器双方的 <strong>发送和接收能力正常</strong>，并 <strong>同步双方的初始序列号（ISN, Initial Sequence Number）</strong>，为后续可靠数据传输做准备。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>SYN &#x3D; 1, seq &#x3D; x</strong></td>
<td align="left">客户端向服务端发起连接请求，随机生成一个初始序列号 x，表示“我想和你建立连接”。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>SYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; y, ack &#x3D; x + 1</strong></td>
<td align="left">服务端收到请求后，同意建立连接，也随机生成一个初始序列号 y，并确认客户端的序号 x+1（ACK &#x3D; x + 1）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, seq &#x3D; x + 1, ack &#x3D; y + 1</strong></td>
<td align="left">客户端收到服务端的同意后，再发送一个确认报文，确认服务端的序号 y+1。此时连接建立成功。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>四次挥手</p>
<ol>
<li><p>由于 TCP 是<strong>全双工</strong>的（即双方可以同时发送和接收数据），因此<strong>每个方向上的数据传输都需要单独关闭</strong>，所以需要四次挥手来确保双方都完成数据发送并安全关闭连接。</p>
</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">方向</th>
<th align="left">消息类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">A → B</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; u</strong></td>
<td align="left">客户端 A 发送 FIN 报文，表示“我不再发送数据了，但还可以接收”。进入 <strong>FIN_WAIT_1</strong> 状态。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">B → A</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; u + 1</strong></td>
<td align="left">服务端 B 收到后，发送 ACK 确认，表示“我知道你不想发了，但我可能还有数据要发给你”。A 进入 <strong>FIN_WAIT_2</strong>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">B → A</td>
<td align="left"><strong>FIN &#x3D; 1, seq &#x3D; v</strong></td>
<td align="left">服务端 B 处理完剩余数据后，也发送 FIN 报文，表示“我也不再发送数据了”。进入 <strong>LAST_ACK</strong> 状态。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">A → B</td>
<td align="left"><strong>ACK &#x3D; 1, ack &#x3D; v + 1</strong></td>
<td align="left">客户端 A 收到后，发送最后的 ACK 确认。B 收到后关闭连接。A 等待一段时间（2MSL）后也关闭连接。</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="浏览器发出一个请求到收到响应经历了那些过程"><a href="#浏览器发出一个请求到收到响应经历了那些过程" class="headerlink" title="浏览器发出一个请求到收到响应经历了那些过程"></a>浏览器发出一个请求到收到响应经历了那些过程</h3><ol>
<li>URL 解析</li>
<li>DNS 查询（域名 → IP 地址）</li>
<li>建立 TCP 连接（三次握手）</li>
<li>如果是 HTTPS，进行 TLS 握手（加密通道建立）</li>
<li>发送 HTTP 请求（浏览器 → 服务器）</li>
<li>服务器处理请求并返回 HTTP 响应</li>
<li>浏览器解析 HTML 内容</li>
<li>请求并加载外部资源</li>
<li>页面渲染与显示</li>
</ol>
<h3 id="跨域请求是什么？有什么问题？怎么解决？"><a href="#跨域请求是什么？有什么问题？怎么解决？" class="headerlink" title="跨域请求是什么？有什么问题？怎么解决？"></a>跨域请求是什么？有什么问题？怎么解决？</h3><ol>
<li><p>是什么</p>
<ol>
<li><p>跨域请求：<strong>当前网页</strong>的域名、协议、端口中的任意一个与<strong>请求</strong>的目标资源不一致，导致浏览器出于安全考虑阻止该请求。</p>
</li>
<li><p>什么是“同源”？</p>
<ol>
<li>两个 URL 如果满足以下 <strong>三者完全相同</strong>，就属于<strong>同源（Same Origin）</strong>，否则就是<strong>跨域（Cross-Origin）</strong>：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">组成部分</th>
<th align="left">是否必须相同</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议（Protocol）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>http</code>vs <code>https</code>就不同源</td>
</tr>
<tr>
<td align="left"><strong>域名（Host）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>www.example.com</code>vs <code>api.example.com</code>不同源</td>
</tr>
<tr>
<td align="left"><strong>端口（Port）</strong></td>
<td align="left">✅ 必须相同</td>
<td align="left"><code>80</code>（HTTP默认） vs <code>443</code>（HTTPS默认） 或 <code>8080</code>不同源</td>
</tr>
</tbody></table>
</li>
<li><p>用一个场景来理解</p>
<ol>
<li><p>场景 1：前端和后端运行在不同的端口（开发时最常见！）</p>
<ul>
<li>你用 <strong>React &#x2F; Vue</strong> 写了一个前端项目，运行在：<code>http://localhost:3000</code>（前端页面）</li>
<li>你的 <strong>后端 API 服务</strong>（比如 Node.js、Java Spring、Python Django）运行在：<code>http://localhost:8080</code>或 <code>http://localhost:3001</code></li>
</ul>
</li>
<li><p>你前端代码中发起请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;http://localhost:8080/api/data&#x27;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>会发生什么？</p>
<ul>
<li>请求确实发到了后端（你可以在后端看到请求日志），</li>
<li>但浏览器收到响应后一看：“咦？你前端是 <code>localhost:3000</code>，却去访问 <code>localhost:8080</code>，<strong>端口不同，属于跨域！</strong>”</li>
<li>于是浏览器就把响应拦下来了，你的 JavaScript 拿不到返回的数据！</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>有什么问题？举个例子</p>
</li>
<li><p>怎么解决</p>
<ol>
<li><p><strong>CORS（跨域资源共享，主流推荐方案）</strong></p>
<ol>
<li>CORS（Cross-Origin Resource Sharing） 是 W3C 标准，通过后端设置一些 HTTP 响应头，告诉浏览器：“这个跨域请求我是允许的”。</li>
<li>后端需要设置的常见响应头：</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Access-Control-Allow-Origin: *</code>或 <code>http://your-frontend-domain.com</code></td>
<td align="left">表示允许哪些来源的网站访问资源。 <code>*</code>表示允许所有（不推荐在生产用，尤其带 Cookie 时） 最好明确指定域名，如 <code>http://localhost:3000</code></td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</code></td>
<td align="left">允许的 HTTP 方法</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Headers: Content-Type, Authorization</code></td>
<td align="left">允许的请求头</td>
</tr>
<tr>
<td align="left"><code>Access-Control-Allow-Credentials: true</code></td>
<td align="left">是否允许发送 Cookie（需前端也设置 <code>withCredentials: true</code>）</td>
</tr>
</tbody></table>
<ol start="3">
<li>后端示例（以 Node.js&#x2F;Express 为例）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:3000&quot;</span>); <span class="comment">// 或 *</span></span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST, PUT, DELETE&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type, Authorization&quot;</span>);</span><br><span class="line">  res.header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 如需传 cookie</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ 只要后端正确配置了 CORS 头，浏览器就允许跨域请求！</p>
</blockquote>
<ol start="2">
<li><p><strong>代理服务器（Proxy）【开发常用】</strong></p>
<ol>
<li><p>在开发环境中，前端代码和后端 API 往往不在一个域，但你可以：</p>
<ol>
<li>通过 webpack devServer、vite、nginx 等设置代理，将前端发出的请求转发到目标 API 服务器，从而<strong>避免浏览器直接跨域</strong></li>
<li>反向代理的核心作用就是：让前端和后端都使用同一个域名和端口（比如 <code>http://localhost:3000</code>或 <code>https://www.yoursite.com</code>），让浏览器认为它访问的就是同源的资源，从而避免跨域问题。</li>
</ol>
</li>
<li><p>例子：Vue&#x2F;React 开发时配置代理（以 vite &#x2F; webpack 为例）</p>
<p>vite.config.js 或 webpack.config.js 中配置代理：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line">export <span class="keyword">default</span> <span class="title function_">defineConfig</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">  server: &#123;</span></span><br><span class="line"><span class="params">    proxy: &#123;</span></span><br><span class="line"><span class="params">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span></span><br><span class="line"><span class="params">        target: <span class="string">&#x27;http://backend-api-server.com&#x27;</span>, // 后端真实地址</span></span><br><span class="line"><span class="params">        changeOrigin: <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">        rewrite: (path)</span> =&gt; path.replace(/^\/api/, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，前端代码中请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;/api/user&#x27;)  // 不是跨域！代理服务器会转发到 http://backend-api-server.com/user</span><br></pre></td></tr></table></figure>

<p>优点：前端无需关心跨域，由代理服务器解决</p>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在讲 <strong>反向代理</strong> 之前，先简单了解一下什么是 <strong>代理（Proxy）</strong>。</p>
<ol>
<li><p><strong>正向代理（Forward Proxy）</strong></p>
<ol>
<li><p>正向代理 是位于 客户端（用户） 和 互联网 之间的代理，代表客户端去访问服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>访问被墙的网站（比如通过代理服务器访问 Google）</p>
</li>
<li><p>隐藏客户端的真实 IP</p>
</li>
<li><p>企业内网上网控制</p>
</li>
</ul>
</li>
<li><p>谁用代理：客户端（用户）主动设置代理</p>
</li>
<li><p>举例：</p>
<ol>
<li>你（客户端）想访问某个网站，但不想直接暴露自己，于是你通过一个代理服务器去访问，代理帮你请求网站，再将结果返回给你。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>反向代理（Reverse Proxy）</strong></p>
<ol>
<li><p>反向代理：是位于 客户端（用户） 和 后端服务器（如你的应用服务器） 之间的代理，代表服务器接收客户端的请求，并将其转发给内部的服务器。</p>
</li>
<li><p>常见用途：</p>
<ul>
<li><p>保护后端服务，隐藏其真实 IP 和端口</p>
</li>
<li><p>实现 负载均衡</p>
</li>
<li><p>提供 统一入口（比如通过域名访问多个服务）</p>
</li>
<li><p>处理 SSL&#x2F;TLS 加密（HTTPS）</p>
</li>
<li><p>缓存、压缩、静态文件服务</p>
</li>
<li><p>实现 反向代理路由（如根据路径转发到不同后端）</p>
</li>
</ul>
</li>
<li><p>谁用代理：是服务器端设置的，对客户端透明（不可见）</p>
</li>
<li><p>意义</p>
<ol>
<li><p>隐藏后端服务的真实 IP 和端口</p>
<ul>
<li>用户只访问 <code>https://www.yourdomain.com</code>，不知道后端是运行在哪个端口或机器上的。</li>
<li>提升安全性，避免直接将后端服务暴露在公网。</li>
</ul>
</li>
<li><p>统一入口，多服务路由</p>
</li>
</ol>
<ul>
<li>你可以用 Nginx 将不同的请求路径转发到不同的后端服务，比如：<code>/api</code>→ Node.js 后端<code>/admin</code>→ Java 后台<code>/static</code>→ Nginx 直接返回静态文件</li>
</ul>
<ol start="3">
<li>负载均衡</li>
</ol>
<ul>
<li><p>将请求分发到多个后端实例，提高系统的可用性和性能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 127.0.0.1:3000;</span><br><span class="line">    server 127.0.0.1:3001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>处理 HTTPS &#x2F; SSL 加密</li>
</ol>
<ul>
<li>你可以通过 Nginx 配置 SSL 证书，让用户通过 <code>https://</code>安全访问，而不用在后端服务里处理复杂的 HTTPS 配置。</li>
</ul>
<ol start="5">
<li>静态资源服务</li>
</ol>
<ul>
<li>Nginx 非常擅长快速返回 HTML、CSS、JS、图片等静态文件，比 Node.js 或 Java 服务效率更高。</li>
</ul>
<ol start="6">
<li>缓存、压缩、安全防护等高级功能</li>
</ol>
<ul>
<li>Nginx 还提供访问控制、防爬虫、GZIP 压缩、缓存、限流等能力。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><ol>
<li>为什么要了解零拷贝<ol>
<li>在传统的数据传输过程中，数据通常需要在 内存、CPU、内核缓冲区、用户缓冲区、网卡缓冲区 等多个地方多次 拷贝，并且伴随着多次 CPU 上下文切换，这样会带来很大的 性能开销。</li>
<li>而 零拷贝技术的核心目标就是：尽可能减少数据在内存中的拷贝次数，避免不必要的 CPU 拷贝和上下文切换，从而提升数据传输效率，降低延迟和 CPU 占用。</li>
</ol>
</li>
<li>什么是零拷贝<ol>
<li>零拷贝的核心思想是：<ol>
<li>尽量减少甚至避免数据在内存中的冗余拷贝，尤其是避免数据在 用户态 和 内核态 之间的 CPU 拷贝，从而提升性能</li>
<li>它并不一定意味着 完全没有数据拷贝（物理上可能还是会有 DMA 拷贝），而是 尽量减少 CPU 参与的拷贝次数，尤其是用户态与内核态之间的拷贝。</li>
</ol>
</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251025175854459.png" alt="image-20251025175854459"></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java开发生态学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:05:34" itemprop="dateModified" datetime="2025-12-03T17:05:34+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li><p>目录结构：</p>
<ol>
<li><p><strong><code>/bin</code></strong></p>
<ul>
<li>存放常用的二进制可执行文件（命令），如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>cat</code>。</li>
<li>所有用户都可以使用。</li>
</ul>
</li>
<li><p><strong><code>/sbin</code></strong></p>
<ul>
<li>存放系统管理用的二进制程序，如 <code>reboot</code>、<code>ifconfig</code>。</li>
<li>一般由 root 管理员使用。</li>
</ul>
</li>
<li><p><strong><code>/boot</code></strong></p>
<ul>
<li>启动相关文件，比如内核 <code>vmlinuz</code>、引导程序 <code>grub</code> 配置。</li>
<li>系统开机时最先用到。</li>
</ul>
</li>
<li><p><strong><code>/dev</code></strong></p>
<ul>
<li>存放设备文件（不是实际的硬件，而是设备接口）。</li>
<li>比如 <code>/dev/sda</code>（硬盘）、<code>/dev/tty</code>（终端）、<code>/dev/null</code>。</li>
</ul>
</li>
<li><p><strong><code>/etc</code></strong></p>
<ul>
<li>存放系统配置文件，例如：<ul>
<li><code>/etc/passwd</code> 用户信息</li>
<li><code>/etc/fstab</code> 磁盘挂载</li>
<li><code>/etc/apt/</code> apt 软件源配置</li>
</ul>
</li>
<li>里面通常没有二进制程序，主要是文本配置文件。</li>
</ul>
</li>
<li><p><strong><code>/home</code></strong></p>
<ul>
<li>普通用户的主目录。</li>
<li>例如用户 <code>hua</code> 的主目录是 <code>/home/hua</code>，里面存放桌面、下载、配置等。</li>
</ul>
</li>
<li><p><strong><code>/lib</code></strong></p>
<ul>
<li>存放系统运行所需的共享库文件（类似 Windows 的 DLL）。</li>
<li>比如 <code>/lib/x86_64-linux-gnu/</code>。</li>
</ul>
</li>
<li><p><strong><code>/media</code></strong></p>
<ul>
<li>挂载点目录，系统自动挂载 U 盘、光盘时会放在这里。</li>
<li>如 <code>/media/username/USB_DRIVE</code>。</li>
</ul>
</li>
<li><p><strong><code>/mnt</code></strong></p>
<ul>
<li>传统的临时挂载点，管理员手动挂载磁盘时常用。</li>
</ul>
</li>
<li><p><strong><code>/opt</code></strong></p>
<ul>
<li>第三方应用软件目录。</li>
<li>比如你单独安装的软件可能放在 <code>/opt/google/chrome/</code>。</li>
</ul>
</li>
<li><p><strong><code>/proc</code></strong></p>
<ul>
<li>虚拟文件系统，内核和进程信息接口。</li>
<li>比如 <code>/proc/cpuinfo</code> 查看 CPU 信息，<code>/proc/meminfo</code> 查看内存信息。</li>
</ul>
</li>
<li><p><strong><code>/root</code></strong></p>
<ul>
<li>root 管理员的主目录（类似 <code>/home/root</code>）。</li>
</ul>
</li>
<li><p><strong><code>/run</code></strong></p>
<ul>
<li>存放系统运行时数据（PID 文件、socket 等）。</li>
<li>系统重启后会清空。</li>
</ul>
</li>
<li><p><strong><code>/srv</code></strong></p>
<ul>
<li>存放一些服务（service）运行需要的数据，如 FTP、HTTP 服务器数据。</li>
</ul>
</li>
<li><p><strong><code>/sys</code></strong></p>
<ul>
<li>内核接口虚拟文件系统，提供硬件信息和控制。</li>
<li>比如 <code>/sys/class/net/</code> 可以看到网卡信息。</li>
</ul>
</li>
<li><p><strong><code>/tmp</code></strong></p>
<ul>
<li>临时文件目录，任何用户都可使用。</li>
<li>重启后一般会被清空。</li>
</ul>
</li>
<li><p><strong><code>/usr</code></strong></p>
<ul>
<li>最庞大的目录，存放用户软件与资源。</li>
<li>细分为：<ul>
<li><code>/usr/bin</code>：用户程序</li>
<li><code>/usr/sbin</code>：管理员程序</li>
<li><code>/usr/lib</code>：库文件</li>
<li><code>/usr/share</code>：共享数据、文档、图标</li>
<li><code>/usr/local</code>：用户本地安装的软件</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>/var</code></strong></p>
<ul>
<li>存放可变数据（log 日志、缓存、邮件、数据库等）。</li>
<li>例如：<ul>
<li><code>/var/log</code>：系统日志</li>
<li><code>/var/tmp</code>：临时文件</li>
<li><code>/var/www</code>：网站文件（如果装了 Apache&#x2F;Nginx）</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ol>
<li><pre><code>小总结：

程序相关：/bin /sbin /lib /usr /opt

配置相关：/etc

用户相关：/home /root

运行相关：/proc /sys /dev /run /tmp

数据相关：/var /srv /media /mnt
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       2. </span><br><span class="line"></span><br><span class="line">### git</span><br><span class="line"></span><br><span class="line">1. 是什么</span><br><span class="line"></span><br><span class="line">   1. Git 是一个**分布式版本控制系统**，用于跟踪文件的变化，协调多人协作开发，管理项目的历史版本。</span><br><span class="line">   2. 核心概念</span><br><span class="line">      1. **仓库（Repository / Repo）**一个 Git 仓库就是项目文件加上其版本历史记录的集合。可以是本地仓库（Local Repository），也可以是远程仓库（Remote Repository，如 GitHub、GitLab 等）。</span><br><span class="line">      2. **提交（Commit）**每次对文件的修改，当你觉得可以保存一个版本时，就可以做一个“提交”。每个提交都有一个唯一的 SHA-1 哈希值，记录了该版本的所有更改内容及提交信息。</span><br><span class="line">      3. **分支（Branch）**分支是独立开发线，允许你在不影响主线（通常是 `main`或 `master`）的情况下进行新功能开发或修复。默认分支通常是 `main`或 `master`。</span><br><span class="line">      4. **工作区、暂存区、版本库</span><br><span class="line">         1. **工作区（Working Directory）**：你直接编辑的文件区域。</span><br><span class="line">         2. **暂存区（Stage/Index）**：通过 `git add`将要提交的变更放入暂存区。</span><br><span class="line">         3. **版本库（Repository）**：通过 `git commit`将暂存区的变更保存到本地仓库中。</span><br><span class="line">      5. **远程仓库（Remote）**托管在网络上的仓库，比如 GitHub 上的项目，可以通过 `git remote`进行关联。</span><br><span class="line"></span><br><span class="line">2. 常用命令</span><br><span class="line"></span><br><span class="line">   1. 配置 Git</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<p>   git config –global user.name “你的名字”<br>   git config –global user.email “你的邮箱”<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 设置全局用户信息，每次提交都会记录是谁提交的。</span><br><span class="line"></span><br><span class="line">查看配置：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git config –list<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">2. 创建仓库</span><br><span class="line"></span><br><span class="line">   初始化一个新的 Git 仓库：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git init<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">克隆一个远程仓库：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git clone &lt;远程仓库地址&gt;</p>
<h1 id="例如：git-clone-https-github-com-username-repo-git"><a href="#例如：git-clone-https-github-com-username-repo-git" class="headerlink" title="例如：git clone https://github.com/username/repo.git"></a>例如：git clone <a target="_blank" rel="noopener" href="https://github.com/username/repo.git">https://github.com/username/repo.git</a></h1>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">3. 查看状态与日志</span><br><span class="line"></span><br><span class="line">   查看当前仓库的状态（哪些文件被修改、暂存等）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   git status<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看提交历史：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git log</p>
<h1 id="简洁版日志"><a href="#简洁版日志" class="headerlink" title="简洁版日志"></a>简洁版日志</h1><p>   git log –oneline<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">4. 添加与提交</span><br><span class="line"></span><br><span class="line">   将工作区的修改添加到暂存区：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git add &lt;文件名&gt;</p>
<h1 id="例如：git-add-index-html"><a href="#例如：git-add-index-html" class="headerlink" title="例如：git add index.html"></a>例如：git add index.html</h1><h1 id="添加所有修改的文件"><a href="#添加所有修改的文件" class="headerlink" title="添加所有修改的文件"></a>添加所有修改的文件</h1><p>   git add .<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提交暂存区的修改到本地仓库：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git commit -m “提交说明”<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">5. 分支操作</span><br><span class="line"></span><br><span class="line">   查看当前分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git branch<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建新分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git branch &lt;分支名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">切换分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git checkout &lt;分支名&gt;</p>
<h1 id="或者使用更现代的命令"><a href="#或者使用更现代的命令" class="headerlink" title="或者使用更现代的命令"></a>或者使用更现代的命令</h1><p>   git switch &lt;分支名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">创建并切换到新分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git checkout -b &lt;新分支名&gt;</p>
<h1 id="或"><a href="#或" class="headerlink" title="或"></a>或</h1><p>   git switch -c &lt;新分支名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">合并分支（通常在主分支上合并其他分支）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git merge &lt;要合并的分支名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git branch -d &lt;分支名&gt;</p>
<h1 id="强制删除未合并的分支"><a href="#强制删除未合并的分支" class="headerlink" title="强制删除未合并的分支"></a>强制删除未合并的分支</h1><p>   git branch -D &lt;分支名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">6. 与远程仓库交互</span><br><span class="line"></span><br><span class="line">   查看远程仓库：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git remote -v<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">添加远程仓库：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git remote add origin &lt;远程仓库地址&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推送本地分支到远程：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git push -u origin &lt;分支名&gt;</p>
<h1 id="第一次推送时使用-u-设置上游分支"><a href="#第一次推送时使用-u-设置上游分支" class="headerlink" title="第一次推送时使用 -u 设置上游分支"></a>第一次推送时使用 -u 设置上游分支</h1><h1 id="之后可以直接使用-git-push"><a href="#之后可以直接使用-git-push" class="headerlink" title="之后可以直接使用 git push"></a>之后可以直接使用 git push</h1>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从远程拉取更新（拉取并尝试合并）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   git pull<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从远程获取更新（不自动合并）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git fetch<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">7. 撤销与回退</span><br><span class="line"></span><br><span class="line">   撤销工作区的修改（未 add）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git checkout – &lt;文件名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">撤销暂存区的修改（已 add 但未 commit）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git reset HEAD &lt;文件名&gt;<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">回退到某个提交（谨慎使用！会修改历史）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git reset –hard <commit-id><br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看所有提交记录，找到想要的 commit-id：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git log –oneline<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">8. 其他实用命令</span><br><span class="line"></span><br><span class="line">   比较差异：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git diff</p>
<h1 id="比较工作区和暂存区"><a href="#比较工作区和暂存区" class="headerlink" title="比较工作区和暂存区"></a>比较工作区和暂存区</h1><p>   git diff –staged</p>
<h1 id="比较暂存区和最新提交"><a href="#比较暂存区和最新提交" class="headerlink" title="比较暂存区和最新提交"></a>比较暂存区和最新提交</h1>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">储藏当前修改（临时保存，用于切换分支等场景）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   git stash<br>   git stash pop<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看远程分支：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git branch -r<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看所有分支（本地+远程）：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   git branch -a<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### maven</span><br><span class="line"></span><br><span class="line">1. 是什么</span><br><span class="line"></span><br><span class="line">   1. **Apache Maven** 是一个 项目管理和构建自动化工具，主要用于 Java 项目，但也可以用于其他语言的项目。</span><br><span class="line">   2. 它基于 项目对象模型（POM, Project Object Model） 的概念，通过一个名为 `pom.xml`的配置文件来管理项目的 构建、依赖、文档、报告、发布 等各个方面。</span><br><span class="line"></span><br><span class="line">2. 主要功能</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 功能                                  | 说明                                                       |</span><br><span class="line">      | :------------------------------------ | :--------------------------------------------------------- |</span><br><span class="line">      | **依赖管理（Dependency Management）** | 自动下载和管理项目所需的第三方库（jar 包），无需手动导入。 |</span><br><span class="line">      | **标准化的项目结构**                  | Maven 规定了统一的目录结构，便于团队协作和工具支持。       |</span><br><span class="line">      | **构建生命周期（Build Lifecycle）**   | 定义了清晰的构建过程，如编译、测试、打包、部署等。         |</span><br><span class="line">      | **插件机制（Plugins）**               | 支持各种插件来扩展功能，如编译插件、打包插件、测试插件等。 |</span><br><span class="line">      | **多模块项目管理（Multi-module）**    | 支持将一个大项目拆分为多个子模块，便于管理和复用。         |</span><br><span class="line">      | **一键构建与部署**                    | 通过简单的命令即可完成编译、测试、打包、发布等操作。       |</span><br><span class="line"></span><br><span class="line">3. 核心概念</span><br><span class="line"></span><br><span class="line">   1. **POM（Project Object Model）**</span><br><span class="line">      1. Maven 项目的核心配置文件，名称固定为：`pom.xml`</span><br><span class="line">      2. 定义了项目的基本信息、依赖、插件、构建配置等。</span><br><span class="line">      3. 所有的 Maven 项目都围绕 POM 文件来管理。</span><br><span class="line"></span><br><span class="line">   2. **坐标（Coordinates）**</span><br><span class="line"></span><br><span class="line">      1. 每个依赖库（第三方 jar 包）都通过一组唯一标识来定位，称为 **Maven 坐标**，包括：</span><br><span class="line"></span><br><span class="line">         - **groupId**：组织或公司名，如 `org.springframework`</span><br><span class="line"></span><br><span class="line">         - **artifactId**：项目或模块名称，如 `spring-core`</span><br><span class="line"></span><br><span class="line">         - **version**：版本号，如 `5.3.10`</span><br><span class="line"></span><br><span class="line">           - 示例：</span><br><span class="line"></span><br><span class="line">           - ```xml</span><br><span class="line">             &lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">                 &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">                 &lt;version&gt;5.3.10&lt;/version&gt;</span><br><span class="line">             &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li><p><strong>仓库（Repositories）</strong></p>
<p>Maven 从仓库中下载依赖包，分为：</p>
<ul>
<li><strong>本地仓库（Local Repository）</strong>：在你电脑上的一个目录（默认是 <code>~/.m2/repository</code>），存放已下载的 jar 包。</li>
<li><strong>中央仓库（Central Repository）</strong>：Maven 官方维护的远程仓库，地址是 <a target="_blank" rel="noopener" href="https://repo.maven.apache.org,包含绝大多数开源/">https://repo.maven.apache.org，包含绝大多数开源</a> Java 库。</li>
<li><strong>私服（Nexus、JFrog 等）</strong>：企业内部搭建的 Maven 仓库，用于管理内部共享的 jar 包。</li>
</ul>
</li>
<li><p><strong>构建生命周期（Build Lifecycle）</strong></p>
<p>Maven 的构建过程分为几个标准的生命周期阶段（Phases），常用的有：</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>validate</code></td>
<td align="left">验证项目是否正确，所需信息是否完整</td>
</tr>
<tr>
<td align="left"><code>compile</code></td>
<td align="left">编译源代码（通常是我们写的 java 代码）</td>
</tr>
<tr>
<td align="left"><code>test</code></td>
<td align="left">运行单元测试（使用 JUnit 等）</td>
</tr>
<tr>
<td align="left"><code>package</code></td>
<td align="left">打包，如生成 jar、war 文件</td>
</tr>
<tr>
<td align="left"><code>install</code></td>
<td align="left">将打包结果安装到本地仓库，供其他项目使用</td>
</tr>
<tr>
<td align="left"><code>deploy</code></td>
<td align="left">将最终包发布到远程仓库（如 Nexus）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>你运行某个阶段时，Maven 会自动执行它之前的所有阶段。</p>
<p>例如运行 <code>mvn install</code>，会依次执行 validate → compile → test → package → install。</p>
</blockquote>
<ol start="4">
<li><p>常用命令</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>mvn clean</code></td>
<td align="left">清理 target 目录，删除之前构建的文件</td>
</tr>
<tr>
<td align="left"><code>mvn compile</code></td>
<td align="left">编译主代码（src&#x2F;main&#x2F;java）</td>
</tr>
<tr>
<td align="left"><code>mvn test</code></td>
<td align="left">编译并运行测试代码（src&#x2F;test&#x2F;java）</td>
</tr>
<tr>
<td align="left"><code>mvn package</code></td>
<td align="left">打包项目，生成 jar&#x2F;war 文件（在 target&#x2F; 目录下）</td>
</tr>
<tr>
<td align="left"><code>mvn install</code></td>
<td align="left">打包并安装到本地仓库，供其他项目依赖</td>
</tr>
<tr>
<td align="left"><code>mvn deploy</code></td>
<td align="left">打包并发布到远程仓库（一般用于发布正式版本）</td>
</tr>
<tr>
<td align="left"><code>mvn dependency:tree</code></td>
<td align="left">查看项目的依赖树，排查依赖冲突</td>
</tr>
<tr>
<td align="left"><code>mvn help:effective-pom</code></td>
<td align="left">查看生效的 POM 配置（包含继承与默认配置）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>maven默认项目结构</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">用途</th>
<th align="left">目录</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">源代码</td>
<td align="left"><code>src/main/java</code></td>
<td align="left">项目的 Java 源代码</td>
</tr>
<tr>
<td align="left">资源文件</td>
<td align="left"><code>src/main/resources</code></td>
<td align="left">配置文件，如 <code>.properties</code>, <code>.xml</code>等</td>
</tr>
<tr>
<td align="left">测试代码</td>
<td align="left"><code>src/test/java</code></td>
<td align="left">单元测试代码，如 JUnit</td>
</tr>
<tr>
<td align="left">测试资源</td>
<td align="left"><code>src/test/resources</code></td>
<td align="left">测试用的配置文件</td>
</tr>
<tr>
<td align="left">构建输出</td>
<td align="left"><code>target/</code></td>
<td align="left">编译后的 class 文件、打包的 jar&#x2F;war 等都放在这里（自动生成）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>pom文件解析</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">元素</th>
<th align="left">是否必需</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>&lt;project&gt;</code></strong></td>
<td align="left">✅ 必需</td>
<td align="left">整个 POM 文件的根元素。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;modelVersion&gt;</code></strong></td>
<td align="left">✅ 必需</td>
<td align="left">POM 模型的版本，目前固定为 <code>4.0.0</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;groupId&gt;</code></strong></td>
<td align="left">✅ 必需</td>
<td align="left">项目所属的组织或公司，通常是反转的域名，如：<code>com.example</code>、<code>org.springframework</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;artifactId&gt;</code></strong></td>
<td align="left">✅ 必需</td>
<td align="left">项目&#x2F;模块的名称，通常是项目名，如：<code>my-app</code>、<code>user-service</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;version&gt;</code></strong></td>
<td align="left">✅ 必需</td>
<td align="left">项目的版本号，如：<code>1.0.0</code>、<code>1.0-SNAPSHOT</code>（SNAPSHOT 表示开发中的快照版本）。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;packaging&gt;</code></strong></td>
<td align="left">❌ 可选，默认为 <code>jar</code></td>
<td align="left">项目的打包方式，常见有： • <code>jar</code>（默认）：普通 Java 应用 • <code>war</code>：Web 应用 • <code>pom</code>：父模块（用于多模块管理）</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;name&gt;</code></strong></td>
<td align="left">❌ 可选</td>
<td align="left">项目名称，用于展示，非必须。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;description&gt;</code></strong></td>
<td align="left">❌ 可选</td>
<td align="left">项目描述信息。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;dependencies&gt;</code></strong></td>
<td align="left">❌ 可选</td>
<td align="left">定义项目所依赖的第三方库（jar 包）。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;dependency&gt;</code></strong></td>
<td align="left">在 <code>&lt;dependencies&gt;</code>中使用</td>
<td align="left">每一个依赖项，包括 <code>groupId</code>、<code>artifactId</code>、<code>version</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;build&gt;</code></strong></td>
<td align="left">❌ 可选</td>
<td align="left">定义项目的构建配置，比如编译器版本、插件配置等。</td>
</tr>
<tr>
<td align="left"><strong><code>&lt;plugins&gt;</code></strong></td>
<td align="left">在 <code>&lt;build&gt;</code>中使用</td>
<td align="left">定义要使用的 Maven 插件及其配置，如编译插件、打包插件等。</td>
</tr>
</tbody></table>
</li>
<li><p>项目坐标（GAV）</p>
<p>Maven 通过以下三个属性来唯一标识一个项目，称为 <strong>GAV 坐标</strong>：</p>
<table>
<thead>
<tr>
<th align="left">元素</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>groupId</strong></td>
<td align="left">项目所属组织，通常是反转域名</td>
<td align="left"><code>com.example</code>、<code>org.apache</code></td>
</tr>
<tr>
<td align="left"><strong>artifactId</strong></td>
<td align="left">项目&#x2F;模块名称</td>
<td align="left"><code>my-app</code>、<code>spring-core</code></td>
</tr>
<tr>
<td align="left"><strong>version</strong></td>
<td align="left">项目版本</td>
<td align="left"><code>1.0.0</code>、<code>2.5.4-SNAPSHOT</code></td>
</tr>
</tbody></table>
<blockquote>
<p>这三个属性合起来就像项目的身份证，Maven 通过它们去仓库中找到对应的 jar 包或项目。</p>
</blockquote>
<hr>
</li>
<li><p>依赖管理 <code>&lt;dependencies&gt;</code></p>
<p>通过 <code>&lt;dependencies&gt;</code>声明项目所需的第三方库，Maven 会自动从本地仓库或远程仓库下载这些依赖。</p>
<p>示例：引入 JUnit（测试框架）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!-- 表示只在测试时使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>scope（作用域）</strong> 可选值：<code>compile</code>（默认）：编译、测试、运行都有效<code>provided</code>：编译和测试时有效，运行时由容器提供（如 Servlet API）<code>runtime</code>：运行和测试时有效，编译时不需要<code>test</code>：仅在测试代码中有效（如 JUnit）</li>
</ul>
</li>
<li><p>构建配置 <code>&lt;build&gt;</code></p>
<ol>
<li>用于配置项目的构建过程，比如指定 Java 版本、使用特定插件等。</li>
<li>示例：配置 Java 编译版本为 11</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这会告诉 Maven：“请使用 JDK 11 来编译我的代码”。</p>
<hr>
</li>
<li><p>属性（Properties）</p>
<p>可以定义一些变量，便于统一管理版本号等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ol>
<li>是什么<ol>
<li>非关系型数据库</li>
<li>数据结构灵活，没有了“列”概念</li>
<li>存储的单元叫“文档”（Document）</li>
</ol>
</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li>数据库和服务之间的中间件，用以提高并发量。</li>
<li>本地缓存<ol>
<li>工作逻辑类比cache，工作原理K-V</li>
</ol>
</li>
<li>远程缓存<ol>
<li>业务逻辑需要多个实例。但是如果一个商品的多个实例都有缓存的话就浪费空间了。于是需要一个远程缓存。</li>
<li>并发问题：通过单线程避免。</li>
</ol>
</li>
<li>支持多种数据结构：不只是string&lt;&#x3D;&gt;string，允许先进先出的List，去重的Set，排序的ZSet</li>
<li>内存过期、内存淘汰：参考cache的淘汰策略</li>
<li>持久化：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250916142637090.png"><ol>
<li>需要避免当缓存重启后没有内存数据，让所有业务全部交给数据库导致崩溃。</li>
<li>定期将缓存数据转储到磁盘文件中。</li>
</ol>
</li>
<li>简化网络协议</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><ol>
<li>倒排索引（inverted index）</li>
<li>term index<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250924222402373.png" alt="image-20250924222402373"></li>
</ol>
</li>
<li>Stored Fields<ol>
<li>存放文本本身的地方</li>
<li>行式存储</li>
</ol>
</li>
<li>Doc Values<ol>
<li>将散落在文档中的某个字段集中存放（比如你要排序啥的）</li>
<li>列式存储</li>
</ol>
</li>
<li>Segment<ol>
<li>对上面的信息的封装</li>
<li>是能够实现搜索的最小单元</li>
<li>segment只读，不可修改。如果要修改，则生成新的segment。这样做避免了并发写带来的低效。</li>
</ol>
</li>
<li>Lucene：<ol>
<li>一个开源基础搜索库，单机文本搜索库</li>
</ol>
</li>
<li>Elastic Search<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250924223517546.png" alt="image-20250924223517546"><ol>
<li>对Lucene扩展之后，得到了高并发高可用持久化的分布式搜索引擎</li>
</ol>
</li>
</ol>
<h2 id="部署运维"><a href="#部署运维" class="headerlink" title="部署运维"></a>部署运维</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol>
<li><p>Docker是什么？</p>
<ol>
<li>是一个 <strong>容器化平台</strong>（一个客户端和服务端的中间件），可以把你的应用程序和它所依赖的环境（运行时、库、配置）打包成一个 <strong>镜像（image）</strong>，然后运行在一个轻量级的 <strong>容器（container）</strong> 里。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915132417733.png" alt="image-20250915132417733"></li>
<li>和虚拟机不同，Docker 容器不需要完整的操作系统，而是共享宿主机的内核。</li>
</ol>
</li>
<li><p>镜像是什么？</p>
<ol>
<li>程序的运行依赖于环境，而操作系统是环境的重要部分。操作系统分为用户空间和内核空间，运行程序只需要关注用户空间。</li>
<li>为了能运行程序，docker把程序所依赖的环境一起打包，“压缩”成一个“压缩文件”，称为镜像。</li>
</ol>
</li>
<li><p>容器是什么？</p>
<ol>
<li>镜像通过docker run把镜像“解压缩”之后的一个独立的环境和程序。</li>
<li>一个操作系统内核可以运行多个容器</li>
</ol>
</li>
<li><p>Dockerfile是什么？</p>
<ol>
<li>从安装镜像到程序运行中间还有一些准备工作要做，就像制定镜像、创建文件夹之类的。而Linux中所有任务都可以通过命令行实现，所以用Dockerfile把准备工作列出来，像一个ToDoList，然后交给程序运行。</li>
</ol>
</li>
<li><p>registry是什么？</p>
<ol>
<li>管理镜像仓库推拉能力的服务。</li>
</ol>
</li>
<li><p>docker的架构原理：client-server架构</p>
<ol>
<li>client：docker-cli（我们在命令行输入的命令就是docker-cli）<ol>
<li>常见命令：<ol>
<li>docker build：docker会根据Dockerfile指令一层层构建容器镜像文件</li>
<li>docker push &#x2F; pull：docker会通过外部registry交互推拉镜像文件</li>
<li>docker run：会调用Containerd组件来驱使runC组件来创建和运行容器<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915134257450.png" alt="image-20250915134257450"></li>
</ol>
</li>
</ol>
</li>
<li>server：docker daemon（守护进程）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915133740199.png" alt="image-20250915133740199"><ol>
<li>核心职责：解析命令，创建和管理各个容器。</li>
<li>docker daemon可以分为docker server（就是一个HTTP服务器），Engine（用于指派Job），Job（实际执行各种工作）</li>
</ol>
</li>
</ol>
</li>
<li><p>docker compose是什么</p>
<ol>
<li>如果说docker是管理一个容器，则docker compose是管理多个容器</li>
<li>需要部署一套多个容器时，一个个docker run很不方便。</li>
<li>可以通过yaml文件写清楚要部署的文件有哪些，部署顺序，占多少cpu等等。</li>
<li>最后通过docker-compose up命令自动化部署</li>
</ol>
</li>
<li><p>docker swarm是什么</p>
<ol>
<li>如果说docker compose是管理一套服务多个容器，docker swarm就是管理多套服务和多个服务器。</li>
<li>如果某台服务器炸了，那么就把上面的服务迁移到另外一套服务器上。</li>
<li>也可以根据需要对服务扩缩容。</li>
</ol>
</li>
<li><p>docker和k8s的关系</p>
<ol>
<li>k8s原来是docker swarm的竞品（）功能很像。</li>
<li>docker compose &lt;&#x3D; 类比 &#x3D;&gt; Pod</li>
<li>docker swarm &lt;&#x3D; 类比 &#x3D;&gt; k8s</li>
</ol>
</li>
<li><p>常用命令</p>
<ol>
<li><p>镜像（Image）管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">***docker pull ubuntu:22.04         # 拉取镜像</span><br><span class="line">***docker images                    # 列出本地镜像</span><br><span class="line">***docker rmi &lt;image_id&gt;            # 删除镜像</span><br><span class="line">*docker tag &lt;image_id&gt; myapp:v1   # 给镜像打标签</span><br><span class="line">*docker build -t myapp:v1 .       # 用 Dockerfile 构建镜像</span><br><span class="line">docker save -o &lt;image_id&gt; filename.tar         # 保存镜像为.tar文件</span><br><span class="line">docker load -i &lt;image_id&gt; filename.tar</span><br></pre></td></tr></table></figure>

<hr>
<p>容器（Container）管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:22.04 bash   # 运行交互式容器并进入 bash</span><br><span class="line">***docker run --name=my_nginx_01 --restart=always -d -p 8080:80 nginx     # 后台运行 nginx，映射端口</span><br><span class="line">***docker ps                          # 查看正在运行的容器</span><br><span class="line">**docker ps -a                       # 查看所有容器（包括已退出）</span><br><span class="line">***docker stop &lt;container_id&gt;         # 停止容器</span><br><span class="line">***docker start &lt;container_id&gt;        # 启动已停止的容器</span><br><span class="line">***docker restart &lt;container_id&gt;      # 重启容器</span><br><span class="line">***docker rm &lt;container_id&gt;           # 删除容器</span><br><span class="line">**docker exec -it &lt;id&gt; bash          # 进入正在运行的容器</span><br><span class="line">docker logs -f &lt;container_id&gt;      # 查看容器日志（实时跟随）</span><br><span class="line">docker cp &lt;id&gt;:/path /path    # 把容器内的内容复制出来。也可以交换路径顺序，表示复制进去。</span><br></pre></td></tr></table></figure>

<hr>
<p> 日常组合示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 拉取 Nginx 并运行</span><br><span class="line">docker run -d --name web -p 8080:80 nginx</span><br><span class="line"></span><br><span class="line"># 构建并运行本地项目</span><br><span class="line">docker build -t myapp:v1 .</span><br><span class="line">docker run -d -p 5000:5000 myapp:v1</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ol>
<li>是一个高性能 Web 服务器和反向代理服务器（一个客户端和服务端的中间件）。</li>
<li>nginx 的主要功能<ol>
<li>Web 服务器<ul>
<li>可以直接提供静态资源（HTML、CSS、JS、图片等）。</li>
</ul>
</li>
<li>反向代理 &#x2F; 负载均衡<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250914173532423.png" alt="image-20250914173532423"><ul>
<li>接收用户请求，然后把请求转发给后端（如 Node.js、Java、Python 应用）。</li>
<li>可以把流量分配给多台后端服务器，实现负载均衡。</li>
</ul>
</li>
<li>缓存功能<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250914174059346.png" alt="image-20250914174059346"><ul>
<li>静态资源缓存，减少后端压力。</li>
</ul>
</li>
<li>模块化网管能力<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250914174201047.png" alt="image-20250914174201047"></li>
<li>SSL&#x2F;TLS<ul>
<li>可以做 HTTPS 加密终端，统一管理证书。</li>
</ul>
</li>
<li>高并发<ul>
<li>基于事件驱动（epoll&#x2F;kqueue），能轻松支撑上万并发连接。</li>
<li>多进程（Worker），每个进程单线程。</li>
</ul>
</li>
<li>Master进程<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250914174323359.png" alt="image-20250914174323359"></li>
</ol>
</li>
</ol>
<h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><ol>
<li><p>k8s是什么</p>
<ol>
<li>Kubernetes（简称 K8s）是一个容器编排系统，主要用来自动管理大量的 Docker 容器</li>
<li>介于应用服务和服务器之间</li>
<li>通过yaml文件配置定义应用的部署顺序等信息，自动部署各个应用到服务器上</li>
<li>能自动扩缩容</li>
<li>能够在服务器炸了之后自动把应用部署到其他服务器</li>
</ol>
</li>
<li><p>k8s的架构原理</p>
<ol>
<li><p>k8s会把服务器分为两部分：控制平面和Node。前者控制后者，后者执行具体应用</p>
</li>
<li><p>控制平面：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915140828453.png" alt="image-20250915140828453"></p>
<ol>
<li>API Server：通过接口操作服务器资源，而不需要具体登录到各个服务器。</li>
<li>Scheduler：自动化决策服务器的cpu和内存是否能够部署应用</li>
<li>Controller Mgt：自动化创建、关闭服务</li>
<li>ETCD：存储层。上面过程中产生的数据存到这里。</li>
</ol>
</li>
<li><p>Node：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915141214215.png" alt="image-20250915141214215"></p>
<ol>
<li><p>可以是真机服务器，也可以是虚拟机</p>
</li>
<li><p>多个应用服务共享一台Node的内存和CPU。</p>
</li>
<li><p>不用手动上传代码，而是把代码打包为容器镜像，然后通过简单的命令部署。</p>
</li>
<li><p>Kubelet：用于接受控制命令，管理Pod。</p>
</li>
<li><p>Kube Proxy：用于网络通讯，可以联系Node内外的应用</p>
</li>
<li><p>Container runtime：用于下载和部署镜像</p>
</li>
<li><p>Pod：应用容器、日志容器、监控容器组成一个Pod。pod运行在Node上。k8s可以调度Pod。</p>
<ul>
<li><strong>Pod是k8s的最小调度单位</strong></li>
</ul>
</li>
</ol>
</li>
<li><p>工作负载：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250920131017877.png" alt="image-20250920131017877"></p>
</li>
<li><p>Cluster（集群）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250920150345535.png" alt="image-20250920150345535"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250915141413962.png" alt="image-20250915141413962"></p>
<ol>
<li>控制平面和Node组成了Cluster</li>
<li>一般在公司中会有多个集群，比如开发集群、测试集群。</li>
<li>通过Ingress控制器把器群的服务暴露给外部</li>
</ol>
</li>
<li><p>kubectl</p>
<ol>
<li>是命令行工具，封装好了控制k8s控制平面的命令</li>
<li>如何使用kubectl<ol>
<li>编写yaml文件，定义Pod里用了哪些镜像，占用多少内存和cpu等信息</li>
<li>通过kubectl apply -f XXX.yaml命令应用配置。</li>
<li>剩下的交给k8s就好了。至此就完成了一个Pod的部署。</li>
</ol>
</li>
</ol>
</li>
<li><p>ConfigMap：配置集</p>
</li>
<li><p>Secret：用来存储敏感信息的</p>
</li>
<li><p>如何调用服务呢</p>
<ol>
<li>以前不用k8s，一个HTTP请求会到达nginx，然后到达服务器，然后返回响应</li>
<li>现在用k8s，请求会先到Ingress控制器，然后到Kube Proxy，找到对应的Pod服务，然后转发到对应的容器服务，并返回响应。</li>
</ol>
</li>
</ol>
</li>
<li><p>k8s指令</p>
<ol>
<li><pre><code class="language-bash"># 创建pod
kubectl run my-nginx --image=nginx:1.25.2 --port=80


# 查看集群所有节点
kubectl get nodes

# 应用配置文件，创建资源
kubectl apply -f xxxx.yaml

# 查看集群中部署了哪些应用
kubectl get pods -A

# 修改镜像
kubectl set image &lt;资源类型&gt;/&lt;资源名&gt; &lt;容器名&gt;=&lt;镜像地址:tag&gt; -n &lt;命名空间&gt;

# 创建、删除命名空间
kubectl create\delete ns &lt;namespace&gt;

# 查看状态
kubectl describe pod &lt;pod_name&gt;

# 每个pod都会分配一个IP，使用pod的ip+port即可访问
kubectl get pod -owide

# 

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 四个组件的关系</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">          +----------------+</span><br><span class="line">          |   Deployment   |</span><br><span class="line">          |  (nginx-app)   |</span><br><span class="line">          +----------------+</span><br><span class="line">                   |</span><br><span class="line">                   |  创建 &amp; 管理</span><br><span class="line">                   v</span><br><span class="line">          +----------------+</span><br><span class="line">          |   ReplicaSet   |</span><br><span class="line">          | (nginx-rs-xxx) |</span><br><span class="line">          +----------------+</span><br><span class="line">                   |</span><br><span class="line">             ---------------------------------</span><br><span class="line">             |                               |</span><br><span class="line">             v                               v</span><br><span class="line">         +----------------+             +----------------+</span><br><span class="line">         |      Pod       |             |      Pod       |</span><br><span class="line">         | (nginx-xxx-1)  |             | (nginx-xxx-2)  |</span><br><span class="line">         |  Container:    |             |  Container:    |</span><br><span class="line">         |  nginx         |             |  nginx         |</span><br><span class="line">         +----------------+             +----------------+</span><br><span class="line">                 ^                               ^</span><br><span class="line">                 |                               |</span><br><span class="line">                 |  Selector: app=my-nginx-03    |</span><br><span class="line">                 |                               |</span><br><span class="line">                 +-------------+-----------------+</span><br><span class="line">                               |</span><br><span class="line">                               v</span><br><span class="line">                      +----------------+</span><br><span class="line">                      |    Service     |</span><br><span class="line">                      | (NodePort 30080)|</span><br><span class="line">                      +----------------+</span><br><span class="line">                               |</span><br><span class="line">                     外部访问：http://&lt;NodeIP&gt;:30080</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="分布架构"><a href="#分布架构" class="headerlink" title="分布架构"></a>分布架构</h2><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>详见其他笔记</p>
<h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>是什么<ol>
<li>Redis（Remote Dictionary Server）是一个<strong>基于内存的键值存储系统</strong>，支持多种数据结构，可以用作：<ul>
<li><strong>缓存（最常见用途）</strong></li>
<li><strong>数据库（持久化场景）</strong></li>
<li><strong>消息中间件（如消息队列、事件发布订阅）</strong></li>
</ul>
</li>
<li>Redis 的特点回顾（简要）<ul>
<li>内存存储，读写速度极快（微秒级响应）</li>
<li>单线程模型（Redis 6.0 前完全单线程，之后部分模块如网络 IO 支持多线程）</li>
<li>支持丰富的数据结构：String、Hash、List、Set、Sorted Set（ZSet）</li>
<li>支持数据持久化（RDB、AOF）</li>
<li>支持主从复制、哨兵、集群等高可用方案</li>
<li>命令原子性，支持事务与 Lua 脚本</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p>String（字符串）</p>
<ol>
<li><p>概述</p>
<ol>
<li><strong>最基本的数据类型</strong>，一个 key 对应一个 value。</li>
<li>Value 可以是字符串、数字或二进制数据（如图片、序列化对象）。</li>
<li>最大支持 <strong>512MB</strong>。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br><span class="line">INCR key          # 数字自增，常用于计数器</span><br><span class="line">DECR</span><br><span class="line">INCRBY</span><br><span class="line">APPEND</span><br><span class="line">MSET / MGET       # 批量设置/获取</span><br><span class="line">EXPIRE key seconds  # 设置过期时间</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>缓存数据（如用户信息 JSON）</p>
</li>
<li><p>计数器（如文章阅读量、点赞数）</p>
</li>
<li><p>分布式锁（SETNX）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Hash（哈希表）</p>
<ol>
<li><p>概述</p>
<ol>
<li>类似于 Map 结构，<strong>一个 key 对应一个字段-值对的集合</strong>。</li>
<li>适合存储对象，比如用户信息、商品详情等。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET user:1 name &quot;Tom&quot; age 25</span><br><span class="line">HGET user:1 name</span><br><span class="line">HGETALL user:1</span><br><span class="line">HKEYS / HVALS</span><br><span class="line">HINCRBY</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>优点：</p>
<ul>
<li><p>相比将整个对象序列化为 String，Hash 可以<strong>只修改部分字段</strong>，更高效。</p>
</li>
<li><p>节省内存（Redis 对小 Hash 有特殊优化）。</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>List（列表）</p>
<ol>
<li><p>概述</p>
<ol>
<li>一个 key 对应一个<strong>双向链表</strong>，支持从头部或尾部插入&#x2F;删除元素。</li>
<li>适合实现：<strong>最新消息、消息队列、文章评论列表</strong>等。</li>
<li>既可以当做栈来用，也可以按照队列来用</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPUSH myList &quot;a&quot;  # 头部插入</span><br><span class="line">RPUSH myList &quot;b&quot;  # 尾部插入</span><br><span class="line">LPOP / RPOP       # 头/尾弹出</span><br><span class="line">LRANGE myList 0 -1  # 获取全部元素</span><br><span class="line">LLEN</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>消息队列（结合 LPOP&#x2F;RPOP 或 BRPOP）</p>
</li>
<li><p>最新 N 条记录（如最新评论、动态）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Set（集合）</p>
<ol>
<li><p>概述</p>
<ol>
<li>无序、<strong>唯一</strong>的字符串集合。</li>
<li>支持交集、并集、差集等操作，适合标签、共同关注等场景。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SADD tags &quot;redis&quot; &quot;db&quot;</span><br><span class="line">SMEMBERS tags</span><br><span class="line">SISMEMBER tags &quot;redis&quot;</span><br><span class="line">SINTER set1 set2  # 交集</span><br><span class="line">SUNION</span><br><span class="line">SDIFF</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>标签系统</p>
</li>
<li><p>好友共同关注</p>
</li>
<li><p>去重统计（结合客户端）</p>
</li>
</ul>
</li>
</ol>
<hr>
</li>
<li><p>Sorted Set（ZSet，有序集合）</p>
<ol>
<li><p>概述</p>
<ol>
<li>集合的升级版，每个元素都关联一个 <strong>score（分数）</strong>，根据 score 排序。</li>
<li>元素唯一，但 score 可重复。</li>
</ol>
</li>
<li><p>常用命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZADD leaderboard 100 &quot;Alice&quot; 200 &quot;Bob&quot;</span><br><span class="line">ZRANGE leaderboard 0 -1          # 按 score 升序获取</span><br><span class="line">ZREVRANGE leaderboard 0 -1       # 降序</span><br><span class="line">ZSCORE leaderboard &quot;Alice&quot;</span><br><span class="line">ZINCRBY leaderboard 10 &quot;Alice&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>应用场景：</p>
<ul>
<li><p>排行榜（游戏、热搜榜）</p>
</li>
<li><p>优先级队列</p>
</li>
<li><p>延迟队列（结合 score 为时间戳）</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><ul>
<li><strong>Redis 6.0 之前：完全单线程</strong>（主线程处理所有客户端请求、命令执行、持久化等）</li>
<li><strong>Redis 6.0 之后：引入多线程 I&#x2F;O（处理网络读写），但命令执行仍然是单线程</strong>目的是提高网络吞吐，缓解高并发下的网络瓶颈，但核心数据操作依旧保持原子性。</li>
</ul>
<blockquote>
<p>✅ 所以，Redis 依然可以认为是<strong>单线程模型（命令执行层面）</strong>，无需考虑锁竞争，执行效率高。</p>
</blockquote>
<h3 id="持久机制"><a href="#持久机制" class="headerlink" title="持久机制"></a>持久机制</h3><p>Redis 默认是内存数据库，但支持将数据保存到磁盘，避免重启后数据丢失。</p>
<ol>
<li><p>RDB（Redis DataBase）</p>
<ol>
<li><p>RDB 触发方式</p>
<ol>
<li><p><strong>手动触发（主动保存）</strong></p>
<ol>
<li>命令：<code>SAVE</code>或 <code>BGSAVE``SAVE</code>：<strong>同步</strong>执行，会阻塞 Redis 主线程，不推荐生产使用</li>
<li><code>BGSAVE</code>：<strong>异步</strong>执行，Redis 会 fork 一个子进程在后台生成 RDB 文件，<strong>主线程不受影响（推荐）</strong></li>
</ol>
</li>
<li><p><strong>自动触发（通过配置规则）</strong></p>
</li>
</ol>
<p>Redis 允许通过配置文件设置<strong>自动快照规则</strong>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1       # 900秒内至少有1个key被修改，就触发一次 RDB</span><br><span class="line">save 300 10      # 300秒内至少10个key被修改</span><br><span class="line">save 60 10000    # 60秒内至少10000个key被修改</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要满足其中任意一条规则，Redis 就会在后台通过 <code>BGSAVE</code>自动保存一次 RDB 快照。</p>
</blockquote>
<hr>
</li>
<li><p>RDB 的优点</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>恢复速度快</strong></td>
<td align="left">RDB 是数据快照，文件小，Redis 启动时加载 RDB 比 AOF 快很多</td>
</tr>
<tr>
<td align="left">✅ <strong>文件体积小</strong></td>
<td align="left">只保存某一时刻的数据，而非所有操作命令</td>
</tr>
<tr>
<td align="left">✅ <strong>适合备份与灾难恢复</strong></td>
<td align="left">可以定期将 RDB 文件拷贝到其他服务器或云存储，用于容灾</td>
</tr>
</tbody></table>
<hr>
</li>
<li><p>RDB 的缺点</p>
<table>
<thead>
<tr>
<th align="left">缺点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>可能丢失数据</strong></td>
<td align="left">RDB 是<strong>定时快照</strong>，如果 Redis 在两次快照之间宕机，这段时间的数据会丢失</td>
</tr>
<tr>
<td align="left">❌ <strong>fork 子进程开销</strong></td>
<td align="left">BGSAVE 会 fork 一个子进程，如果数据量很大，fork 可能会阻塞主线程（特别是大内存实例）</td>
</tr>
<tr>
<td align="left">❌ <strong>不适合实时性要求极高的场景</strong></td>
<td align="left">不如 AOF 安全</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>AOF（Append Only File）</p>
<ol>
<li><p>AOF 工作流程</p>
</li>
<li><p>客户端执行一个写命令（如 SET key value）</p>
</li>
<li><p>Redis 不仅将数据写入内存，还会将该命令<strong>追加到 AOF 缓冲区</strong></p>
</li>
<li><p>根据配置的同步策略，将缓冲区内容写入磁盘的 AOF 文件</p>
</li>
<li><p>Redis 重启时，会<strong>重新加载并执行 AOF 文件中的命令</strong>，恢复数据</p>
</li>
<li><p>AOF 配置选项（同步频率）</p>
<p>在 redis.conf 中，可以通过以下参数控制 AOF 的写入磁盘策略（即命令同步到磁盘的时机）：</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">安全性</th>
<th align="left">性能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>appendfsync always</code></td>
<td align="left">每个写命令都同步到磁盘</td>
<td align="left">✅ 最安全，几乎不丢数据</td>
<td align="left">❌ 性能最差</td>
</tr>
<tr>
<td align="left"><code>appendfsync everysec</code>（默认）</td>
<td align="left">每秒同步一次</td>
<td align="left">⚠️ 最多丢失 1 秒的数据</td>
<td align="left">✅ 性能较好，推荐</td>
</tr>
<tr>
<td align="left"><code>appendfsync no</code></td>
<td align="left">由操作系统决定何时同步</td>
<td align="left">❌ 可能丢失较多数据</td>
<td align="left">✅ 性能最好</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ <strong>生产环境推荐使用：appendfsync everysec（折中方案，安全且性能较好）</strong></p>
</blockquote>
</li>
<li><p>AOF 的优点</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">✅ <strong>数据安全性更高</strong></td>
<td align="left">记录了所有写操作，最多只丢失 1 秒的数据（取决于配置）</td>
</tr>
<tr>
<td align="left">✅ <strong>可修复</strong></td>
<td align="left">AOF 文件损坏时，Redis 提供 <code>redis-check-aof</code>工具可以尝试修复</td>
</tr>
<tr>
<td align="left">✅ <strong>更适合数据重要性高的场景</strong></td>
<td align="left">比 RDB 更可靠</td>
</tr>
</tbody></table>
</li>
<li><p>AOF 的缺点</p>
<table>
<thead>
<tr>
<th align="left">缺点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">❌ <strong>文件体积大</strong></td>
<td align="left">记录了所有写命令，尤其是数据量大或频繁更新时，AOF 文件会膨胀</td>
</tr>
<tr>
<td align="left">❌ <strong>恢复速度慢</strong></td>
<td align="left">启动时要<strong>重新执行所有命令</strong>，比加载 RDB 慢</td>
</tr>
<tr>
<td align="left">❌ <strong>写放大</strong></td>
<td align="left">同一个数据多次修改会产生多条命令</td>
</tr>
</tbody></table>
<hr>
</li>
<li><p>AOF 重写（AOF Rewrite）</p>
<p>随着时间推移，AOF 文件会越来越大。为了解决这个问题，Redis 提供了 <strong>AOF 重写机制</strong>：</p>
<ul>
<li><p><strong>作用：</strong> 对 AOF 文件进行“瘦身”，去掉冗余命令，用<strong>最终的数据状态</strong>重写一个新的、更小的 AOF 文件</p>
</li>
<li><p><strong>命令：</strong> <code>BGREWRITEAOF</code>（后台异步执行）</p>
</li>
<li><p><strong>触发方式：</strong> 可配置自动触发策略，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 当前 AOF 文件比上次重写后增长了 100%</span><br><span class="line">auto-aof-rewrite-min-size 64mb   # AOF 文件至少达到 64MB 才触发</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="高可用与扩展（集群策略）"><a href="#高可用与扩展（集群策略）" class="headerlink" title="高可用与扩展（集群策略）"></a>高可用与扩展（集群策略）</h3><ol>
<li><p><strong>主从复制（Master-Slave Replication）</strong></p>
<ol>
<li><p>核心思想：</p>
<ol>
<li>允许一个 <strong>Master（主节点）</strong> 可以有多个 <strong>Slave（从节点）</strong>，<strong>从节点会异步复制主节点上的数据</strong>，实现数据的<strong>备份、读写分离、负载均衡</strong>。</li>
</ol>
</li>
<li><p>架构与原理</p>
<ol>
<li><strong>Master</strong>：负责写操作（也可读），数据变更后<strong>异步同步</strong>给 Slave。</li>
<li><strong>Slave</strong>：只读（也可配置为可写，但不推荐），从 Master 拉取数据，保持同步。</li>
</ol>
</li>
<li><p>数据同步方式：</p>
<ul>
<li><p><strong>全量同步（初次同步）</strong>：Slave 第一次连接 Master 时，Master 会生成 RDB 快照并发送给 Slave，然后同步增量命令。</p>
</li>
<li><p><strong>增量同步</strong>：后续 Master 的写操作会以命令的方式发送给 Slave，保持数据一致。</p>
</li>
</ul>
</li>
<li><p>特点与作用</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>特点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 读写分离</td>
<td>Master 写，Slave 读，分担读压力</td>
</tr>
<tr>
<td>✅ 数据备份</td>
<td>Slave 是 Master 的数据副本，可用于容灾</td>
</tr>
<tr>
<td>❌ 无自动故障转移</td>
<td>如果 Master 宕机，需要手动切换 Slave 为 Master</td>
</tr>
<tr>
<td>❌ 无自动负载均衡</td>
<td>需要客户端或代理层实现读请求分发</td>
</tr>
</tbody></table>
<ol start="5">
<li><p>优点</p>
<ol>
<li><p>简单易用，配置方便</p>
</li>
<li><p>数据冗余，提高可用性</p>
</li>
<li><p>支持读扩展（多个 Slave 分担读负载）</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ul>
<li><p><strong>不具备高可用性</strong>：Master 宕机后，整个集群不可写，需人工干预</p>
</li>
<li><p><strong>数据一致性是最终一致</strong>（异步复制，Slave 数据可能有延迟）</p>
</li>
<li><p><strong>无自动 Failover（故障切换）能力</strong></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>哨兵模式（Sentinel）</strong></p>
<ol>
<li><p>核心思想：</p>
<ol>
<li>在 <strong>主从复制的基础上，引入 Sentinel（哨兵）进程</strong>，用于 监控 Redis 主从节点的健康状态，并在 <strong>Master 宕机时自动进行故障转移（Failover），选举新的 Master</strong>，实现高可用性。</li>
</ol>
</li>
<li><p>架构组成</p>
<ol>
<li><strong>Master</strong>：主节点，负责写操作</li>
<li><strong>Slave</strong>：从节点，复制 Master 数据</li>
<li><strong>Sentinel（哨兵）</strong>：独立的 Redis 进程（或线程），<strong>不存储数据</strong>，用于监控 + 故障转移</li>
</ol>
</li>
</ol>
<blockquote>
<p>通常部署 <strong>至少 3 个 Sentinel 节点（避免脑裂）</strong>，它们共同监控 Redis 节点并协作决策。</p>
</blockquote>
<ol start="3">
<li>Sentinel 做了什么？</li>
</ol>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 监控</td>
<td>持续检查 Master 和 Slave 是否正常运行</td>
</tr>
<tr>
<td>✅ 自动故障转移</td>
<td>当 Master 宕机，Sentinel 会<strong>选举出一个 Slave 作为新 Master</strong>，并通知其他 Slave 复制新 Master</td>
</tr>
<tr>
<td>✅ 通知</td>
<td>通过 API 或消息告知客户端 Master 发生了变更</td>
</tr>
<tr>
<td>✅ 配置提供者</td>
<td>客户端可以从 Sentinel 获取最新的 Master 地址</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<ol start="4">
<li>优点：</li>
</ol>
<pre><code>  - **自动故障转移**（High Availability）

  - **自动发现与通知**（客户端可感知新 Master）

  - 仍然支持 **读写分离 &amp; 读扩展**
</code></pre>
<ol start="5">
<li><p>缺点：</p>
<ul>
<li><p>不支持自动扩容 &#x2F; 数据分片：数据仍然全部存在一个 Master 上，无法解决大数据量存储问题</p>
</li>
<li><p>Sentinel 本身不存储数据，只是协调者</p>
</li>
<li><p>客户端需要支持 Sentinel 感知机制，或使用支持 Sentinel 的 Redis 客户端 SDK</p>
</li>
</ul>
</li>
<li><p><strong>集群模式（Redis Cluster）</strong></p>
<ol>
<li>核心思想：<ol>
<li>Redis 官方推出的<strong>分布式集群解决方案</strong>，支持 <strong>数据自动分片（Sharding）、高可用、多主多从、横向扩展</strong>，是生产环境 <strong>大规模数据 + 高并发 + 高可用</strong> 场景下的首选架构。</li>
</ol>
</li>
<li>核心特性</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 数据分片（Sharding）</td>
<td>数据按哈希槽（16384 个 slot）分片，分散存储在多个主节点上</td>
</tr>
<tr>
<td>✅ 多主多从</td>
<td>每个分片是一个 <strong>主从结构</strong>，主节点负责写，从节点负责备份与故障切换</td>
</tr>
<tr>
<td>✅ 高可用</td>
<td>如果某个主节点宕机，其从节点会被 <strong>自动提升为主节点</strong></td>
</tr>
<tr>
<td>✅ 客户端直连</td>
<td>客户端可以直接连接集群节点，支持智能路由</td>
</tr>
<tr>
<td>✅ 横向扩展</td>
<td>可通过增加节点来扩展存储容量与并发能力</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>数据分片原理（16384 个 Slot）</p>
<ul>
<li><p>Redis Cluster 将所有的数据分成 <strong>16384 个哈希槽（hash slot）</strong></p>
</li>
<li><p>每个 <strong>Key 通过 CRC16(key) % 16384 计算出所属的 Slot</strong></p>
</li>
<li><p>每个 <strong>主节点负责一部分 Slot（比如节点 A 负责 0<del>5000，节点 B 负责 5001</del>10000…）</strong></p>
</li>
<li><p>客户端访问时，Redis 会告诉客户端应该去哪个节点操作</p>
</li>
</ul>
</li>
<li><p>高可用实现</p>
<ul>
<li><p>每个主节点可以有 <strong>1 个或多个从节点</strong></p>
</li>
<li><p>如果某个主节点宕机，其对应的 <strong>从节点会通过选举成为新的主节点</strong>（类似哨兵的故障转移，但是集群内置）</p>
</li>
<li><p>如果某个节点完全宕机且无从节点，则对应的 Slot 不可用</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ol>
<li>支持海量数据存储（通过分片）</li>
<li>支持高并发（多节点共同承担）</li>
<li>自动故障转移（内置，无需 Sentinel）</li>
<li>横向可扩展（可动态增加节点）</li>
<li>官方原生支持，无需第三方组件</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>架构复杂，部署和运维成本较高</li>
<li>不支持多 Key 操作（除非这些 Key 在同一个 Slot，可使用 Hash Tag</li>
<li>事务操作受限（跨节点事务不支持）</li>
<li>需要客户端支持 Cluster 协议（或使用代理）</li>
</ol>
</li>
</ol>
<p>三种集群策略 对比总结</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>主从复制</th>
<th>哨兵模式</th>
<th>Redis Cluster（集群）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据复制</strong></td>
<td>✅ Master → Slave</td>
<td>✅ Master → Slave</td>
<td>✅ 每个主节点有从节点，支持复制</td>
</tr>
<tr>
<td><strong>读写分离</strong></td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>✅ 支持（主写从读）</td>
</tr>
<tr>
<td><strong>高可用（自动 Failover）</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持（Sentinel）</td>
<td>✅ 支持（内置）</td>
</tr>
<tr>
<td><strong>数据分片 &#x2F; 扩展性</strong></td>
<td>❌ 不支持</td>
<td>❌ 不支持</td>
<td>✅ 支持（16384 slots，多主多从）</td>
</tr>
<tr>
<td><strong>数据存储能力</strong></td>
<td>❌ 单机限制</td>
<td>❌ 单机限制</td>
<td>✅ 海量数据，可扩展</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>中等</td>
<td>高（需理解分片、路由等）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少、简单备份</td>
<td>中小应用、要求高可用</td>
<td>大数据、高并发、生产级集群</td>
</tr>
</tbody></table>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol>
<li><p>事务（Transaction）</p>
<ol>
<li><p>使用 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>实现。</p>
<ol>
<li>将多个命令打包，按顺序执行，但<strong>不保证原子性（中间可能被其他客户端打断）</strong></li>
<li>WATCH 可以实现乐观锁。</li>
</ol>
</li>
<li><p>实现原理</p>
<ol>
<li><p>Redis 的事务提供了一种将多个命令打包，然后一次性、按顺序执行的机制。它的实现主要依赖三个核心命令：<code>MULTI</code>、<code>EXEC</code> 和 <code>DISCARD</code>。</p>
<ol>
<li><p>启动事务：<code>MULTI</code></p>
<ol>
<li>当客户端发送 <code>MULTI</code> 命令时，Redis 会将该客户端的状态从<strong>非事务模式</strong>切换到<strong>事务模式</strong>。</li>
<li>在此之后，客户端发送的任何命令（除了 <code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 等少数几个命令）都不会立即执行。</li>
<li>相反，这些命令会被放入一个<strong>命令队列</strong>中，等待后续执行。</li>
<li>Redis 只是简单地回复 <code>QUEUED</code>，表示命令已成功入队。</li>
</ol>
</li>
<li><p>执行事务：<code>EXEC</code></p>
<ol>
<li>当客户端发送 <code>EXEC</code> 命令时，Redis 事务正式开始执行。</li>
<li>Redis 会将命令队列中的所有命令<strong>按顺序、原子性地一次性执行完毕</strong>。</li>
<li>执行完后，Redis 会将每个命令的执行结果按顺序打包成一个列表（Array）返回给客户端。</li>
<li>客户端退出事务模式。</li>
</ol>
</li>
<li><p>取消事务：<code>DISCARD</code></p>
<ol>
<li>如果客户端在 <code>MULTI</code> 之后，但在 <code>EXEC</code> 之前发送 <code>DISCARD</code> 命令，Redis 会清空命令队列。</li>
<li>客户端退出事务模式，所有已入队的命令都不会被执行。</li>
</ol>
</li>
<li><p>监控键值：<code>WATCH</code> </p>
<ol>
<li>命令用于监视（Watch）一个或多个键。它的核心机制可以概括为一句话：</li>
<li>如果在 <code>WATCH</code> 之后，到 <code>EXEC</code> 执行之前，任何被监视的键发生了修改，那么整个事务将被取消（EXEC 返回空）。</li>
<li>当 <code>EXEC</code> 失败（返回空响应）时，客户端程序就知道事务执行失败了，因为它依赖的底层数据已经被修改，必须：<ol>
<li>清除监视： 自动或手动（通过 <code>UNWATCH</code> 命令）清除当前的监视状态。</li>
<li>重试： 从第 1 步重新开始整个操作流程（重新 <code>WATCH</code>，重新读取数据，重新计算，重新 <code>EXEC</code>）。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>错误处理</p>
<ol>
<li>入队时发现的错误（Syntax Error）<ul>
<li>如果在 <code>MULTI</code> 和 <code>EXEC</code> 之间，客户端发送了一个<strong>格式错误</strong>（如拼写错误、参数数量错误等）的命令，Redis 会在入队时就发现这个错误。</li>
<li>在这种情况下，Redis 会拒绝执行整个事务队列，当执行 <code>EXEC</code> 时，<strong>所有</strong>命令都不会被执行。</li>
</ul>
</li>
<li>执行时发现的错误（Runtime Error）***<ul>
<li>如果在 <code>EXEC</code> 执行过程中，某个命令因为<strong>操作了错误的数据类型</strong>等原因而执行失败（Runtime Error），<strong>Redis 不会回滚（Rollback）</strong> 已经执行成功的命令。</li>
<li>事务中其他<strong>执行成功的命令仍然会生效</strong>，只有失败的命令返回错误信息。</li>
<li><strong>这是 Redis 事务与关系型数据库事务最大的区别之一。</strong> Redis 强调的是简单和高性能，它不会为了支持回滚而引入额外的复杂性。</li>
</ul>
</li>
</ol>
</li>
<li><p>并发控制</p>
<ol>
<li>为了解决事务过程中数据被其他客户端修改的问题，Redis 引入了 <code>WATCH</code> 命令，实现了<strong>乐观锁（Optimistic Locking）</strong>：<ol>
<li><strong><code>WATCH key [key ...]</code></strong>: 客户端在 <code>MULTI</code> 之前使用 <code>WATCH</code> 监视一个或多个键。</li>
<li><strong>执行事务</strong>: 客户端执行 <code>MULTI</code>，然后发送命令入队。</li>
<li><strong>检查</strong>: 当客户端执行 <code>EXEC</code> 时，Redis 会检查所有被 <code>WATCH</code> 监视的键。</li>
<li><strong>失败</strong>: 如果在 <code>WATCH</code> 之后到 <code>EXEC</code> 之前，<strong>任何一个</strong>被监视的键被其他客户端修改了，那么整个事务将被<strong>中断和取消</strong>，<code>EXEC</code> 命令会返回一个空结果（Null Reply）。</li>
<li><strong>重试</strong>: 客户端需要重新 <code>WATCH</code> 键，并重新执行整个事务流程。</li>
</ol>
</li>
</ol>
</li>
<li><p>ACID</p>
<ol>
<li><p>原子性如何实现？Redis没有回滚机制，是否破坏了原子性？</p>
<ol>
<li>我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断</li>
<li>在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性</li>
<li>虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。</li>
<li>并且运行时错误多为编程错误，可以避免。</li>
</ol>
</li>
<li><p>一致性如何实现？</p>
<ol>
<li><strong>内部一致性：</strong> Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。</li>
<li><strong>事务隔离性：</strong> <code>I</code> 的保证间接支撑了 <code>C</code>，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。</li>
</ol>
</li>
<li><p>隔离性如何实现？</p>
<ol>
<li>Redis 对隔离性的保证是<strong>非常强大</strong>的，因为它基于单线程模型。</li>
<li>保证方式： Redis 使用 <strong>单线程</strong> 模型处理所有客户端请求（除了后台的持久化操作）。</li>
<li>结果： <code>MULTI</code>&#x2F;<code>EXEC</code> 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。</li>
<li>总结： <strong>Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离</strong>。</li>
</ol>
</li>
<li><p>持久性如何实现？</p>
<ol>
<li><p>Redis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，<strong>默认情况下持久性是有风险的</strong>。</p>
</li>
<li><p>Redis 主要通过两种方式实现持久性：</p>
<ol>
<li><strong>AOF (Append Only File) 模式：</strong><ul>
<li>将所有写命令以日志形式追加到文件中。</li>
<li>如果配置了 <code>always</code> 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。</li>
<li>但为了性能，通常配置为 <code>everysec</code>（每秒同步一次），这意味着最近一秒内的数据可能会丢失。</li>
</ul>
</li>
<li><strong>RDB (Redis Database) 快照模式：</strong><ul>
<li>定期将内存中的数据生成一个二进制快照文件。</li>
<li>由于是<strong>定期</strong>快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>总结：</strong> Redis 的持久性是<strong>可配置的</strong>。只有在启用 AOF 并设置为 <code>always</code> 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h3><ol>
<li>是什么<ol>
<li><strong>Lua</strong> 是一种轻量级、高效、可嵌入的脚本语言，可作为编程语言的扩展语言，被广泛的运用到Redis脚本中</li>
</ol>
</li>
<li>在Redis中的应用<ol>
<li>原子性操作<ul>
<li>Redis 执行 单个命令是原子性的，但多个命令组合在一起 默认不是原子性 的（中间可能被其他客户端的命令插入）。</li>
<li>把多个命令封装进一个 Lua 脚本，Redis 会<strong>一次性、按顺序执行脚本里的所有命令，不会被其他操作打断</strong>，保证原子性。</li>
</ul>
</li>
<li>减少网络开销<ul>
<li>如果你要执行多个 Redis 命令，通常需要多次网络往返。</li>
<li>使用 Lua 脚本，可以把多个命令一次性发送到 Redis 服务端执行，<strong>只需一次网络通信</strong>，提高效率。</li>
</ul>
</li>
<li>复杂业务逻辑<ul>
<li>有些业务逻辑比较复杂，比如“先判断再修改”、“循环操作”、“带条件的多键操作”等，用 Lua 脚本可以在服务端高效完成。</li>
</ul>
</li>
<li>实现分布式锁、计数器、限流等高级功能<ul>
<li>像 Redis 分布式锁的正确释放（判断 value 一致再 DEL）</li>
<li>限流算法（如令牌桶、漏桶）</li>
<li>排行榜加分、扣分逻辑都可以用 Lua 脚本优雅地实现。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="过期策略与内存淘汰机制"><a href="#过期策略与内存淘汰机制" class="headerlink" title="过期策略与内存淘汰机制"></a>过期策略与内存淘汰机制</h3><ol>
<li>过期策略<ol>
<li><p>可以给 Key 设置过期时间：<code>EXPIRE key seconds</code></p>
</li>
<li><p>Redis 采用以下两种方式清理过期 Key：</p>
<ol>
<li><strong>定期删除</strong>：每隔一段时间随机抽取一些 key 检查是否过期</li>
<li><strong>惰性删除</strong>：当访问某个 key 时，检查是否过期，如果过期则删除</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>⚠️ 过期不会立即释放内存，而是惰性或定期清理。</p>
</blockquote>
<ol start="2">
<li>内存淘汰机制（maxmemory-policy）</li>
</ol>
<p>当 Redis 内存达到上限时，根据策略删除部分 key，常见策略包括：</p>
<ul>
<li>noeviction（默认）：不删除，写入报错</li>
<li>allkeys-lru：从所有 key 中淘汰最近最少使用的</li>
<li>volatile-lru：只从设置了过期时间的 key 中淘汰</li>
<li>allkeys-random &#x2F; volatile-random：随机淘汰</li>
<li>allkeys-ttl：优先淘汰快过期的</li>
</ul>
<blockquote>
<p>生产环境推荐使用：allkeys-lru 或 volatile-lru</p>
</blockquote>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><ol>
<li><p>概述</p>
<ol>
<li>在分布式系统中，多个进程或服务（可能运行在不同的服务器上）可能会同时尝试访问共享资源（如数据库、文件、缓存等），为了保证数据一致性，我们需要一种跨进程&#x2F;服务的互斥机制，这就是 分布式锁（Distributed Lock）。</li>
<li>在分布式系统中，传统的线程锁（如 Java 的 synchronized、ReentrantLock）<strong>只能在单个 JVM 内起作用</strong>，无法跨进程、跨服务器工作。而 <strong>Redis 是一个高性能的、支持网络访问的、内存数据库，天生适合用来实现跨服务的锁机制。</strong></li>
<li>注意是用Redis实现一个分布式锁，而不是Redis内部机制（毕竟Redis是单线程的，不用考虑分布式锁）</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>使用 Redis 的 <code>SET key value NX PX timeout</code>命令，来实现：</p>
<ul>
<li><strong>互斥性（Mutual Exclusion）</strong>：同一时刻只有一个客户端能成功设置锁</li>
<li><strong>避免死锁</strong>：锁必须要有过期时间，防止客户端崩溃后锁永远不释放</li>
<li><strong>锁的释放必须是原子的且只能由加锁者释放</strong>：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁</li>
</ul>
</li>
<li><p>释放锁（<strong>必须验证锁是自己的！！</strong>）</p>
<ol>
<li>不能直接用 <code>DEL lockKey</code>，因为：<ol>
<li>如果 A 加了锁，但锁过期了，B 获取到了锁</li>
<li>此时 A 的业务还没执行完，但锁已经失效，A 还去执行 <code>DEL</code>，就会把 B 的锁删掉 ❌</li>
</ol>
</li>
<li>正确做法：使用 Lua 脚本保证原子性，校验 value 一致才删除<ol>
<li>Lua 脚本如下：</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>KEYS[1]</code>是锁的 key，比如 <code>order_lock_123</code></li>
<li><code>ARGV[1]</code>是加锁时设置的唯一标识（requestId &#x2F; UUID）</li>
</ul>
</li>
</ol>
</li>
<li><p>实现方式</p>
<ol>
<li><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 30000</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数解释：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>lock_key</code></td>
<td align="left">锁的名称，比如 <code>order_lock_123</code></td>
</tr>
<tr>
<td align="left"><code>unique_value</code></td>
<td align="left">唯一标识，通常是 UUID 或 客户端生成的随机字符串，用于标识锁的持有者</td>
</tr>
<tr>
<td align="left"><code>NX</code></td>
<td align="left">仅当 key 不存在时才设置成功（保证互斥）</td>
</tr>
<tr>
<td align="left"><code>PX 30000</code></td>
<td align="left">设置锁的过期时间，单位毫秒（这里是 30 秒），防止死锁</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="常见问题与优化建议"><a href="#常见问题与优化建议" class="headerlink" title="常见问题与优化建议"></a>常见问题与优化建议</h3><table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">本质</th>
<th align="left">原因</th>
<th align="left">解决方案关键词</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>缓存穿透</strong></td>
<td align="left">查询了不存在的数据，每次都访问 DB</td>
<td align="left">恶意&#x2F;错误查询、缓存没有拦截</td>
<td align="left">布隆过滤器、缓存空对象</td>
</tr>
<tr>
<td align="left"><strong>缓存击穿</strong></td>
<td align="left">热点 key 突然失效，大量请求直达 DB</td>
<td align="left">单个热点 key 过期，高并发访问</td>
<td align="left">永不过期（逻辑过期）、互斥锁</td>
</tr>
<tr>
<td align="left"><strong>缓存雪崩</strong></td>
<td align="left">大量 key 同时失效 &#x2F; Redis 宕机，DB 崩溃</td>
<td align="left">过期时间集中、Redis 故障</td>
<td align="left">随机过期、多级缓存、高可用、熔断</td>
</tr>
</tbody></table>
<ol>
<li><p>缓存穿透</p>
<ol>
<li><p>查询一个<strong>不存在的数据</strong>，导致每次都访问数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>布隆过滤器</p>
<ol>
<li><p>布隆过滤器是一种空间效率极高、用于判断某个元素是否可能存在于集合中的数据结构。</p>
<ul>
<li>在缓存层或应用启动时，将所有合法的数据 key 提前加载到布隆过滤器中</li>
<li>当用户查询某个 key 时，先经过布隆过滤器判断：这个 key 是否可能存在如果布隆过滤器判断 “不存在” → 直接返回，不去查缓存和数据库如果判断 “可能存在” → 再去查缓存&#x2F;数据库</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li><p>对于大量不存在的 key 请求，在第一层就拦截掉</p>
</li>
<li><p>占用内存极小，效率高</p>
</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li><p>适合ID类查询、提前已知所有合法 key 的业务（如商品 ID、用户 ID）</p>
</li>
<li><p>常用于防止恶意或错误查询穿透到数据库</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>缓存空对象</p>
<ol>
<li>即使数据库查询结果为空（比如 ID 为 999 的用户不存在），也把这个 <strong>空结果进行缓存</strong>，并设置一个较短的过期时间（如 30~60 秒）。</li>
<li>下次同样查询时，缓存中能命中这个“空值”，就不再查数据库。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>缓存击穿</p>
<ol>
<li><p>某个<strong>热点 key 突然失效</strong>，大量请求直接打到数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>设置热点 key 永不过期（逻辑过期）</p>
<ol>
<li><p>对于特别热点的 key，不设置真正的过期时间（或者设置一个非常长的时间）</p>
</li>
<li><p>但数据本身可以设置一个 “逻辑过期时间”（比如在 value 中保存一个过期时间戳）</p>
</li>
<li><p>后台启动一个 定时任务或异步线程，在数据即将过期时，异步更新缓存</p>
</li>
<li><p><strong>优点：</strong> 避免大量请求同时击穿缓存</p>
</li>
<li><p><strong>缺点：</strong> 数据更新可能有一定延迟，需要维护逻辑过期时间</p>
</li>
</ol>
</li>
<li><p>使用互斥锁（Mutex Lock） &#x2F; 分布式锁重建缓存</p>
<ol>
<li><p>当缓存未命中时，不是所有请求都去查数据库，而是：</p>
<ol>
<li>第一个请求去查库，并重建缓存，同时对其他请求加锁（互斥）</li>
<li>其它请求发现锁存在，就 等待或短暂休眠后重试，或者直接返回旧数据 &#x2F; 默认值</li>
<li>锁释放后，其它请求再尝试从缓存获取</li>
</ol>
</li>
<li><p>实现方式：</p>
<ul>
<li><p>使用 Redis 的 <code>SETNX</code>或 <code>RedLock</code>等实现分布式锁</p>
</li>
<li><p>或者使用本地锁（单机情况下）</p>
</li>
</ul>
</li>
<li><p>关键点： 只让 一个请求去查库并重建缓存，其他请求等待或重试</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>缓存雪崩</p>
<ol>
<li><p>大量 key <strong>在同一时间过期</strong>，导致请求全部压到数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li><p>设置不同的过期时间（随机过期）</p>
<ul>
<li><p>为每个缓存 key 的过期时间添加一个 随机值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基础过期时间：3600 秒（1小时）</span><br><span class="line">随机值：± 300 秒（5分钟）</span><br><span class="line">=&gt; 最终过期时间在 3300 ~ 3900 秒之间</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免大量 key 同时失效，错开缓存刷新时间</p>
</li>
</ul>
</li>
<li><p>使用多级缓存</p>
<ul>
<li><p>不止依赖 Redis，还可以引入本地缓存（如 Caffeine、Guava Cache）作为一级缓存</p>
</li>
<li><p>Redis 作为二级缓存</p>
</li>
<li><p>即使 Redis 缓存失效，本地缓存还能挡一波请求</p>
<p> 优点： 多层防护，即使某一层失效，也有兜底</p>
</li>
</ul>
</li>
<li><p>Redis 高可用（主从 + 哨兵 &#x2F; 集群）</p>
<ul>
<li>避免因为 Redis 宕机 导致所有缓存不可用</li>
<li>通过 Redis Sentinel 或 Cluster 提高 Redis 自身的可用性</li>
</ul>
</li>
<li><p>熔断降级 &amp; 请求限流</p>
<ul>
<li>当数据库压力过大时，可使用 熔断机制（如 Hystrix、Sentinel、Resilience4j）</li>
<li>或对请求进行 限流（如令牌桶、漏桶算法），保护数据库</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>性能优化建议</p>
<ul>
<li><p>避免大 Key（如大 Hash、大 List）、热 Key</p>
</li>
<li><p>合理使用 Pipeline 批量操作，减少网络往返</p>
</li>
<li><p>根据业务选择合适的数据结构</p>
</li>
<li><p>监控慢查询、内存使用、命中率等指标</p>
</li>
</ul>
</li>
</ol>
<h3 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h3><ol>
<li><p>是什么</p>
<ol>
<li>Redis 的 <strong>Pub&#x2F;Sub（发布&#x2F;订阅）</strong> 是一种<strong>消息通信模式</strong>，它允许：<ul>
<li><strong>发送者（Publisher）</strong> 向 <strong>指定的频道（Channel）发送消息</strong>；</li>
<li><strong>接收者（Subscriber）</strong> 可以<strong>订阅一个或多个频道</strong>，从而<strong>接收发送到这些频道的消息</strong>；</li>
</ul>
</li>
<li>关键点：<ul>
<li>发布者和订阅者之间<strong>没有直接的连接或耦合</strong>；</li>
<li>消息传递是<strong>实时的、广播式的</strong>；</li>
<li>Redis Pub&#x2F;Sub 是<strong>基于内存的、即发即弃（fire-and-forget）的消息系统</strong>，<strong>不提供消息持久化</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><strong>订阅者（Subscriber）</strong> 通过命令订阅一个或多个频道；</li>
<li><strong>发布者（Publisher）</strong> 向某个频道发送消息；</li>
<li><strong>Redis 服务器</strong> 将该消息<strong>实时推送给所有订阅了该频道的订阅者</strong>；</li>
<li>如果某个客户端<strong>没有订阅该频道，则不会收到任何消息</strong>。</li>
</ol>
</li>
<li><p>命令</p>
<ol>
<li><p>订阅频道（Subscribe）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel1 [channel2 ...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE news sports</span><br></pre></td></tr></table></figure>

<p>订阅者会进入监听模式，等待消息。此时 Redis CLI 会阻塞，等待发布消息。</p>
</li>
<li><p>发布消息（Publish）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH news &quot;Hello, this is a news update!&quot;</span><br></pre></td></tr></table></figure>

<p>这条消息会被推送给所有订阅了 <code>news</code>频道的客户端。</p>
</li>
<li><p>取消订阅（Unsubscribe）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSUBSCRIBE [channel1 channel2 ...]</span><br></pre></td></tr></table></figure>

<p>如果不指定频道，则取消所有订阅。</p>
</li>
<li><p>查看活跃的频道（可选，用于监控）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB CHANNELS [pattern]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBSUB CHANNELS news *</span><br></pre></td></tr></table></figure>

<p>可以查看当前有哪些频道正被订阅（支持通配符）。</p>
</li>
</ol>
</li>
</ol>
<h2 id="docker实战"><a href="#docker实战" class="headerlink" title="docker实战"></a>docker实战</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><ol>
<li><p>卸载旧版本：sudo apt-get remove docker docker-engine docker.io containerd runc</p>
</li>
<li><p>安装依赖：</p>
<ol>
<li><code>sudo apt-get update sudo apt-get install -y ca-certificates curl gnupg lsb-release</code></li>
</ol>
</li>
<li><p>添加 Docker 官方 GPG key</p>
<ol>
<li><pre><code>sudo mkdir -p /etc/apt/keyrings

curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
  | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 设置软件源</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      echo \</span><br><span class="line">        &quot;deb [arch=$(dpkg --print-architecture) \</span><br><span class="line">        signed-by=/etc/apt/keyrings/docker.gpg] \</span><br><span class="line">        https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">        $(lsb_release -cs) stable&quot; \</span><br><span class="line">        | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>安装docker：</p>
<ol>
<li><code>sudo apt-get update sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</code></li>
</ol>
</li>
<li><p>配置加速</p>
<ol>
<li><pre><code>sudo mkdir -p /etc/docker
sudo nano /etc/docker/daemon.json

写入以下内容：
{
  &quot;registry-mirrors&quot;: [
    &quot;https://registry.docker-cn.com&quot;,
    &quot;https://docker.m.daocloud.io&quot;,
    &quot;https://mirror.ccs.tencentyun.com&quot;,
    &quot;https://hub-mirror.c.163.com&quot;
  ]
}

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 容器</span><br><span class="line"></span><br><span class="line">1. 如何进入docker容器内部修改内容：`docker exec -it &lt;id&gt; bash  # 进入正在运行的容器 `</span><br><span class="line">2. 挂载：进入容器修改页面太麻烦，我们把它挂在到服务器的目录中。修改服务器目录就能够修改容器中的内容。注意是index.html文件</span><br><span class="line"></span><br><span class="line">### 如何把java上传到服务器</span><br><span class="line"></span><br><span class="line">1. 把写好的代码用maven打包为.jar，在target目录下</span><br><span class="line">2. 编写Dockerfile。一定会有FROM指明需要从DockerHub上下载的java镜像和作者</span><br><span class="line">3. 上传到服务器，建好工作目录。</span><br><span class="line">4. docker build, docker run</span><br><span class="line"></span><br><span class="line">## k8s实战</span><br><span class="line"></span><br><span class="line">### 创建集群</span><br><span class="line"></span><br><span class="line">1. 预备环境</span><br><span class="line">   1. 需要多台服务器，分为控制服务器master和服务节点nide</span><br><span class="line">   2. 创建以后把他们放在一个VPC中</span><br><span class="line">   3. 每台都要安装docker</span><br><span class="line">   4. 改主机名</span><br><span class="line">   5. 确保组内互信</span><br><span class="line">   6. 确保永久禁止交换分区（free -m 的结果中 Swap 一项全是 0）</span><br><span class="line">   7. 允许流量桥接（iptables）</span><br><span class="line">   8. 下载所需依赖</span><br><span class="line">2. 下载“三大件”</span><br><span class="line">   1. kubelet</span><br><span class="line">   2. kubeadm</span><br><span class="line">   3. kubectl</span><br><span class="line"></span><br><span class="line">### 引导启动集群</span><br><span class="line"></span><br><span class="line">1. 启动kubelet。注意，kubelet此时会反复重启，属正常现象</span><br><span class="line"></span><br><span class="line">2. 设置域名映射</span><br><span class="line"></span><br><span class="line">3. 启用CRI</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      检查 containerd 是否安装并运行</span><br><span class="line">      systemctl status containerd</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      如果没安装：</span><br><span class="line">      </span><br><span class="line">      apt-get update &amp;&amp; apt-get install -y containerd</span><br><span class="line">      </span><br><span class="line">      2. 生成并修改配置文件</span><br><span class="line">      </span><br><span class="line">      生成默认配置：</span><br><span class="line">      </span><br><span class="line">      containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      修改关键配置：</span><br><span class="line">      </span><br><span class="line">      CRI 插件必须启用：确认 [plugins.&quot;io.containerd.grpc.v1.cri&quot;] 没被注释掉。</span><br><span class="line">      </span><br><span class="line">      sandbox 镜像（pause 镜像）要改成国内可拉取的地址，例如：</span><br><span class="line">      </span><br><span class="line">      [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">        sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br><span class="line">      </span><br><span class="line">      3. 重启 containerd</span><br><span class="line">      systemctl daemon-reexec</span><br><span class="line">      systemctl restart containerd</span><br><span class="line">      </span><br><span class="line">      4. 验证 CRI socket 是否可用</span><br><span class="line">      crictl info</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      能输出 JSON 就说明 OK（如果 crictl 没装，可以 apt-get install -y cri-tools）。</span><br><span class="line">      </span><br><span class="line">      5. 重新加入集群</span><br><span class="line">      </span><br><span class="line">      在 node 上重新执行 master 给的 join 命令：</span><br><span class="line">      </span><br><span class="line">      kubeadm join 172.23.159.16:6443 --token txnlw2.j83802umcetcr3mo \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:46251037d5a972db8d96635b4c1244c00c9d17f6e90963a2e6da5d42106724ab</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>改完的&#x2F;etc&#x2F;container&#x2F;conf.toml</p>
<ol>
<li><pre><code class="language-bash">disabled_plugins = []
imports = []
oom_score = 0
plugin_dir = &quot;&quot;
required_plugins = []
root = &quot;/var/lib/containerd&quot;
state = &quot;/run/containerd&quot;
temp = &quot;&quot;
version = 2

[cgroup]
  path = &quot;&quot;

[debug]
  address = &quot;&quot;
  format = &quot;&quot;
  gid = 0
  level = &quot;&quot;
  uid = 0

[grpc]
  address = &quot;/run/containerd/containerd.sock&quot;
  gid = 0
  max_recv_message_size = 16777216
  max_send_message_size = 16777216
  tcp_address = &quot;&quot;
  tcp_tls_ca = &quot;&quot;
  tcp_tls_cert = &quot;&quot;
  tcp_tls_key = &quot;&quot;
  uid = 0

[metrics]
  address = &quot;&quot;
  grpc_histogram = false

[plugins]

  [plugins.&quot;io.containerd.gc.v1.scheduler&quot;]
    deletion_threshold = 0
    mutation_threshold = 100
    pause_threshold = 0.02
    schedule_delay = &quot;0s&quot;
    startup_delay = &quot;100ms&quot;

  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]
    cdi_spec_dirs = [&quot;/etc/cdi&quot;, &quot;/var/run/cdi&quot;]
    device_ownership_from_security_context = false
    disable_apparmor = false
    disable_cgroup = false
    disable_hugetlb_controller = true
    disable_proc_mount = false
    disable_tcp_service = true
    drain_exec_sync_io_timeout = &quot;0s&quot;
    enable_cdi = false
    enable_selinux = false
    enable_tls_streaming = false
    enable_unprivileged_icmp = false
    enable_unprivileged_ports = false
    ignore_deprecation_warnings = []
    ignore_image_defined_volumes = false
    image_pull_progress_timeout = &quot;5m0s&quot;
    image_pull_with_sync_fs = false
    max_concurrent_downloads = 3
    max_container_log_line_size = 16384
    netns_mounts_under_state_dir = false
    restrict_oom_score_adj = false
    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;
    selinux_category_range = 1024
    stats_collect_period = 10
    stream_idle_timeout = &quot;4h0m0s&quot;
    stream_server_address = &quot;127.0.0.1&quot;
    stream_server_port = &quot;0&quot;
    systemd_cgroup = false
    tolerate_missing_hugetlb_controller = true
    unset_seccomp_profile = &quot;&quot;

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]
      bin_dir = &quot;/opt/cni/bin&quot;
      conf_dir = &quot;/etc/cni/net.d&quot;
      conf_template = &quot;&quot;
      ip_pref = &quot;&quot;
      max_conf_num = 1
      setup_serially = false

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]
      default_runtime_name = &quot;runc&quot;
      disable_snapshot_annotations = true
      discard_unpacked_layers = false
      ignore_blockio_not_enabled_errors = false
      ignore_rdt_not_enabled_errors = false
      no_pivot = false
      snapshotter = &quot;overlayfs&quot;

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]
        base_runtime_spec = &quot;&quot;
        cni_conf_dir = &quot;&quot;
        cni_max_conf_num = 0
        container_annotations = []
        pod_annotations = []
        privileged_without_host_devices = false
        privileged_without_host_devices_all_devices_allowed = false
        runtime_engine = &quot;&quot;
        runtime_path = &quot;&quot;
        runtime_root = &quot;&quot;
        runtime_type = &quot;&quot;
        sandbox_mode = &quot;&quot;
        snapshotter = &quot;&quot;

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
          base_runtime_spec = &quot;&quot;
          cni_conf_dir = &quot;&quot;
          cni_max_conf_num = 0
          container_annotations = []
          pod_annotations = []
          privileged_without_host_devices = false
          privileged_without_host_devices_all_devices_allowed = false
          runtime_engine = &quot;&quot;
          runtime_path = &quot;&quot;
          runtime_root = &quot;&quot;
          runtime_type = &quot;io.containerd.runc.v2&quot;
          sandbox_mode = &quot;podsandbox&quot;
          snapshotter = &quot;&quot;

          [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
            BinaryName = &quot;&quot;
            CriuImagePath = &quot;&quot;
            CriuPath = &quot;&quot;
            CriuWorkPath = &quot;&quot;
            IoGid = 0
            IoUid = 0
            NoNewKeyring = false
            NoPivotRoot = false
            Root = &quot;&quot;
            ShimCgroup = &quot;&quot;
            SystemdCgroup = true

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]
        base_runtime_spec = &quot;&quot;
        cni_conf_dir = &quot;&quot;
        cni_max_conf_num = 0
        container_annotations = []
        pod_annotations = []
        privileged_without_host_devices = false
        privileged_without_host_devices_all_devices_allowed = false
        runtime_engine = &quot;&quot;
        runtime_path = &quot;&quot;
        runtime_root = &quot;&quot;
        runtime_type = &quot;&quot;
        sandbox_mode = &quot;&quot;
        snapshotter = &quot;&quot;

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]
      key_model = &quot;node&quot;

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]
      config_path = &quot;&quot;

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]  

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]
      tls_cert_file = &quot;&quot;
      tls_key_file = &quot;&quot;

  [plugins.&quot;io.containerd.internal.v1.opt&quot;]
    path = &quot;/opt/containerd&quot;

  [plugins.&quot;io.containerd.internal.v1.restart&quot;]
    interval = &quot;10s&quot;

  [plugins.&quot;io.containerd.internal.v1.tracing&quot;]

  [plugins.&quot;io.containerd.metadata.v1.bolt&quot;]
    content_sharing_policy = &quot;shared&quot;

  [plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]
    no_prometheus = false

  [plugins.&quot;io.containerd.nri.v1.nri&quot;]
    disable = true
    disable_connections = false
    plugin_config_path = &quot;/etc/nri/conf.d&quot;
    plugin_path = &quot;/opt/nri/plugins&quot;
    plugin_registration_timeout = &quot;5s&quot;
    plugin_request_timeout = &quot;2s&quot;
    socket_path = &quot;/var/run/nri/nri.sock&quot;

  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]
    no_shim = false
    runtime = &quot;runc&quot;
    runtime_root = &quot;&quot;
    shim = &quot;containerd-shim&quot;
    shim_debug = false

  [plugins.&quot;io.containerd.runtime.v2.task&quot;]
    platforms = [&quot;linux/amd64&quot;]
    sched_core = false

  [plugins.&quot;io.containerd.service.v1.diff-service&quot;]
    default = [&quot;walking&quot;]
    sync_fs = false

  [plugins.&quot;io.containerd.service.v1.tasks-service&quot;]
    blockio_config_file = &quot;&quot;
    rdt_config_file = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.blockfile&quot;]
    fs_type = &quot;&quot;
    mount_options = []
    root_path = &quot;&quot;
    scratch_file = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]
    async_remove = false
    base_image_size = &quot;&quot;
    discard_blocks = false
    fs_options = &quot;&quot;
    fs_type = &quot;&quot;
    pool_name = &quot;&quot;
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.native&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]
    mount_options = []
    root_path = &quot;&quot;
    sync_remove = false
    upperdir_label = false

  [plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.tracing.processor.v1.otlp&quot;]

  [plugins.&quot;io.containerd.transfer.v1.local&quot;]
    config_path = &quot;&quot;
    max_concurrent_downloads = 3
    max_concurrent_uploaded_layers = 3

    [[plugins.&quot;io.containerd.transfer.v1.local&quot;.unpack_config]]
      differ = &quot;&quot;
      platform = &quot;linux/amd64&quot;
      snapshotter = &quot;overlayfs&quot;

[proxy_plugins]

[stream_processors]

  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]
    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;]
    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]
    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]
    path = &quot;ctd-decoder&quot;
    returns = &quot;application/vnd.oci.image.layer.v1.tar&quot;

  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]
    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;]
    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]
    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]
    path = &quot;ctd-decoder&quot;
    returns = &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;

[timeouts]
  &quot;io.containerd.timeout.bolt.open&quot; = &quot;0s&quot;
  &quot;io.containerd.timeout.metrics.shimstats&quot; = &quot;2s&quot;
  &quot;io.containerd.timeout.shim.cleanup&quot; = &quot;5s&quot;
  &quot;io.containerd.timeout.shim.load&quot; = &quot;5s&quot;
  &quot;io.containerd.timeout.shim.shutdown&quot; = &quot;3s&quot;
  &quot;io.containerd.timeout.task.state&quot; = &quot;2s&quot;

[ttrpc]
  address = &quot;&quot;
  gid = 0
  uid = 0
root@k8s-master:~# vim /etc/containerd/config.toml
root@k8s-master:~# cat /etc/containerd/config.toml
disabled_plugins = []
imports = []
oom_score = 0
plugin_dir = &quot;&quot;
required_plugins = []
root = &quot;/var/lib/containerd&quot;
state = &quot;/run/containerd&quot;
temp = &quot;&quot;
version = 2

[cgroup]
  path = &quot;&quot;

[debug]
  address = &quot;&quot;
  format = &quot;&quot;
  gid = 0
  level = &quot;&quot;
  uid = 0

[grpc]
  address = &quot;/run/containerd/containerd.sock&quot;
  gid = 0
  max_recv_message_size = 16777216
  max_send_message_size = 16777216
  tcp_address = &quot;&quot;
  tcp_tls_ca = &quot;&quot;
  tcp_tls_cert = &quot;&quot;
  tcp_tls_key = &quot;&quot;
  uid = 0

[metrics]
  address = &quot;&quot;
  grpc_histogram = false

[plugins]

  [plugins.&quot;io.containerd.gc.v1.scheduler&quot;]
    deletion_threshold = 0
    mutation_threshold = 100
    pause_threshold = 0.02
    schedule_delay = &quot;0s&quot;
    startup_delay = &quot;100ms&quot;

  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]
    cdi_spec_dirs = [&quot;/etc/cdi&quot;, &quot;/var/run/cdi&quot;]
    device_ownership_from_security_context = false
    disable_apparmor = false
    disable_cgroup = false
    disable_hugetlb_controller = true
    disable_proc_mount = false
    disable_tcp_service = true
    drain_exec_sync_io_timeout = &quot;0s&quot;
    enable_cdi = false
    enable_selinux = false
    enable_tls_streaming = false
    enable_unprivileged_icmp = false
    enable_unprivileged_ports = false
    ignore_deprecation_warnings = []
    ignore_image_defined_volumes = false
    image_pull_progress_timeout = &quot;5m0s&quot;
    image_pull_with_sync_fs = false
    max_concurrent_downloads = 3
    max_container_log_line_size = 16384
    netns_mounts_under_state_dir = false
    restrict_oom_score_adj = false
    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;
    selinux_category_range = 1024
    stats_collect_period = 10
    stream_idle_timeout = &quot;4h0m0s&quot;
    stream_server_address = &quot;127.0.0.1&quot;
    stream_server_port = &quot;0&quot;
    systemd_cgroup = false
    tolerate_missing_hugetlb_controller = true
    unset_seccomp_profile = &quot;&quot;

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]
      bin_dir = &quot;/opt/cni/bin&quot;
      conf_dir = &quot;/etc/cni/net.d&quot;
      conf_template = &quot;&quot;
      ip_pref = &quot;&quot;
      max_conf_num = 1
      setup_serially = false

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]
      default_runtime_name = &quot;runc&quot;
      disable_snapshot_annotations = true
      discard_unpacked_layers = false
      ignore_blockio_not_enabled_errors = false
      ignore_rdt_not_enabled_errors = false
      no_pivot = false
      snapshotter = &quot;overlayfs&quot;

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]
        base_runtime_spec = &quot;&quot;
        cni_conf_dir = &quot;&quot;
        cni_max_conf_num = 0
        container_annotations = []
        pod_annotations = []
        privileged_without_host_devices = false
        privileged_without_host_devices_all_devices_allowed = false
        runtime_engine = &quot;&quot;
        runtime_path = &quot;&quot;
        runtime_root = &quot;&quot;
        runtime_type = &quot;&quot;
        sandbox_mode = &quot;&quot;
        snapshotter = &quot;&quot;

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
          base_runtime_spec = &quot;&quot;
          cni_conf_dir = &quot;&quot;
          cni_max_conf_num = 0
          container_annotations = []
          pod_annotations = []
          privileged_without_host_devices = false
          privileged_without_host_devices_all_devices_allowed = false
          runtime_engine = &quot;&quot;
          runtime_path = &quot;&quot;
          runtime_root = &quot;&quot;
          runtime_type = &quot;io.containerd.runc.v2&quot;
          sandbox_mode = &quot;podsandbox&quot;
          snapshotter = &quot;&quot;

          [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
            BinaryName = &quot;&quot;
            CriuImagePath = &quot;&quot;
            CriuPath = &quot;&quot;
            CriuWorkPath = &quot;&quot;
            IoGid = 0
            IoUid = 0
            NoNewKeyring = false
            NoPivotRoot = false
            Root = &quot;&quot;
            ShimCgroup = &quot;&quot;
            SystemdCgroup = true

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]
        base_runtime_spec = &quot;&quot;
        cni_conf_dir = &quot;&quot;
        cni_max_conf_num = 0
        container_annotations = []
        pod_annotations = []
        privileged_without_host_devices = false
        privileged_without_host_devices_all_devices_allowed = false
        runtime_engine = &quot;&quot;
        runtime_path = &quot;&quot;
        runtime_root = &quot;&quot;
        runtime_type = &quot;&quot;
        sandbox_mode = &quot;&quot;
        snapshotter = &quot;&quot;

        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]
      key_model = &quot;node&quot;

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]
      config_path = &quot;&quot;

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]

      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]

    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]
      tls_cert_file = &quot;&quot;
      tls_key_file = &quot;&quot;

  [plugins.&quot;io.containerd.internal.v1.opt&quot;]
    path = &quot;/opt/containerd&quot;

  [plugins.&quot;io.containerd.internal.v1.restart&quot;]
    interval = &quot;10s&quot;

  [plugins.&quot;io.containerd.internal.v1.tracing&quot;]

  [plugins.&quot;io.containerd.metadata.v1.bolt&quot;]
    content_sharing_policy = &quot;shared&quot;

  [plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]
    no_prometheus = false

  [plugins.&quot;io.containerd.nri.v1.nri&quot;]
    disable = true
    disable_connections = false
    plugin_config_path = &quot;/etc/nri/conf.d&quot;
    plugin_path = &quot;/opt/nri/plugins&quot;
    plugin_registration_timeout = &quot;5s&quot;
    plugin_request_timeout = &quot;2s&quot;
    socket_path = &quot;/var/run/nri/nri.sock&quot;

  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]
    no_shim = false
    runtime = &quot;runc&quot;
    runtime_root = &quot;&quot;
    shim = &quot;containerd-shim&quot;
    shim_debug = false

  [plugins.&quot;io.containerd.runtime.v2.task&quot;]
    platforms = [&quot;linux/amd64&quot;]
    sched_core = false

  [plugins.&quot;io.containerd.service.v1.diff-service&quot;]
    default = [&quot;walking&quot;]
    sync_fs = false

  [plugins.&quot;io.containerd.service.v1.tasks-service&quot;]
    blockio_config_file = &quot;&quot;
    rdt_config_file = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.blockfile&quot;]
    fs_type = &quot;&quot;
    mount_options = []
    root_path = &quot;&quot;
    scratch_file = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]
    async_remove = false
    base_image_size = &quot;&quot;
    discard_blocks = false
    fs_options = &quot;&quot;
    fs_type = &quot;&quot;
    pool_name = &quot;&quot;
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.native&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]
    mount_options = []
    root_path = &quot;&quot;
    sync_remove = false
    upperdir_label = false

  [plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]
    root_path = &quot;&quot;

  [plugins.&quot;io.containerd.tracing.processor.v1.otlp&quot;]

  [plugins.&quot;io.containerd.transfer.v1.local&quot;]
    config_path = &quot;&quot;
    max_concurrent_downloads = 3
    max_concurrent_uploaded_layers = 3

    [[plugins.&quot;io.containerd.transfer.v1.local&quot;.unpack_config]]
      differ = &quot;&quot;
      platform = &quot;linux/amd64&quot;
      snapshotter = &quot;overlayfs&quot;

[proxy_plugins]

[stream_processors]

  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]
    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;]
    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]
    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]
    path = &quot;ctd-decoder&quot;
    returns = &quot;application/vnd.oci.image.layer.v1.tar&quot;

  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]
    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;]
    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]
    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]
    path = &quot;ctd-decoder&quot;
    returns = &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;

[timeouts]
  &quot;io.containerd.timeout.bolt.open&quot; = &quot;0s&quot;
  &quot;io.containerd.timeout.metrics.shimstats&quot; = &quot;2s&quot;
  &quot;io.containerd.timeout.shim.cleanup&quot; = &quot;5s&quot;
  &quot;io.containerd.timeout.shim.load&quot; = &quot;5s&quot;
  &quot;io.containerd.timeout.shim.shutdown&quot; = &quot;3s&quot;
  &quot;io.containerd.timeout.task.state&quot; = &quot;2s&quot;

[ttrpc]
  address = &quot;&quot;
  gid = 0
  uid = 0
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 配置crictl使用containerd</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      sudo tee /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">      runtime-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">      image-endpoint: unix:///run/containerd/containerd.sock</span><br><span class="line">      timeout: 10</span><br><span class="line">      debug: false</span><br><span class="line">      EOF</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>初始化master</p>
<ol>
<li><pre><code>sudo kubeadm init \
  --apiserver-advertise-address=172.23.159.13 \
  --apiserver-cert-extra-sans=120.55.74.89,k8s-master \
  --image-repository registry.aliyuncs.com/google_containers \
  --kubernetes-version $(kubeadm version -o short) \
  --pod-network-cidr=10.244.0.0/16

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 结果:</span><br><span class="line"></span><br><span class="line">3. ```</span><br><span class="line">   Your Kubernetes control-plane has initialized successfully!</span><br><span class="line">   </span><br><span class="line">   To start using your cluster, you need to run the following as a regular user:</span><br><span class="line">   </span><br><span class="line">     mkdir -p $HOME/.kube</span><br><span class="line">     sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">     sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">   </span><br><span class="line">   Alternatively, if you are the root user, you can run:</span><br><span class="line">   </span><br><span class="line">     export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">   </span><br><span class="line">   You should now deploy a pod network to the cluster.</span><br><span class="line">   Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">     https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line">   </span><br><span class="line">   Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line">   </span><br><span class="line">   kubeadm join 172.23.159.16:6443 --token 3hhxla.q0vggulqf855w9qj \</span><br><span class="line">           --discovery-token-ca-cert-hash sha256:46251037d5a972db8d96635b4c1244c00c9d17f6e90963a2e6da5d42106724ab </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>配置kubectl</p>
</li>
<li><p>安装网络插件</p>
<ol>
<li><p>calico</p>
<ol>
<li><pre><code>Calico 镜像拉取失败（国内环境）解决步骤
1. 部署 Calico（官方 YAML）
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/calico.yaml

2. 替换镜像源（解决国内拉取失败问题）

👉 把 docker.io 换成 DaoCloud 镜像加速地址：

# 替换 calico-node DaemonSet 主容器和 cni 容器
kubectl -n kube-system set image daemonset/calico-node \
  calico-node=quay.m.daocloud.io/calico/node:v3.27.3 \
  install-cni=quay.m.daocloud.io/calico/cni:v3.27.3 \
  upgrade-ipam=quay.m.daocloud.io/calico/cni:v3.27.3

3. 额外修复 init 容器 mount-bpffs
kubectl -n kube-system set image daemonset/calico-node \
  mount-bpffs=quay.m.daocloud.io/calico/node:v3.27.3

4. 替换 calico-kube-controllers 镜像
kubectl -n kube-system set image deployment/calico-kube-controllers \
  calico-kube-controllers=quay.m.daocloud.io/calico/kube-controllers:v3.27.3

5. 删除旧的 Pod，让 DaemonSet/Deployment 重建
kubectl delete pod -n kube-system -l k8s-app=calico-node
kubectl delete pod -n kube-system -l k8s-app=calico-kube-controllers

6. 验证状态
kubectl get pods -n kube-system


期望结果：

calico-node → Running

calico-kube-controllers → Running

其他系统组件 → Running
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. </span><br><span class="line"></span><br><span class="line">7. 导入nodes</span><br><span class="line"></span><br><span class="line">   1. 让master生成加入命令：`kubeadm token create --print-join-command`</span><br><span class="line">   2. 把上面的命令运行到nodes上</span><br><span class="line"></span><br><span class="line">8. （可选）可视化组件dashboard</span><br><span class="line"></span><br><span class="line">   1. 安装：`kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml`</span><br><span class="line"></span><br><span class="line">   2. 改镜像</span><br><span class="line"></span><br><span class="line">      1. ```</span><br><span class="line">         # Dashboard</span><br><span class="line">         kubectl -n kubernetes-dashboard set image deploy/kubernetes-dashboard \</span><br><span class="line">           kubernetes-dashboard=registry.cn-hangzhou.aliyuncs.com/google_containers/dashboard:v2.7.0</span><br><span class="line">         </span><br><span class="line">         # Metrics Scraper</span><br><span class="line">         kubectl -n kubernetes-dashboard set image deploy/dashboard-metrics-scraper \</span><br><span class="line">           dashboard-metrics-scraper=registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper:v1.0.8</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>改设置：</p>
<ol>
<li><code>kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</code>把里面的type: ClassIp 改为NodePort</li>
<li><code>kubectl get svc -A | grep kubernetes-dashboard</code>得到控制台端口，在安全组中开放之</li>
<li>就可以通过浏览器，任意集群服务公网加端口，访问控制。<a target="_blank" rel="noopener" href="https://115.29.194.182:32100/">https://115.29.194.182:32100</a></li>
</ol>
</li>
<li><p>生成token</p>
<ol>
<li><p>创建角色</p>
<ol>
<li><pre><code class="language-bash"># 创建一个 ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kubernetes-dashboard
---
# 将 ServiceAccount 绑定到 cluster-admin 角色
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kubernetes-dashboard
---
# 为 ServiceAccount 创建一个 Secret（长期有效的 token）
apiVersion: v1
kind: Secret
metadata:
  name: admin-user-token
  namespace: kubernetes-dashboard
  annotations:
    kubernetes.io/service-account.name: &quot;admin-user&quot;
type: kubernetes.io/service-account-token

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. 应用配置</span><br><span class="line"></span><br><span class="line">      3. 获取token: `kubectl -n kubernetes-dashboard describe secret admin-user-token`长期有效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### token</span><br><span class="line"></span><br><span class="line">1. ```</span><br><span class="line">   eyJhbGciOiJSUzI1NiIsImtpZCI6IjRwMG9ycHJOTkNUbXFiQ0VtaHZFcWN4Z1c5SE5FSndoeXczblhqOGE3V1UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJhMGJhYzk4Ny1iZmJkLTRiYzItOTU0My1mZjA3YmIwOGU5MWMiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.olewgwArPXj57FGM5Kmo99yeVRVl7tEnfbLorPzzQxP97nuACkO1aWCVakFMKkjT3UeVTSUyKvzpEO7qTF_T2xC556sKt_qJ-uxtFmooix3ix1gUIrrAYOKjaiFcajNFlSuZ5XscMlNoJkmqr8cpJkXWO_B0qXSm0o4KKWSBtU4up9Mus10Mu_wlJpBxPEpQ0O-95lA1jBvR9A7WkfhDXYJ-IzKFDqS30mizQUO8Lc-iZLftLdhj9aabbmSm3xScCpemo_rFP1RtH0Yr0WZCVoBq1xZSI7tC0rbRro1uhc15skCO5Y7Epr5xftorP1KVYi11ux7kFTcMFttjDGt_BQ</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="核心实战"><a href="#核心实战" class="headerlink" title="核心实战"></a>核心实战</h3><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><ol>
<li><p>通过Deployment启用Pod，负责控制Pod，使之有多个副本，有自愈、扩缩容等能力</p>
</li>
<li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx-03</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-nginx-03</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-nginx-03</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ghcr.io/nginxinc/nginx-unprivileged:1.25</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx-03-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-nginx-03</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>创建了一个deployment，设置replicas&#x3D;2，创建两个pod和一个service。</li>
<li>两个pod的ip不一样。但一个pod中的不同container的ip一样的，端口不一样。</li>
</ol>
</li>
<li><p>命令：</p>
<ol>
<li><pre><code class="language-bash"># 创建deployment
kubectl create deployment my-nginx --image=nginx:1.25.2 --replicas=2
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. </span><br><span class="line"></span><br><span class="line">4. 体验deployment的功能</span><br><span class="line"></span><br><span class="line">   1. 扩缩容`kubectl scale deploy/&lt;pod&gt; --replicas=&lt;n&gt; `</span><br><span class="line">   2. 自愈 &amp; 故障转移：如果感知到pod故障，就重启pod。如果pod无法重启，比如服务器断电，则在其他服务器部署</span><br><span class="line">   3. 滚动更新：pod要更新时，不停机更新，一个一个更新。</span><br><span class="line">      1. `kubectl set image deploy/&lt;deploy&gt; &lt;image&gt;=xxxx --record`</span><br><span class="line">   4. 版本控制：`kubectl rollout undo deploy/&lt;dep&gt; --to-revision=xxx`</span><br><span class="line"></span><br><span class="line">#### Service</span><br><span class="line"></span><br><span class="line">1. 将一组Pods公开为网络服务的抽象方法。负责Pod服务的发现与负载均衡。</span><br><span class="line"></span><br><span class="line">2. 命令</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      # kubectl expose &lt;name&gt; </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>–port：暴露端口（集群内部port）</p>
</li>
<li><p>–target-port：映射端口</p>
</li>
<li><p>–type&#x3D;NodePort：把所有pod的IP映射到同一个Service的IP，以实现负载均衡。可公网访问</p>
</li>
<li><p>–type&#x3D;ClusterIP：把所有pod的IP映射到同一个Service的IP，以实现负载均衡。但是只能在集群内部访问（也是默认情况）</p>
</li>
</ol>
</li>
</ol>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250920150332000.png" alt="image-20250920150332000"></h4><ol>
<li><p>k8s希望Ingress是流量唯一入口（网关）</p>
</li>
<li><p>安装Ingress</p>
<ol>
<li><p>添加官方部署yaml文件（⚠️ 这一步可能失败（因为默认拉取的是 <code>k8s.gcr.io</code> &#x2F; <code>registry.k8s.io</code> 的国外镜像）。）：<code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controllerv-1.9.6/deploy/static/provider/baremetal/deploy.yaml</code></p>
</li>
<li><p>修改为国内镜像</p>
<ol>
<li><pre><code class="language-bash"># 找到pod
kubectl get pods -n ingress-nginx

# 修改镜像。用DaoCloud 提供的一个中国代理镜像仓库
# 替换 Ingress Controller 镜像
kubectl -n ingress-nginx set image deployment ingress-nginx-controller \
  controller=k8s-gcr.m.daocloud.io/ingress-nginx/controller:v1.9.6


# 替换 Admission Webhook Job 镜像
# 因为一直调不通，就不用admiss了
kubectl -n ingress-nginx set image job/ingress-nginx-admission-create \
  create=k8s-gcr.m.daocloud.io/ingress-nginx/kube-webhook-certgen:v1.4.1

kubectl -n ingress-nginx set image job/ingress-nginx-admission-patch \
  patch=k8s-gcr.m.daocloud.io/ingress-nginx/kube-webhook-certgen:v1.4.1



# 验证安装
kubectl get pods -n ingress-nginx -w

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. 一系列授权（改动的原理我就不知道了）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### nfs</span><br><span class="line"></span><br><span class="line">1. 为了同步各个服务器的存储信息，用nfs</span><br><span class="line"></span><br><span class="line">2. 服务端安装nfs-server（存储）</span><br><span class="line"></span><br><span class="line">   1. ```bash</span><br><span class="line">      sudo apt install -y nfs-kernel-server</span><br><span class="line">      </span><br><span class="line">      sudo mkdir -p /nfs/data</span><br><span class="line">      sudo chown nobody:nogroup /nfs/data</span><br><span class="line">      sudo chmod 777 /nfs/data</span><br><span class="line">      </span><br><span class="line">      # 编辑导出配置</span><br><span class="line">      echo &quot;/nfs/data *(rw,sync,no_subtree_check,no_root_squash,insecure)&quot; | sudo tee -a /etc/exports</span><br><span class="line">      </span><br><span class="line">      # 启动服务</span><br><span class="line">      sudo systemctl enable rpcbind --now</span><br><span class="line">      sudo systemctl enable nfs-kernel-server --now</span><br><span class="line">      </span><br><span class="line">      # 生效导出</span><br><span class="line">      sudo exportfs -rav</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>所有节点安装nfs-client（挂载）</p>
<ol>
<li><pre><code class="language-bash">sudo apt update
sudo apt install -y nfs-common


# 查看服务端导出目录
showmount -e 172.23.159.16

# 本地挂载目录
sudo mkdir -p /nfs/data
sudo mount -t nfs 172.23.159.16:/nfs/data /nfs/data

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. PV：持久卷。就是真实存储内容的位置。</span><br><span class="line"></span><br><span class="line">5. PVC：持久卷声明。申请存储空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 小结</span><br><span class="line"></span><br><span class="line">![image-20250920164917122](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250920164917122.png)</span><br><span class="line"></span><br><span class="line">1. **基础集群环境**</span><br><span class="line"></span><br><span class="line">   - 已经搭建好一个 **Kubernetes 集群 (v1.28.2)**，包含：</span><br><span class="line">     - 控制平面组件：`etcd`、`kube-apiserver`、`kube-controller-manager`、`kube-scheduler` ✅</span><br><span class="line">     - 网络插件：**Calico**（`calico-node`、`calico-kube-controllers`） ✅</span><br><span class="line">     - 集群 DNS：`coredns` ✅</span><br><span class="line">     - 代理：`kube-proxy`（iptables 模式） ✅</span><br><span class="line">     - 辅助：部署了 **kubernetes-dashboard** ✅</span><br><span class="line"></span><br><span class="line">   集群核心服务状态良好，全部 Running。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">2. **业务工作负载**</span><br><span class="line"></span><br><span class="line">   - 在 `default` 命名空间部署了一个 **nginx 应用**：</span><br><span class="line">     - Deployment `my-nginx-03`，有 2 个 Pod Running ✅</span><br><span class="line">     - 用于后续测试 Service 和 Ingress 转发。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">3. **Ingress 部署**</span><br><span class="line"></span><br><span class="line">   - 尝试部署了 **ingress-nginx-controller (v1.9.6)**，过程中遇到几个问题：</span><br><span class="line">     1. **镜像拉取失败** → 解决方法：换用 `k8s-gcr.m.daocloud.io/ingress-nginx/controller:v1.9.6` ✅</span><br><span class="line">     2. **Admission Jobs CrashLoopBackOff** → 你决定跳过 admission，不再使用 webhook ✅</span><br><span class="line">     3. **Controller Pod 启动失败** →</span><br><span class="line">        - 原因：`ServiceAccount` RBAC 权限不足</span><br><span class="line">        - 修复：补齐了对 `services`、`endpointslices`、`leases` 的访问权限 ✅</span><br><span class="line">     4. **最终 ingress-nginx-controller 正常 Running**，日志显示 Nginx 已经启动，并完成 Leader Election ✅</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">4. **验证 Ingress**</span><br><span class="line"></span><br><span class="line">   - 访问 `http://172.23.159.15:31080`（NodePort 方式） → 成功命中 ingress-nginx，但返回 **404**（因为还没有配置 Ingress 规则）。</span><br><span class="line">   - 这一步证明 **Ingress Controller + NodePort 已经完全打通**，只差创建路由规则。</span><br><span class="line"></span><br><span class="line">5. **有两个可对外访问的 NodePort 服务**：</span><br><span class="line"></span><br><span class="line">   1. **`my-nginx-03-svc`**</span><br><span class="line">      - 类型：`NodePort`</span><br><span class="line">      - ClusterIP: `10.97.118.5`</span><br><span class="line">      - 端口：`80:30080/TCP`</span><br><span class="line">         👉 直接访问 `http://&lt;NodeIP&gt;:30080` 就能看到 **nginx welcome page**。</span><br><span class="line">   2. **`ingress-nginx-controller`**</span><br><span class="line">      - 类型：`NodePort`</span><br><span class="line">      - ClusterIP: `10.101.33.201`</span><br><span class="line">      - 端口：`80:31080/TCP, 443:31443/TCP`</span><br><span class="line">         👉 这是 Ingress Controller 的入口，当前访问会返回 **404**，因为还没有配置任何 Ingress 规则。</span><br><span class="line"></span><br><span class="line">6. 示例demo</span><br><span class="line"></span><br><span class="line">1. ```yaml</span><br><span class="line">   # ---------------------------</span><br><span class="line">   # hello-server Deployment</span><br><span class="line">   # ---------------------------</span><br><span class="line">   apiVersion: apps/v1</span><br><span class="line">   kind: Deployment</span><br><span class="line">   metadata:</span><br><span class="line">     name: hello-server</span><br><span class="line">     namespace: default</span><br><span class="line">   spec:</span><br><span class="line">     replicas: 2</span><br><span class="line">     selector:</span><br><span class="line">       matchLabels:</span><br><span class="line">         app: hello-server</span><br><span class="line">     template:</span><br><span class="line">       metadata:</span><br><span class="line">         labels:</span><br><span class="line">           app: hello-server</span><br><span class="line">       spec:</span><br><span class="line">         containers:</span><br><span class="line">         - name: hello-server</span><br><span class="line">           image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span><br><span class="line">           ports:</span><br><span class="line">           - containerPort: 9000</span><br><span class="line">   ---</span><br><span class="line">   # hello-server Service</span><br><span class="line">   apiVersion: v1</span><br><span class="line">   kind: Service</span><br><span class="line">   metadata:</span><br><span class="line">     name: hello-server</span><br><span class="line">     namespace: default</span><br><span class="line">   spec:</span><br><span class="line">     selector:</span><br><span class="line">       app: hello-server</span><br><span class="line">     ports:</span><br><span class="line">     - port: 8000</span><br><span class="line">       targetPort: 9000</span><br><span class="line">       protocol: TCP</span><br><span class="line">   ---</span><br><span class="line">   # ---------------------------</span><br><span class="line">   # nginx-demo Deployment</span><br><span class="line">   # ---------------------------</span><br><span class="line">   apiVersion: apps/v1</span><br><span class="line">   kind: Deployment</span><br><span class="line">   metadata:</span><br><span class="line">     name: nginx-demo</span><br><span class="line">     namespace: default</span><br><span class="line">   spec:</span><br><span class="line">     replicas: 2</span><br><span class="line">     selector:</span><br><span class="line">       matchLabels:</span><br><span class="line">         app: nginx-demo</span><br><span class="line">     template:</span><br><span class="line">       metadata:</span><br><span class="line">         labels:</span><br><span class="line">           app: nginx-demo</span><br><span class="line">       spec:</span><br><span class="line">         containers:</span><br><span class="line">         - name: nginx-demo</span><br><span class="line">           image: ghcr.io/nginxinc/nginx-unprivileged:1.25</span><br><span class="line">           ports:</span><br><span class="line">           - containerPort: 80</span><br><span class="line">   ---</span><br><span class="line">   # nginx-demo Service</span><br><span class="line">   apiVersion: v1</span><br><span class="line">   kind: Service</span><br><span class="line">   metadata:</span><br><span class="line">     name: nginx-demo</span><br><span class="line">     namespace: default</span><br><span class="line">   spec:</span><br><span class="line">     selector:</span><br><span class="line">       app: nginx-demo</span><br><span class="line">     ports:</span><br><span class="line">     - port: 8000</span><br><span class="line">       targetPort: 80</span><br><span class="line">       protocol: TCP</span><br><span class="line">   ---</span><br><span class="line">   # ---------------------------</span><br><span class="line">   # Ingress 配置</span><br><span class="line">   # ---------------------------</span><br><span class="line">   apiVersion: networking.k8s.io/v1</span><br><span class="line">   kind: Ingress</span><br><span class="line">   metadata:</span><br><span class="line">     name: demo-ingress</span><br><span class="line">     namespace: default</span><br><span class="line">   spec:</span><br><span class="line">     ingressClassName: nginx</span><br><span class="line">     rules:</span><br><span class="line">     - host: hello.mukongshan.com</span><br><span class="line">       http:</span><br><span class="line">         paths:</span><br><span class="line">         - path: /</span><br><span class="line">           pathType: Prefix</span><br><span class="line">           backend:</span><br><span class="line">             service:</span><br><span class="line">               name: hello-server</span><br><span class="line">               port:</span><br><span class="line">                 number: 8000</span><br><span class="line">     - host: demo.mukongshan.com</span><br><span class="line">       http:</span><br><span class="line">         paths:</span><br><span class="line">         - path: /</span><br><span class="line">           pathType: Prefix</span><br><span class="line">           backend:</span><br><span class="line">             service:</span><br><span class="line">               name: nginx-demo</span><br><span class="line">               port:</span><br><span class="line">                 number: 8000</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><ol>
<li>ingress<ol>
<li>路径重写</li>
<li>限流</li>
</ol>
</li>
</ol>
<h2 id="Kubesphere"><a href="#Kubesphere" class="headerlink" title="Kubesphere"></a>Kubesphere</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>裸机安装（很方便，几条指令就好了）<ol>
<li><p>如果遇到镜像联不通，试试<code>export KKZONE=cn</code></p>
</li>
<li><p>删除已有应用：</p>
<ol>
<li><pre><code class="language-bash"># 停止并卸载 kubeadm/kubelet/kubectl
sudo systemctl stop kubelet
sudo apt-get purge -y kubeadm kubectl kubelet kubernetes-cni kube*
sudo apt-get autoremove -y
sudo rm -rf ~/.kube /etc/kubernetes /var/lib/etcd /var/etcd /var/lib/kubelet

# 卸载 Docker（如果不打算用 KK 自带的 Docker）
sudo systemctl stop docker docker.socket
sudo apt-get purge -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo apt-get autoremove -y
sudo rm -rf /var/lib/docker /var/lib/containerd

# 卸载containerd
sudo systemctl stop containerd
sudo apt-get purge -y containerd containerd.io
sudo apt-get autoremove -y
sudo rm -rf /etc/containerd /var/lib/containerd
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li>在已有的k8s集群上安装<ol>
<li>先安装Helm Chart</li>
<li></li>
</ol>
</li>
</ol>
<h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><ol>
<li>admin是最高权限</li>
<li>划分多个角色，权限不同，对企业、项目、角色的访问能力不同</li>
</ol>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250922212806241.png" alt="image-20250922212806241"></p>
<ol>
<li>考虑工作负载<ol>
<li>部署（无状态）</li>
<li>有状态副本集</li>
<li>守护进程集</li>
</ol>
</li>
<li>考虑数据挂载和配置</li>
<li>考虑访问控制</li>
</ol>
<h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><ol>
<li>凡拉取镜像都应该先上DockerHub上看拉取方式</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250923095045954.png" alt="image-20250923095045954"></li>
<li>考虑配置文件<ol>
<li>根据dockerhub上的mysql官方文档描述，以.cnf结尾的文件会被默认为配置文件。</li>
<li>在Kubesphere的可视化平台中，找到配置，其中key就是原来的文件名，value就是你的配置</li>
</ol>
</li>
<li>考虑卷挂载声明</li>
</ol>
<h4 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h4><h4 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h4><ol>
<li>注意，如果挂载配置文件时，文件夹下有多个配置文件，但我们只想挂载某些时，需要把挂载路径精确到文件</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SSM学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:05:59" itemprop="dateModified" datetime="2025-12-03T17:05:59+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ul>
<li>不需要完整学习 Spring（特别是 XML 配置那一套）。</li>
<li>只需要补齐一些 Spring 的核心概念：<ul>
<li><strong>IoC&#x2F;DI（控制反转 &#x2F; 依赖注入）</strong></li>
<li><strong>Bean 生命周期与作用域</strong></li>
<li><strong>AOP（切面编程，事务、日志、权限）</strong></li>
<li><strong>Spring MVC 的基本原理（DispatcherServlet、HandlerMapping、Controller）</strong><br> 👉 这些都是 Spring Boot 底层依然在用的，你必须理解，不然看不懂它的自动装配。</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251010163619400.png" alt="image-20251010163619400"></p>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250912194959230.png" alt="image-20250912194959230"></p>
<h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><h3 id="IoC（Inversion-of-Control）控制反转"><a href="#IoC（Inversion-of-Control）控制反转" class="headerlink" title="IoC（Inversion of Control）控制反转"></a>IoC（Inversion of Control）控制反转</h3><ol>
<li>核心思想：使用对象时，不要显示的new创建对象，而是由“外部”提供对象。这个过程中对象创建权由程序移交到外部，称为控制反转。</li>
<li>被创建和管理的对象在IoC容器中，称为Bean</li>
</ol>
<h3 id="DI（Dependency-Injection）依赖注入"><a href="#DI（Dependency-Injection）依赖注入" class="headerlink" title="DI（Dependency Injection）依赖注入"></a>DI（Dependency Injection）依赖注入</h3><ol>
<li>在容器中建立Bean与Bean之间依赖关系的过程，称为依赖注入</li>
</ol>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><ol>
<li><p>什么是bean</p>
<ol>
<li><strong>Bean &#x3D; 被 Spring 容器（IoC 容器）管理的对象</strong></li>
<li>在普通 Java 程序里，我们需要手动 <code>new</code> 一个对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li>在 Spring 里，不用自己 <code>new</code>，交给 Spring 来管理，它会创建、装配、销毁对象。</li>
</ol>
</li>
<li><p>Bean 的来源</p>
<ol>
<li><strong>注解声明</strong><ul>
<li><code>@Component</code>：通用组件</li>
<li><code>@Service</code>：业务逻辑层</li>
<li><code>@Repository</code>：数据访问层（DAO）</li>
<li><code>@Controller</code> &#x2F; <code>@RestController</code>：控制层（Web）</li>
<li><code>@Configuration</code> + <code>@Bean</code>：在配置类里手动声明 Bean</li>
</ul>
</li>
<li><strong>自动装配</strong><ul>
<li>Spring Boot 通过 <strong>自动配置（AutoConfiguration）</strong> 和 <code>@EnableAutoConfiguration</code>，会自动往容器里注册很多 Bean（例如 DataSource、EntityManager）。</li>
</ul>
</li>
</ol>
</li>
<li><p>生命周期</p>
<ol>
<li><strong>实例化</strong>：Spring 创建对象（相当于 <code>new</code>）</li>
<li><strong>属性赋值 &#x2F; 依赖注入</strong>：给 Bean 注入依赖（DI, Dependency Injection）</li>
<li><strong>初始化</strong>：执行初始化方法（<code>@PostConstruct</code> &#x2F; <code>InitializingBean.afterPropertiesSet()</code>）</li>
<li><strong>使用</strong>：在应用中被调用</li>
<li><strong>销毁</strong>：应用关闭时销毁 Bean（<code>@PreDestroy</code> &#x2F; <code>DisposableBean.destroy()</code>）</li>
</ol>
</li>
<li><p>作用域：</p>
<table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>singleton（默认）</strong></td>
<td align="left">每个 Spring 容器中只有一个实例（共享）</td>
</tr>
<tr>
<td align="left"><strong>prototype</strong></td>
<td align="left">每次获取 Bean 都创建一个新实例</td>
</tr>
<tr>
<td align="left"><strong>request</strong></td>
<td align="left">每个 HTTP 请求创建一个 Bean（Web 环境）</td>
</tr>
<tr>
<td align="left"><strong>session</strong></td>
<td align="left">每个用户会话一个 Bean</td>
</tr>
<tr>
<td align="left"><strong>application</strong></td>
<td align="left">整个 ServletContext 生命周期内一个 Bean</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>什么是 AOP？</p>
<ul>
<li>OOP（面向对象编程）：我们通过类和对象来组织代码。</li>
<li>AOP（面向切面编程）：我们把 横切关注点（cross-cutting concerns） 从业务逻辑中抽离出来。</li>
</ul>
<ol>
<li><p>简单说：<br> <strong>在不改动原有业务代码的情况下，动态地在某些方法的前后“插入”额外逻辑。</strong></p>
</li>
<li><p>常见的横切关注点有：</p>
<ul>
<li><p>日志记录（打印方法调用情况）</p>
</li>
<li><p>性能监控（统计方法耗时）</p>
</li>
<li><p>权限校验（检查用户是否有权限访问）</p>
</li>
<li><p>事务管理（方法执行失败时回滚）</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>AOP 的几个核心概念</p>
<ol>
<li>Aspect（切面）<br> 横切逻辑的模块化单元，比如“日志切面”、“事务切面”。</li>
<li>Join Point（连接点）<br> 程序运行的某个点，可以是方法调用、异常抛出等。<br> Spring AOP 支持的连接点是 <strong>方法级别</strong>。</li>
<li>Pointcut（切点）<br> 定义哪些连接点要被拦截，比如 <code>execution(* com.example.service.*.*(..))</code> 表示拦截 service 包下所有方法。</li>
<li>Advice（通知）<br> 切面在切点处要执行的操作，有几种类型：<ul>
<li><code>@Before</code>：方法执行前</li>
<li><code>@After</code>：方法执行后</li>
<li><code>@AfterReturning</code>：方法成功返回后</li>
<li><code>@AfterThrowing</code>：方法抛出异常时</li>
<li><code>@Around</code>：方法执行前后都能操作（最强大，可以手动控制目标方法是否执行）</li>
</ul>
</li>
<li>Weaving（织入）<br> 把切面逻辑“织入”到目标对象的过程。Spring AOP 用 <strong>动态代理</strong> 实现：<ul>
<li>如果目标类实现了接口 → JDK 动态代理</li>
<li>如果没有接口 → CGLIB 字节码生成</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h3><ol>
<li><p>AOP 代理是 Spring AOP 实现“横切逻辑织入”的核心机制，它是 Spring 在运行时为目标对象生成的一个代理对象，用来在调用目标方法前后，插入额外的增强逻辑（Advice），从而实现 AOP 的功能。</p>
</li>
<li><p>运行流程</p>
<ol>
<li>你定义一个切面（Aspect），包含：切点（Pointcut）：描述哪些方法需要被增强（比如 <code>execution(* com.example.service.*.*(..))</code>）通知（Advice）：描述在目标方法执行 前&#x2F;后&#x2F;异常&#x2F;最终 要执行的逻辑（比如日志、事务）</li>
<li>Spring 容器启动时，会扫描这些切面，并为目标 Bean 创建代理对象如果有接口 → JDK 动态代理如果无接口 → CGLIB 代理</li>
<li>当你从 Spring 容器中获取 Bean 时，实际上拿到的是代理对象，不是原始对象！</li>
<li>当你调用代理对象的方法时，代理会先执行横切逻辑（Advice），再调用真正目标方法（或根据通知类型决定顺序）</li>
</ol>
</li>
<li><p>示例</p>
<ol>
<li><p>启用AOP</p>
<ol>
<li><pre><code class="language-java">@SpringBootApplication
@EnableAspectJAutoProxy  // 启用 Spring AOP
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 定义切片类</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      import org.aspectj.lang.annotation.*;</span><br><span class="line">      import org.springframework.stereotype.Component;</span><br><span class="line">      </span><br><span class="line">      @Aspect</span><br><span class="line">      @Component</span><br><span class="line">      public class LoggingAspect &#123;</span><br><span class="line">      </span><br><span class="line">          // 定义切点：拦截 com.example.service 包下的所有方法</span><br><span class="line">          @Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</span><br><span class="line">          public void serviceMethods() &#123;&#125;</span><br><span class="line">      </span><br><span class="line">          // 前置通知：在目标方法执行前执行</span><br><span class="line">          @Before(&quot;serviceMethods()&quot;)</span><br><span class="line">          public void logBefore() &#123;</span><br><span class="line">              System.out.println(&quot;[AOP] 方法即将执行...&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          // 后置通知：在目标方法执行后执行</span><br><span class="line">          @After(&quot;serviceMethods()&quot;)</span><br><span class="line">          public void logAfter() &#123;</span><br><span class="line">              System.out.println(&quot;[AOP] 方法执行完成！&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><ol>
<li><p>解释：</p>
<ol>
<li>M：Model。由Controller准备，包含要展示的数据</li>
<li>V：View。由Thymeleaf模版担任，负责如何展示数据</li>
<li>C：Controller。</li>
</ol>
</li>
<li><p><strong>核心组件：</strong></p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>DispatcherServlet（前端控制器）</strong></td>
<td align="left"><strong>核心入口，接收所有 HTTP 请求，负责调度</strong></td>
</tr>
<tr>
<td align="left"><strong>HandlerMapping</strong></td>
<td align="left"><strong>根据请求 URL 找到对应的 Controller 方法</strong></td>
</tr>
<tr>
<td align="left"><strong>Controller</strong></td>
<td align="left"><strong>处理具体业务逻辑，返回 Model 和 View 或数据（如 JSON）</strong></td>
</tr>
<tr>
<td align="left"><strong>ViewResolver</strong></td>
<td align="left"><strong>将逻辑视图名解析为实际页面（如 JSP、Thymeleaf）</strong></td>
</tr>
<tr>
<td align="left"><strong>ModelAndView &#x2F; @ResponseBody</strong></td>
<td align="left"><strong>用于返回数据或视图</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>基本流程：</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251010163218244.png" alt="image-20251010163218244"></p>
<ol>
<li>用户发起请求 → <strong>DispatcherServlet</strong> 接收</li>
<li><strong>HandlerMapping</strong> 找到匹配的 <strong>Controller 方法</strong></li>
<li><strong>Controller</strong> 处理请求，返回<strong>ModelAndView</strong></li>
<li><strong>视图解析并渲染返回给用户</strong></li>
</ol>
<blockquote>
<p>🎯 <strong>一句话：</strong> Spring MVC 通过 <strong>DispatcherServlet</strong> 统一调度，把请求交给对应的 Controller 处理，最终返回结果，是 Web 开发的核心框架。</p>
</blockquote>
</li>
</ol>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>在 Spring 的事务管理中，事务传播机制（Transaction Propagation Behavior） 是指：当一个事务方法被另一个事务方法调用时，这个事务该如何传播？是加入已有的事务，还是开启一个新的事务，还是以非事务方式运行？</li>
<li>换句话说：事务传播机制定义了多个事务方法相互调用时，事务边界应该如何传播、如何管理，是 Spring 事务管理中非常核心的一个概念。</li>
</ol>
<h3 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h3><table>
<thead>
<tr>
<th align="left">传播机制</th>
<th align="left">枚举常量</th>
<th align="left">说明</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. REQUIRED（默认）</strong></td>
<td align="left"><code>Propagation.REQUIRED</code></td>
<td align="left">如果当前存在事务，就加入该事务；如果当前没有事务，就新建一个事务</td>
<td align="left">✅ 最常用，适用于大多数业务方法</td>
</tr>
<tr>
<td align="left"><strong>2. REQUIRES_NEW</strong></td>
<td align="left"><code>Propagation.REQUIRES_NEW</code></td>
<td align="left">无论当前是否存在事务，都新建一个事务，并挂起当前事务（如果有）</td>
<td align="left">适用于独立事务场景，比如日志记录、审计等不应与主事务同生共死</td>
</tr>
<tr>
<td align="left"><strong>3. SUPPORTS</strong></td>
<td align="left"><code>Propagation.SUPPORTS</code></td>
<td align="left">如果当前有事务，就加入事务；如果当前没有事务，就以非事务方式运行</td>
<td align="left">适用于可选事务的场景</td>
</tr>
<tr>
<td align="left"><strong>4. NOT_SUPPORTED</strong></td>
<td align="left"><code>Propagation.NOT_SUPPORTED</code></td>
<td align="left">以非事务方式运行，如果当前有事务，就把当前事务挂起</td>
<td align="left">适用于不想参与事务的方法，比如只读查询</td>
</tr>
<tr>
<td align="left"><strong>5. MANDATORY</strong></td>
<td align="left"><code>Propagation.MANDATORY</code></td>
<td align="left">必须在一个已有的事务中运行，如果当前没有事务，就抛出异常</td>
<td align="left">适用于必须被事务方法调用的方法，防止误调用</td>
</tr>
<tr>
<td align="left"><strong>6. NEVER</strong></td>
<td align="left"><code>Propagation.NEVER</code></td>
<td align="left">必须以非事务方式运行，如果当前存在事务，就抛出异常</td>
<td align="left">适用于禁止事务的方法，比如某些严格只读操作</td>
</tr>
<tr>
<td align="left"><strong>7. NESTED</strong></td>
<td align="left"><code>Propagation.NESTED</code></td>
<td align="left">如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则新建一个事务 （嵌套事务是保存点机制，可部分回滚）</td>
<td align="left">适用于需要部分回滚的场景</td>
</tr>
</tbody></table>
<h3 id="事务的两种实现方式"><a href="#事务的两种实现方式" class="headerlink" title="事务的两种实现方式"></a>事务的两种实现方式</h3><ol>
<li><p>声明式事务（Declarative Transaction）【推荐】</p>
<blockquote>
<p>使用 <strong>注解（如 @Transactional）</strong> 或 XML 配置，<strong>将事务管理代码与业务逻辑分离，让事务管理变得非常简单。</strong></p>
</blockquote>
</li>
<li><p>编程式事务（Programmatic Transaction）</p>
<blockquote>
<p>通过 <strong>代码手动控制事务的开启、提交、回滚</strong>，更灵活但代码更繁琐，一般适用于需要 <strong>精细化控制事务边界</strong> 的场景。</p>
</blockquote>
</li>
</ol>
<h3 id="事务什么时候会失效"><a href="#事务什么时候会失效" class="headerlink" title="事务什么时候会失效"></a>事务什么时候会失效</h3><ol>
<li><p>Spring 的事务管理（特别是 声明式事务，即 @Transactional）是通过 Spring **AOP（动态代理）**实现的。</p>
</li>
<li><p>也就是说：只有通过 Spring 代理对象调用的方法，事务才会生效；如果绕过代理直接调用，或者配置&#x2F;使用不当，事务就不会生效（即事务失效）。</p>
</li>
<li><p>Spring 事务生效的条件总结（牢记）</p>
<table>
<thead>
<tr>
<th align="left">条件</th>
<th align="left">是否必须</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>方法必须是 public</strong></td>
<td align="left">✅ 是</td>
<td align="left">Spring AOP 只能代理 public 方法</td>
</tr>
<tr>
<td align="left"><strong>调用方式必须通过 Spring 代理对象（不能是 this.方法() 内部调用）</strong></td>
<td align="left">✅ 是</td>
<td align="left">内部调用不会走代理，事务失效</td>
</tr>
<tr>
<td align="left"><strong>异常必须是 RuntimeException 或 Error，或者配置了 rollbackFor</strong></td>
<td align="left">✅ 是</td>
<td align="left">默认只对未捕获的 RuntimeException 回滚</td>
</tr>
<tr>
<td align="left"><strong>方法不能是 final &#x2F; static</strong></td>
<td align="left">✅ 是</td>
<td align="left">无法被代理增强</td>
</tr>
<tr>
<td align="left"><strong>必须启用事务管理（@EnableTransactionManagement 或 Spring Boot 自动配置）</strong></td>
<td align="left">✅ 是</td>
<td align="left">否则事务注解不生效</td>
</tr>
<tr>
<td align="left"><strong>数据库与表引擎要支持事务（如 InnoDB）</strong></td>
<td align="left">✅ 是</td>
<td align="left">如 MyISAM 不支持事务</td>
</tr>
</tbody></table>
</li>
<li><p>Spring 事务在以下情况会失效</p>
<table>
<thead>
<tr>
<th align="left">失效场景</th>
<th align="left">原因简述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>this.方法() 内部调用</strong></td>
<td align="left">没走 Spring 代理，事务不生效</td>
</tr>
<tr>
<td align="left"><strong>非 public 方法（private &#x2F; protected）</strong></td>
<td align="left">AOP 代理不拦截</td>
</tr>
<tr>
<td align="left"><strong>异常被捕获未抛出 或 抛出非 RuntimeException</strong></td>
<td align="left">默认不触发回滚</td>
</tr>
<tr>
<td align="left"><strong>方法被 final &#x2F; static 修饰</strong></td>
<td align="left">无法被代理增强</td>
</tr>
<tr>
<td align="left"><strong>没有启用事务管理 或 事务管理器配置错误</strong></td>
<td align="left">注解不生效</td>
</tr>
<tr>
<td align="left"><strong>数据库引擎不支持事务（如 MyISAM）</strong></td>
<td align="left">表不支持事务机制</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a>事务的实现方式</h3><ol>
<li><p>Spring 中的事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的，底层依托于数据库的事务机制，通过 声明式事务（@Transactional）或编程式事务（TransactionTemplate） 提供灵活的事务管理能力，让开发者可以轻松控制事务的提交、回滚与传播。</p>
</li>
<li><p>Spring 的事务管理，本质上是对 <strong>数据库事务</strong>（如 MySQL 的事务）的封装和增强。一般都是在数据库的场景下使用事务。</p>
<ol start="2">
<li><p>实现方式</p>
<ol>
<li><p>AOP（面向切面编程）—— 事务的底层实现方式</p>
<ol>
<li>Spring 的 声明式事务（@Transactional） 是通过 Spring AOP（动态代理） 实现的。也就是说：Spring 并没有直接操作事务，而是通过 AOP 在方法调用前后，添加了事务的开启、提交、回滚等逻辑。</li>
<li>原理流程（简化）：<ol>
<li>当你使用 @Transactional 注解时，Spring 会为这个方法生成一个代理对象（JDK 动态代理 或 CGLIB）</li>
<li>当你调用这个方法时，实际上是调用了代理对象的方法</li>
<li>代理对象在方法执行前：根据配置开启事务（比如调用 <code>beginTransaction()</code>）</li>
<li>代理对象在方法执行后：如果方法正常执行完毕 → 提交事务（<code>commit()</code>）如果方法抛出了异常（且符合回滚规则）→ 回滚事务（<code>rollback()</code>）</li>
</ol>
</li>
</ol>
</li>
<li><p>事务管理器（PlatformTransactionManager）—— 事务执行的核心组件</p>
<ol>
<li>Spring <strong>并不直接操作数据库事务</strong>，而是通过 <strong>事务管理器（PlatformTransactionManager）</strong> 与底层数据库交互，真正控制事务的开启、提交和回滚。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Spring用了哪些设计模式"><a href="#Spring用了哪些设计模式" class="headerlink" title="Spring用了哪些设计模式"></a>Spring用了哪些设计模式</h2><table>
<thead>
<tr>
<th align="left">设计模式</th>
<th align="left">应用场景</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工厂模式</strong></td>
<td align="left">BeanFactory &#x2F; ApplicationContext</td>
<td align="left">管理 Bean 的创建</td>
</tr>
<tr>
<td align="left"><strong>单例模式</strong></td>
<td align="left">默认的 Bean Scope</td>
<td align="left">一个 Bean 只有一个实例</td>
</tr>
<tr>
<td align="left"><strong>代理模式</strong></td>
<td align="left">Spring AOP</td>
<td align="left">实现方法拦截与增强</td>
</tr>
<tr>
<td align="left"><strong>模板方法模式</strong></td>
<td align="left">JdbcTemplate、RestTemplate</td>
<td align="left">封装固定流程</td>
</tr>
<tr>
<td align="left"><strong>观察者模式</strong></td>
<td align="left">ApplicationEvent &#x2F; Listener</td>
<td align="left">事件发布与订阅</td>
</tr>
<tr>
<td align="left"><strong>适配器模式</strong></td>
<td align="left">HandlerAdapter、AdvisorAdapter</td>
<td align="left">接口转换与兼容</td>
</tr>
<tr>
<td align="left"><strong>装饰器模式</strong></td>
<td align="left">BeanPostProcessor</td>
<td align="left">增强 Bean 功能</td>
</tr>
<tr>
<td align="left"><strong>策略模式</strong></td>
<td align="left">事务管理器、视图解析器</td>
<td align="left">多种实现动态选择</td>
</tr>
<tr>
<td align="left"><strong>责任链模式</strong></td>
<td align="left">过滤器链、拦截器链</td>
<td align="left">多个处理器依次处理请求</td>
</tr>
<tr>
<td align="left"><strong>原型模式</strong></td>
<td align="left">Bean Scope 为 prototype</td>
<td align="left">每次获取新实例</td>
</tr>
<tr>
<td align="left"><strong>组合模式</strong></td>
<td align="left">树形结构数据（非核心）</td>
<td align="left">组合对象与叶子对象统一处理</td>
</tr>
<tr>
<td align="left"><strong>外观模式</strong></td>
<td align="left">高级封装（如 JdbcTemplate）</td>
<td align="left">简化复杂 API</td>
</tr>
<tr>
<td align="left"><strong>建造者模式</strong></td>
<td align="left">SpringApplicationBuilder</td>
<td align="left">分步骤构建复杂对象</td>
</tr>
</tbody></table>
<h2 id="Spring常用的注解及其底层实现"><a href="#Spring常用的注解及其底层实现" class="headerlink" title="Spring常用的注解及其底层实现"></a>Spring常用的注解及其底层实现</h2><h3 id="Bean定义相关"><a href="#Bean定义相关" class="headerlink" title="Bean定义相关"></a>Bean定义相关</h3><ol>
<li><p><strong>@Component</strong></p>
<ul>
<li><strong>作用：</strong> 标识一个类为 Spring 管理的 Bean（即交给 IoC 容器管理）</li>
<li>**底层实现：**Spring 在启动时通过 ClassPathScanningCandidateComponentProvider 扫描带有 @Component（以及衍生注解）的类将这些类解析成 BeanDefinition（Bean 的定义信息），并注册到 BeanDefinitionRegistry（通常是 DefaultListableBeanFactory）最终由容器实例化、管理这些 Bean</li>
</ul>
<p>@Component 是以下注解的“父注解”或“通用注解”</p>
</li>
<li><p><strong>@Service、@Repository、@Controller</strong></p>
<ul>
<li>底层实现： 它们主要用于代码语义分层，底层实现与 @Component 完全一样</li>
</ul>
</li>
</ol>
<h3 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h3><ol>
<li><strong>@Autowired</strong><ul>
<li><strong>作用：</strong> 自动注入一个 Bean（默认按 类型（byType） 匹配，如果有多个相同类型，再按 名称（byName &#x2F; @Qualifier））</li>
<li>**底层实现：**Spring 通过 AutowiredAnnotationBeanPostProcessor（一个 Bean 后置处理器） 扫描带有 @Autowired 的字段 &#x2F; 方法 &#x2F; 构造器在 Bean 初始化过程中，<strong>自动解析匹配的 Bean 并注入</strong>如果找不到匹配的 Bean，默认会抛出 NoSuchBeanDefinitionException（可配置 required&#x3D;false）</li>
</ul>
</li>
</ol>
<h3 id="事务管理相关"><a href="#事务管理相关" class="headerlink" title="事务管理相关"></a>事务管理相关</h3><ol>
<li><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a><strong>@Transactional</strong></h3><ul>
<li><strong>作用：</strong> 声明一个方法或类是事务性的，方法执行时会由 Spring 自动管理事务（开启、提交、回滚）</li>
<li>**底层实现：**基于 <strong>AOP（动态代理） + PlatformTransactionManager 事务管理器</strong>Spring 会为标注了 @Transactional 的方法生成一个 代理对象在方法调用前后，<strong>通过事务管理器控制事务的开启、提交、异常回滚</strong>支持配置传播机制（Propagation）、隔离级别（Isolation）、回滚异常类型等</li>
</ul>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><strong>@SpringBootApplication</strong></h3><ul>
<li><strong>作用：</strong> Spring Boot 应用的主启动注解，<strong>组合了以下三个注解：</strong>@Configuration@EnableAutoConfiguration@ComponentScan</li>
<li><strong>底层实现：</strong>@EnableAutoConfiguration 通过 SpringFactoriesLoader 加载 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 中的自动配置类，实现“约定优于配置”@ComponentScan 扫描当前包及子包，注册 Bean@Configuration 表明这是一个配置类</li>
</ul>
</li>
</ol>
<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol>
<li><p>核心功能：它解决了什么问题？</p>
<ol>
<li><p>认证 (Authentication) —— “你是谁？”</p>
<ol>
<li><p>验证用户的身份。</p>
<ul>
<li><p>方式： 用户名&#x2F;密码、指纹、手机验证码、API Key、OAuth2（微信&#x2F;Google登录）等。</p>
</li>
<li><p>结果： 告诉系统当前用户是 “张三”。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>授权 (Authorization) —— “你能做什么？”</p>
<ol>
<li><p>判断已认证的用户是否有权限执行某个操作。</p>
<ul>
<li><p>方式： URL 访问控制（如 &#x2F;admin 只有管理员能进）、方法级安全（如 deleteUser() 方法只有经理能调）。</p>
</li>
<li><p>结果： 允许或拒绝请求（403 Forbidden）。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>底层原理</p>
<ol>
<li>Spring Security 的底层是基于 <strong>Servlet 过滤器链 (Filter Chain)</strong> 实现的。<ol>
<li><strong>拦截请求：</strong> 当一个请求到达应用时，会先经过一系列的 Security 过滤器。</li>
<li><strong>处理安全逻辑：</strong> 每个过滤器负责不同的任务（例如：解析 Token、校验登录表单、检查 URL 权限、处理异常等）。</li>
<li><strong>SecurityContext：</strong> 认证成功后，用户信息会被存放在 SecurityContextHolder 中（通常基于 ThreadLocal），在整个请求处理过程中，你可以随时获取当前用户信息。</li>
</ol>
</li>
</ol>
</li>
<li><p>核心组件：</p>
<ol>
<li><strong>UserDetailsService (接口)</strong><ul>
<li>作用： 加载用户数据的核心接口。你需要实现它，告诉 Spring Security 如何从你的数据库（MySQL, Redis 等）中查找用户。</li>
<li>方法： loadUserByUsername(String username)</li>
</ul>
</li>
<li><strong>UserDetails (接口)</strong><ul>
<li>作用： 代表一个标准的用户对象。你的数据库 User 实体类通常需要实现这个接口，或者转换为这个接口的实现类。它包含密码、用户名、权限列表、账户是否过期等信息。</li>
</ul>
</li>
<li><strong>PasswordEncoder (接口)</strong><ul>
<li>作用： 处理密码加密。永远不要存储明文密码！</li>
<li>常用实现： BCryptPasswordEncoder (目前最推荐)。</li>
</ul>
</li>
<li><strong>SecurityFilterChain</strong><ul>
<li>作用： 定义安全规则（哪些接口公开，哪些需要登录，使用什么登录方式等）。</li>
</ul>
</li>
</ol>
</li>
<li><p>配置示例</p>
<ol>
<li><pre><code class="language-java">@Configuration
@EnableWebSecurity // 开启 Spring Security
public class SecurityConfig {

    // 1. 定义安全过滤器链 (核心配置)
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF (通常在前后端分离/使用 JWT 时禁用，传统 Web 开发建议开启)
            .csrf(csrf -&gt; csrf.disable())
            
            // 配置请求拦截规则
            .authorizeHttpRequests(auth -&gt; auth
                .requestMatchers(&quot;/public/**&quot;, &quot;/auth/login&quot;).permitAll() // 允许匿名访问
                .requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)            // 只有 ADMIN 角色能访问
                .anyRequest().authenticated()                             // 其他所有请求都需要登录
            )
            
            // 配置表单登录 (如果不配置，默认会弹出一个浏览器自带的登录框)
            .formLogin(form -&gt; form
                .loginPage(&quot;/login&quot;)        // 自定义登录页面 URL
                .loginProcessingUrl(&quot;/perform_login&quot;) // 提交表单的接口
                .defaultSuccessUrl(&quot;/home&quot;, true)
                .permitAll()
            );

        return http.build();
    }

    // 2. 配置密码加密器
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</code></pre>
</li>
</ol>
</li>
<li><p>常见应用场景</p>
<ol>
<li>传统 Web 应用 (Monolith)<ul>
<li><strong>机制：</strong> Session + Cookie。</li>
<li><strong>流程：</strong> 用户登录 -&gt; 服务器创建 Session -&gt; 返回 Cookie -&gt; 后续请求带 Cookie -&gt; 服务器验证 Session。</li>
<li>Spring Security 原生支持极好。</li>
</ul>
</li>
<li>前后端分离 &#x2F; 微服务 (Modern)<ul>
<li><strong>机制：</strong> Token (如 JWT)。</li>
<li><strong>流程：</strong> 用户登录 -&gt; 服务器签发 JWT -&gt; 前端存储 JWT -&gt; 后续请求 Header 带 Authorization: Bearer <token> -&gt; 服务器解析 Token 验证身份。</li>
<li><strong>配置：</strong> 需要自定义 Filter 来拦截请求并解析 Token，且通常需要将 Session 策略设置为 STATELESS (无状态)。</li>
</ul>
</li>
<li>第三方登录 (OAuth2 &#x2F; OIDC)<ul>
<li><strong>机制：</strong> 微信登录、GitHub 登录、SSO (单点登录)。</li>
<li>Spring Security 提供了 spring-security-oauth2-client 和 spring-security-oauth2-resource-server 模块，极大简化了集成难度。</li>
</ul>
</li>
</ol>
</li>
<li><p>必做功能</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">必做工作</th>
<th align="left">说明</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>配置用户认证的数据来源（核心）</strong></td>
<td align="left">必须告诉 Spring Security：用户信息从哪里来（数据库？内存？LDAP？）</td>
<td align="left">通常通过实现 <code>UserDetailsService</code>接口来完成</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>实现 UserDetailsService 接口</strong></td>
<td align="left">根据用户名加载用户信息，返回 <code>UserDetails</code>对象（包含用户名、密码、权限等）</td>
<td align="left">是认证流程中连接数据与 Security 的桥梁</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>密码加密存储与匹配（核心安全）</strong></td>
<td align="left">用户密码必须加密存储（如 BCrypt），并在认证时用 <code>PasswordEncoder</code>进行匹配</td>
<td align="left">严禁明文存储密码！推荐使用 <code>BCryptPasswordEncoder</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>配置 HttpSecurity（权限控制）</strong></td>
<td align="left">定义哪些 URL 需要登录、哪些角色能访问哪些接口、是否允许匿名访问等</td>
<td align="left">通过 <code>authorizeHttpRequests()</code>或旧版 <code>antMatchers()</code>配置</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><ol>
<li><strong>SecurityContextHolderFilter</strong>：检查你的 Session 或 Token。<ul>
<li><em>情况A（已登录）：</em> 发现你是 “User: ZhangSan, Role: ADMIN”，放入上下文。</li>
<li><em>情况B（未登录）：</em> 上下文是空的（Anonymous）。</li>
</ul>
</li>
<li><strong>UsernamePasswordAuthenticationFilter</strong>：检查 URL。<ul>
<li>发现 URL 是 &#x2F;admin&#x2F;users 而不是 &#x2F;login，<strong>直接放行</strong>，不做任何事。</li>
</ul>
</li>
<li><strong>…中间经过一堆其他 Filter…</strong></li>
<li><strong>AuthorizationFilter</strong>（最终守门员）：<ul>
<li>检查配置：&#x2F;admin&#x2F;** 需要 ADMIN 权限。</li>
<li><em>情况A：</em> 上下文里有 ZhangSan 且是 ADMIN -&gt; <strong>放行</strong> -&gt; 进入 Controller。</li>
<li><em>情况B：</em> 上下文是空的 -&gt; <strong>抛出 AccessDeniedException</strong>。</li>
</ul>
</li>
<li><strong>ExceptionTranslationFilter</strong>（捕获异常）：<ul>
<li>捕获到异常，发现你根本没登录，于是重定向到 &#x2F;login 页面。</li>
</ul>
</li>
</ol>
<h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><ol>
<li><strong>Authentication</strong>接口概念：<ol>
<li>它的实现类表示当前访问系统的用户，封装了用户相关信息。例如，用户名、密码以及其他可能的用户属性（如角色等）。</li>
<li>使用时机：在身份验证过程中，当用户尝试登录系统时，会创建一个Authentication对象的实例来代表用户的认证请求。在认证成功后，也会得到一个包含用户完整信息的Authentication对象。</li>
<li>使用方法：通常不需要直接实例化，而是通过Spring Security框架中的认证机制来创建和管理。例如，在自定义的认证逻辑中，可以获取已有的Authentication对象来检查用户是否已经通过认证，或者获取用户的相关信息。</li>
</ol>
</li>
<li><strong>AuthenticationManager</strong>接口概念：<ol>
<li>定义了认证Authentication的方法。它是整个认证流程的核心管理接口，负责接收Authentication对象并进行认证操作。</li>
<li>使用时机：在用户提交登录信息后，系统会将用户的登录信息封装成Authentication对象，然后交给AuthenticationManager进行认证。例如，当用户在前端输入用户名和密码并点击登录按钮后，后端代码会将这些信息构建成Authentication对象，调用AuthenticationManager的方法来进行认证。</li>
<li>使用方法：一般通过配置来注入一个具体的AuthenticationManager实现（如DaoAuthenticationProvider等），然后在需要进行认证的地方调用其<code>authenticate(Authentication authentication)</code>方法，传入待认证的Authentication对象。如果认证成功，该方法会返回一个完全认证的Authentication对象；如果认证失败，则会抛出相应的异常。</li>
</ol>
</li>
<li><strong>UserDetailsService</strong>接口概念：<ol>
<li>加载用户特定数据的核心接口。它里面定义了一个根据用户名查询用户信息的方法。</li>
<li>使用时机：在认证过程中，当需要获取用户的详细信息时（例如，根据用户输入的用户名查找对应的用户记录），就会用到UserDetailsService。比如，在基于数据库的用户认证场景中，会根据用户名从数据库中查询用户的密码、角色等信息。</li>
<li>使用方法：实现该接口并重写<code>loadUserByUsername(String username)</code>方法。在这个方法中，编写逻辑从数据源（如数据库、LDAP等）中根据给定的用户名获取用户信息，并将其封装成UserDetails对象返回。例如，在一个使用JDBC从数据库获取用户信息的实现中，会在这个方法中执行SQL查询，将查询结果转换为UserDetails对象。</li>
</ol>
</li>
<li><strong>UserDetails</strong>接口概念：<ol>
<li>提供核心用户信息。通过UserDetailsService根据用户名从数据库获取处理的用户信息后，封装成UserDetails对象返回，然后将这些信息封装到Authentication对象中。</li>
<li>使用时机：在整个认证和授权过程中都需要用到，用于传递和处理用户的基本信息和权限信息。例如，在认证时检查用户密码是否正确，在授权时确定用户具有的角色和权限。</li>
<li>使用方法：通常会有多个实现类（如org.springframework.security.core.userdetails.User等），可以直接使用这些实现类来封装用户信息。也可以自定义实现类，根据具体需求添加或修改用户信息的字段和获取方式。在认证和授权相关的代码中，可以通过UserDetails对象来访问用户的基本属性和权限信息。</li>
</ol>
</li>
</ol>
<h1 id="服务端开发课程"><a href="#服务端开发课程" class="headerlink" title="服务端开发课程"></a>服务端开发课程</h1><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><ol>
<li><p>定义：</p>
<ol>
<li><strong>Thymeleaf 是一个现代化的、用于 Java 的</strong> <strong>服务器端模板引擎（Template Engine）</strong>，主要用于在 Web 应用中生成动态 HTML 页面，支持 <strong>自然模板（Natural Templates）</strong>，可以直接在浏览器中预览静态效果。</li>
<li>它特别适合与 <strong>Spring Boot &#x2F; Spring MVC</strong> 一起使用，是它们的<strong>默认推荐模板引擎之一</strong>（另一个常见的是 JSP，但 Thymeleaf 更现代）。</li>
</ol>
</li>
<li><p>特性</p>
<ol>
<li><p>Thymeleaf 的核心特点（重点！）</p>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">说明</th>
<th align="left">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 基于 HTML 的模板</strong></td>
<td align="left">模板文件就是普通的 <code>.html</code>文件，不需要特殊扩展名</td>
<td align="left">易于编写、直观，前端开发者友好</td>
</tr>
<tr>
<td align="left"><strong>2. 支持自然模板（Natural Templates）</strong></td>
<td align="left">模板可以直接在浏览器中打开并显示静态内容，便于设计和调试</td>
<td align="left">前后端分离开发更顺畅</td>
</tr>
<tr>
<td align="left"><strong>3. 与 Spring 深度集成</strong></td>
<td align="left">是 Spring Boot &#x2F; Spring MVC 的<strong>官方推荐模板引擎</strong>，配置简单，使用方便</td>
<td align="left">适合 Spring 全家桶项目</td>
</tr>
<tr>
<td align="left"><strong>4. 表达式语言（Thymeleaf Expression）</strong></td>
<td align="left">使用类似 <code>th:text=&quot;${name}&quot;</code>的标签来动态渲染数据</td>
<td align="left">清晰、简洁、功能强大</td>
</tr>
<tr>
<td align="left"><strong>5. 支持逻辑控制</strong></td>
<td align="left">比如条件判断 <code>th:if</code>、循环 <code>th:each</code>、变量定义 <code>th:with</code>等</td>
<td align="left">可以灵活控制页面渲染逻辑</td>
</tr>
<tr>
<td align="left"><strong>6. 不依赖 Servlet 容器运行（可静态预览）</strong></td>
<td align="left">模板可以在没有服务器的情况下直接用浏览器打开查看静态效果</td>
<td align="left">便于 UI 设计与原型开发</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>用法</p>
<ol>
<li><p>Thymeleaf 常用语法</p>
<p>在 <code>hello.html</code>中，我们只用了最基本的 <code>th:text</code>，其实 Thymeleaf 还支持很多强大的功能：</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">语法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>显示文本</strong></td>
<td align="left"><code>th:text=&quot;${var}&quot;</code></td>
<td align="left">设置元素的文本</td>
</tr>
<tr>
<td align="left"><strong>显示 HTML（谨慎使用）</strong></td>
<td align="left"><code>th:utext=&quot;${htmlContent}&quot;</code></td>
<td align="left">渲染 HTML 内容（有 XSS 风险，慎用）</td>
</tr>
<tr>
<td align="left"><strong>循环遍历</strong></td>
<td align="left"><code>th:each=&quot;item : ${list}&quot;</code></td>
<td align="left">类似 <code>for</code>循环，遍历集合</td>
</tr>
<tr>
<td align="left"><strong>条件判断</strong></td>
<td align="left"><code>th:if=&quot;${condition}&quot;</code></td>
<td align="left">条件为 true 时显示该元素</td>
</tr>
<tr>
<td align="left"><strong>变量定义</strong></td>
<td align="left"><code>th:with=&quot;name=${value}&quot;</code></td>
<td align="left">定义局部变量</td>
</tr>
<tr>
<td align="left"><strong>表单绑定</strong></td>
<td align="left"><code>th:field=&quot;*{fieldName}&quot;</code></td>
<td align="left">用于 Spring 表单绑定（配合 <code>@ModelAttribute</code>）</td>
</tr>
<tr>
<td align="left"><strong>链接生成</strong></td>
<td align="left"><code>th:href=&quot;@{/path}&quot;</code></td>
<td align="left">生成上下文相关的 URL</td>
</tr>
<tr>
<td align="left"><strong>引入模板 &#x2F; 布局</strong></td>
<td align="left"><code>th:replace=&quot;~{fragments/header :: header}&quot;</code></td>
<td align="left">用于模板复用和布局（高级用法）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="表单提交"><a href="#表单提交" class="headerlink" title="表单提交"></a>表单提交</h2><ol>
<li><strong>注意提交后一定要重定向一次，否则不安全，会出错。</strong></li>
</ol>
<h2 id="期中作业"><a href="#期中作业" class="headerlink" title="期中作业"></a>期中作业</h2><ol>
<li>用Thymeleaf写一个网页小游戏</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">python核心库学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:05:34" itemprop="dateModified" datetime="2025-12-03T17:05:34+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><p>NumPy（Numerical Python）是 Python 中一个强大的科学计算库，提供了高性能的多维数组对象（<code>ndarray</code>）以及大量的数学函数和操作工具，是许多其他科学计算库（如 SciPy、Pandas、Matplotlib 等）的基础。</p>
<p>下面是 NumPy 库的一些<strong>基本用法</strong>：</p>
<hr>
<h2 id="一、安装-NumPy"><a href="#一、安装-NumPy" class="headerlink" title="一、安装 NumPy"></a>一、安装 NumPy</h2><p>如果尚未安装 NumPy，可以使用 pip 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、导入-NumPy"><a href="#二、导入-NumPy" class="headerlink" title="二、导入 NumPy"></a>二、导入 NumPy</h2><p>通常我们这样导入 NumPy，并给它起一个别名 <code>np</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、NumPy-的核心：ndarray（多维数组）"><a href="#三、NumPy-的核心：ndarray（多维数组）" class="headerlink" title="三、NumPy 的核心：ndarray（多维数组）"></a>三、NumPy 的核心：ndarray（多维数组）</h2><p>NumPy 最核心的数据结构是 <strong>ndarray（N-dimensional array）</strong>，即 N 维数组。它是一个高效、固定类型的多维数组对象。</p>
<h3 id="1-创建-ndarray"><a href="#1-创建-ndarray" class="headerlink" title="1. 创建 ndarray"></a>1. 创建 ndarray</h3><h4 id="从-Python-列表创建："><a href="#从-Python-列表创建：" class="headerlink" title="从 Python 列表创建："></a>从 Python 列表创建：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 一维数组</span><br><span class="line">a = np.array([1, 2, 3, 4])</span><br><span class="line">print(a)  # 输出: [1 2 3 4]</span><br><span class="line"></span><br><span class="line"># 二维数组</span><br><span class="line">b = np.array([[1, 2], [3, 4]])</span><br><span class="line">print(b)</span><br><span class="line"># 输出:</span><br><span class="line"># [[1 2]</span><br><span class="line">#  [3 4]]</span><br></pre></td></tr></table></figure>

<h4 id="使用内置函数快速创建数组："><a href="#使用内置函数快速创建数组：" class="headerlink" title="使用内置函数快速创建数组："></a>使用内置函数快速创建数组：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>np.zeros(shape)</code></td>
<td>全零数组</td>
<td><code>np.zeros((2, 3))</code>→ 2行3列的全0数组</td>
</tr>
<tr>
<td><code>np.ones(shape)</code></td>
<td>全1数组</td>
<td><code>np.ones((3,))</code>→ 一维的3个1</td>
</tr>
<tr>
<td><code>np.empty(shape)</code></td>
<td>未初始化的数组（值随机）</td>
<td><code>np.empty((2,2))</code></td>
</tr>
<tr>
<td><code>np.arange(start, stop, step)</code></td>
<td>类似 range，生成一维数组</td>
<td><code>np.arange(0, 10, 2)</code>→ [0 2 4 6 8]</td>
</tr>
<tr>
<td><code>np.linspace(start, stop, num)</code></td>
<td>指定范围内的等间隔 num 个数</td>
<td><code>np.linspace(0, 1, 5)</code>→ [0.   0.25 0.5  0.75 1.  ]</td>
</tr>
<tr>
<td><code>np.random.rand(d0, d1, ...)</code></td>
<td>生成 [0,1) 区间的随机数数组</td>
<td><code>np.random.rand(2, 3)</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zeros_arr = np.zeros((2, 3))</span><br><span class="line">ones_arr = np.ones(4)</span><br><span class="line">rand_arr = np.random.rand(3)</span><br><span class="line">print(zeros_arr)</span><br><span class="line">print(ones_arr)</span><br><span class="line">print(rand_arr)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、数组的基本属性"><a href="#四、数组的基本属性" class="headerlink" title="四、数组的基本属性"></a>四、数组的基本属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[1, 2, 3], [4, 5, 6]])</span><br><span class="line"></span><br><span class="line">print(a.shape)    # 数组的维度，输出 (2, 3)</span><br><span class="line">print(a.ndim)     # 数组的轴数（维度数），输出 2</span><br><span class="line">print(a.size)     # 数组元素的总数，输出 6</span><br><span class="line">print(a.dtype)    # 数组元素的数据类型，如 int64, float64</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、数组的索引与切片"><a href="#五、数组的索引与切片" class="headerlink" title="五、数组的索引与切片"></a>五、数组的索引与切片</h2><h3 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1. 一维数组"></a>1. 一维数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([10, 20, 30, 40, 50])</span><br><span class="line"></span><br><span class="line">print(a[0])    # 10</span><br><span class="line">print(a[1:4])  # [20 30 40] （左闭右开）</span><br></pre></td></tr></table></figure>

<h3 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2. 二维数组"></a>2. 二维数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span><br><span class="line"></span><br><span class="line">print(b[0, 1])   # 第0行第1列 → 2</span><br><span class="line">print(b[1:, :2]) # 第1行及之后，前两列 → [[4 5], [7 8]]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、数组的运算"><a href="#六、数组的运算" class="headerlink" title="六、数组的运算"></a>六、数组的运算</h2><p>NumPy 支持**逐元素（element-wise）**的数学运算，无需写循环，非常高效！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([1, 2, 3])</span><br><span class="line">b = np.array([4, 5, 6])</span><br><span class="line"></span><br><span class="line">print(a + b)  # [5 7 9]</span><br><span class="line">print(a - b)  # [-3 -3 -3]</span><br><span class="line">print(a * b)  # [ 4 10 18]</span><br><span class="line">print(a / b)  # [0.25 0.4  0.5 ]</span><br><span class="line">print(a ** 2) # [1 4 9]  平方</span><br></pre></td></tr></table></figure>

<p>也可以与标量进行运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a + 10)  # [11 12 13]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、常用函数"><a href="#七、常用函数" class="headerlink" title="七、常用函数"></a>七、常用函数</h2><h3 id="1-数学函数"><a href="#1-数学函数" class="headerlink" title="1. 数学函数"></a>1. 数学函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([1, 4, 9])</span><br><span class="line"></span><br><span class="line">print(np.sqrt(a))   # 平方根 → [1. 2. 3.]</span><br><span class="line">print(np.sum(a))    # 求和 → 14</span><br><span class="line">print(np.mean(a))   # 均值 → 4.666...</span><br><span class="line">print(np.max(a))    # 最大值 → 9</span><br><span class="line">print(np.min(a))    # 最小值 → 1</span><br><span class="line">print(np.std(a))    # 标准差</span><br></pre></td></tr></table></figure>

<h3 id="2-聚合函数可以指定-axis"><a href="#2-聚合函数可以指定-axis" class="headerlink" title="2. 聚合函数可以指定 axis"></a>2. 聚合函数可以指定 axis</h3><p>对于二维数组，可以按行或列聚合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[1, 2, 3], [4, 5, 6]])</span><br><span class="line"></span><br><span class="line">print(np.sum(b, axis=0))  # 按列求和 → [5 7 9]</span><br><span class="line">print(np.sum(b, axis=1))  # 按行求和 → [ 6 15]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、形状操作"><a href="#八、形状操作" class="headerlink" title="八、形状操作"></a>八、形状操作</h2><h3 id="1-改变数组形状：reshape"><a href="#1-改变数组形状：reshape" class="headerlink" title="1. 改变数组形状：reshape"></a>1. 改变数组形状：reshape</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(6)  # [0 1 2 3 4 5]</span><br><span class="line">b = a.reshape(2, 3)  # 变成 2行3列</span><br><span class="line">print(b)</span><br><span class="line"># 输出:</span><br><span class="line"># [[0 1 2]</span><br><span class="line">#  [3 4 5]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：reshape 不改变原数组，而是返回新视图（如果可能）。</p>
</blockquote>
<h3 id="2-展平数组：ravel-或-flatten"><a href="#2-展平数组：ravel-或-flatten" class="headerlink" title="2. 展平数组：ravel 或 flatten"></a>2. 展平数组：ravel 或 flatten</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(b.ravel())   # 展平为一维 [0 1 2 3 4 5]</span><br><span class="line">print(b.flatten()) # 同上，也是展平</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、数组拼接与分割"><a href="#九、数组拼接与分割" class="headerlink" title="九、数组拼接与分割"></a>九、数组拼接与分割</h2><h3 id="1-拼接数组"><a href="#1-拼接数组" class="headerlink" title="1. 拼接数组"></a>1. 拼接数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br><span class="line"></span><br><span class="line"># 垂直拼接（按行）→ 上下堆叠</span><br><span class="line">c = np.vstack((a, b))</span><br><span class="line">print(c)</span><br><span class="line"># 输出:</span><br><span class="line"># [[1 2]</span><br><span class="line">#  [3 4]</span><br><span class="line">#  [5 6]</span><br><span class="line">#  [7 8]]</span><br><span class="line"></span><br><span class="line"># 水平拼接（按列）→ 左右合并</span><br><span class="line">d = np.hstack((a, b))</span><br><span class="line">print(d)</span><br><span class="line"># 输出:</span><br><span class="line"># [[1 2 5 6]</span><br><span class="line">#  [3 4 7 8]]</span><br></pre></td></tr></table></figure>

<h3 id="2-分割数组"><a href="#2-分割数组" class="headerlink" title="2. 分割数组"></a>2. 分割数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(12).reshape(3, 4)</span><br><span class="line"></span><br><span class="line"># 按行切分</span><br><span class="line">upper, lower = np.vsplit(a, [2])</span><br><span class="line">print(upper)</span><br><span class="line">print(lower)</span><br><span class="line"></span><br><span class="line"># 按列切分</span><br><span class="line">left, right = np.hsplit(a, [2])</span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十、广播机制（Broadcasting）"><a href="#十、广播机制（Broadcasting）" class="headerlink" title="十、广播机制（Broadcasting）"></a>十、广播机制（Broadcasting）</h2><p>NumPy 允许不同形状的数组进行运算，系统会自动扩展较小数组的形状，这个机制叫<strong>广播（Broadcasting）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([1, 2, 3])</span><br><span class="line">b = 2  # 标量</span><br><span class="line"></span><br><span class="line">print(a + b)  # [3 4 5] → 相当于 a + [2, 2, 2]</span><br><span class="line"></span><br><span class="line"># 另一个例子</span><br><span class="line">c = np.array([[1], [2], [3]])  # 3x1</span><br><span class="line">d = np.array([10, 20, 30])     # 1x3</span><br><span class="line"></span><br><span class="line">print(c + d)</span><br><span class="line"># 输出一个 3x3 的数组，每个元素是对应位置相加</span><br></pre></td></tr></table></figure>

<blockquote>
<p>广播规则较为复杂，但基本原则是：从尾部维度开始对齐，维度相同或其中一个为1时可广播。</p>
</blockquote>
<hr>
<h2 id="总结：NumPy-常用功能一览"><a href="#总结：NumPy-常用功能一览" class="headerlink" title="总结：NumPy 常用功能一览"></a>总结：NumPy 常用功能一览</h2><table>
<thead>
<tr>
<th>功能类别</th>
<th>常用函数&#x2F;操作</th>
</tr>
</thead>
<tbody><tr>
<td>创建数组</td>
<td><code>np.array()</code>, <code>np.zeros()</code>, <code>np.ones()</code>, <code>np.arange()</code>, <code>np.random.rand()</code></td>
</tr>
<tr>
<td>数组属性</td>
<td><code>.shape</code>, <code>.ndim</code>, <code>.size</code>, <code>.dtype</code></td>
</tr>
<tr>
<td>索引与切片</td>
<td><code>a[0]</code>, <code>a[:, 1:3]</code>, <code>a[1:, :]</code></td>
</tr>
<tr>
<td>数学运算</td>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>np.sqrt()</code>, <code>np.sin()</code>, …</td>
</tr>
<tr>
<td>统计函数</td>
<td><code>np.sum()</code>, <code>np.mean()</code>, <code>np.max()</code>, <code>np.min()</code>, <code>np.std()</code></td>
</tr>
<tr>
<td>形状操作</td>
<td><code>reshape()</code>, <code>ravel()</code>, <code>flatten()</code></td>
</tr>
<tr>
<td>拼接与分割</td>
<td><code>np.vstack()</code>, <code>np.hstack()</code>, <code>np.vsplit()</code>, <code>np.hsplit()</code></td>
</tr>
<tr>
<td>广播机制</td>
<td>自动扩展维度进行运算</td>
</tr>
</tbody></table>
<hr>
<p>如果你有具体想了解的 NumPy 功能（比如线性代数、随机数生成、文件读写等），欢迎继续提问！我可以为你深入讲解。</p>
<h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1><p><code>pandas</code>是 Python 中最流行、功能最强大的<strong>数据分析库</strong>之一，特别适合处理和分析<strong>结构化数据</strong>（比如表格数据）。它是建立在 NumPy 基础之上的，提供了高效的数据结构和丰富的数据操作功能，是数据清洗、处理、分析、探索性分析（EDA）中不可或缺的工具。</p>
<hr>
<h2 id="一、什么是-pandas？"><a href="#一、什么是-pandas？" class="headerlink" title="一、什么是 pandas？"></a>一、什么是 pandas？</h2><p><strong>pandas（Python Data Analysis Library）</strong> 是一个开源的、提供高性能、易用的数据结构与数据分析工具的库。</p>
<p>它的两个核心数据结构是：</p>
<ol>
<li>1.<strong>Series（一维数据，类似带标签的一维数组）</strong></li>
<li>2.<strong>DataFrame（二维数据，类似带标签的电子表格或 SQL 表）</strong></li>
</ol>
<hr>
<h2 id="二、安装-pandas"><a href="#二、安装-pandas" class="headerlink" title="二、安装 pandas"></a>二、安装 pandas</h2><p>如果你的环境中还没有安装 pandas，可以通过 pip 安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure>

<p>通常也会一并安装依赖库，如 NumPy。</p>
<hr>
<h2 id="三、导入-pandas"><a href="#三、导入-pandas" class="headerlink" title="三、导入 pandas"></a>三、导入 pandas</h2><p>一般习惯这样导入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>

<p>（<code>pd</code>是社区广泛接受的别名）</p>
<hr>
<h2 id="四、pandas-的两个核心数据结构"><a href="#四、pandas-的两个核心数据结构" class="headerlink" title="四、pandas 的两个核心数据结构"></a>四、pandas 的两个核心数据结构</h2><h3 id="1-Series（一维数据）"><a href="#1-Series（一维数据）" class="headerlink" title="1. Series（一维数据）"></a>1. <strong>Series（一维数据）</strong></h3><p>Series 是一个<strong>带标签的一维数组</strong>，可以保存任意数据类型（整数、字符串、浮点数、Python 对象等）。</p>
<h4 id="创建-Series："><a href="#创建-Series：" class="headerlink" title="创建 Series："></a>创建 Series：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># 从列表创建</span><br><span class="line">s = pd.Series([10, 20, 30, 40])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>输出类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0    10</span><br><span class="line">1    20</span><br><span class="line">2    30</span><br><span class="line">3    40</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<ul>
<li>•左边是<strong>索引（index）</strong>，右边是<strong>值（value）</strong></li>
<li>•可以指定索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([10, 20, 30], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a    10</span><br><span class="line">b    20</span><br><span class="line">c    30</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>你可以通过索引访问数据，如 <code>s[&#39;a&#39;]</code>→ 10</p>
<hr>
<h3 id="2-DataFrame（二维数据，最常用）"><a href="#2-DataFrame（二维数据，最常用）" class="headerlink" title="2. DataFrame（二维数据，最常用）"></a>2. <strong>DataFrame（二维数据，最常用）</strong></h3><p>DataFrame 是一个<strong>带标签的二维表格数据结构</strong>，类似于 Excel 表格或者 SQL 表，由多个 Series 组成（每列是一个 Series），每一列可以是不同的数据类型。</p>
<h4 id="创建-DataFrame-的常见方式："><a href="#创建-DataFrame-的常见方式：" class="headerlink" title="创建 DataFrame 的常见方式："></a>创建 DataFrame 的常见方式：</h4><h5 id="从字典创建（最常见）："><a href="#从字典创建（最常见）：" class="headerlink" title="从字典创建（最常见）："></a>从字典创建（最常见）：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    &#x27;姓名&#x27;: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;],</span><br><span class="line">    &#x27;年龄&#x27;: [25, 30, 35],</span><br><span class="line">    &#x27;城市&#x27;: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;广州&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名  年龄  城市</span><br><span class="line">0   Alice  25  北京</span><br><span class="line">1     Bob  30  上海</span><br><span class="line">2  Charlie  35  广州</span><br></pre></td></tr></table></figure>

<ul>
<li>•每一列是一个 Series</li>
<li>•默认索引是 0, 1, 2, …</li>
<li>•可以自定义索引：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(data, index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、查看和访问数据"><a href="#五、查看和访问数据" class="headerlink" title="五、查看和访问数据"></a>五、查看和访问数据</h2><h3 id="查看-DataFrame-的基本信息："><a href="#查看-DataFrame-的基本信息：" class="headerlink" title="查看 DataFrame 的基本信息："></a>查看 DataFrame 的基本信息：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.info()        # 数据类型、非空数量、内存使用等</span><br><span class="line">df.describe()    # 数值列的统计摘要（如均值、标准差、最小最大值等）</span><br><span class="line">df.shape         # 返回 (行数, 列数)</span><br><span class="line">df.columns       # 查看列名</span><br><span class="line">df.index         # 查看索引</span><br></pre></td></tr></table></figure>

<h3 id="查看部分数据："><a href="#查看部分数据：" class="headerlink" title="查看部分数据："></a>查看部分数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head(2)   # 查看前 2 行</span><br><span class="line">df.tail(2)   # 查看后 2 行</span><br></pre></td></tr></table></figure>

<h3 id="选择列："><a href="#选择列：" class="headerlink" title="选择列："></a>选择列：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df[&#x27;姓名&#x27;])       # 选择单列，返回一个 Series</span><br><span class="line">print(df[[&#x27;姓名&#x27;, &#x27;年龄&#x27;]])  # 选择多列，返回一个 DataFrame</span><br></pre></td></tr></table></figure>

<h3 id="选择行："><a href="#选择行：" class="headerlink" title="选择行："></a>选择行：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.loc[&#x27;a&#x27;])      # 按标签选择某一行（loc = location）</span><br><span class="line">print(df.iloc[0])       # 按位置（索引号）选择某一行（iloc = integer location）</span><br></pre></td></tr></table></figure>

<p>选择多行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.loc[[&#x27;a&#x27;, &#x27;b&#x27;]])</span><br><span class="line">print(df.iloc[0:2])     # 前两行（左闭右开）</span><br></pre></td></tr></table></figure>

<p>选择某行某列的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df.loc[&#x27;a&#x27;, &#x27;年龄&#x27;])   # 获取 a 行，年龄列 → 25</span><br><span class="line">print(df.iloc[0, 1])         # 第0行，第1列 → 25</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、常用数据处理操作"><a href="#六、常用数据处理操作" class="headerlink" title="六、常用数据处理操作"></a>六、常用数据处理操作</h2><h3 id="1-增加-删除列"><a href="#1-增加-删除列" class="headerlink" title="1. 增加&#x2F;删除列"></a>1. <strong>增加&#x2F;删除列</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 增加列</span><br><span class="line">df[&#x27;性别&#x27;] = [&#x27;女&#x27;, &#x27;男&#x27;, &#x27;男&#x27;]</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">df = df.drop(&#x27;性别&#x27;, axis=1)  # axis=1 表示列</span><br></pre></td></tr></table></figure>

<h3 id="2-增加-删除行"><a href="#2-增加-删除行" class="headerlink" title="2. 增加&#x2F;删除行"></a>2. <strong>增加&#x2F;删除行</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 增加行（一般通过 concat 或 append，但 append 已不推荐）</span><br><span class="line">new_row = pd.DataFrame(&#123;&#x27;姓名&#x27;: [&#x27;David&#x27;], &#x27;年龄&#x27;: [40], &#x27;城市&#x27;: [&#x27;深圳&#x27;]&#125;)</span><br><span class="line">df = pd.concat([df, new_row], ignore_index=True)</span><br><span class="line"></span><br><span class="line"># 删除行</span><br><span class="line">df = df.drop(index=0)  # 删除第0行</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、数据筛选（条件过滤）"><a href="#七、数据筛选（条件过滤）" class="headerlink" title="七、数据筛选（条件过滤）"></a>七、数据筛选（条件过滤）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 筛选年龄大于28的行</span><br><span class="line">filtered = df[df[&#x27;年龄&#x27;] &gt; 28]</span><br><span class="line">print(filtered)</span><br><span class="line"></span><br><span class="line"># 多条件：年龄&gt;25 且 城市 == &#x27;北京&#x27;</span><br><span class="line">filtered = df[(df[&#x27;年龄&#x27;] &gt; 25) &amp; (df[&#x27;城市&#x27;] == &#x27;北京&#x27;)]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、常用统计函数"><a href="#八、常用统计函数" class="headerlink" title="八、常用统计函数"></a>八、常用统计函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df[&#x27;年龄&#x27;].mean()    # 平均年龄</span><br><span class="line">df[&#x27;年龄&#x27;].sum()     # 年龄总和</span><br><span class="line">df[&#x27;年龄&#x27;].max()     # 最大年龄</span><br><span class="line">df[&#x27;年龄&#x27;].min()     # 最小年龄</span><br><span class="line">df[&#x27;年龄&#x27;].std()     # 标准差</span><br><span class="line">df.describe()        # 数值列统计汇总</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、排序"><a href="#九、排序" class="headerlink" title="九、排序"></a>九、排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按年龄升序</span><br><span class="line">df_sorted = df.sort_values(by=&#x27;年龄&#x27;)</span><br><span class="line"></span><br><span class="line"># 按年龄降序</span><br><span class="line">df_sorted = df.sort_values(by=&#x27;年龄&#x27;, ascending=False)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十、处理缺失值"><a href="#十、处理缺失值" class="headerlink" title="十、处理缺失值"></a>十、处理缺失值</h2><p>在实际数据中，经常会遇到缺失值（NaN）。</p>
<h3 id="检查缺失值："><a href="#检查缺失值：" class="headerlink" title="检查缺失值："></a>检查缺失值：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.isnull()      # 每个值是否为缺失值</span><br><span class="line">df.isnull().sum()  # 每列缺失值的数量</span><br></pre></td></tr></table></figure>

<h3 id="删除缺失值："><a href="#删除缺失值：" class="headerlink" title="删除缺失值："></a>删除缺失值：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna()      # 删除含有缺失值的行</span><br></pre></td></tr></table></figure>

<h3 id="填充缺失值："><a href="#填充缺失值：" class="headerlink" title="填充缺失值："></a>填充缺失值：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(0)          # 用 0 填充</span><br><span class="line">df[&#x27;年龄&#x27;].fillna(df[&#x27;年龄&#x27;].mean(), inplace=True)  # 用均值填充年龄列的缺失值</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十一、读取和保存数据"><a href="#十一、读取和保存数据" class="headerlink" title="十一、读取和保存数据"></a>十一、读取和保存数据</h2><p>pandas 支持多种格式的数据读写，如 CSV、Excel、JSON 等。</p>
<h3 id="读取-CSV-文件："><a href="#读取-CSV-文件：" class="headerlink" title="读取 CSV 文件："></a>读取 CSV 文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(&#x27;data.csv&#x27;)  # 从当前目录读取 data.csv 文件</span><br><span class="line">print(df.head())</span><br></pre></td></tr></table></figure>

<h3 id="保存为-CSV："><a href="#保存为-CSV：" class="headerlink" title="保存为 CSV："></a>保存为 CSV：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(&#x27;output.csv&#x27;, index=False)  # 不保存行索引</span><br></pre></td></tr></table></figure>

<p>其他格式：</p>
<ul>
<li>•Excel: <code>pd.read_excel()</code>, <code>df.to_excel()</code></li>
<li>•JSON: <code>pd.read_json()</code>, <code>df.to_json()</code></li>
<li>•SQL: 结合 SQLAlchemy 使用</li>
</ul>
<hr>
<h2 id="十二、数据合并与连接"><a href="#十二、数据合并与连接" class="headerlink" title="十二、数据合并与连接"></a>十二、数据合并与连接</h2><p>类似于 SQL 的 join 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设有 df1 和 df2</span><br><span class="line">result = pd.concat([df1, df2])           # 简单堆叠</span><br><span class="line">result = pd.merge(df1, df2, on=&#x27;key&#x27;)    # 按某个键合并，类似 SQL join</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结：pandas-常用功能速查"><a href="#总结：pandas-常用功能速查" class="headerlink" title="总结：pandas 常用功能速查"></a>总结：pandas 常用功能速查</h2><table>
<thead>
<tr>
<th>功能</th>
<th>方法&#x2F;操作</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建数据</strong></td>
<td><code>pd.Series()</code>, <code>pd.DataFrame()</code></td>
</tr>
<tr>
<td><strong>查看数据</strong></td>
<td><code>df.head()</code>, <code>df.tail()</code>, <code>df.info()</code>, <code>df.describe()</code></td>
</tr>
<tr>
<td><strong>选择数据</strong></td>
<td><code>df[&#39;列名&#39;]</code>, <code>df[[&#39;列1&#39;,&#39;列2&#39;]]</code>, <code>df.loc[]</code>, <code>df.iloc[]</code></td>
</tr>
<tr>
<td><strong>筛选数据</strong></td>
<td><code>df[df[&#39;列&#39;] &gt; 值]</code>, 多条件用 <code>&amp;</code>, &#96;</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td><code>df.sort_values(by=&#39;列名&#39;, ascending=True/False)</code></td>
</tr>
<tr>
<td><strong>处理缺失值</strong></td>
<td><code>df.isnull()</code>, <code>df.dropna()</code>, <code>df.fillna(value)</code></td>
</tr>
<tr>
<td><strong>统计计算</strong></td>
<td><code>df.mean()</code>, <code>df.sum()</code>, <code>df.max()</code>, <code>df.min()</code></td>
</tr>
<tr>
<td><strong>增删行列</strong></td>
<td>增加列：<code>df[&#39;新列&#39;] = ...</code>；删除：<code>df.drop()</code></td>
</tr>
<tr>
<td><strong>读写文件</strong></td>
<td><code>pd.read_csv()</code>, <code>df.to_csv()</code>, <code>pd.read_excel()</code>, <code>df.to_excel()</code></td>
</tr>
<tr>
<td><strong>合并数据</strong></td>
<td><code>pd.concat()</code>, <code>pd.merge()</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="推荐学习路径（如果你是新手）："><a href="#推荐学习路径（如果你是新手）：" class="headerlink" title="推荐学习路径（如果你是新手）："></a>推荐学习路径（如果你是新手）：</h2><ol>
<li>1.<strong>掌握 Series 和 DataFrame 的创建与基本操作</strong></li>
<li>2.<strong>学会查看和选择数据（列、行）</strong></li>
<li>3.<strong>学会数据筛选、排序、统计</strong></li>
<li>4.<strong>学会处理缺失值</strong></li>
<li>5.<strong>学会读取&#x2F;保存 CSV、Excel 文件</strong></li>
<li>6.<strong>尝试实际的数据分析小项目（比如分析销售数据、学生成绩等）</strong></li>
</ol>
<hr>
<p>🔥 <strong>如果你有具体的需求，比如：</strong></p>
<ul>
<li>•如何用 pandas 处理某个 csv 文件？</li>
<li>•如何筛选&#x2F;分组&#x2F;聚合数据？</li>
<li>•如何画图（结合 matplotlib&#x2F;seaborn）？</li>
<li>•如何做数据清洗？</li>
</ul>
<p>欢迎继续提问，我可以给你出详细代码示例！ 😊</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:06:23" itemprop="dateModified" datetime="2025-12-03T17:06:23+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="考核形式"><a href="#考核形式" class="headerlink" title="考核形式"></a>考核形式</h1><h2 id="平时成绩（60-）"><a href="#平时成绩（60-）" class="headerlink" title="平时成绩（60%）"></a>平时成绩（60%）</h2><p>课程作业30%（每人提交，共八次）</p>
<p>上机报告30%（小组提交，共六次）</p>
<h2 id="期末成绩（40-）"><a href="#期末成绩（40-）" class="headerlink" title="期末成绩（40%）"></a>期末成绩（40%）</h2><p>专题报告（小组提交，共一次）</p>
<ul>
<li>无期末试卷考试</li>
</ul>
<h1 id="机器学习四大问题"><a href="#机器学习四大问题" class="headerlink" title="机器学习四大问题"></a>机器学习四大问题</h1><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><ul>
<li><strong>定义</strong>：一种 <strong>无监督学习方法</strong>，目标是把样本自动划分为若干组（簇），同一簇内的样本相似度高，不同簇间的相似度低。</li>
<li><strong>常见算法</strong><ul>
<li><strong>K-means</strong>：基于中心点迭代优化，快速但对初始值和簇数敏感。</li>
<li><strong>层次聚类</strong>（Hierarchical Clustering）：逐层合并或拆分，得到树状聚类结构。</li>
<li><strong>DBSCAN</strong>：基于密度，能发现任意形状的簇，并识别噪声。</li>
<li><strong>高斯混合模型 (GMM)</strong>：用概率分布来建模簇。</li>
</ul>
</li>
<li><strong>应用</strong>：用户分群、市场细分、异常检测、推荐系统。</li>
</ul>
<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p><strong>定义</strong>：把高维数据映射到低维空间，同时尽量保留数据的主要信息。</p>
<p><strong>目的</strong></p>
<ul>
<li>降低计算复杂度</li>
<li>去除噪声、减少冗余</li>
<li>便于可视化</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><strong>线性方法</strong><ul>
<li><strong>PCA（主成分分析）</strong>：通过正交变换找到最大方差方向。</li>
<li><strong>LDA（线性判别分析）</strong>：监督方法，最大化类间差异、最小化类内差异。</li>
</ul>
</li>
<li><strong>非线性方法</strong><ul>
<li><strong>t-SNE</strong>：常用于高维数据的可视化（比如词向量）。</li>
<li><strong>UMAP</strong>：保持局部和全局结构，更适合大规模数据。</li>
</ul>
</li>
</ul>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p><strong>定义</strong>：对原始数据进行处理，构造出更能表达模式的特征，提高模型效果。</p>
<p><strong>流程</strong></p>
<ul>
<li><strong>特征预处理</strong><ul>
<li>缺失值处理（均值填充、插值、模型预测）</li>
<li>标准化 &#x2F; 归一化（Z-score, MinMaxScaler）</li>
<li>离散化（分箱、one-hot 编码）</li>
</ul>
</li>
<li><strong>特征选择</strong><ul>
<li>过滤法（方差选择、相关系数、卡方检验）</li>
<li>包装法（递归特征消除 RFE）</li>
<li>嵌入法（Lasso, 决策树特征重要性）</li>
</ul>
</li>
<li><strong>特征构造</strong><ul>
<li>组合特征（交互项、多项式特征）</li>
<li>时间序列特征（滞后、移动平均）</li>
<li>NLP 特征（TF-IDF, word2vec, BERT）</li>
</ul>
</li>
</ul>
<h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><ul>
<li><strong>目的</strong>：衡量训练好的模型在未知数据上的泛化能力。</li>
<li><strong>评估方法</strong><ul>
<li><strong>分类任务</strong><ul>
<li>准确率（Accuracy）</li>
<li>精确率（Precision）、召回率（Recall）、F1-score</li>
<li>AUC-ROC 曲线</li>
</ul>
</li>
<li><strong>回归任务</strong><ul>
<li>MSE（均方误差）、RMSE</li>
<li>MAE（平均绝对误差）</li>
<li>$R^2$（决定系数）</li>
</ul>
</li>
<li><strong>聚类任务</strong><ul>
<li>轮廓系数（Silhouette Coefficient）</li>
<li>Calinski-Harabasz 指数</li>
<li>Davies-Bouldin 指数</li>
</ul>
</li>
</ul>
</li>
<li><strong>验证方式</strong><ul>
<li>留出法（Train&#x2F;Test Split）</li>
<li>交叉验证（k-fold Cross Validation）</li>
<li>自助法（Bootstrap）</li>
</ul>
</li>
</ul>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题定义</span><br><span class="line">    ↓</span><br><span class="line">数据收集</span><br><span class="line">    ↓</span><br><span class="line">数据预处理 &amp; 特征工程</span><br><span class="line">    ↓</span><br><span class="line">数据划分（训练/验证/测试）</span><br><span class="line">    ↓</span><br><span class="line">模型选择与训练</span><br><span class="line">    ↓</span><br><span class="line">模型评估</span><br><span class="line">    ↓</span><br><span class="line">模型优化（调参/集成/正则化）</span><br><span class="line">    ↓</span><br><span class="line">模型部署</span><br><span class="line">    ↓</span><br><span class="line">维护与迭代</span><br></pre></td></tr></table></figure>

<p>一、问题定义（Problem Definition）</p>
<ul>
<li><strong>目标：</strong> 明确你要解决的问题是什么。是分类问题（如垃圾邮件识别）？还是回归问题（如房价预测）？或者是无监督问题（如客户分群）？</li>
<li><strong>评估指标：</strong> 确定如何衡量模型的好坏。分类：准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1分数等回归：均方误差（MSE）、均方根误差（RMSE）、R²等</li>
</ul>
<hr>
<p>二、数据收集（Data Collection）</p>
<ul>
<li>**来源：**公开数据集（如Kaggle、UCI、政府开放数据等）业务系统&#x2F;数据库爬虫&#x2F;传感器&#x2F;日志等</li>
<li>**类型：**结构化数据（表格数据，如CSV）非结构化数据（文本、图像、音频等）</li>
</ul>
<hr>
<p>三、数据预处理（Data Preprocessing）</p>
<p>这是非常关键的一步，数据质量直接影响模型效果。</p>
<ul>
<li>**数据清洗：**处理缺失值（删除、填充均值&#x2F;中位数&#x2F;众数等）处理异常值（删除、修正、分箱等）去重</li>
<li>**数据转换：**特征编码：类别型变量 → 数值（如独热编码 One-Hot Encoding、标签编码 Label Encoding）数据标准化 &#x2F; 归一化（如Z-score标准化、Min-Max归一化）</li>
<li>**特征工程：**特征选择（过滤法、包裹法、嵌入法）特征构造（组合特征、多项式特征等）降维（如PCA、LDA）</li>
</ul>
<hr>
<p>四、数据划分（Data Splitting）</p>
<p>将数据划分为训练集、验证集和测试集，常见比例：</p>
<ul>
<li>训练集（Train）：70% ~ 80%</li>
<li>验证集（Validation）：10% ~ 15%（用于调参和模型选择）</li>
<li>测试集（Test）：10% ~ 15%（最终评估模型泛化能力）</li>
</ul>
<p>或者使用交叉验证（如 k-fold Cross Validation）</p>
<hr>
<p>五、模型选择与训练（Model Selection &amp; Training）</p>
<ul>
<li>**选择模型：**线性模型：线性回归、逻辑回归树模型：决策树、随机森林、梯度提升树（如XGBoost、LightGBM、CatBoost）神经网络：多层感知机（MLP）、CNN、RNN等（用于复杂任务）其他：支持向量机（SVM）、K近邻（KNN）、朴素贝叶斯等</li>
<li>**训练模型：**使用训练集对模型进行拟合（fit）可使用默认参数先跑通流程，再优化</li>
</ul>
<hr>
<p>六、模型评估（Model Evaluation）</p>
<ul>
<li>在验证集或测试集上评估模型性能</li>
<li>根据任务类型选择合适的评估指标</li>
<li>可视化结果（如混淆矩阵、ROC曲线、学习曲线等）</li>
</ul>
<hr>
<p>七、模型优化（Model Optimization）</p>
<ul>
<li>**超参数调优：**网格搜索（Grid Search）随机搜索（Random Search）贝叶斯优化、进化算法等</li>
<li>**模型融合&#x2F;集成：**Bagging（如随机森林）Boosting（如XGBoost）Stacking、Voting等</li>
<li>**防止过拟合&#x2F;欠拟合：**正则化（L1&#x2F;L2）Dropout（神经网络）增加数据、简化模型等</li>
</ul>
<hr>
<p>八、模型部署（Model Deployment）</p>
<ul>
<li>将训练好的模型应用到实际环境中</li>
<li>**部署方式：**批处理预测实时API服务（如使用 Flask、FastAPI、Django）嵌入到移动端&#x2F;嵌入式设备</li>
<li>**模型监控：**模型性能衰减监控数据漂移检测持续更新与迭代</li>
</ul>
<hr>
<p>九、维护与迭代（Maintenance &amp; Iteration）</p>
<ul>
<li>收集用户反馈与新的数据</li>
<li>定期重新训练与优化模型</li>
<li>持续改进业务流程与模型效果</li>
</ul>
<h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p><strong>定义</strong>：</p>
<ol>
<li>过拟合是指模型在训练集上表现得非常好，但在新的、未见过的测试集上表现较差的现象。此时，模型过于复杂，记住了训练数据中的噪声和细节，导致无法很好地泛化到新的数据。</li>
</ol>
<p><strong>影响</strong></p>
<ol>
<li>过拟合的模型能够在训练数据中准确地预测，但在测试集或实际应用中性能差，不能有效地处理未见过的数据。这是因为模型不仅学习到了数据的普遍规律，还过度关注了训练集的特殊性。</li>
</ol>
<p><strong>原因</strong></p>
<ol>
<li>模型过于复杂：例如，神经网络的层数和参数过多，决策树的深度过深，大参数。<ol>
<li><strong>（数值）大参数的模型，尤其是在高维度中，容易导致过拟合。所以我们要小参数，不要大参数</strong></li>
<li>为什么在相同的参数量下，小参数意味着复杂度低？<ol>
<li>减小参数值的大小会约束模型的灵活性</li>
<li>小参数使得模型“平滑”</li>
<li>大参数带来更高的方差</li>
</ol>
</li>
</ol>
</li>
<li>训练数据不足：样本量少，模型无法学习到足够的普遍性规律。</li>
<li>缺乏正则化：模型没有适当的惩罚项来控制其复杂性。</li>
</ol>
<p><strong>预防策略</strong></p>
<ol>
<li><p><strong>数据方面</strong>：</p>
<ol>
<li>增加训练数据量：更多的数据有助于模型捕捉到数据中的普遍规律，减少对偶然性噪声的依赖。</li>
<li>数据增强：通过对训练数据进行不同的变换（如旋转、裁剪、翻转等），来生成更多样化的训练数据，增加数据的多样性，帮助模型泛化。</li>
</ol>
</li>
<li><p><strong>模型方面</strong>：</p>
<ol>
<li><p>使用正则化：正则化技术如 L1 或 L2 正则化可以对模型参数施加约束，从而防止模型过于复杂。</p>
<ol>
<li><p>L1正则化：</p>
</li>
<li><p>原理：</p>
<ol>
<li><p>L1 正则化是通过在损失函数中加入模型参数的 <strong>绝对值</strong> 的和来进行惩罚。其惩罚项为：</p>
</li>
<li><p>$$<br>L1 Regularization&#x3D;λ_i∑∣w_i∣<br>$$</p>
</li>
<li><p>其中，w是模型的参数，λ 是正则化强度超参数，控制惩罚的力度。</p>
</li>
</ol>
</li>
<li><p>特点：适用于特征稀疏的模型，比如在很多特征中只有少数特征对预测有用的情况</p>
</li>
<li><p>L2正则化：</p>
</li>
<li><p>$$<br>L2 Regularization&#x3D;λ_i∑w_i^2<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>训练方面</strong>：</p>
<ol>
<li>早停法（Early Stopping）：在训练过程中监控验证集的表现，一旦验证误差开始增加，停止训练，从而避免过拟合。</li>
<li>交叉验证（Cross-validation）：将数据分成多个子集，每次训练时使用不同的训练集和验证集，确保模型在不同数据集上都有良好的表现。<ol>
<li>特别适用于样本量相对较小的情况</li>
<li>它通过将数据集分成多个子集，在不同的子集上训练和验证模型，从而使得模型的训练和验证更加稳定，避免过拟合。</li>
<li><strong>K折交叉验证</strong>是最常见的交叉验证方法。将数据集分为 K 个子集，模型会在 K-1 个子集上进行训练，然后在剩下的一个子集上进行验证。这个过程重复 K 次，每次选择不同的子集作为验证集，最终得到一个平均的模型性能评估结果。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h3><p><strong>定义</strong></p>
<p>欠拟合是指模型对训练数据的学习能力不足，无法捕捉到数据的基本规律。表现为训练集和测试集上都无法取得良好的性能。</p>
<p><strong>影响</strong></p>
<ol>
<li>欠拟合的模型无法从数据中提取有用的信息，导致预测精度较低。它通常发生在模型过于简单，不能表达数据中复杂关系时。</li>
</ol>
<p><strong>原因</strong></p>
<ul>
<li><p>模型过于简单：例如，使用了线性模型来拟合本应是非线性关系的数据。</p>
</li>
<li><p>特征不足：没有选取到有意义的特征，模型无法有效地学习数据的规律。</p>
</li>
<li><p>训练不充分：模型训练不够充分，未能在训练集上学习到足够的信息。</p>
</li>
</ul>
<p><strong>防止策略</strong></p>
<ol>
<li>增加模型复杂度：选择更复杂的模型，增加更多的特征或增加模型的非线性能力。例如，使用多层神经网络、非线性回归或决策树等。</li>
<li>增加训练时间：确保模型有足够的时间来学习训练数据中的模式，避免过早终止训练。</li>
<li>选择更合适的特征：通过特征工程选取更加有意义的特征，使模型能够学习到更复杂的模式。</li>
<li>降低正则化强度：如果正则化太强，可能会限制模型的学习能力，导致欠拟合。因此，可以适当减小正则化项的系数。</li>
</ol>
<h2 id="分类和回归任务"><a href="#分类和回归任务" class="headerlink" title="分类和回归任务"></a>分类和回归任务</h2><h3 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>分类任务的目标是将样本正确地分类到一个或多个预定的类别中</p>
<h4 id="类别平衡"><a href="#类别平衡" class="headerlink" title="类别平衡"></a>类别平衡</h4><ol>
<li>定义：类别平衡是指数据集中每个类别的样本数量大致相等。即，不同类别的数据样本数量差不多，分类器可以公平地学习每个类别的特征。</li>
<li>特点<ol>
<li>每个类别的样本数差异较小。</li>
<li>模型训练时，每个类别对模型的影响相对均衡。</li>
<li>评估指标（如准确率、精确率、召回率等）能较为客观地反映模型的性能。</li>
</ol>
</li>
</ol>
<h4 id="类别不平衡的影响"><a href="#类别不平衡的影响" class="headerlink" title="类别不平衡的影响"></a>类别不平衡的影响</h4><ol>
<li>模型偏向于多数类<ul>
<li>在类别不平衡的情况下，多数类的样本在训练集中的占比非常大，模型会倾向于预测多数类样本，从而导致少数类的分类效果较差。</li>
<li>比如在上面的例子中，模型如果只预测为负类（多数类），它也能取得较高的 准确率，但其实模型并没有有效地识别少数类样本。</li>
</ul>
</li>
<li>评估指标失真<ul>
<li>在不平衡的情况下，准确率是一个 误导性指标。因为即使模型忽略了少数类样本，只预测多数类，准确率也可能很高。</li>
<li>对于 少数类 的评价，精确率 和 召回率 等指标更为重要，尤其是 F1 分数，能够综合考虑精确率和召回率，帮助更好地评估模型对少数类的预测能力。</li>
</ul>
</li>
<li>训练困难<ul>
<li>类别不平衡会导致模型的 学习偏差，模型可能会忽略少数类样本的特征，甚至完全不去学习少数类的样本。这样一来，模型的 泛化能力 就会变差，尤其是在实际应用中，少数类样本往往才是 关键性数据（例如，疾病诊断中的患病类别）。</li>
</ul>
</li>
<li>不良的泛化能力<ul>
<li>由于模型倾向于学习多数类的特征，它在处理 新数据 时可能会产生较差的预测，特别是当新数据的类别分布与训练集不同（例如，大量少数类数据突然出现时），模型的表现可能会急剧下降。</li>
</ul>
</li>
</ol>
<h4 id="如何应对类别不平衡"><a href="#如何应对类别不平衡" class="headerlink" title="如何应对类别不平衡"></a>如何应对类别不平衡</h4><ol>
<li>重新采样</li>
<li>类别权重调整<ol>
<li>一些机器学习算法（如 支持向量机、逻辑回归、决策树 等）允许调整每个类别的权重。在类别不平衡时，增加少数类的权重，使得模型在训练时更加关注少数类样本。</li>
</ol>
</li>
<li>使用合适的评估指标<ol>
<li>使用 F1 分数、精确率、召回率 或 AUC 等更适合不平衡数据集的指标，而不是简单的准确率。</li>
<li>AUC（Area Under Curve）：ROC 曲线下的面积，能够更全面地评估模型在不同阈值下的表现，尤其是在数据不平衡的情况下。</li>
<li>F1 分数：综合考虑 精确率 和 召回率，在不平衡数据中更能准确反映模型的性能。</li>
</ol>
</li>
<li>集成学习方法<ol>
<li>一些集成学习方法，如 Bagging 和 Boosting，在处理不平衡数据时也具有优势。例如，随机森林和XGBoost可以通过调整 类别权重 或 数据采样 来处理类别不平衡。</li>
</ol>
</li>
<li>生成对抗网络</li>
</ol>
<h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><ol>
<li><p><strong>准确率</strong></p>
<ol>
<li><strong>定义</strong>：准确率是指正确分类的样本数与总样本数之比：<br>$$<br>\text{Accuracy} &#x3D; \frac{\text{正确分类的样本数}}{\text{总样本数}}<br>$$</li>
</ol>
<p>​    2. <strong>优点</strong>：简单直观，适用于类别均衡的情况。</p>
<ol start="3">
<li><strong>缺点</strong>：当数据类别不平衡时，准确率可能会误导模型的真实性能。</li>
</ol>
</li>
<li><p><strong>精确率</strong></p>
<ol>
<li><p><strong>定义</strong>：精确率是指被分类为正类的样本中，实际为正类的比例：</p>
</li>
<li><p>$$<br>\text{Precision} &#x3D; \frac{\text{真正例（TP）}}{\text{真正例（TP）} + \text{假正例（FP）}}<br>$$</p>
<ul>
<li>其中，TP 为真正例，FP 为假正例。</li>
</ul>
</li>
<li><p><strong>优点</strong>：关注模型的<strong>误报率</strong>（False Positive），即模型预测为正类的样本中，实际为负类的比例。</p>
</li>
<li><p><strong>缺点</strong>：精确率高并不一定意味着模型总体表现好，因为它忽视了召回率（Recall）。</p>
</li>
</ol>
</li>
<li><p><strong>召回率</strong></p>
<ol>
<li><p><strong>定义</strong>：召回率是指所有实际为正类的样本中，被正确预测为正类的比例：</p>
</li>
<li><p>$$<br>\text{Recall} &#x3D; \frac{\text{真正例（TP）}}{\text{真正例（TP）} + \text{假负例（FN）}}<br>$$</p>
<ul>
<li>其中，FN 为假负例。</li>
</ul>
</li>
<li><p><strong>优点</strong>：关注模型的<strong>漏报率</strong>（False Negative），即实际为正类但被误预测为负类的比例。</p>
</li>
<li><p><strong>缺点</strong>：召回率高并不意味着模型总体表现好，因为它忽视了精确率。</p>
</li>
</ol>
</li>
<li><p><strong>F1 分数</strong></p>
<ol>
<li><p><strong>定义</strong>：F1 分数是精确率和召回率的调和平均数，综合考虑了精确率和召回率：</p>
</li>
<li><p>$$<br>\text{F1 Score} &#x3D; 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}<br>$$</p>
</li>
<li><p><strong>优点</strong>：适用于需要平衡精确率和召回率的场景，尤其是当数据类别不平衡时，F1 分数比准确率更能反映模型性能。</p>
</li>
<li><p><strong>缺点</strong>：可能会过于简化，忽略某些特定的应用场景。</p>
</li>
</ol>
</li>
<li><p>ROC 曲线和 AUC（Area Under the Curve）</p>
<ul>
<li>ROC 曲线：通过绘制 假正率（False Positive Rate, FPR） 与 真正率（True Positive Rate, TPR） 的关系图来评估模型的表现。<ul>
<li>TPR（True Positive Rate）即召回率，反映模型对正类样本的识别能力。</li>
<li>FPR（False Positive Rate）反映模型对负类样本错误分类的能力。</li>
</ul>
</li>
<li>AUC（Area Under the Curve）：ROC 曲线下的面积，AUC 值越接近 1，表示模型的分类性能越好，AUC 为 0.5 表示模型没有分类能力。</li>
</ul>
</li>
</ol>
<h3 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>回归任务的目标是预测一个连续的数值。</p>
<h4 id="评价指标-1"><a href="#评价指标-1" class="headerlink" title="评价指标"></a>评价指标</h4><ol>
<li><p><strong>均方误差（Mean Squared Error, MSE）</strong></p>
<ul>
<li><p><strong>定义</strong>：均方误差是预测值与真实值之差的平方的平均值：</p>
</li>
<li><p>$$<br>\text{MSE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} (y_i - \hat{y}_i)^2<br>$$</p>
<p>其中，$y_i$ 是真实值，$\hat{y}_i $是预测值。</p>
</li>
<li><p><strong>优点</strong>：常用且简单，能够强调较大的误差。</p>
</li>
<li><p><strong>缺点</strong>：对异常值非常敏感。</p>
</li>
</ul>
</li>
<li><p><strong>均方根误差（Root Mean Squared Error, RMSE）</strong></p>
<ul>
<li><p><strong>定义</strong>：均方根误差是均方误差的平方根：</p>
</li>
<li><p>$$<br>\text{RMSE} &#x3D; \sqrt{\text{MSE}}<br>$$</p>
</li>
<li><p><strong>优点</strong>：相比 MSE，这个RMSE 具有与原数据相同的单位，更直观。</p>
</li>
<li><p><strong>缺点</strong>：同样对异常值敏感。</p>
</li>
</ul>
</li>
<li><p><strong>平均绝对误差（Mean Absolute Error, MAE）</strong></p>
<ul>
<li><p><strong>定义</strong>：平均绝对误差是预测值与真实值之差的绝对值的平均值：</p>
</li>
<li><p>$$<br>\text{MAE} &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} |y_i - \hat{y}_i|<br>$$</p>
</li>
<li><p><strong>优点</strong>：相较于 MSE，MAE 对异常值不那么敏感。</p>
</li>
<li><p><strong>缺点</strong>：不会对大的误差进行惩罚，可能不如 MSE 更加有效。</p>
</li>
</ul>
</li>
</ol>
<h2 id="⽀持向量机与核函数"><a href="#⽀持向量机与核函数" class="headerlink" title="⽀持向量机与核函数"></a>⽀持向量机与核函数</h2><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><ol>
<li>概念<ol>
<li>支持向量机（<strong>SVM</strong>）是一种强大的监督学习算法，广泛用于分类和回归任务。它的基本思想是寻找一个 <strong>超平面</strong>，将数据集分成不同的类别，并且尽量使得各类之间的间隔（<strong>边界</strong>）最大化。对于<strong>线性可分</strong>的数据，SVM 可以很好地进行分类，但在面对 <strong>线性不可分</strong> 的数据时，SVM 就显得有些力不从心。</li>
</ol>
</li>
<li><strong>线性可分数据</strong>：数据点可以通过一个超平面（线性决策边界）完全分开。线性不可分则反之</li>
<li>核函数的引入：如何解决线性不可分问题<ol>
<li>概述<ol>
<li>当数据是线性不可分的时，SVM 的标准方法无法找到一个合适的超平面来分割这些数据。为了克服这个问题，SVM 引入了 <strong>核函数</strong>的思想，<strong>通过将数据映射到更高维的空间</strong>，使得数据在新的空间中变得线性可分，从而能够找到一个超平面进行分类。</li>
</ol>
</li>
<li>核心思想<ol>
<li><strong>映射到更高维空间</strong>：核函数通过某种方式将原始数据从低维空间映射到更高维的空间，在高维空间中，数据可能变得线性可分。例如，如果二维数据在三维空间中能够被一个平面分开，核函数的作用就是将数据从二维空间映射到三维空间。</li>
<li><strong>避免直接计算映射</strong>：直接计算映射到高维空间的特征非常复杂，尤其当维度极高时。因此，SVM 使用 <strong>核技巧</strong>（kernel trick）来避免显式计算这个映射。通过核函数直接计算数据在高维空间中的内积，而不需要实际地将数据投影到高维空间中，从而大大提高了计算效率。</li>
</ol>
</li>
<li>内积：<ol>
<li>代数定义就是对应的元素之积的和</li>
<li>几何定义是两个向量的模之积乘夹角的余弦<ol>
<li>内积的值与两向量之间的夹角相关。内积越大，表示两个向量的方向越相似。</li>
<li>如果内积为零，则表示两个向量是 正交的（垂直的）。</li>
</ol>
</li>
<li>为什么要计算内积？<ol>
<li><strong>内积</strong>在高维空间中可以告诉我们数据点之间的相似性，进而帮助我们找到最优的分类超平面。</li>
<li>核函数通过内积实现了 <strong>将数据映射到高维空间</strong>，而无需明确计算每个数据点的高维表示。通过这种技巧，SVM 可以有效地解决 <strong>线性不可分</strong> 问题。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="三种决策树算法对比"><a href="#三种决策树算法对比" class="headerlink" title="三种决策树算法对比"></a>三种决策树算法对比</h2><p>ID3、C4.5 和 CART 是三种经典的 <strong>决策树算法</strong>。下面，我们将从以下几个方面对这三种算法进行对比：</p>
<h3 id="特征选择依据"><a href="#特征选择依据" class="headerlink" title="特征选择依据"></a>特征选择依据</h3><p>特征选择是决策树算法中最重要的步骤之一，它决定了树的结构和分类效果。ID3、C4.5 和 CART 在特征选择时采用不同的标准：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>ID3</strong></th>
<th><strong>C4.5</strong></th>
<th><strong>CART</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>特征选择依据</strong></td>
<td>信息增益（Information Gain）</td>
<td>信息增益比（Information Gain Ratio）</td>
<td>基尼指数（Gini Index）</td>
</tr>
<tr>
<td><strong>剪枝策略</strong></td>
<td>无剪枝或后期剪枝</td>
<td>后剪枝（Post-pruning）</td>
<td>成本复杂度剪枝（Cost Complexity Pruning）</td>
</tr>
<tr>
<td><strong>处理连续特征</strong></td>
<td>不支持连续特征，需离散化</td>
<td>允许处理连续特征，选择最佳切分点（如中位数）</td>
<td>允许处理连续特征，选择最佳切分点</td>
</tr>
<tr>
<td><strong>处理缺失数据</strong></td>
<td>忽略缺失数据或使用默认值</td>
<td>根据条件概率处理缺失数据</td>
<td>插补方法（多数类或平均值填充）</td>
</tr>
<tr>
<td><strong>生成树类型</strong></td>
<td>分类树（Classification Tree）</td>
<td>分类树（Classification Tree）</td>
<td>分类树和回归树（Classification and Regression Trees）</td>
</tr>
<tr>
<td><strong>适用任务</strong></td>
<td>主要用于分类问题</td>
<td>主要用于分类问题，但支持概率输出</td>
<td>既可以用于分类问题，也可以用于回归问题</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>- 简单易实现 - 易过拟合（因为缺乏剪枝机制）</td>
<td>- 解决了ID3的偏向性 - 计算复杂 - 能处理缺失数据</td>
<td>- 支持回归任务 - 基尼指数计算简洁 - 处理缺失数据较好</td>
</tr>
</tbody></table>
<ol>
<li><p>ID3</p>
<ol>
<li><p><strong>特征选择依据</strong>：ID3 使用 <strong>信息增益</strong>（Information Gain）作为特征选择的依据。信息增益衡量的是 <strong>通过某个特征对数据集的分类效果的提高</strong>。信息增益越大，表示该特征越能有效地减少数据的不确定性，因此被优先选择。</p>
</li>
<li><p>信息增益的公式<br>$$<br>Gain(D,A)&#x3D;Entropy(D)−∑_{v∈A}\frac{∣D∣}{∣D_v|}·Entropy(D_v)<br>$$</p>
</li>
<li><p><strong>优缺点</strong>：</p>
<ul>
<li>优点：计算简单，易于理解。</li>
<li>缺点：信息增益倾向于选择取值较多的特征，这可能导致偏向复杂特征，从而容易过拟合。</li>
</ul>
</li>
</ol>
</li>
<li><p>C4.5</p>
<ol>
<li><p><strong>特征选择依据</strong>：C4.5 在 ID3 的基础上做了改进，使用了 <strong>信息增益比</strong>（Information Gain Ratio）作为特征选择的依据。信息增益比通过对信息增益进行归一化，解决了 ID3 在特征选择时偏向取值较多的特征的问题。</p>
</li>
<li><p>信息增益比的公式<br>$$<br>GainRatio(D,A)&#x3D;\frac{Gain(D,A)}{SplitInfo(D,A)}<br>$$<br>其中，<strong>SplitInfo</strong> 衡量的是特征 A 的 <strong>分裂能力</strong>，即特征 A 能把数据集分成多少子集。C4.5 通过信息增益比避免了 ID3 中的信息增益偏向取值多的特征的问题。</p>
</li>
<li><p><strong>优缺点</strong>：</p>
<ul>
<li>优点：信息增益比克服了 ID3 的偏向性，能更合理地选择特征。</li>
<li>缺点：信息增益比并不总能在所有情况下都最优。</li>
</ul>
</li>
</ol>
</li>
<li><p>CART</p>
<ol>
<li><p><strong>特征选择依据</strong>：CART（Classification and Regression Trees）使用 <strong>基尼指数</strong>（Gini Index）作为特征选择的依据。基尼指数衡量的是数据集的不纯度或不确定性。基尼指数越小，表示数据集越纯，分类效果越好。</p>
</li>
<li><p>基尼指数的公式<br>$$<br>Gini(D)&#x3D;1−∑_{i&#x3D;1}^kp_i^2<br>$$</p>
</li>
<li><p><strong>基尼指数与信息增益的对比</strong>：</p>
<ul>
<li><strong>信息增益</strong>关注的是特征选择后的信息不确定性的减少，而基尼指数则关注通过某个特征划分数据集后的纯度。基尼指数在处理不平衡数据时效果较好。</li>
<li><strong>优缺点</strong>：<ul>
<li>优点：基尼指数计算简单，并且能有效处理不平衡数据。</li>
<li>缺点：在某些情况下，基尼指数的表现可能不如信息增益比。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="剪枝策略"><a href="#剪枝策略" class="headerlink" title="剪枝策略"></a>剪枝策略</h3><p>剪枝是用来去除决策树中过拟合部分的步骤。</p>
<ol>
<li><p>ID3：</p>
<ul>
<li>ID3 没有内置剪枝机制。通常，ID3 构建的树可能会过度拟合训练数据，因此需要在决策树构建后通过其他方法（如交叉验证）进行剪枝。</li>
</ul>
</li>
<li><p>C4.5：</p>
<ul>
<li>C4.5 提出了 <strong>后剪枝（Post-pruning）</strong> 方法。C4.5 在构建树时会先完全生成一棵决策树，然后通过对每个子树进行剪枝来避免过拟合。剪枝过程通过 <strong>错误率的估计</strong> 来决定是否剪除某个节点。<ul>
<li>C4.5 使用了 <strong>最小错误率</strong> 和 <strong>最小增益</strong> 等标准来进行剪枝。通过这些标准，可以去掉对训练数据拟合过度的部分，从而提高模型的泛化能力。</li>
</ul>
</li>
</ul>
</li>
<li><p>CART：</p>
<ul>
<li><p>CART 使用 <strong>成本复杂度剪枝（Cost Complexity Pruning）</strong>，也叫 <strong>最小化误差剪枝（Error Complexity Pruning）</strong>。它通过计算每个节点的 <strong>复杂度参数</strong> 来判断是否剪枝。在剪枝过程中，CART 会遍历所有可能的子树，选择一个误差最小且复杂度最低的子树作为最终的模型。</p>
</li>
<li><p><strong>复杂度参数的定义</strong>：<br>$$<br>\alpha &#x3D; \frac{R(T) - R(T’)}{|T| - |T’|}<br>$$</p>
<p>其中，R(T) 是树 TTT 的误差率，∣T∣ 是树的大小，T′ 是剪枝后的树，α 是剪枝的复杂度系数。</p>
<ul>
<li><strong>优缺点</strong>：<ul>
<li>优点：CART 的剪枝机制可以有效控制树的复杂度，避免过拟合。</li>
<li>缺点：剪枝过程可能需要更多的计算，尤其是在数据集较大时。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="处理连续特征"><a href="#处理连续特征" class="headerlink" title="处理连续特征"></a>处理连续特征</h3><ol>
<li><p>ID3：</p>
<ul>
<li>处理连续特征：ID3 原生只支持 离散特征。对于连续特征，ID3 通常需要先将其离散化，将连续特征转化为离散区间，然后再进行处理。</li>
</ul>
</li>
<li><p>C4.5：</p>
<ul>
<li>处理连续特征：C4.5 允许直接处理连续特征。它会 根据连续特征的值（如某个特征值的中位数）将数据集分成两个子集。然后，根据信息增益比来选择最优的切分点。</li>
</ul>
</li>
<li><p>CART：</p>
<ul>
<li>处理连续特征：CART 也可以处理连续特征。它会通过 二分法 将连续特征分成两部分（小于某个阈值的部分和大于等于该阈值的部分），并根据基尼指数来选择最佳的切分点。</li>
</ul>
</li>
</ol>
<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>缺失数据是决策树算法中常见的挑战之一。q</p>
<ol>
<li><p>ID3：</p>
<ul>
<li>缺失数据：ID3 没有专门的缺失数据处理机制。通常在构建树时，会忽略缺失的数据，或者将缺失值当作某个默认值来处理。</li>
</ul>
</li>
<li><p>C4.5：</p>
<ul>
<li>缺失数据：C4.5 在遇到缺失数据时，会通过 概率分配 来处理缺失值。如果某个样本缺失了某个特征的值，C4.5 会计算该特征的不同取值的概率，并根据这些概率对数据进行划分。</li>
</ul>
</li>
<li><p>CART：</p>
<ul>
<li>缺失数据：CART 使用 插补法 来处理缺失数据。对于某个样本的缺失特征，CART 会用 该特征的平均值（回归树）或 多数类值（分类树）来填补缺失数据。</li>
</ul>
</li>
</ol>
<h3 id="生成的树类型"><a href="#生成的树类型" class="headerlink" title="生成的树类型"></a>生成的树类型</h3><ol>
<li>ID3：ID3 只生成 分类树，即每个叶子节点都对应一个类标签。</li>
<li>C4.5：C4.5 也生成 分类树，但它可以处理连续数据，并且生成的树更为平衡。</li>
<li>CART：CART 既可以生成 分类树（用于分类问题），也可以生成 回归树（用于回归问题）。</li>
</ol>
<h2 id="三类集成学习⽅法"><a href="#三类集成学习⽅法" class="headerlink" title="三类集成学习⽅法"></a>三类集成学习⽅法</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Bagging</strong></th>
<th><strong>Boosting</strong></th>
<th><strong>Stacking</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本思想</strong></td>
<td>通过独立训练多个基学习器，减少方差</td>
<td>逐步训练基学习器，减少偏差</td>
<td>综合多个基学习器的预测结果，通过次级学习器进行组合</td>
</tr>
<tr>
<td><strong>训练过程</strong></td>
<td>并行化训练基学习器，投票或平均组合</td>
<td>序列化训练，每个基学习器修正前一轮错误</td>
<td>并行训练基学习器，次级学习器进行加权组合</td>
</tr>
<tr>
<td><strong>降低的误差类型</strong></td>
<td>主要降低方差（防止过拟合）</td>
<td>主要降低偏差（提高准确度）</td>
<td>同时降低偏差和方差</td>
</tr>
<tr>
<td><strong>是否并行化</strong></td>
<td>可以并行化训练基学习器</td>
<td>训练过程是串行的，不能并行化</td>
<td>基学习器可并行化，次级学习器不能并行</td>
</tr>
<tr>
<td><strong>过拟合风险</strong></td>
<td>较低，特别适用于高方差模型（如决策树）</td>
<td>易过拟合，尤其在基学习器复杂时</td>
<td>较低，但需要合理选择基学习器</td>
</tr>
<tr>
<td><strong>典型算法</strong></td>
<td>随机森林（Random Forest）</td>
<td>AdaBoost，Gradient Boosting，XGBoost</td>
<td>Stacking（Stacked Generalization）</td>
</tr>
</tbody></table>
<h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><ol>
<li><p><strong>集成学习（Ensemble Learning）</strong> 是一种将多个学习器（基学习器）组合成一个更强大的模型的技术。与单一模型不同，集成学习的目标是通过结合多个模型的预测结果来提高整体的性能。集成学习的关键思想是：<strong>多个模型的组合通常比单个模型更能捕捉数据的复杂性</strong>，从而提高预测的准确性和泛化能力。</p>
<ul>
<li><p><strong>基学习器（Base Learner）</strong>：集成学习中的每一个单独的学习模型，通常是比较简单的模型。例如，决策树、逻辑回归、支持向量机等。</p>
</li>
<li><p><strong>组合方法</strong>：集成学习通过某种方式将这些基学习器的结果进行 <strong>加权投票</strong>（分类任务）或 <strong>加权平均</strong>（回归任务），从而得到最终的预测结果。</p>
</li>
</ul>
</li>
<li><p>分类：</p>
<ol>
<li><strong>并行集成学习</strong>：多个基学习器在同一阶段独立训练和预测，然后将结果结合起来。这类方法通常可以并行化训练。<ul>
<li><strong>例如</strong>：Bagging（如随机森林）。</li>
</ul>
</li>
<li><strong>串行集成学习</strong>：基学习器是按顺序逐个训练的，每个基学习器都会在前一个基学习器的基础上进行改进。此类方法通常 <strong>不能并行化</strong>，训练过程是有依赖关系的。<ul>
<li><strong>例如</strong>：Boosting（如 AdaBoost、XGBoost）。</li>
</ul>
</li>
</ol>
</li>
<li><p>意义</p>
<ol>
<li>提高模型的准确性</li>
<li>防止过拟合</li>
<li>处理不同类型的数据和特征</li>
<li>增强模型的鲁棒性</li>
<li>利用不同模型的优势</li>
<li>改进模型的泛化能力</li>
</ol>
</li>
</ol>
<h3 id="Bagging（Bootstrap-Aggregating）"><a href="#Bagging（Bootstrap-Aggregating）" class="headerlink" title="Bagging（Bootstrap Aggregating）"></a>Bagging（Bootstrap Aggregating）</h3><ol>
<li>训练过程（基本思想）<ol>
<li><strong>数据采样</strong>：从原始训练集通过 <strong>自助采样法（bootstrap）</strong> 随机抽取多个训练子集。每个子集的大小与原始数据集相同，但由于是有放回采样，某些样本可能在一个子集中重复出现，而有些样本则可能缺失。</li>
<li><strong>训练基学习器</strong>：在每个子集上训练一个基学习器。每个学习器的训练过程是独立的。</li>
<li><strong>组合预测</strong>：对于分类任务，使用 <strong>多数投票</strong>（即选取各学习器预测结果中出现最多的类别）来做最终预测；对于回归任务，使用 <strong>平均值</strong> 作为最终预测结果。</li>
</ol>
</li>
<li>应用特点<ol>
<li><strong>降低方差</strong>：Bagging 通过使用多个基学习器来减少模型的方差，特别适用于高方差模型（如决策树）。</li>
<li><strong>并行化</strong>：因为各基学习器的训练过程是独立的，所以 Bagging 具有很好的 <strong>并行化能力</strong>。</li>
</ol>
</li>
</ol>
<h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><ol>
<li>基本思想<ol>
<li><strong>Boosting</strong> 的基本思想是 <strong>逐步构建弱学习器</strong>，每一步都专注于 <strong>修正前一步的错误</strong>，即通过 <strong>加权调整</strong> 样本的重要性，使后续学习器更加关注难以预测的样本。最终的预测结果是所有弱学习器加权后的组合。</li>
</ol>
</li>
<li>训练过程<ol>
<li><strong>初始化训练</strong>：首先训练一个基学习器，并评估其表现。</li>
<li><strong>样本加权</strong>：根据上一步的预测误差，对训练数据中的样本进行加权。错误预测的样本会被赋予更大的权重，正确预测的样本权重较小。</li>
<li><strong>训练下一轮学习器</strong>：在加权后的数据集上训练下一个基学习器，使其更加关注误分类的样本。</li>
<li><strong>组合预测</strong>：通过对所有基学习器的加权投票（分类任务）或加权平均（回归任务）来得出最终的预测结果。</li>
</ol>
</li>
<li>应用特点<ol>
<li><strong>降低偏差</strong>：Boosting 主要通过减少模型的偏差来提高模型的准确度，适合处理弱学习器难以拟合的数据。</li>
<li><strong>序列化训练</strong>：由于每个学习器的训练过程都依赖于前一个学习器的结果，因此 Boosting 的训练过程是 <strong>串行化的</strong>，这意味着它不适合并行化。</li>
<li><strong>容易过拟合</strong>：Boosting 对噪声比较敏感，容易在训练集上过拟合，尤其是基学习器过于复杂时。</li>
</ol>
</li>
</ol>
<h3 id="Stacking（Stacked-Generalization）"><a href="#Stacking（Stacked-Generalization）" class="headerlink" title="Stacking（Stacked Generalization）"></a>Stacking（Stacked Generalization）</h3><ol>
<li>基本思想<ol>
<li><strong>Stacking</strong> 是一种更复杂的集成学习方法，其基本思想是将多个不同类型的基学习器的预测结果作为输入，训练一个 <strong>次级学习器</strong>（meta-learner）来对这些预测结果进行加权组合，从而得到最终的预测结果。</li>
<li>这使得 Stacking 在处理复杂任务时，比单一的模型表现更好，特别是在基学习器类型多样时。</li>
</ol>
</li>
<li>训练过程<ol>
<li><strong>训练基学习器</strong>：首先，训练多个不同类型的基学习器（例如，决策树、支持向量机、逻辑回归等），并用它们对训练数据进行预测。</li>
<li><strong>生成次级数据集</strong>：将每个基学习器的预测结果作为特征，形成一个新的数据集。这个数据集的每一行是由各个基学习器对原数据的预测组成的。</li>
<li><strong>训练次级学习器</strong>：使用新的数据集来训练一个 <strong>次级学习器</strong>，该学习器通常是一个简单的模型（如线性回归或逻辑回归），它的任务是 <strong>学习如何组合基学习器的预测</strong>，从而提高模型的准确性。</li>
<li><strong>组合预测</strong>：最终的预测由次级学习器输出，即基学习器的加权组合。</li>
</ol>
</li>
<li>应用特点<ol>
<li><strong>降低偏差和方差</strong>：Stacking 通过综合多个不同类型的模型来降低偏差和方差，因此在许多任务中能够取得较好的效果。</li>
<li><strong>适用多种基学习器</strong>：Stacking 可以组合不同类型的基学习器，利用它们各自的优势。</li>
<li><strong>训练过程复杂</strong>：与 Bagging 和 Boosting 不同，Stacking 的训练过程更为复杂，因为它不仅需要训练多个基学习器，还需要训练一个次级学习器。</li>
</ol>
</li>
</ol>
<h2 id="三种聚类⽅法"><a href="#三种聚类⽅法" class="headerlink" title="三种聚类⽅法"></a>三种聚类⽅法</h2><h3 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>定义：K-Means 是一种基于划分（partitioning）的聚类方法，其目标是将数据集划分为 K 个簇（cluster），使得每个数据点属于离它最近的簇中心（质心，centroid），并且所有数据点到其所属簇中心的距离平方和（即惯性，inertia 或 Within-Cluster Sum of Squares, WCSS）最小。</p>
</li>
<li><p>算法流程：</p>
<ol>
<li>随机选择 K 个初始质心。</li>
<li>将每个数据点分配给距离最近的质心，形成 K 个簇。</li>
<li>重新计算每个簇的质心（即簇中所有点的均值）。</li>
<li>重复步骤 2 和 3，直到质心不再发生显著变化或达到最大迭代次数。</li>
</ol>
</li>
<li><p>优点：</p>
<ul>
<li>简单、易于实现和理解。</li>
<li>计算效率较高，适合大规模数据。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>必须<strong>事先指定 K 值（簇的数量）</strong>。</p>
</li>
<li><p>对<strong>异常值敏感</strong>（异常点可能显著影响质心位置）。</p>
</li>
<li><p>只能发现<strong>凸形（通常是球形或类球形）的簇</strong>，对复杂形状的簇效果差。</p>
</li>
<li><p>对初始质心敏感，可能收敛到局部最优。</p>
</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>数据分布大致为<strong>球形或类球形的多个簇</strong>。</li>
<li>簇之间<strong>分离较好，且大小相近</strong>。</li>
<li>你知道（或可以合理猜测）<strong>簇的数量 K</strong>。</li>
<li>比如：客户分群、图像压缩、文档主题初步聚类等。</li>
</ul>
</li>
</ol>
<h4 id="处理非球形簇的问题"><a href="#处理非球形簇的问题" class="headerlink" title="处理非球形簇的问题"></a>处理非球形簇的问题</h4><ol>
<li>K-Means 的核心假设之一是：簇是凸的（通常是球形或类球形），且簇的密度相对均匀。这个假设源于它使用均值作为簇的中心，并通过最小化点到簇中心的距离来进行分配。</li>
<li>问题具体表现：<ol>
<li>对非球形簇（如环形、月牙形、L形等）效果差K-Means 倾向于将簇的中心放在“中间位置”，并通过距离（通常是欧氏距离）分配样本。如果真实簇的形状是非球形的（例如数据点分布在一个环上），K-Means 很可能会在环的内部找一个“中心点”作为质心，导致环上的点被错误地划分到多个簇，或者都归到一个错误的中心。</li>
<li>依赖欧氏距离的局限性K-Means 默认使用欧氏距离来衡量数据点与质心的远近，这种距离度量对于方向性强的分布或复杂几何形态并不敏感，它更适合各向同性的、对称分布的数据。</li>
<li>无法发现具有复杂内部结构的簇如果某些簇是嵌套的、有洞的、或者呈流形分布，K-Means 无法有效捕捉这些结构。</li>
</ol>
</li>
</ol>
<h3 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h3><ol>
<li><p>基本思想：</p>
<ol>
<li><p>DBSCAN 是一种<strong>基于密度的聚类算法</strong>，它认为<strong>簇是由密度相连的数据点组成的区域，而低密度区域中的点是噪声（outliers）</strong>。</p>
<p>核心概念：</p>
<ul>
<li><strong>ε (eps)：邻域半径</strong></li>
<li><strong>MinPts：形成一个簇所需的最小邻域点数</strong></li>
</ul>
<p>一个点被认为是<strong>核心点（core point）</strong>，如果它的 ε 邻域内至少包含 MinPts 个点（包括自己）。通过核心点的“密度可达”关系，可以将相互密度连接的点聚集为一个簇。</p>
</li>
</ol>
</li>
<li><p>优点：</p>
<ul>
<li><strong>不需要预先指定簇的数量</strong>。</li>
<li>能发现<strong>任意形状的簇</strong>（如非球形、环形等）。</li>
<li>能识别并剔除<strong>噪声点（outliers）</strong>。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>对参数 <strong>ε 和 MinPts 敏感</strong>，参数选择不当会影响聚类效果。</li>
<li>对于<strong>密度差异较大的数据集效果不佳</strong>（即不同簇的密度相差悬殊时难以处理）。</li>
<li>当数据维度很高时（高维数据），密度定义变得模糊（“维度灾难”）。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>簇的形状<strong>不规则、非球形</strong>。</li>
<li>数据中含有噪声或离群点，希望算法能自动识别并排除。</li>
<li>不知道簇的数量，或者簇的密度相对均匀。</li>
<li>比如：地理信息聚类（如城市中密集的商铺）、异常检测、社交网络中的社区发现等。</li>
</ul>
</li>
</ol>
<h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><ol>
<li><p>基本思想：<img src="D:\All_of_mine\大学\学习\大三上\大数据分析\hw\hw6\src\层次聚类树状图.png" alt="层次聚类树状图"></p>
<p>层次聚类是一种基于数据点间相似性（或距离）构建树状结构的聚类方法。它分为两种主要类型：</p>
<ul>
<li>凝聚式（Agglomerative，自底向上）：每个点初始为一个簇，逐步合并最相似的簇，直到满足停止条件（如只剩一个簇，或达到指定的簇数）。</li>
<li>分裂式（Divisive，自顶向下）：从所有数据点作为一个簇开始，逐步分裂为更小的簇。</li>
</ul>
<p>常用的是凝聚式层次聚类。</p>
<p>在每一步，算法根据某种距离度量（如欧氏距离、曼哈顿距离）和连接标准（如单连接、全连接、平均连接、Ward等）来决定哪些簇应该合并。</p>
<pre><code> 1. 单链接：两个簇之间的距离 = 两个簇中最近的两个数据点之间的距离（即最小距离）
 2. 全连接：两个簇之间的距离 = 两个簇中最远的两个数据点之间的距离（即最大距离）
 3. Ward：Ward 方法不是直接定义两个簇之间的距离，而是定义：合并两个簇后，总体 类内方差（intra-cluster variance） 的增量（或者说增加的平方误差）最小。换句话说，Ward 方法在每一步选择：合并后使得 所有点到其簇中心的平方距离之和（SSE）增加最小的那两个簇进行合并。
</code></pre>
</li>
<li><p>优点：</p>
<ul>
<li>不需要预先指定簇的数量（但可以依据树状图后期决定）。</li>
<li>可以生成层次化的聚类结果，便于分析和可视化（比如画出树状图 dendrogram）。</li>
<li>对于小规模数据效果不错，解释性强。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>计算复杂度高，不适合大规模数据集（时间复杂度通常为 O(n^3) 或优化后 O(n^2)）。</li>
<li>一旦合并或分裂，无法撤销，缺乏灵活性。</li>
<li>对噪声和异常值较为敏感。</li>
<li>对高维数据的距离度量可能失效（维度灾难）。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>数据量不是特别大，希望探索数据的层次结构。</li>
<li>想要直观地通过树状图分析不同层次的聚类情况。</li>
<li>比如：基因表达数据分析、组织结构分析、文档主题的层级归纳等。</li>
</ul>
</li>
</ol>
<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol>
<li>一句话理解：找到那些**最能代表数据分布方向（即数据变化最大的方向）**的轴（主成分），然后把数据投影到这些方向上，从而用更少的维度表示数据的大部分信息。</li>
<li>这些新的维度（主成分）是彼此正交（不相关）的；</li>
<li>第一个主成分方向是数据方差最大的方向，第二个主成分是在与第一个正交的方向上方差最大的，依此类推</li>
</ol>
<h3 id="协方差矩阵的作用"><a href="#协方差矩阵的作用" class="headerlink" title="协方差矩阵的作用"></a>协方差矩阵的作用</h3><ol>
<li><p>概念：</p>
<ol>
<li><strong>方差</strong>：反映了单个特征（维度）上的数据分布范围，即该维度上的数据变化程度。方差越大，说明该方向上的信息越多。</li>
<li><strong>协方差</strong>：反映了两个不同特征之间的变化趋势是否一致。如果协方差为正，说明两者倾向于同时增大或减小；为负则相反；接近零则说明几乎不相关。</li>
<li><strong>协方差矩阵</strong>：<ul>
<li><strong>对角线元素</strong>：是每个特征的<strong>方差</strong>（即该特征自身的变化幅度）；</li>
<li><strong>非对角线元素</strong>：是<strong>不同特征之间的协方差</strong>（反映特征之间的相关性）。</li>
</ul>
</li>
</ol>
</li>
<li><p>如何发挥作用</p>
<ol>
<li><p>协方差矩阵的特征值和特征向量，决定了主成分的方向和重要性：</p>
<ul>
<li>对协方差矩阵 Σ 进行特征分解（Eigendecomposition）：<br>$$<br>Σ&#x3D;VΛV^T<br>$$</li>
</ul>
</li>
</ol>
<p>其中：</p>
<ul>
<li>Λ 是对角矩阵，对角线上的元素是特征值（λ₁, λ₂, …, λ_d），代表每个主成分方向上的方差大小</li>
<li>V 的列是对应的特征向量，代表主成分的方向（即新的坐标轴方向）</li>
</ul>
<ol>
<li>特征值越大，说明对应的主成分方向上数据方差越大，信息量越丰富；</li>
<li>我们按照特征值从大到小排序，选择前 k 个最大的特征值对应的特征向量，作为新的 k 维空间的基，将数据投影过去，就实现了降维。</li>
</ol>
</li>
</ol>
<h2 id="SMOTE缓解不平衡问题"><a href="#SMOTE缓解不平衡问题" class="headerlink" title="SMOTE缓解不平衡问题"></a>SMOTE缓解不平衡问题</h2><ol>
<li><p>核心思想：</p>
<ol>
<li>SMOTE 是一种数据层面的方法，用于解决少数类样本不足的问题。</li>
<li>通过对少数类样本进行“人工合成”，生成一些新的、合理的少数类样本，从而增加少数类的样本数量，缓解类别不平衡。</li>
<li>它不是简单地复制少数类样本（那样容易导致过拟合），而是基于现有少数类样本的特征，合成“看起来合理”的新样本。</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>假设我们有一个少数类的样本点 $x_i$，SMOTE 的操作步骤大致如下：</p>
<ol>
<li>选择一个少数类样本点$x_i$；</li>
<li>计算该样本在少数类样本集中的 K 个最近邻（通常 K&#x3D;5）；</li>
<li>从这 K 个近邻中随机选择一个样本点 $x_{nn}$ ；</li>
<li>在$x_i$和 $x_{nn}$ 之间的连线上，随机选择一个位置，合成一个新的样本点：</li>
</ol>
<p>$$<br>x_{new}&#x3D;x_i+rand(0,1)×(x_{nn}−x_i)<br>$$</p>
<ul>
<li>这个公式的意思是：在特征空间中，在少数类样本$x_i$和$x_{nn}$之间的“线段”上，随机插值生成一个新的样本点，这个点看起来像是这两个真实样本的“混合体”，是合理的“人造”样本。</li>
</ul>
<ol start="5">
<li>重复上述过程，为少数类生成足够多的新样本，使其数量接近或达到多数类的水平（或设定的平衡比例）。</li>
</ol>
</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li>有效增加少数类样本数量，缓解类别不平衡</li>
<li>生成的新样本是基于真实数据的插值，比单纯复制样本更有效、更不容易导致过拟合</li>
<li>简单易实现，是处理类别不平衡问题的经典方法之一</li>
<li>可以与欠采样（如随机删除部分多数类样本）等方法联合使用，效果更佳</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>仅适用于数值型特征数据（因为需要在特征空间中进行插值），对于类别型变量不适用，需要额外处理；</li>
<li>合成样本仍然是“人造”的，如果少数类样本本身很少或噪声较多，生成的新样本可能不太合理，有一定过拟合风险；</li>
<li>SMOTE 是在原始特征空间中操作的，如果特征维度很高，合成样本的代表性可能下降（可考虑先降维）；</li>
<li>它只解决训练集中的不平衡问题，不会改变测试集的分布，测试时仍需使用真实分布评估模型效果</li>
</ol>
</li>
</ol>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li><p>定义</p>
<ol>
<li>感知机是一种最简单的前馈神经网络模型，属于单层二分类线性模型，它是现代神经网络和深度学习的最基础组成单元之一。</li>
</ol>
</li>
<li><p>目标：</p>
<ol>
<li>给定一组输入特征，感知机通过一个线性函数对输入进行加权求和，然后通过一个激活函数（通常是阶跃函数）输出一个类别标签，用于解决二分类问题。</li>
</ol>
</li>
<li><p>基本结构</p>
<ol>
<li><p>设有一个样本的特征向量为：<br>$$<br>x&#x3D;[x1,x2,…,xn]（n维输入）<br>$$</p>
</li>
<li><p>感知机模型通过一组<strong>权重</strong> <em>w</em>1,<em>w</em>2,…,<em>w**n</em>和一个<strong>偏置项</strong> <em>b</em>，对输入进行<strong>线性组合</strong>：<br>$$<br>z&#x3D;w_1x_1+w_2x_2+⋯+w_nx_n+b&#x3D;W^TX+b<br>$$</p>
</li>
<li><p>然后，通过一个**激活函数（如阶跃函数 &#x2F; sign 函数）**进行二元分类决策：<br>$$<br>y&#x3D;\left{<br>         \begin{array}{<strong>lr</strong>}<br>         +1, \ \ 如果 z≥0,  &amp; \<br>         -1, \ \ 如果 z&lt;0,  &amp;<br>         \end{array}<br>\right. 或有时定义为 y&#x3D;sign(z)<br>$$</p>
</li>
</ol>
</li>
<li><p>训练过程</p>
<ol>
<li>感知机通过迭代的方式调整权重 w和偏置 b，使得模型能够正确分类训练数据。</li>
</ol>
</li>
</ol>
<h3 id="单层感知机无法解决-XOR（异或）问题"><a href="#单层感知机无法解决-XOR（异或）问题" class="headerlink" title="单层感知机无法解决 XOR（异或）问题"></a>单层感知机无法解决 XOR（异或）问题</h3><ol>
<li><p>问题描述</p>
<ol>
<li>单层感知机本质是一个线性模型，它只能学习线性决策边界（一条直线&#x2F;一个超平面），而 XOR 是一个非线性可分问题，所以单层感知机无法找到一个线性超平面将两类样本正确分开。</li>
</ol>
</li>
<li><p>解决策略</p>
<ol>
<li><strong>使用多层感知机（Multi-Layer Perceptron, MLP），即神经网络</strong></li>
<li>隐藏层引入非线性变换，使网络可学习复杂的非线性决策边界，从而解决 XOR</li>
</ol>
</li>
<li></li>
</ol>
<h2 id="反向传播神经⽹络"><a href="#反向传播神经⽹络" class="headerlink" title="反向传播神经⽹络"></a>反向传播神经⽹络</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li><strong>它并不是具体的神经网络类型，而是一种训练算法。</strong></li>
<li><strong>BP 神经网络（Backpropagation Neural Network，反向传播神经网络）</strong>。BP 神经网络是一种<strong>多层前馈神经网络</strong>，它通过<strong>有监督学习</strong>的方式进行训练，即给定输入和对应的正确输出（标签），网络通过不断调整内部参数（权重和偏置），使得输出尽可能接近真实值。</li>
<li>一句话解释核心：<strong>利用“前向传播”计算输出，再通过“反向传播”将误差逐层传回，并基于梯度下降法更新网络参数，从而逐步优化模型。</strong></li>
</ol>
<h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><ol>
<li><p>目的：根据当前的网络参数（权重和偏置），将输入数据逐层向前计算，最终得到网络的输出预测值。</p>
</li>
<li><p>一句话总结：<strong>前向传播就是：从输入层开始，逐层计算加权和（线性变换），再经过激活函数（非线性变换），最终得到网络输出的过程。这个过程只用到了当前的参数，不涉及任何更新。</strong></p>
</li>
<li><p>过程（以三层网络为例：输入层 → 隐藏层 → 输出层）：</p>
<ol>
<li><p>假设：</p>
<ul>
<li>输入层有 <em>n</em>个神经元，输入向量为：<strong>x</strong>&#x3D;[<em>x</em>1,<em>x</em>2,…,<em>x**n</em>]<em>T</em></li>
<li>隐藏层有 <em>m</em>个神经元</li>
<li>输出层有 <em>k</em>个神经元（对应分类或回归任务的输出）</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li><p>输入层 → 隐藏层</p>
<ol>
<li><p>每个隐藏层神经元接收来自所有输入层神经元的加权输入，并加上偏置，然后通过激活函数输出。</p>
</li>
<li><p>设：</p>
<ol>
<li>输入到隐藏层的权重矩阵为：<strong>W</strong>(1)∈R<em>m</em>×<em>n</em></li>
<li>隐藏层偏置向量：<strong>b</strong>(1)∈R<em>m</em></li>
<li>激活函数：如 Sigmoid、ReLU、Tanh，记为 <em>σ</em></li>
</ol>
</li>
<li><p>则隐藏层的**加权输入（净输入）**为：<br>$$<br>z^{(1)}&#x3D;W^{(1)}x+b^{(1)}<br>$$</p>
</li>
<li><p>隐藏层的**输出（激活值）**为：<br>$$<br>h&#x3D;σ(z^{(1)})<br>$$</p>
</li>
</ol>
</li>
<li><p>隐藏层 → 输出层</p>
<ol>
<li><p>类似地，输出层接收来自隐藏层的输出，再次进行加权求和 + 偏置 + 激活函数</p>
</li>
<li><p>设：</p>
<ul>
<li><p>隐藏到输出的权重矩阵：<strong>W</strong>(2)∈R<em>k</em>×<em>m</em></p>
</li>
<li><p>输出层偏置：<strong>b</strong>(2)∈R<em>k</em></p>
</li>
<li><p>输出层激活函数可能根据任务而定（比如分类用 Sigmoid &#x2F; Softmax，回归可能不用或用线性）</p>
</li>
</ul>
</li>
<li><p>输出层的净输入：<br>$$<br>z^{(2)}&#x3D;W^{(2)}x+b^{(2)}<br>$$</p>
</li>
<li><p>输出层的最终输出（预测值）：<br>$$<br>ypred&#x3D;f(z^{(2)})（比如用 Sigmoid 或 Softmax）<br>$$</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><ol>
<li><p>目的：通过计算预测输出与真实标签之间的<strong>误差</strong>，然后<strong>将该误差从输出层反向传播至每一层</strong>，从而计算出<strong>每一层参数（权重和偏置）的梯度</strong>，为参数更新提供依据。</p>
</li>
<li><p>一句话总结：这个过程会对<strong>每一层的所有权重和偏置</strong>都进行更新，从而一步步让网络的输出逼近真实值。</p>
</li>
<li><p>基本流程：</p>
<ol>
<li><p><strong>计算损失函数（Loss Function）</strong></p>
<ol>
<li><p>假设我们使用均方误差（MSE，回归）或交叉熵损失（Cross Entropy，分类）</p>
</li>
<li><p>这个损失函数反映了当前输出与真实值之间的差距，是我们优化的目标。</p>
</li>
</ol>
</li>
<li><p><strong>反向传播：从输出层开始，逐层回传误差并计算梯度</strong></p>
<ol>
<li><p>我们采用**链式法则（Chain Rule）**来计算损失函数对每一层参数（权重和偏置）的偏导数（即梯度）。</p>
</li>
<li><p>计算输出层的误差</p>
</li>
<li><p>根据输出层误差，计算隐藏层的误差。依次倒推</p>
</li>
<li><p>计算梯度（对参数的偏导数）</p>
<ol>
<li>这些梯度告诉我们：<strong>当权重或偏置发生微小变化时，损失函数会如何变化。</strong></li>
</ol>
</li>
</ol>
</li>
<li><p><strong>参数更新（Gradient Descent）</strong></p>
<ol>
<li>得到梯度后，我们使用**梯度下降法（或其变种，如 SGD、Adam 等）**来更新参数：</li>
<li>这个过程会对<strong>每一层的所有权重和偏置</strong>都进行更新，从而一步步让网络的输出逼近真实值。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="三大深度神经网络"><a href="#三大深度神经网络" class="headerlink" title="三大深度神经网络"></a>三大深度神经网络</h2><h3 id="前馈神经网络（Feedforward-Neural-Network-FNN）"><a href="#前馈神经网络（Feedforward-Neural-Network-FNN）" class="headerlink" title="前馈神经网络（Feedforward Neural Network, FNN）"></a>前馈神经网络（Feedforward Neural Network, FNN）</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ol>
<li>前馈神经网络是最简单、最基础的神经网络类型，也是其他复杂网络的基础。在 FNN 中，信息<strong>只沿着一个方向传播</strong>（从输入层 → 隐藏层 → 输出层），<strong>没有反馈或循环连接</strong>。</li>
<li>特点：<ol>
<li>每一层中的神经元与下一层的所有神经元相连接（全连接），称为<strong>全连接层（Dense Layer&#x2F;FC Layer）</strong>；</li>
<li>数据流向是单向的，没有循环或记忆功能；</li>
<li>通常使用激活函数引入非线性（如 ReLU、Sigmoid 等）。</li>
</ol>
</li>
<li>工作原理<ol>
<li>输入数据经过各层的加权求和与激活函数，逐层向前传播，最终在输出层得到预测结果；</li>
<li>通过<strong>反向传播算法</strong>和<strong>梯度下降</strong>等方法优化网络参数，最小化损失函数。</li>
</ol>
</li>
</ol>
<h3 id="卷积神经网络（Convolutional-Neural-Network-CNN）"><a href="#卷积神经网络（Convolutional-Neural-Network-CNN）" class="headerlink" title="卷积神经网络（Convolutional Neural Network, CNN）"></a>卷积神经网络（Convolutional Neural Network, CNN）</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ol>
<li>卷积神经网络是专门为处理具有<strong>网格状拓扑结构的数据</strong>（如图像、视频）而设计的一种神经网络。它通过<strong>局部感知、权值共享、下采样</strong>等机制，大幅减少了参数数量，同时能够有效提取空间特征。</li>
<li>结构特点<ol>
<li><strong>卷积核</strong>：在卷积神经网络中，<strong>卷积核（也称为滤波器、过滤器）是一个小的矩阵（比如 3×3、5×5 等）</strong>，它是网络中可学习的参数，用来对输入数据（通常是图像）的局部区域进行<strong>卷积运算（Convolution Operation）</strong>，从而提取某种特定的<strong>局部特征</strong>。</li>
<li><strong>卷积层（Convolutional Layer）</strong>：使用一组可学习的滤波器（卷积核）对输入数据进行<strong>局部区域卷积操作</strong>，提取局部特征（如边缘、纹理）；权值共享：同一个卷积核在整个图像上滑动使用，减少参数量；输出称为<strong>特征图（Feature Map）</strong>。</li>
<li><strong>激活函数层</strong>（如 ReLU）：引入非线性。</li>
<li><strong>池化层（Pooling Layer）</strong>：通常是最大池化（Max Pooling）或平均池化（Average Pooling）；降低特征图的空间尺寸，减少计算量，增强特征不变性。</li>
<li><strong>全连接层（Fully Connected Layer）</strong>：将提取到的高级特征进行整合，用于最终分类或回归。</li>
</ol>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><p>通过卷积操作提取<strong>局部特征</strong>，通过<strong>池化</strong>逐步<strong>降维</strong>并保留重要信息；</p>
<ol>
<li>卷积核如何工作？<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251018140124542.png" alt="image-20251018140124542"></li>
<li>卷积核的参数（权重）是<strong>可学习</strong>的，训练过程中自动调整以提取对任务最有用的特征；</li>
<li><strong>参数共享</strong>：同一个卷积核在整个图像上滑动使用，大大减少参数数量；</li>
<li>可以有多个卷积核（如 32 个、64 个），每个提取不同的特征，生成多个特征图。</li>
</ol>
</li>
<li><p>通道</p>
<ol>
<li>可以理解为，某个点的多维度信息。比如在图片中，一个像素点的信息包含RGB三个维度（三种颜色）的信息，所以通道数为三。</li>
<li>抽象的，这个维度可以更高。</li>
</ol>
</li>
<li><p>池化</p>
<ol>
<li>对特征图进行<strong>降采样（Downsampling）</strong>，减少数据维度，降低计算量，同时增强特征的<strong>平移、缩放、旋转的鲁棒性</strong>。</li>
<li>通常在卷积层之后使用，每隔一定区域取一个代表性值。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251018140704218.png" alt="image-20251018140704218"></li>
<li>常见池化方式：<ol>
<li><strong>最大池化（Max Pooling）</strong>：取区域内最大值，最常用</li>
<li><strong>平均池化（Average Pooling）</strong>：取区域内平均值</li>
<li></li>
<li><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><strong>最大池化（Max Pooling）</strong></th>
<th align="left"><strong>平均池化（Average Pooling）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作</strong></td>
<td align="left">取窗口内<strong>最大值</strong></td>
<td align="left">取窗口内<strong>平均值</strong></td>
</tr>
<tr>
<td align="left"><strong>关注点</strong></td>
<td align="left">突出<strong>最显著、最强的特征</strong>（比如边缘、激活）</td>
<td align="left">反映<strong>整体区域的平均信息</strong></td>
</tr>
<tr>
<td align="left"><strong>对噪声的鲁棒性</strong></td>
<td align="left">较强（不受个别噪点影响）</td>
<td align="left">一般（会被平均稀释）</td>
</tr>
<tr>
<td align="left"><strong>特征保留能力</strong></td>
<td align="left">更好保留<strong>显著特征、纹理、轮廓</strong></td>
<td align="left">更强调<strong>整体分布、背景信息</strong></td>
</tr>
<tr>
<td align="left"><strong>常用场景</strong></td>
<td align="left"><strong>图像分类、检测任务（主流选择）</strong></td>
<td align="left"><strong>某些回归任务、全卷积网络等</strong></td>
</tr>
<tr>
<td align="left"><strong>效果倾向</strong></td>
<td align="left">特征更尖锐、显著</td>
<td align="left">特征更平滑、稳定</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
<li><p>最终通过全连接层进行决策（如分类）；</p>
<ol>
<li>展平：把卷积得到的所有特征图转化为一维向量，将空间特征转换为全连接网络可处理的格式</li>
<li>全连接：把展平后的特征向量输入到全连接神经网络中，将学到的分布式特征表示映射到样本的类别得分或回归值。</li>
</ol>
</li>
<li><p>同样采用反向传播与梯度下降优化参数。</p>
</li>
</ol>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入图像（H×W×C）</span><br><span class="line">       ↓</span><br><span class="line">[卷积层] → 提取局部特征 → 生成特征图</span><br><span class="line">       ↓</span><br><span class="line">[激活函数 e.g. ReLU] → 引入非线性</span><br><span class="line">       ↓</span><br><span class="line">[池化层] → 降维，减少计算（如 Max Pooling）</span><br><span class="line">       ↓</span><br><span class="line">（重复多个 [卷积 → 激活 → 池化] 的组合）</span><br><span class="line">       ↓</span><br><span class="line">[展平层] → 将多维特征图展平为一维向量</span><br><span class="line">       ↓</span><br><span class="line">[全连接层] → 整合所有特征，用于分类/回归</span><br><span class="line">       ↓</span><br><span class="line">[输出层] → 输出预测结果（如类别概率）</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="循环神经网络（Recurrent-Neural-Network-RNN）"><a href="#循环神经网络（Recurrent-Neural-Network-RNN）" class="headerlink" title="循环神经网络（Recurrent Neural Network, RNN）"></a>循环神经网络（Recurrent Neural Network, RNN）</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>循环神经网络是一类专门用于处理<strong>序列数据（如时间序列、文本、语音）<strong>的神经网络。与 FNN 不同，RNN 具有</strong>记忆能力</strong>，能够利用之前的信息影响当前的输出，因此适合处理有前后依赖关系的数据。</p>
</li>
<li><p>结构特点：</p>
</li>
</ol>
<ul>
<li><p>RNN 的关键特点是：<strong>神经元之间存在循环连接（反馈连接）</strong>，使得网络具有“记忆”前一时刻信息的能力；</p>
</li>
<li><p>在每一时间步，RNN 接收当前输入和上一时刻的隐状态，输出当前隐状态和（可能的）输出；</p>
</li>
<li><p>数学上，RNN 的隐状态更新公式大致为：$h_t$&#x3D;<em>f</em>(<em>W<strong>h</strong>h**t</em>−1+<em>W**x</em>$x_t$+<em>b</em>)<br>$$<br>h_t&#x3D;f(W_hh_{t-1}+W_xx_t+b)<br>$$</p>
</li>
</ul>
<p>   其中 $h_t$是当前时刻的隐状态，$x_t$是当前输入，$h_t$−1是上一时刻的隐状态。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><p>循环结构（核心机制）</p>
<ul>
<li>RNN 在每一时间步接收两个输入：当前时刻的输入数据（比如一个词、一个时间点的数值）上一时刻的隐藏状态（即之前积累的信息）</li>
<li>然后通过一个循环计算单元，输出：当前时刻的隐藏状态（新的记忆）当前时刻的输出（可以是预测、分类等）</li>
</ul>
<p> 这个过程在时间上是重复展开的（unrolled），形成对整个序列的处理。</p>
</li>
<li><p>标准 RNN 在处理<strong>长序列</strong>时，往往会遇到<strong>梯度消失或梯度爆炸</strong>，导致难以学到远距离的依赖关系。</p>
<ol>
<li><p>为什么在RNN强调，在FNN和CNN力却不提及？</p>
<ol>
<li>反向传播时逐层计算的，在FNN和CNN中，每一层计算的参数不多</li>
<li>但是RNN在序列上延伸，每一步是串联起来的，在反向传播时会连乘，参数越来越多。</li>
</ol>
</li>
<li><p>梯度消失</p>
<ol>
<li>定义：在反向传播过程中，梯度随着网络层数的增加变得越来越小，趋近于 0，导致深层网络的参数几乎得不到更新，模型学不动了，训练停滞。</li>
<li>原因：在反向传播中，梯度是从输出层逐层反向传播到输入层的，每一层的梯度是通过链式法则相乘得到的。如果这些连乘的因子中，有很多<strong>小于 1 的数</strong>（比如激活函数导数接近 0，或权重初始化过小），那么随着层数增多，梯度就会<strong>指数级地变小</strong>，最终趋近于 0。</li>
</ol>
</li>
<li><p>梯度爆炸</p>
<ol>
<li>定义：在反向传播过程中，梯度值变得非常大，甚至无限增长（溢出），导致参数更新幅度过大，模型无法收敛，损失函数震荡甚至发散。</li>
<li>原因：和梯度消失类似，连乘的因子中，有很多<strong>大于 1 的数</strong>，那么随着层数或时间步的增加，梯度就会<strong>指数级地变大</strong>，导致数值溢出或参数更新过大。</li>
</ol>
</li>
<li><p>解决策略：使用优化后的循环模型</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>LSTM（长短期记忆网络）</strong></td>
<td align="left">通过<strong>门控机制（输入门、遗忘门、输出门）</strong>，有选择地记住或遗忘信息，能很好地捕捉长距离依赖，缓解梯度消失.</td>
</tr>
<tr>
<td align="left"><strong>GRU（门控循环单元）</strong></td>
<td align="left">LSTM 的简化版，效果相当但参数更少，同样能缓解梯度问题</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入序列</span><br><span class="line">↓</span><br><span class="line">[循环层（RNN层）] → 融合当前输入与上一时刻记忆，计算当前隐藏状态</span><br><span class="line">↓</span><br><span class="line">[激活函数 e.g. Tanh] → 引入非线性变换（将线性组合通过 tanh 压缩到 [-1, 1]，增强表达能力）</span><br><span class="line">↓</span><br><span class="line">（可选）[输出层] → 根据当前隐藏状态生成当前时刻输出（如 y_t）（例如：y_t=softmax(Vh_t+c)，用于分类或预测）→ 每个时间步可输出，也可只在最后输出</span><br><span class="line">↓</span><br><span class="line">（重复多个 [循环 → 激活 → (输出)] 的组合）依次处理x_1到 x_T，得到 h_1,...,h _T）</span><br><span class="line">↓</span><br><span class="line">[展平或直接使用隐藏状态]（可以选择使用所有隐藏状态，或仅使用最后一个h_T作为整个序列的表示）</span><br><span class="line">↓</span><br><span class="line">[全连接层（可选）] → 整合序列信息，用于最终决策（例如将h_T映射到类别空间，用于分类任务）</span><br><span class="line">↓</span><br><span class="line">[输出层] → 输出最终预测结果（如：类别概率、数值预测、序列标签等）</span><br></pre></td></tr></table></figure>

<h4 id="LSTM长短期记忆网络"><a href="#LSTM长短期记忆网络" class="headerlink" title="LSTM长短期记忆网络"></a>LSTM长短期记忆网络</h4><ol>
<li><p>核心思想</p>
<ol>
<li>LSTM 是一种特殊的 RNN，它在每个时间步不仅维护一个隐藏状态（hidden state），还维护一个<strong>细胞状态（cell state）</strong>，后者可以看作是网络的“长期记忆”。LSTM 通过引入<strong>三个门结构</strong>：<strong>遗忘门（Forget Gate）、输入门（Input Gate）、输出门（Output Gate）</strong>，来控制信息的保留、更新和输出，从而有效地学习长期依赖关系</li>
</ol>
</li>
<li><p>LSTM 的基本结构与变量说明</p>
<ol>
<li>在每个时间步 t，LSTM 接收当前输入 $x_t$和上一时间步的隐藏状态 $h_{t-1}$，并操作以下主要变量：<ol>
<li><strong>隐藏状态（Hidden State）</strong>：$h_t$，用于传递信息到下一个时间步或输出层。</li>
<li><strong>细胞状态（Cell State）</strong>：$C_t$，相当于“记忆单元”，贯穿整个序列，承载长期信息。</li>
<li><strong>三个门控向量（都是通过 sigmoid 函数输出 0~1 的值，用于控制信息流）</strong>：<ol>
<li>遗忘门（Forget Gate）：决定丢弃细胞状态中的哪些信息。</li>
<li>输入门（Input Gate）：决定哪些新信息需要写入细胞状态。</li>
<li>输出门（Output Gate）：决定当前隐藏状态的输出内容。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>基本工作原理</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121100949500.png" alt="image-20251121100949500"></p>
</li>
<li><p>为了实现记忆，引入了记忆元，并通过三个门控制记忆。遗忘门控制过去的记忆的记忆程度，输入门控制当前输入对候选记忆的影响，输出门控制“真正的”记忆元对现在状态H的影响</p>
</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>遗忘阶</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121102532474.png" alt="image-20251121102532474"></p>
</li>
<li><p>对上一阶段的记忆进行选择，选出重要的相关部分，遗忘无关信息</p>
</li>
<li><p>使用sigmoid函数激活，取值范围[0, 1]</p>
</li>
</ol>
</li>
<li><p>选择记忆阶段</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121102934942.png" alt="image-20251121102934942"></li>
<li>对当前时刻的信息进行筛选，选出重要的部分添加到记忆中</li>
<li>使用sigmoid函数激活，取值范围[0, 1]</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121103039608.png" alt="image-20251121103039608"></li>
<li>前两个阶段的输出相加，就得到了当前阶段的记忆</li>
</ol>
</li>
<li><p>输出状态</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121103205331.png" alt="image-20251121103205331"></p>
</li>
<li><p>记忆元先通过tanh函数缩放到[-1, 1]，然后和输出门逐元素相乘</p>
</li>
<li><p>输出门越大，记忆元中的信息就会越多的保存到当前隐藏层输出中</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>LSTM 中的各个门及其作用详解</p>
<ol>
<li>遗忘门（Forget Gate）<ol>
<li><strong>作用：</strong> 控制上一时间步的细胞状态 <em>C**t</em>−1中的哪些信息需要被遗忘（即丢弃）。</li>
<li><strong>公式：</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251120212439270.png" alt="image-20251120212439270"></li>
</ol>
</li>
</ol>
<p><strong>解释：</strong></p>
<p>如果 <em>f**t</em>接近 0，表示遗忘该信息；接近 1 则表示保留。它决定了细胞状态 <em>C**t</em>−1中的哪些内容应该被保留到当前时间步。</p>
<hr>
<ol start="2">
<li>输入门（Input Gate）<ol>
<li><strong>作用：</strong> 决定哪些<strong>新信息</strong>需要被加入到细胞状态中，即控制新内容的写入。</li>
<li><strong>公式分为两部分：</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251120212509500.png" alt="image-20251120212509500"></li>
</ol>
</li>
</ol>
<p><strong>解释：</strong></p>
<p>输入门与候选状态共同作用，决定哪些新信息被存储进细胞状态，实现“记忆更新”。</p>
<hr>
<ol start="3">
<li>输出门（Output Gate）<ol>
<li><strong>作用：</strong> 控制当前时间步的**隐藏状态 *h**t***（即输出给下一层或下一时间步的内容），它基于当前的细胞状态，但经过筛选。</li>
</ol>
</li>
</ol>
<p><strong>公式：</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251120212558392.png" alt="image-20251120212558392"></p>
<p><strong>解释：</strong></p>
<p>输出门控制了当前细胞状态中有多少信息被暴露或传递出去，从而影响后续时间步的决策。</p>
<hr>
<ol start="4">
<li>LSTM 总结：门的作用回顾</li>
</ol>
<table>
<thead>
<tr>
<th align="left">门名称</th>
<th align="left">控制目标</th>
<th align="left">作用简述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">遗忘门</td>
<td align="left">细胞状态中的旧信息</td>
<td align="left">决定哪些历史信息需要丢弃，解决“记忆污染”问题</td>
</tr>
<tr>
<td align="left">输入门</td>
<td align="left">新的候选信息</td>
<td align="left">决定哪些新信息需要被添加到记忆中，更新细胞状态</td>
</tr>
<tr>
<td align="left">输出门</td>
<td align="left">当前隐藏状态（输出内容）</td>
<td align="left">决定当前细胞状态中哪些信息作为输出传递给下一层</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="GRU门控循环单元"><a href="#GRU门控循环单元" class="headerlink" title="GRU门控循环单元"></a>GRU门控循环单元</h4><ol>
<li><p>是什么</p>
<ol>
<li>GRU 是 LSTM 的一种简化版本，由 Cho 等人于 2014 年提出。GRU 同样使用门控机制来控制信息的流动，但<strong>相比 LSTM，它合并了细胞状态和隐藏状态，同时只使用了两个门：重置门（Reset Gate）和更新门（Update Gate）</strong>，结构更简单，计算效率更高，在很多任务中表现与 LSTM 相当甚至更优。</li>
</ol>
</li>
<li><p>GRU 的基本结构与变量说明</p>
<p>GRU 在每个时间步也接收当前输入 <em>x**t</em>和上一时间步的隐藏状态 <em>h**t</em>−1，并引入以下两个门：</p>
<ul>
<li><strong>更新门（Update Gate）</strong>：决定保留多少旧信息，更新多少新信息（类似 LSTM 中遗忘门和输入门的组合）。</li>
<li><strong>重置门（Reset Gate）</strong>：决定如何将新的输入与历史状态结合起来，控制过去信息的“相关性”。</li>
</ul>
<p>此外，GRU <strong>没有独立的细胞状态</strong>，而是直接更新隐藏状态 <em>h**t</em>。</p>
</li>
<li><p>基本工作原理</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121104101413.png" alt="image-20251121104101413"></li>
<li>作为“简化版LSTM”，这里GRU只提出了两个门：重置门控制历史状态对当前输入的影响，更新门控制历史状态和候选信息对当前输出的影响。</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li>更新门<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121104557384.png" alt="image-20251121104557384"></li>
</ol>
</li>
</ol>
<p><strong>作用：</strong> 控制前一时间步的隐藏状态中有多少信息需要被“重置”或忽略，即决定如何将新输入与历史状态结合。</p>
<p><strong>公式：</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121100218626.png" alt="image-20251121100218626"></p>
<hr>
<p>（2）更新门（Update Gate）</p>
<p><strong>作用：</strong> 控制保留多少之前的隐藏状态（历史信息），以及更新多少新的候选状态（新信息）。</p>
<p><strong>公式：</strong></p>
<ul>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251121100248396.png" alt="image-20251121100248396"></li>
</ul>
<p><strong>解释：</strong></p>
<p>更新门实际上做了 LSTM 中“遗忘门 + 输入门”的一部分工作，通过控制新旧信息的融合比例，实现状态的更新。</p>
<hr>
<ol start="4">
<li>GRU 总结：门的作用回顾</li>
</ol>
<table>
<thead>
<tr>
<th align="left">门名称</th>
<th align="left">控制目标</th>
<th align="left">作用简述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重置门</td>
<td align="left">历史隐藏状态</td>
<td align="left">决定如何将新输入与过去状态结合，控制历史信息的贡献度</td>
</tr>
<tr>
<td align="left">更新门</td>
<td align="left">新旧隐藏状态的比例</td>
<td align="left">决定保留多少旧信息，更新多少新信息</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="BiLSTM双向长短期记忆网络"><a href="#BiLSTM双向长短期记忆网络" class="headerlink" title="BiLSTM双向长短期记忆网络"></a>BiLSTM双向长短期记忆网络</h4><ol>
<li><p>基本原理</p>
<ol>
<li>BiLSTM 是在 LSTM 基础上的一种扩展，其核心思想是：同时使用两个独立的 LSTM 层，一个按正向顺序处理序列，另一个按反向顺序处理序列，最后将两个方向的隐藏状态进行合并（通常是拼接），从而让每个时间步都能同时“看到”过去和未来的信息。</li>
<li>结构组成：<ul>
<li><strong>正向 LSTM</strong>：按 <em>t</em>&#x3D;1→2→⋯→<em>T</em>的顺序处理序列，得到正向隐藏状态序列 <em>h**t</em>。</li>
<li><strong>反向 LSTM</strong>：按 <em>t</em>&#x3D;<em>T</em>→<em>T</em>−1→⋯→1的顺序处理序列，得到反向隐藏状态序列 <em>h**t</em>。</li>
<li><strong>合并策略</strong>：通常将同一时间步的正向与反向隐藏状态进行<strong>拼接（concatenate）</strong>。这样，每个时间步的表示 <em>h**t</em>就包含了该位置的前后文信息。</li>
</ul>
</li>
</ol>
</li>
<li><p>与LSTM的对比</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">标准 RNN</th>
<th align="left">LSTM</th>
<th align="left">BiLSTM</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>梯度问题</strong></td>
<td align="left">容易出现梯度消失&#x2F;爆炸，难以学习长距离依赖</td>
<td align="left">通过门控机制与细胞状态，有效缓解梯度消失，擅长长序列建模</td>
<td align="left">同 LSTM，且能利用双向上下文</td>
</tr>
<tr>
<td align="left"><strong>记忆能力</strong></td>
<td align="left">几乎没有长期记忆能力</td>
<td align="left">通过细胞状态实现长期记忆的保存与更新</td>
<td align="left">同 LSTM，同时获取前后文信息</td>
</tr>
<tr>
<td align="left"><strong>信息利用</strong></td>
<td align="left">仅使用当前及之前的信息（单向）</td>
<td align="left">仅使用当前及之前的信息（单向）</td>
<td align="left">同时利用当前位置的前后文信息（双向）</td>
</tr>
<tr>
<td align="left"><strong>序列理解能力</strong></td>
<td align="left">弱，尤其对长文本、复杂依赖任务效果差</td>
<td align="left">强，适合处理长序列、复杂语义</td>
<td align="left">更强，对上下文语境敏感的任务效果显著提升</td>
</tr>
<tr>
<td align="left"><strong>应用效果</strong></td>
<td align="left">一般，逐渐被替代</td>
<td align="left">广泛用于各类序列任务</td>
<td align="left">在需要上下文信息的任务中表现尤为出色</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="Transformer-架构及其变体"><a href="#Transformer-架构及其变体" class="headerlink" title="Transformer 架构及其变体"></a>Transformer 架构及其变体</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><pre><code>1. 是什么
	1. 在现代深度学习，特别是自然语言处理（NLP）和序列建模任务中，**Transformer 架构及其变体**已经成为主流模型，比如 BERT、GPT、T5 等。这些模型虽然应用广泛，但它们的核心结构都可以归类为以下三种基本架构之一：
    	1. Encoder-only（仅编码器）结构
    	2. Decoder-only（仅解码器）结构
    	3. Encoder-Decoder（编码器-解码器）结构
	2. 这三种结构本质上都来源于 Transformer 模型，它们在组件构成、信息流动方式以及适用任务上有明显区别。理解它们的差异及适用场景，对于模型选型、任务设计和算法优化至关重要。
</code></pre>
<ol start="2">
<li>基本概念与结构来源<ol>
<li><strong>Encoder（编码器）</strong>：负责对输入序列进行编码，提取高层次语义表示，通常由多个相同的编码层堆叠而成，每层包含多头自注意力机制和前馈网络。</li>
<li><strong>Decoder（解码器）</strong>：负责根据编码器的输出（或部分信息）逐步生成目标序列，常用于生成式任务，也包含自注意力与交叉注意力机制。</li>
</ol>
</li>
</ol>
<h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><ul>
<li>Attention Is All You Need</li>
</ul>
<ol>
<li><p><strong>自注意力机制（Self-Attention）</strong> </p>
<ol>
<li><p>是一种让模型在处理一个序列（比如一句话）时，能够<strong>自动关注这个序列中其他相关部分</strong>的机制。</p>
</li>
<li><p>理解</p>
<ol>
<li><blockquote>
<p>当模型处理某个词时，它不仅仅看这个词本身，还会“看看”这句话里的其他词，找到和它最相关的信息，从而更好地理解这个词的含义。</p>
<p>.</p>
<p>比如说“书”一词，他可以指书本，也可以指《尚书》。单独作为一个词时，他有自己的嵌入向量。但是他可能注意到了上下文，知道了这里应该指书本，于是嵌入向量向书本的一方偏移。这个发现上下文含义的过程就是自注意力机制。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>掩码自注意力</strong></p>
<ol>
<li>在解码器生成token时，不能让解码器看到未来的词（就像看答案），他只能看到前面的词，并以此推理、生成token。否则就是“从答案出发”写过程了。</li>
</ol>
</li>
<li><p><strong>交叉注意力机制</strong></p>
<ol>
<li><p>是什么</p>
<ol>
<li><p>交叉注意力机制（Cross-Attention） 是注意力机制的一种扩展形式，它可以让一个序列（称为 Query）去关注另一个不同的序列（称为 Key 和 Value），从而实现两个序列之间的信息交互与融合。</p>
<p>简单来说：</p>
<blockquote>
<p>交叉注意力让一组 token（比如问题、目标语言）去“查询”另一组 token（比如上下文、源语言），从而获取与之相关的信息。</p>
</blockquote>
</li>
<li><p>它最常用于 Transformer 的 Encoder-Decoder 架构中，尤其是在机器翻译、文本摘要、对话系统等任务里，让解码器（Decoder）能够关注编码器（Encoder）的输出，实现从源序列到目标序列的信息传递。</p>
</li>
</ol>
</li>
<li><p>通俗解释</p>
<ol>
<li><p>假设我们在进行机器翻译，任务是把一句英文翻译成中文：</p>
<ul>
<li>Encoder（编码器）：处理输入的英文句子，得到一组表示（Key 和 Value）。</li>
<li>Decoder（解码器）：逐步生成中文翻译，每一步生成一个中文词。</li>
</ul>
</li>
<li><p>在生成每个中文词时，Decoder 不仅仅看已经生成的中文词（这部分用自注意力），还需要<strong>去看输入的英文句子，从中找到与当前要生成的中文词最相关的信息</strong>。 这时就需要用交叉注意力：</p>
<ul>
<li><strong>Query（查询）</strong>：来自 Decoder 当前要生成的词（或隐藏状态）→ 表示“我想知道什么”</li>
<li><strong>Key 和 Value（键与值）</strong>：来自 Encoder 的输出（即源语言句子的表示）→ 表示“有什么信息可供查询”</li>
</ul>
</li>
<li><p>模型会计算 Query 和 Key 的相似度，得到注意力权重，然后根据这些权重，从 Value（也就是 Encoder 的信息）中提取相关内容，帮助当前生成更准确。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Encoder-only（仅编码器）结构"><a href="#Encoder-only（仅编码器）结构" class="headerlink" title="Encoder-only（仅编码器）结构"></a>Encoder-only（仅编码器）结构</h3><ol>
<li><p>结构组成：</p>
<ul>
<li>只有 <strong>Encoder 部分</strong>，没有 Decoder。</li>
<li>输入一个序列，经过多层编码后，输出该序列的<strong>全局语义表示（上下文嵌入）</strong>。</li>
</ul>
</li>
<li><p>工作原理：</p>
<ul>
<li>输入序列通过 <strong>自注意力机制（Self-Attention）</strong> 捕捉内部各位置的关系。</li>
<li>最终输出的向量可用于表示整个输入序列的语义，常用于<strong>序列理解类任务</strong>。</li>
</ul>
</li>
<li><p>典型模型：</p>
<ul>
<li><strong>BERT</strong></li>
<li><strong>RoBERTa、ALBERT、DistilBERT</strong> 等基于 BERT 的改进模型</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>能充分理解输入序列的上下文语义。</li>
<li>适合<strong>不需要生成新内容，而是理解、判断、分类的任务</strong>。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>不能生成新序列</strong>，因为它没有解码器结构。</li>
</ul>
</li>
<li><p>适用场景</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>文本分类</strong></td>
<td align="left">判断文本的主题、情感、领域等</td>
<td align="left">情感分析、垃圾邮件识别</td>
</tr>
<tr>
<td align="left"><strong>命名实体识别（NER）</strong></td>
<td align="left">识别文本中具有特定意义的实体</td>
<td align="left">人名、地名、机构名抽取</td>
</tr>
<tr>
<td align="left"><strong>问答系统（QA）</strong></td>
<td align="left">给定上下文和问题，定位答案区间</td>
<td align="left">SQuAD 数据集任务</td>
</tr>
<tr>
<td align="left"><strong>句子&#x2F;文本匹配</strong></td>
<td align="left">判断两个句子是否语义相似、相关</td>
<td align="left">语义文本相似度（STS）、复述检测</td>
</tr>
<tr>
<td align="left"><strong>序列标注</strong></td>
<td align="left">对序列中每个 token 打标签</td>
<td align="left">POS 词性标注、槽位填充（Slot Filling）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="Decoder-only（仅解码器）结构"><a href="#Decoder-only（仅解码器）结构" class="headerlink" title="Decoder-only（仅解码器）结构"></a>Decoder-only（仅解码器）结构</h3><ol>
<li><p>结构组成：</p>
<ul>
<li><p>只有 <strong>Decoder 部分</strong>，没有 Encoder。</p>
</li>
<li><p>通常基于 <strong>掩码自注意力（Masked Self-Attention）</strong>，确保在生成当前 token 时，模型只能看到当前及之前的 token，不能“偷看”未来信息。</p>
</li>
</ul>
</li>
<li><p>工作原理：</p>
<ul>
<li><p>模型根据已经生成的 token 和可能的提示（prompt &#x2F; input），<strong>一步一步地预测下一个 token</strong>，适用于<strong>自回归式生成任务</strong>。</p>
</li>
<li><p>通过不断迭代，逐步生成完整的目标序列。</p>
</li>
</ul>
</li>
<li><p>典型模型：</p>
<ul>
<li><p><strong>GPT（Generative Pre-trained Transformer）系列</strong>：GPT、GPT-2、GPT-3、GPT-4、ChatGPT</p>
<blockquote>
<p>虽然 GPT 是 Decoder-only，<strong>但它仍然需要对输入（即你的提示词 &#x2F; Prompt）进行编码（Embedding）和上下文建模</strong>，只不过：</p>
<ul>
<li>它使用的是 Transformer 的 Decoder 结构，而不是 Encoder。</li>
<li>它对输入也进行<strong>Token 嵌入（Embedding） + 位置编码</strong>，和 Encoder 做的事情类似。</li>
<li>它使用的是 掩码自注意力（Masked Self-Attention），确保在处理第 i 个词时，只能看到第 1 到 i-1 个词（不能偷看后面）。</li>
</ul>
<p> <strong>也就是说：GPT 把你的提示词当作一个“序列”输入到 Decoder 中，通过自注意力机制对它们进行编码和理解，然后基于此生成后续内容。</strong></p>
<table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">答案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GPT 是不是不编码提示词？</td>
<td align="left">不是！它对提示词也进行了编码（嵌入 + 注意力），只是没有专门的 Encoder 模块。</td>
</tr>
<tr>
<td align="left">为什么是 Decoder-only？</td>
<td align="left">因为 GPT是生成式模型，只用 Decoder 就能同时完成“理解输入 + 生成输出”，不需要分离的 Encoder。</td>
</tr>
<tr>
<td align="left">它怎么理解我的输入（Prompt）？</td>
<td align="left">把输入当作一个序列，通过 Decoder 的自注意力机制进行编码和建模，再基于此生成后续内容。</td>
</tr>
<tr>
<td align="left">为什么不用 Encoder-Decoder？</td>
<td align="left">为了简化结构、提升效率、统一训练与推理流程，GPT 选择仅用 Decoder 实现理解与生成</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><strong>LLaMA、Falcon、Mistral 等大语言模型（LLMs）</strong></p>
</li>
</ul>
</li>
<li><p>适用任务（生成类任务）：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>文本生成</strong></td>
<td align="left">根据提示生成连贯的文本内容</td>
<td align="left">文章生成、故事创作、对话生成</td>
</tr>
<tr>
<td align="left"><strong>代码生成</strong></td>
<td align="left">根据注释或需求生成程序代码</td>
<td align="left">GitHub Copilot、CodeX</td>
</tr>
<tr>
<td align="left"><strong>对话系统（Chatbot）</strong></td>
<td align="left">与用户进行多轮自然语言交互</td>
<td align="left">智能客服、虚拟助手</td>
</tr>
<tr>
<td align="left"><strong>机器翻译（部分实现）</strong></td>
<td align="left">根据源语言生成目标语言（若输入已嵌入提示）</td>
<td align="left">简单翻译任务</td>
</tr>
<tr>
<td align="left"><strong>摘要生成</strong></td>
<td align="left">根据输入文本生成简洁摘要</td>
<td align="left">新闻摘要、会议纪要</td>
</tr>
</tbody></table>
<ol start="5">
<li><p>优点：</p>
<ul>
<li><p>擅长<strong>生成连贯、上下文相关的文本</strong>。</p>
</li>
<li><p>模型结构简单，推理时只需 decoder，计算效率高（相对 encoder-decoder）。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p><strong>缺乏显式的编码器结构，对复杂输入的结构化理解能力较弱</strong>（不过通过 prompt engineering 可部分弥补）。</p>
</li>
<li><p>对需要同时理解输入 + 生成输出的任务（如翻译、问答），不如 encoder-decoder 灵活。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Encoder-Decoder（编码器-解码器）结构"><a href="#Encoder-Decoder（编码器-解码器）结构" class="headerlink" title="Encoder-Decoder（编码器-解码器）结构"></a>Encoder-Decoder（编码器-解码器）结构</h3><ol>
<li><p>结构组成：</p>
<ul>
<li><p>包含完整的 <strong>Encoder 和 Decoder 两部分</strong>，两者通过**交叉注意力机制（Cross-Attention）**相连。</p>
</li>
<li><p><strong>Encoder 负责理解输入序列</strong>，<strong>Decoder 负责基于编码信息生成目标序列</strong>。</p>
</li>
</ul>
</li>
<li><p>工作原理：</p>
<ul>
<li><p>输入序列（如源语言句子）通过 Encoder 编码成一个或多个上下文向量。</p>
</li>
<li><p>Decoder 在生成目标序列（如目标语言句子）时，通过<strong>交叉注意力机制关注 Encoder 的输出</strong>，从而实现输入到输出的信息映射。</p>
</li>
</ul>
</li>
<li><p>典型模型：</p>
<ul>
<li><p><strong>Transformer（原始论文模型）</strong></p>
</li>
<li><p><strong>T5（Text-To-Text Transfer Transformer）</strong></p>
</li>
<li><p><strong>BART（Bidirectional and Auto-Regressive Transformer）</strong></p>
</li>
<li><p><strong>mBART、PEGASUS</strong> 等</p>
</li>
</ul>
</li>
<li><p>适用任务（理解 + 生成类 &#x2F; 序列到序列任务）：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>机器翻译（Machine Translation）</strong></td>
<td align="left">源语言 → 目标语言</td>
<td align="left">英文 → 中文翻译</td>
</tr>
<tr>
<td align="left"><strong>文本摘要（Text Summarization）</strong></td>
<td align="left">长文本 → 摘要</td>
<td align="left">新闻摘要生成</td>
</tr>
<tr>
<td align="left"><strong>问答系统（问答生成）</strong></td>
<td align="left">问题 + 上下文 → 答案文本</td>
<td align="left">开放域问答</td>
</tr>
<tr>
<td align="left"><strong>对话生成（多轮生成）</strong></td>
<td align="left">用户输入 → 系统回复</td>
<td align="left">多轮对话系统</td>
</tr>
<tr>
<td align="left"><strong>语音转文本后再生成（ASR + TTS）</strong></td>
<td align="left">语音 → 中间表示 → 自然语言</td>
<td align="left">语音问答系统</td>
</tr>
<tr>
<td align="left"><strong>图像描述生成（Image Captioning）</strong></td>
<td align="left">图像特征 → 描述文本</td>
<td align="left">AI 看图说话</td>
</tr>
</tbody></table>
<ol start="5">
<li><p>优点：</p>
<ul>
<li><p>同时具备<strong>强大的理解能力（Encoder）和生成能力（Decoder）</strong>。</p>
</li>
<li><p>适合处理<strong>输入与输出均为序列，且两者结构&#x2F;语义均较复杂</strong>的任务。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>模型结构更复杂，训练成本更高。</p>
</li>
<li><p>推理时需要同时运行 encoder 和 decoder，计算开销较大。</p>
</li>
</ul>
</li>
</ol>
<h3 id="序列生成任务评价指标"><a href="#序列生成任务评价指标" class="headerlink" title="序列生成任务评价指标"></a>序列生成任务评价指标</h3><ol>
<li><p><strong>BLEU</strong> </p>
<ol>
<li>是最经典、最广泛使用的机器翻译评价指标，由 IBM 研究者在 2002 年提出。它通过比较<strong>模型生成的译文（Candidate）与一个或多个参考译文（Reference）之间的 n-gram 匹配程度</strong>，来衡量生成结果的质量。</li>
</ol>
<blockquote>
<p> 核心思想： 生成文本与参考文本在 n-gram（如 1~4 个词连续组合）层面越匹配，BLEU 分数越高，说明生成质量越好。</p>
</blockquote>
<ol start="2">
<li><p>计算方法（简化版）：BLEU 的计算主要包括两个部分：</p>
<ol>
<li><p><strong>n-gram 精度（Precision）</strong></p>
<ul>
<li>统计生成文本中每个 n-gram（比如 1-gram: 单词，2-gram: 词对，…）出现的次数，</li>
<li>并计算这些 n-gram 在参考译文中也出现了多少次，取<strong>最小值（避免夸大）</strong>，</li>
<li>最终对多个 n（通常为 1~4）做加权平均。</li>
</ul>
</li>
<li><p><strong>BP（Brevity Penalty，长度惩罚）</strong></p>
<ul>
<li>如果生成的句子比参考句子短太多，即使 n-gram 匹配很高，也会扣分。</li>
</ul>
</li>
</ol>
</li>
<li><p>适用场景</p>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">是否适用</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>机器翻译</strong></td>
<td align="left">非常常用</td>
<td align="left">标准评价指标，广泛用于 MT 任务（如 WMT 比赛）</td>
</tr>
<tr>
<td align="left"><strong>文本摘要</strong></td>
<td align="left">可用</td>
<td align="left">但更推荐 ROUGE（见下）</td>
</tr>
<tr>
<td align="left"><strong>对话生成 &#x2F; 问答</strong></td>
<td align="left">一般</td>
<td align="left">对语义要求高，BLEU 对词面匹配敏感，不太关注语义正确性</td>
</tr>
<tr>
<td align="left"><strong>代码生成</strong></td>
<td align="left">不适用</td>
<td align="left">代码不是自然语言，要用 CodeBLEU（见下）</td>
</tr>
</tbody></table>
<p> <strong>优点：</strong> 客观、可复现、与人工评价有一定相关性</p>
<p> <strong>缺点：</strong> 只看词面 n-gram 匹配，<strong>不关心语义、词序灵活性、同义词替换等</strong></p>
</li>
</ol>
</li>
<li><p>CodeBLEU（针对代码生成任务）</p>
<ol>
<li>概述<ol>
<li><strong>CodeBLEU</strong> 是在 BLEU 基础上，为<strong>代码生成任务（如自动编程、代码补全、SQL 生成等）</strong> 设计的改进评价指标，由华为研究者提出。</li>
</ol>
</li>
</ol>
<blockquote>
<p>代码 ≠ 自然语言，不能只看词频匹配！CodeBLEU 综合考虑了：</p>
<ul>
<li><strong>Token 级 BLEU（词法层面）</strong></li>
<li><strong>语法树结构（AST，Abstract Syntax Tree）相似度</strong></li>
<li><strong>数据流信息</strong></li>
<li><strong>代码功能正确性（可选，需额外工具）</strong></li>
</ul>
</blockquote>
<hr>
<ol start="2">
<li>计算思路（简化）</li>
</ol>
<p>CodeBLEU 分数通常是几部分的加权组合：<br>$$<br>CodeBLEU&#x3D;w_1⋅BLEU+w_2⋅AST+w_3⋅Dataflow+…<br>$$</p>
<ul>
<li>BLEU：普通词法 n-gram 匹配</li>
<li>AST：抽象语法树匹配（代码结构是否相似）</li>
<li>Dataflow：变量使用、控制流等是否合理</li>
<li>不同任务可调整权重</li>
</ul>
<hr>
<ol start="3">
<li>适用场景</li>
</ol>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">是否适用</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码生成 &#x2F; 补全 &#x2F; 翻译</strong></td>
<td align="left">✅ 推荐</td>
<td align="left">比 BLEU 更适合代码，综合语法与结构信息</td>
</tr>
<tr>
<td align="left"><strong>自然语言生成</strong></td>
<td align="left">❌ 不适用</td>
<td align="left">是为代码任务定制的</td>
</tr>
</tbody></table>
<p><strong>优点：</strong> 更贴近代码语义与结构，评价更准确</p>
<p><strong>缺点：</strong> 实现复杂，依赖语法树等工具</p>
</li>
<li><p>ROUGE（Recall-Oriented Understudy for Gisting Evaluation）</p>
</li>
<li><p>概述</p>
</li>
</ol>
<p>   ROUGE 是用于文本摘要（Text Summarization）任务的主要评价指标，由 Lin 等人提出。它侧重于衡量生成摘要与参考摘要之间的词重叠度（尤其是召回率）。</p>
<blockquote>
<p>与 BLEU 不同，ROUGE 更关注<strong>生成内容是否覆盖了参考中的重要信息（词、短语、n-gram）</strong>。</p>
</blockquote>
<hr>
<ol start="2">
<li>常见变体</li>
</ol>
<table>
<thead>
<tr>
<th align="left">指标</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>ROUGE-N</strong></td>
<td align="left">N-gram 重叠（如 ROUGE-1：单词；ROUGE-2：词对）</td>
</tr>
<tr>
<td align="left"><strong>ROUGE-L</strong></td>
<td align="left">基于最长公共子序列（LCS），衡量生成与参考之间的最佳匹配顺序</td>
</tr>
<tr>
<td align="left"><strong>ROUGE-S &#x2F; ROUGE-W</strong></td>
<td align="left">基于跳跃 n-gram 或加权匹配</td>
</tr>
</tbody></table>
<hr>
<ol start="4">
<li>适用场景</li>
</ol>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">是否适用</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>文本摘要</strong></td>
<td align="left">主流指标</td>
<td align="left">重点看是否涵盖关键信息</td>
</tr>
<tr>
<td align="left"><strong>机器翻译</strong></td>
<td align="left">可用但非主流</td>
<td align="left">一般更偏向 BLEU</td>
</tr>
<tr>
<td align="left"><strong>问答 &#x2F; 对话</strong></td>
<td align="left">可尝试</td>
<td align="left">但通常不用作主要指标</td>
</tr>
</tbody></table>
<p>   <strong>优点：</strong> 更关注内容覆盖，对词序相对宽容</p>
<p>   <strong>缺点：</strong> 仍基于词面匹配，不涉及深层语义</p>
<ol start="4">
<li><p>METEOR（Metric for Evaluation of Translation with Explicit ORdering）</p>
<ol>
<li>简介</li>
</ol>
<p><strong>METEOR</strong> 是一种兼顾<strong>精确率、召回率、词义相似性、词序</strong>的评价指标，由 Banerjee &amp; Lavie 提出，目标是<strong>更贴近人工评价</strong>。</p>
<blockquote>
<p>它不仅看词是否出现，还考虑了：</p>
<ul>
<li><strong>同义词匹配（通过 WordNet）</strong></li>
<li><strong>词干还原（stemming）</strong></li>
<li><strong>词序与句法结构</strong></li>
<li><strong>精确率 + 召回率的调和</strong></li>
</ul>
</blockquote>
<hr>
<ol start="2">
<li><p>计算思路（简化）: METEOR 分数综合考虑：</p>
<ul>
<li><p>匹配的 unigrams（词）数量</p>
</li>
<li><p>是否同义词 &#x2F; 词干相同</p>
</li>
<li><p>词序信息</p>
</li>
<li><p>使用 F-mean（精确率与召回率的加权调和）</p>
</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li>适用场景</li>
</ol>
<table>
<thead>
<tr>
<th align="left">任务类型</th>
<th align="left">是否适用</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>机器翻译</strong></td>
<td align="left">✅ 推荐（比 BLEU 更接近人工）</td>
<td align="left">更关注语义相似性</td>
</tr>
<tr>
<td align="left"><strong>文本生成 &#x2F; 摘要</strong></td>
<td align="left">✅ 可用</td>
<td align="left">对语义更友好</td>
</tr>
<tr>
<td align="left"><strong>代码 &#x2F; 对话</strong></td>
<td align="left">⚠️ 较少用</td>
<td align="left">不是主流</td>
</tr>
</tbody></table>
<p><strong>优点：</strong> 更接近人工判断，<strong>考虑同义词与词序</strong></p>
<p><strong>缺点：</strong> 计算复杂，使用不如 BLEU 广泛</p>
</li>
</ol>
<h2 id="⽣成式对抗⽹络（GAN）"><a href="#⽣成式对抗⽹络（GAN）" class="headerlink" title="⽣成式对抗⽹络（GAN）"></a>⽣成式对抗⽹络（GAN）</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>是什么</p>
<ol>
<li>生成式对抗网络（Generative Adversarial Network，GAN）由生成器（Generator）和判别器（Discriminator）这两个核心部分组成，二者通过对抗博弈的方式进行训练，以提升各自的性能。</li>
<li>基本结构<ol>
<li>生成器（Generator）功能：生成器的任务是学习从一个潜在空间到目标数据分布的映射。简单来说，就是根据随机输入的噪声向量 <em>z</em>，生成尽可能逼真的数据样本，这些数据样本与真实数据分布相似。<ol>
<li>结构：一般由多层神经网络构成，常见的如多层全连接网络或者卷积神经网络（在处理图像等数据时）。</li>
<li>例如，在图像生成任务中，生成器可能是一个反卷积神经网络（也称为转置卷积网络），它可以将低维的噪声向量逐步转换为高维的图像数据。</li>
</ol>
</li>
<li>判别器（Discriminator）功能：判别器的作用是区分输入的数据是来自真实数据分布还是由生成器生成的假数据。它接收真实数据样本和生成器生成的假数据样本作为输入，然后输出一个概率值，表示输入数据是真实数据的可能性。<ol>
<li>结构：同样由多层神经网络组成，其结构与生成器类似，但在设计上更侧重于对数据的特征提取和分类能力。</li>
<li>例如，在图像判别任务中，判别器也是一个卷积神经网络，通过对图像的特征提取和分析，判断图像的真实性。</li>
</ol>
</li>
</ol>
</li>
<li><strong>生成器和判别器以对抗的方式进行交互，生成器试图生成能够欺骗判别器的假数据，而判别器则努力准确区分真实数据和假数据，二者在不断的博弈过程中逐渐提升性能，是为对抗</strong></li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>目标：GAN 的训练过程是一个迭代优化的过程，目标是找到生成器和判别器的最优参数，使得生成器能够生成与真实数据分布高度相似的数据，同时判别器难以区分真实数据和生成器生成的数据。其训练过程主要基于一个极小极大博弈的目标函数。</p>
<ol>
<li><p>$$<br>\min_{G}\max_{D}V(D,G)&#x3D;E_{x∼pdata(x)}[logD(x)]+E_{z∼pz(z)}[log(1−D(G(z)))]<br>$$</p>
</li>
<li><p>等式左侧：即要求只考虑D的情况下，最大化损失函数（以便判别器更好的区分），然后再只考虑G的情况下，最小化损失函数（以便生成器更好的拟合）。</p>
</li>
</ol>
</li>
<li><p>工作步骤：</p>
<ol>
<li>训练步骤初始化：随机初始化生成器 <em>G</em>和判别器 <em>D</em>的参数。</li>
<li>训练判别器：固定生成器的参数，通过优化判别器的参数，使其能够更好地区分真实数据和生成器生成的假数据。</li>
<li>训练生成器：固定判别器的参数，通过优化生成器的参数，使其生成的数据能够更有效地欺骗判别器。</li>
<li>迭代训练：重复步骤 2 和步骤 3，不断交替训练判别器和生成器，直到达到预设的训练轮数或者满足一定的收敛条件。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Wasserstein-GAN（WGAN）"><a href="#Wasserstein-GAN（WGAN）" class="headerlink" title="Wasserstein GAN（WGAN）"></a>Wasserstein GAN（WGAN）</h3><ol>
<li><p>核心区别：损失函数不同。</p>
<ol>
<li><p>传统GAN使用的是JS散度（Jensen - Shannon散度）来衡量真实数据分布 <em>Pr</em>和生成数据分布 <em>Pg</em>之间的差异，JS散度衡量的是 两个分布 *P*和 *Q*有多“不同”，数值越小，说明两个分布越相似。其判别器的目标是最大化如下目标函数：</p>
<ol>
<li>$$<br>V(D,G) &#x3D; {E}<em>{x \sim P_r}[\log D(x)] + {E}</em>{x \sim P_g}[\log(1 - D(x))]<br>$$</li>
</ol>
</li>
<li><p>WGAN使用Wasserstein距离（也称为推土机距离）来衡量两个分布之间的差异。Wasserstein距离定义为：$W(P_r, P_g) &#x3D; \inf_{\gamma \in \Pi(P_r, P_g)} \mathbb{E}_{(x,y) \sim \gamma}[|x - y|]$，即把真实分布 <em>Pr</em>的数据“移动”成生成分布 <em>Pg</em>的数据所需的最小“成本”，这里的“成本”是样本间的欧氏距离 ∥<em>x</em>−<em>y</em>∥。判别器目标是最大化这个函数： </p>
<ol>
<li>$$<br>L &#x3D; {E}<em>{x \sim P_r}[D(x)] - {E}</em>{x \sim P_g}[D(x)]<br>$$</li>
</ol>
</li>
</ol>
</li>
<li><p>由此引出的差异</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>传统GAN</strong></th>
<th align="left"><strong>Wasserstein GAN (WGAN)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>分布差异度量</strong></td>
<td align="left">JS散度：当真实分布 <em>P**r</em>和生成分布 <em>P**g</em>不重叠时，<strong>退化为常数 log2，导致梯度消失</strong></td>
<td align="left">Wasserstein距离：<strong>即使分布不重叠，仍能提供有意义的梯度，反映分布间的“平移距离”</strong></td>
</tr>
<tr>
<td align="left"><strong>训练稳定性</strong></td>
<td align="left">极不稳定： - 判别器过强时，生成器梯度消失（JS散度为常数） - 容易出现模式崩溃（生成单一模式样本）</td>
<td align="left">更稳定： - Wasserstein距离提供平滑梯度 - 判别器（Critic）不会过强，生成器持续学习</td>
</tr>
<tr>
<td align="left"><strong>模式崩溃问题</strong></td>
<td align="left">常见： - 生成器可能只生成少数几种样本（陷入局部最优）</td>
<td align="left">缓解： - 更稳定的训练使生成器能覆盖更多数据模式</td>
</tr>
<tr>
<td align="left"><strong>判别器&#x2F;Critic设计</strong></td>
<td align="left">判别器输出概率（0~1），使用Sigmoid激活函数</td>
<td align="left">Critic输出实数（无Sigmoid），不直接预测概率</td>
</tr>
<tr>
<td align="left"><strong>额外技术要求</strong></td>
<td align="left">无特殊约束</td>
<td align="left">需保证Critic的Lipschitz连续性（通常通过权重裁剪或梯度惩罚实现）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="条件⽣成式对抗⽹络（Conditional-GAN，cGAN）"><a href="#条件⽣成式对抗⽹络（Conditional-GAN，cGAN）" class="headerlink" title="条件⽣成式对抗⽹络（Conditional GAN，cGAN）"></a>条件⽣成式对抗⽹络（Conditional GAN，cGAN）</h3><ol>
<li><p><strong>核心思想</strong></p>
<ol>
<li><p>传统的GAN（如原始GAN、DCGAN等）生成的样本是<strong>无条件的</strong>（unconditional），即生成器（Generator）随机生成数据，无法控制生成内容的属性（如生成特定类别的图像、特定风格的文本等）。</p>
</li>
<li><p>cGAN 的核心思想是<strong>将条件信息（condition）同时输入生成器和判别器</strong>，使它们在训练时都“知道”要生成或判断什么内容。例如：</p>
<ul>
<li><p>在图像生成任务中，可以控制生成<strong>特定类别的图像</strong>（如“生成一张猫的图片”）。</p>
</li>
<li><p>在文本生成任务中，可以控制生成<strong>符合特定主题的句子</strong>（如“生成一篇关于AI的短文”）。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>结构</strong></p>
<ol>
<li>生成器：输入 &#x3D; 随机噪声向量 *z*+ 条件信息 *c*输出 &#x3D; 符合条件 *c*的生成数据（如图像、文本等）（例如，<em>c</em>可以是类别标签、文本描述、用户指定的属性等）</li>
<li>判别器：输入 &#x3D; 真实数据（或生成数据） + 条件信息 *c*输出 &#x3D; 判断该数据是否真实（且是否符合条件 *c*）</li>
<li>数学目标函数（cGAN的损失函数）：</li>
</ol>
</li>
</ol>
<p>$$<br>\min_{G}\max_{D}V(D,G)&#x3D;E_{x∼pdata(x)}[logD(x|c)]+E_{z∼pz(z)}[log(1−D(G(z|c)|c))]<br>$$</p>
<p>（即判别器要区分<strong>真实数据+条件</strong>和<strong>生成数据+条件</strong>，生成器要欺骗判别器）</p>
<ol start="3">
<li><p><strong>实现方式</strong></p>
<ol>
<li>条件信息 *c*的形式：<ol>
<li>类别标签（Class Label）：如MNIST手写数字分类（0~9），生成器输入“生成数字3”。</li>
<li>文本描述（Text Description）：如用自然语言描述生成图像（如“一只红色的猫”）。</li>
<li>用户指定属性（Attributes）：如生成特定发型、肤色的人脸图像。</li>
</ol>
</li>
<li>如何输入条件 *c*：<ol>
<li>直接拼接（Concatenation）：将 <em>c</em>和 <em>z</em>拼接后输入生成器（最简单的方式）。</li>
<li>嵌入（Embedding）：如果 <em>c</em>是离散的（如类别标签），先将其转换为嵌入向量（embedding），再与噪声 <em>z</em>结合。</li>
<li>条件批归一化（Conditional BatchNorm）：在生成器中使用条件信息调整批归一化层的参数。**</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>典型应用</strong></p>
<ul>
<li><p>图像生成：如条件MNIST（生成特定数字）、条件CelebA（生成特定属性的人脸）。</p>
</li>
<li><p>图像翻译（Image-to-Image Translation）：如将黑白图像着色、将草图生成真实图像（Pix2Pix）。</p>
</li>
<li><p>文本到图像生成（Text-to-Image）：如根据文字描述生成对应图像（StackGAN、AttnGAN）。</p>
</li>
</ul>
</li>
</ol>
<h3 id="可控生成（Controllable-Generation）"><a href="#可控生成（Controllable-Generation）" class="headerlink" title="可控生成（Controllable Generation）"></a>可控生成（Controllable Generation）</h3><ol>
<li><p><strong>基本思想</strong></p>
<ol>
<li><p>可控生成（Controllable Generation） 是比cGAN更广泛的概念，它指的是让生成模型能够按照用户指定的多种控制条件生成数据，而不仅仅是简单的类别标签。</p>
<ul>
<li><p>cGAN 是可控生成的一种特例（控制条件通常是类别标签或简单属性）。</p>
</li>
<li><p>更高级的可控生成 可以控制： 多个属性（Multi-Attribute Control）：如生成“戴眼镜、棕色头发、微笑的女性人脸”。 连续控制（Continuous Control）：如调节生成图像的“亮度、风格强度、人脸年龄”等。 交互式控制（Interactive Control）：如用户实时调整生成参数（如GANpaint、StyleGAN的潜空间控制）。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>实现方法</strong></p>
<ol>
<li><p>基于cGAN的扩展</p>
<ul>
<li><p>多条件输入（Multiple Conditions）： 例如，生成人脸时，同时输入性别、年龄、发型、表情等多个条件。</p>
</li>
<li><p>条件嵌入（Condition Embedding）： 如果条件是文本或复杂属性，先将其编码为向量（如用BERT、MLP），再输入生成器。</p>
</li>
</ul>
</li>
<li><p>潜空间控制（Latent Space Manipulation）</p>
<ul>
<li><p>GAN的潜空间（Latent Space） 是一个高维向量 z，生成器通过 z生成数据。</p>
</li>
<li><p>可控生成的关键：找到潜空间中哪些维度控制哪些属性（如“第10维控制微笑，第20维控制头发颜色”）。</p>
</li>
<li><p>方法： 线性插值（Linear Interpolation）：在潜空间中调整某些维度，观察生成数据的变化。 属性解耦（Disentangled Representation Learning）：让潜空间的不同维度控制不同属性（如StyleGAN、β-VAE）。 潜空间优化（Latent Optimization）：通过优化算法（如梯度下降）调整 z，使生成结果符合用户要求。</p>
</li>
</ul>
</li>
<li><p>条件批归一化 &amp; 注意力机制</p>
<ul>
<li><p>条件批归一化（Conditional BatchNorm）：让生成器的不同层根据条件调整特征。</p>
</li>
<li><p>注意力机制（Attention）：让生成器聚焦于特定区域（如文本到图像生成时，让模型关注描述的物体）。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>典型应用</strong></p>
<ul>
<li><p>文本到图像生成（Text-to-Image）：如 DALL·E、Stable Diffusion（根据文字生成图像）。</p>
</li>
<li><p>图像编辑（Image Editing）：如 GANpaint（修改生成图像的局部区域）。</p>
</li>
<li><p>人脸生成 &amp; 控制：如 StyleGAN（控制年龄、姿势、表情）。</p>
</li>
<li><p>音乐&#x2F;视频生成：如 根据用户输入生成特定风格的音乐或视频。</p>
</li>
</ul>
</li>
<li><ol start="3">
<li>cGAN vs. 可控生成（对比总结）</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Conditional GAN (cGAN)</strong></th>
<th><strong>可控生成（Controllable Generation）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>控制方式</strong></td>
<td>通常基于<strong>单一条件</strong>（如类别标签）</td>
<td>可以基于<strong>多条件、连续控制、交互式控制</strong></td>
</tr>
<tr>
<td><strong>输入条件</strong></td>
<td>类别标签、文本、简单属性</td>
<td>多属性、潜空间调节、用户交互</td>
</tr>
<tr>
<td><strong>典型方法</strong></td>
<td>cGAN（条件输入+判别器）</td>
<td>潜空间控制、注意力机制、条件批归一化</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>生成特定类别的图像&#x2F;文本</td>
<td>精细控制生成内容（如人脸属性、风格强度）</td>
</tr>
<tr>
<td><strong>代表模型</strong></td>
<td>Pix2Pix、AC-GAN</td>
<td>StyleGAN、DALL·E、GANpaint</td>
</tr>
</tbody></table>
<h2 id="强化学习（Reinforcement-Learning）"><a href="#强化学习（Reinforcement-Learning）" class="headerlink" title="强化学习（Reinforcement Learning）"></a>强化学习（Reinforcement Learning）</h2><blockquote>
<p>在网上看到的用AI来玩游戏的就属于强化学习了</p>
</blockquote>
<h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>是什么</p>
<ol>
<li><p>强化学习是一种通过智能体（Agent）与环境（Environment）交互来学习最优策略（Policy）的学习范式，其核心目标是让智能体在动态环境中采取一系列行动（Actions），以最大化长期累积奖励（Rewards）。</p>
</li>
<li><p>核心结构：强化学习的核心要素可以概括为 5 个关键组成部分，它们共同构成了RL的基本框架：</p>
<ol>
<li><p><strong>智能体（Agent）</strong></p>
<ol>
<li>定义：智能体是执行动作的决策者（如机器人、游戏玩家、算法等）。</li>
<li>作用：观察环境状态，选择动作，并通过与环境交互学习最优策略。</li>
<li>示例：在围棋游戏中，智能体就是下棋的AI（如AlphaGo）；在自动驾驶中，智能体就是控制车辆的决策系统。</li>
</ol>
</li>
<li><p><strong>环境（Environment）</strong></p>
<ul>
<li><p>定义：环境是智能体所处的外部世界，它接收智能体的动作并返回新的状态和奖励。</p>
</li>
<li><p>作用：动态响应智能体的行为，并提供反馈（状态和奖励）。</p>
</li>
<li><p>示例：在机器人控制中，环境可能是物理世界；在游戏中，环境可能是游戏规则和虚拟世界。</p>
</li>
</ul>
</li>
<li><p><strong>状态（State, S）</strong></p>
<ul>
<li><p>定义：状态是环境在某一时刻的描述，包含了智能体做出决策所需的所有信息。</p>
</li>
<li><p>特点：在马尔可夫决策过程（MDP）中，当前状态包含了历史信息（马尔可夫性），即未来只依赖于当前状态，而与过去无关。</p>
</li>
<li><p>示例： 在围棋中，状态可以是棋盘的当前布局。 在自动驾驶中，状态可以是车辆的速度、位置、周围障碍物等。</p>
</li>
</ul>
</li>
<li><p><strong>动作（Action, A）</strong></p>
<ul>
<li><p>定义：动作是智能体在某个状态下可以采取的行为。</p>
</li>
<li><p>特点：动作空间（Action Space）可以是离散的（如“左转、右转、直行”）或连续的（如“方向盘角度 0~360°”）。</p>
</li>
<li><p>示例： 在游戏中，动作可能是“向上移动、攻击、跳跃”。 在机器人控制中，动作可能是“移动左腿、施加力矩”。</p>
</li>
</ul>
</li>
<li><p><strong>奖励（Reward, R）</strong></p>
<ul>
<li><p>定义：奖励是环境在智能体采取某个动作后返回的即时反馈信号，用于衡量该动作的好坏。</p>
</li>
<li><p>特点：奖励通常是标量（正、负或零），智能体的目标是最大化长期累积奖励。</p>
</li>
<li><p>示例： 在围棋中，胜利可能获得 +1 奖励，失败获得 -1 奖励。 在机器人导航中，到达目标位置可能获得 +10 奖励，撞墙可能获得 -5 奖励。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>强化学习的基本流程</p>
<ol>
<li>智能体（Agent） 观察当前环境状态（State）。</li>
<li>智能体 根据策略（Policy）选择一个动作（Action）。</li>
<li>环境（Environment） 接收动作并转移到新的状态，同时返回一个奖励（Reward）。</li>
<li>智能体 根据新的状态和奖励，更新策略，以在未来获得更高的累积奖励。</li>
</ol>
<ul>
<li>这一过程不断循环，形成一个马尔可夫决策过程（Markov Decision Process, MDP）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>强化学习的交互过程</strong></p>
</li>
</ol>
<p>强化学习的交互过程可以用 <strong>马尔可夫决策过程（MDP）</strong> 来形式化描述，其核心要素包括：</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>状态空间（State Space）</td>
<td>所有可能的状态集合</td>
</tr>
<tr>
<td>A</td>
<td>动作空间（Action Space）</td>
<td>所有可能的动作集合</td>
</tr>
<tr>
<td>P(s’, s, a)</td>
<td>状态转移概率（Transition Probability）</td>
<td>在状态 s下采取动作 a并转移到状态 s′的概率</td>
</tr>
<tr>
<td>R(s,a,s′)</td>
<td>奖励函数（Reward Function）</td>
<td>在状态 s下采取动作 a并转移到状态 s′后获得的即时奖励</td>
</tr>
<tr>
<td>γ</td>
<td>折扣因子（Discount Factor）</td>
<td>用于权衡短期和长期奖励（0 ≤ γ ≤ 1）</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>马尔可夫性（Markov Property）</strong></p>
<ul>
<li><p>定义：未来状态 st+1只依赖于当前状态 st和当前动作 at，而与过去的状态和动作无关。</p>
</li>
<li><p>数学表达：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(st+1∣st,at,st−1,at−1,…)=P(st+1∣st,at)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>智能体的目标</strong></p>
<ol>
<li>智能体的目标是找到一个<strong>最优策略（Optimal Policy）</strong> π∗(a∣s)，使得在长期内获得的<strong>累积奖励（Return）</strong> 最大化。</li>
<li><strong>累积奖励（Return, Gt）</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gt=Rt+1+γRt+2+γ2Rt+3+⋯=k=0∑∞γkRt+k+1</span><br></pre></td></tr></table></figure>

<p>（γ是折扣因子，用于平衡短期和长期奖励）</p>
<ol start="3">
<li><p><strong>策略（Policy, π）</strong>： 策略是智能体在某个状态 s下选择动作 a的规则。 可以是 <strong>确定性策略</strong>（a&#x3D;π(s)）或 <strong>随机性策略</strong>（π(a∣s)表示在状态 s下选择动作 a的概率）。</p>
</li>
<li><p><strong>目标</strong>：找到最优策略 π∗，使得 <strong>长期累积奖励 Gt最大化</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π∗=argπmaxEπ[k=0∑∞γkRt+k+1]</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li><p>强化学习的核心挑战</p>
<ol>
<li><p>探索与利用（Exploration vs. Exploitation） 探索：尝试新的动作，发现可能更好的策略。 利用：选择已知能获得高奖励的动作。 挑战：如何在探索新策略和利用已知策略之间取得平衡？</p>
</li>
<li><p>延迟奖励（Delayed Reward） 智能体的某些动作可能不会立即获得奖励，而是影响未来的长期奖励。 挑战：如何让智能体学会考虑长期影响，而不仅仅是短期奖励？</p>
</li>
<li><p>高维状态与动作空间（High-Dimensional Spaces） 在复杂任务（如机器人控制、游戏AI）中，状态和动作空间可能非常大甚至连续。 挑战：如何高效地搜索最优策略？</p>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="5">
<li>强化学习的典型算法（简要提及）</li>
</ol>
<table>
<thead>
<tr>
<th><strong>算法类型</strong></th>
<th><strong>代表算法</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>值函数方法（Value-Based）</strong></td>
<td>Q-Learning、Deep Q-Network (DQN)</td>
<td>学习状态-动作值函数 Q(s,a)，选择最大 Q值的动作</td>
</tr>
<tr>
<td><strong>策略梯度方法（Policy-Based）</strong></td>
<td>REINFORCE、Proximal Policy Optimization (PPO)</td>
<td>直接优化策略 (\pi(a</td>
</tr>
<tr>
<td><strong>Actor-Critic 方法</strong></td>
<td>A2C、A3C、SAC</td>
<td>结合值函数和策略梯度，兼顾稳定性和灵活性</td>
</tr>
<tr>
<td><strong>基于模型的方法（Model-Based）</strong></td>
<td>Dyna-Q</td>
<td>学习环境模型，用于预测未来状态和奖励</td>
</tr>
</tbody></table>
<h3 id="Actor-Critic方法"><a href="#Actor-Critic方法" class="headerlink" title="Actor-Critic方法"></a>Actor-Critic方法</h3><ol>
<li><p>Actor-Critic方法的基本思想</p>
<ol>
<li>Actor-Critic（演员-评论家） 是强化学习中一类重要的 结合值函数（Value Function）和策略（Policy） 的方法，它综合了 值函数方法和策略梯度方法 的优点，旨在 更高效、更稳定地学习最优策略。</li>
</ol>
</li>
<li><p>核心概念</p>
<ul>
<li><p><strong>Actor（演员）</strong>： 负责策略，即根据当前状态选择动作。 通常是一个 <strong>策略网络（Policy Network）</strong>，输出动作的概率分布（在随机策略中）或直接输出动作（在确定性策略中）。 <strong>目标</strong>：学习一个 最优策略 π(a∣s)，使得长期累积奖励最大化。</p>
</li>
<li><p><strong>Critic（评论家）</strong>： 负责评估，即评估当前状态或状态-动作对的价值（如状态值函数 V(s)或动作值函数 Q(s,a)）。 通常是一个 <strong>值函数网络（Value Network）</strong>，用于估计 当前策略下的长期回报。 <strong>目标</strong>：评估 Actor 选择的动作有多好，并提供 改进策略的信号（如TD误差）。</p>
</li>
</ul>
</li>
<li><p>为什么需要Actor-Critic？</p>
<ul>
<li><p>纯策略梯度方法： 直接优化策略，但 方差大（高方差梯度估计），训练不稳定。</p>
</li>
<li><p>纯值函数方法： 适用于离散动作空间，但在 连续动作空间中难以直接优化策略。</p>
</li>
<li><p><strong>Actor-Critic</strong>： Actor 负责探索（选择动作），Critic 负责评估（指导Actor改进）。 结合策略梯度和值函数估计，降低方差，提高训练稳定性。</p>
</li>
</ul>
</li>
<li><p>训练过程</p>
<ol>
<li><p>Actor-Critic 方法的核心是 <strong>Actor 和 Critic 同时学习</strong>：</p>
<ul>
<li><p><strong>Actor</strong> 学习 <strong>策略 π(a∣s)</strong>（如何选择动作）。</p>
</li>
<li><p><strong>Critic</strong> 学习 <strong>值函数 V(s)或 Q(s,a)</strong>（如何评估动作的好坏）。</p>
</li>
</ul>
</li>
<li><p>基本流程</p>
<ol>
<li><strong>Actor</strong> 根据当前状态 st选择一个动作 at（基于策略 π(a∣s)）。</li>
<li><strong>环境</strong> 接收动作 at，返回下一个状态 st+1和奖励 rt。</li>
<li><strong>Critic</strong> 计算 <strong>TD误差（Temporal Difference Error）</strong> 或 <strong>值函数误差</strong>，用于评估当前动作的好坏。</li>
<li><strong>Critic</strong> 更新值函数（如 V(s)或 Q(s,a)），提供更准确的评估。</li>
<li><strong>Actor</strong> 根据 <strong>Critic 的反馈（如TD误差）</strong> 更新策略（如调整动作选择概率）。</li>
<li><strong>循环</strong>：不断重复上述过程，直到策略收敛。</li>
</ol>
</li>
</ol>
</li>
<li><p>关键组件</p>
<ol>
<li><p><strong>Critic 的值函数（Value Function）</strong>：Critic 通常学习以下两种值函数之一：</p>
<ol>
<li><p><strong>状态值函数 V(s)</strong>：</p>
<ul>
<li><p>估计在状态 s下，<strong>遵循当前策略 π的长期回报</strong>。</p>
</li>
<li><p><strong>TD误差（Temporal Difference Error）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">δt=rt+γV(st+1)−V(st)</span><br></pre></td></tr></table></figure>

<p>（γ是折扣因子，rt是即时奖励，V(st+1)是下一状态的值）</p>
</li>
</ul>
</li>
<li><p><strong>动作值函数 Q(s,a)</strong>：</p>
<ul>
<li><p>估计在状态 s下采取动作 a的长期回报。</p>
</li>
<li><p><strong>TD误差</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">δt=rt+γQ(st+1,at+1)−Q(st,at)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>Actor 的策略（Policy）</p>
<ul>
<li><p><strong>策略 π(a∣s)</strong> 可以是 <strong>随机策略（概率分布）</strong> 或 <strong>确定性策略（直接输出动作）</strong>。</p>
</li>
<li><p><strong>Actor 的更新</strong> 通常基于 <strong>Critic 提供的TD误差 δt</strong>，例如：</p>
<ul>
<li><p><strong>策略梯度更新</strong>（适用于随机策略）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∇θJ(θ)≈E[δt⋅∇θlogπθ(at∣st)]</span><br></pre></td></tr></table></figure>

<p>（θ是策略网络的参数，δt是Critic提供的TD误差）</p>
</li>
<li><p><strong>确定性策略梯度（如DDPG）</strong>：适用于连续动作空间。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Actor-Critic方法的优点</p>
<ol>
<li>结合策略梯度和值函数： 策略梯度方法（Actor） 直接优化策略，但方差大。 值函数方法（Critic） 提供更稳定的评估信号，降低方差。</li>
<li>适用于连续动作空间（如机器人控制）。</li>
<li>比纯策略梯度方法更稳定（Critic 提供TD误差指导）。</li>
<li>比纯值函数方法（如Q-Learning）更灵活（适用于连续动作）。</li>
</ol>
</li>
</ol>
<h3 id="强化学习在生成模型中的潜在应用"><a href="#强化学习在生成模型中的潜在应用" class="headerlink" title="强化学习在生成模型中的潜在应用"></a><strong>强化学习在生成模型中的潜在应用</strong></h3><ol>
<li><p>核心思想</p>
<ol>
<li>将生成过程视为<strong>序列决策问题</strong>，用强化学习（RL）的<strong>奖励信号</strong>直接优化生成结果（如文本质量、图像美观度等），弥补传统方法（如最大似然）只能优化局部目标的不足。</li>
</ol>
</li>
<li><p>典型应用与实例</p>
<ol>
<li><p>文本生成（如翻译、对话、故事）</p>
<ul>
<li><p><strong>问题</strong>：传统模型（如NLP）倾向生成“安全但平淡”的文本（追求单词语义正确，而非整体质量）。</p>
</li>
<li><p><strong>RL作用</strong>：用<strong>全局奖励</strong>（如BLEU分数、用户满意度）优化生成策略，提升连贯性&#x2F;创意性。</p>
</li>
<li><p><strong>实例</strong>：谷歌机器翻译引入RL优化BLEU；对话系统优化回复质量。</p>
</li>
</ul>
</li>
<li><p>图像生成（如文本到图像、艺术创作）</p>
<ul>
<li><p><strong>问题</strong>：生成图像需匹配复杂条件（如文本描述），传统方法难直接优化匹配度。</p>
</li>
<li><p><strong>RL作用</strong>：通过奖励（如图像-文本对齐度、美学评分）指导生成，提升细节与相关性。</p>
</li>
<li><p><strong>实例</strong>：AttnGAN结合RL优化图像与文本匹配；艺术生成追求风格一致性。</p>
</li>
</ul>
</li>
<li><p>分子&#x2F;药物设计（生成功能性分子）</p>
<ul>
<li><p><strong>问题</strong>：需生成具有特定性质（如药效、稳定性）的分子结构。</p>
</li>
<li><p><strong>RL作用</strong>：以分子性质（如生物活性、毒性）为奖励，指导分子图逐步构建。</p>
</li>
<li><p><strong>实例</strong>：RL生成高药物相似性分子（优化QED&#x2F;LogP指标）。</p>
</li>
</ul>
</li>
<li><p>游戏&#x2F;虚拟内容生成</p>
<ul>
<li><p><strong>问题</strong>：自动生成游戏关卡&#x2F;地图需平衡难度与趣味性。</p>
</li>
<li><p><strong>RL作用</strong>：以玩家体验（如挑战性、探索性）为奖励，优化内容设计。</p>
</li>
<li><p><strong>实例</strong>：RL生成Mario&#x2F;Doom游戏关卡。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>常用RL方法</p>
<ul>
<li><strong>策略梯度（如REINFORCE）</strong>：直接优化生成策略（适合文本&#x2F;分子）。</li>
<li><strong>Actor-Critic</strong>：结合策略与值函数，更稳定（适合图像&#x2F;复杂生成）。</li>
<li><strong>奖励驱动</strong>：用外部指标（BLEU、化学性质、用户反馈）定义奖励。</li>
</ul>
</li>
<li><p>核心优势</p>
<ul>
<li><p>优化<strong>复杂目标</strong>（如美学、功能性、用户偏好）</p>
</li>
<li><p>适配<strong>序列生成任务</strong>（文本&#x2F;图像&#x2F;分子逐步构建）</p>
</li>
<li><p>灵活设计<strong>奖励信号</strong>（模拟&#x2F;人工&#x2F;仿真反馈）</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">计算机网络八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:05:34" itemprop="dateModified" datetime="2025-12-03T17:05:34+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">名称</th>
<th align="left">中文名</th>
<th align="left">主要功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>7</strong></td>
<td align="left">Application Layer</td>
<td align="left"><strong>应用层</strong></td>
<td align="left">直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）</td>
</tr>
<tr>
<td align="left"><strong>6</strong></td>
<td align="left">Presentation Layer</td>
<td align="left"><strong>表示层</strong></td>
<td align="left">数据格式转换、加密、解密、压缩、解压缩</td>
</tr>
<tr>
<td align="left"><strong>5</strong></td>
<td align="left">Session Layer</td>
<td align="left"><strong>会话层</strong></td>
<td align="left">建立、管理和终止会话（通信连接）</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">Transport Layer</td>
<td align="left"><strong>传输层</strong></td>
<td align="left">提供端到端的可靠传输（如 TCP、UDP，负责端口、分段、流量控制）</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left">Network Layer</td>
<td align="left"><strong>网络层</strong></td>
<td align="left">负责数据路由和转发（如 IP 协议，决定数据怎么走到目的地）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Data Link Layer</td>
<td align="left"><strong>数据链路层</strong></td>
<td align="left">负责相邻节点间可靠传输（如以太网，MAC 地址，帧同步）</td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left">Physical Layer</td>
<td align="left"><strong>物理层</strong></td>
<td align="left">物理介质上的比特流传输（如电缆、光纤、网卡、信号）</td>
</tr>
</tbody></table>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">层名称（中文）</th>
<th align="left">层名称（英文）</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>4</strong></td>
<td align="left"><strong>应用层</strong></td>
<td align="left">Application Layer</td>
<td align="left">直接面向用户，提供各种网络应用服务，如网页、邮件、文件传输等</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"><strong>传输层</strong></td>
<td align="left">Transport Layer</td>
<td align="left">提供端到端的通信服务，如可靠传输（TCP）或快速传输（UDP）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left"><strong>网络层</strong></td>
<td align="left">Internet Layer</td>
<td align="left">负责数据包的路由和寻址，让数据包跨网络找到目的地，核心协议是 <strong>IP</strong></td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>网络接口层（或链路层&#x2F;物理层）</strong></td>
<td align="left">Network Interface Layer（或 Link Layer）</td>
<td align="left">负责在物理网络上传输数据帧，如以太网、WiFi、ARP 等</td>
</tr>
</tbody></table>
<h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><ol>
<li><p>第1层：网络接口层（Network Interface Layer）</p>
<ol>
<li><p>主要功能：</p>
<ol>
<li>负责 <strong>数据在物理网络上的传输</strong>，比如通过 <strong>网线、光纤、无线信号（WiFi）</strong> 等。</li>
<li>处理 <strong>MAC 地址（物理地址）</strong>、<strong>数据帧的封装与解封装</strong>、<strong>错误检测</strong>。</li>
<li>包括 <strong>局域网技术（如以太网 Ethernet）、无线技术（如 Wi-Fi 802.11）、ARP（地址解析协议）</strong> 等。</li>
</ol>
</li>
<li><p>常见协议 &#x2F; 技术：</p>
<ol>
<li><strong>Ethernet（以太网）</strong></li>
<li><strong>Wi-Fi（802.11）</strong></li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：将 IP 地址转换为 MAC 地址</li>
<li><strong>PPP（Point-to-Point Protocol，点对点协议）</strong></li>
<li><strong>物理层相关：网卡、光纤、双绞线、信号调制等</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>🔧 这一层关注的是：<strong>数据如何在具体的物理网络介质上传输。</strong></p>
</blockquote>
</li>
<li><p>第2层：网络层（Internet Layer）</p>
<ol>
<li><p>主要功能：</p>
<ol>
<li>负责 <strong>数据包的路由与转发</strong>，让数据从源主机跨越多个网络，最终到达目标主机。</li>
<li>使用 <strong>逻辑地址（IP 地址）</strong> 来标识设备。</li>
<li>核心任务是：<strong>IP 寻址、路由选择、分组转发</strong>。</li>
</ol>
</li>
<li><p>常见协议：</p>
<ol>
<li><strong>IP（Internet Protocol）</strong>：最核心的协议，包括 <strong>IPv4 和 IPv6</strong></li>
<li><strong>ICMP（Internet Control Message Protocol）</strong>：用于网络诊断，比如 <code>ping</code>命令就用了 ICMP</li>
<li><strong>IGMP（Internet Group Management Protocol）</strong>：用于组播管理</li>
<li><strong>ARP（Address Resolution Protocol）</strong>：有时也被归入这一层，用于 IP → MAC 的映射</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p> <strong>IP 协议让数据包找到了“去哪里”，但不保证一定能送到或按顺序到达。</strong></p>
</blockquote>
<ol start="3">
<li>第3层：传输层（Transport Layer）<ol>
<li>主要功能：<ol>
<li>提供 <strong>端到端（End-to-End）的通信服务</strong>，确保数据可靠传输或高效传输。</li>
<li>负责 <strong>端口管理、数据分段、流量控制、错误恢复</strong>。</li>
<li>区分不同应用程序的数据（比如浏览器和邮件软件同时运行）。</li>
</ol>
</li>
<li>常见协议：<ol>
<li><strong>TCP（Transmission Control Protocol）</strong>：<strong>可靠的、面向连接的传输协议</strong>用于：网页（HTTP）、文件传输（FTP）、邮件（SMTP）、远程登录（SSH）等需要可靠性的场景特点：三次握手、流量控制、重传机制、保证顺序</li>
<li><strong>UDP（User Datagram Protocol）</strong>：<strong>不可靠的、无连接的传输协议</strong>用于：视频流、语音通话（VoIP）、在线游戏、DNS 查询等对实时性要求高、允许少量丢包的场景特点：无连接、速度快、不保证顺序和可靠</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>🎯 <strong>传输层是真正实现“端口到端口通信”的地方，是应用层与网络层之间的桥梁。</strong></p>
</blockquote>
<ol start="4">
<li>第4层：应用层（Application Layer）<ol>
<li>主要功能：<ol>
<li><strong>直接面向用户或应用程序</strong>，提供各种网络服务和应用协议。</li>
<li>负责处理 <strong>用户数据格式、用户接口、应用逻辑</strong>。</li>
<li>包括我们日常使用的各种网络应用协议，如浏览网页、发送邮件、文件共享等。</li>
</ol>
</li>
<li>常见协议：<ol>
<li><strong>HTTP &#x2F; HTTPS</strong>：用于网页浏览（HTTPS 是加密的 HTTP）</li>
<li><strong>FTP（File Transfer Protocol）</strong>：文件传输</li>
<li><strong>SMTP &#x2F; POP3 &#x2F; IMAP</strong>：电子邮件相关协议</li>
<li><strong>DNS（Domain Name System）</strong>：域名解析（比如把 <a target="_blank" rel="noopener" href="http://www.baidu.com转成/">www.baidu.com转成</a> IP 地址）</li>
<li><strong>Telnet &#x2F; SSH</strong>：远程登录协议（SSH 更安全）</li>
<li><strong>DHCP</strong>：动态主机配置协议（自动分配 IP 地址）</li>
<li><strong>SNMP</strong>：网络管理协议</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol>
<li><p>是什么</p>
<ol>
<li>HTTP（HyperText Transfer Protocol），即 超文本传输协议。</li>
<li>它是互联网上应用最广泛的一种 <strong>应用层协议</strong>，用来在 客户端（如浏览器）和服务器之间传输数据，主要是网页内容（如 HTML、图片、CSS、JS 等）。</li>
<li><strong>规定浏览器（客户端）和网站服务器之间如何“请求”和“响应”数据。</strong></li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>HTTP 是基于 <strong>请求与响应（Request&#x2F;Response）模型</strong> 的：</p>
<ol>
<li>客户端（通常是浏览器） 发送一个 HTTP 请求（Request） 给服务器。</li>
<li>服务器 收到请求后，处理并返回一个 HTTP 响应（Response） 给客户端。</li>
<li>客户端接收响应并展示内容（比如显示网页）。</li>
</ol>
<ul>
<li>这个过程是 <strong>无状态的（Stateless）</strong>，也就是说，<strong>每次请求都是独立的，服务器默认不会记住你之前的请求</strong>（除非用 Cookie、Session 等机制）。</li>
</ul>
</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>浏览器通过 <strong>TCP 协议</strong> 与服务器建立连接（默认端口是 <strong>80</strong>）。</p>
</li>
<li><p>浏览器发送一个 HTTP 请求，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>

<p>意思是：请给我 <code>/index.html</code>这个页面，使用的是 HTTP 1.1 协议。</p>
</li>
<li><p>服务器收到请求后，返回一个 HTTP 响应，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...这里是网页内容...&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>表示请求成功（状态码 200），并返回了 HTML 内容。</p>
</li>
<li><p>浏览器接收到响应后，将 HTML 渲染成可视化的网页。</p>
</li>
</ol>
</li>
<li><p>特点</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>无状态（Stateless）</strong></td>
<td align="left">每次请求互相独立，服务器不记录之前的交互（除非使用 Cookie&#x2F;Session）</td>
</tr>
<tr>
<td align="left"><strong>基于请求-响应模型</strong></td>
<td align="left">客户端发起请求，服务器返回响应</td>
</tr>
<tr>
<td align="left"><strong>简单、灵活</strong></td>
<td align="left">易于实现，支持多种数据类型（文本、图片、视频等）</td>
</tr>
<tr>
<td align="left"><strong>明文传输（不加密）</strong></td>
<td align="left">数据以 <strong>明文形式在网络中传输</strong>，容易被窃听或篡改 ⚠️</td>
</tr>
<tr>
<td align="left"><strong>默认端口是 80</strong></td>
<td align="left">当你访问 <code>http://xxx</code>时，一般使用 80 端口通信</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ol>
<li><p>是什么</p>
<ol>
<li>HTTPS（HyperText Transfer Protocol Secure） 是 HTTP 的安全版本，它在 HTTP 的基础上加入了 <strong>SSL&#x2F;TLS 协议</strong>，通过 <strong>加密、身份认证和数据完整性校验</strong> 来保护客户端与服务器之间的通信。</li>
</ol>
</li>
<li><p>解决了什么问题</p>
<ol>
<li>在传统的 HTTP 通信中，主要存在以下三大安全隐患：<ol>
<li>**窃听风险（Confidentiality）**数据在传输过程中可能被第三方监听，比如密码、个人信息等。</li>
<li>**篡改风险（Integrity）**数据在传输途中可能被恶意修改，而通信双方无法察觉。</li>
<li>**冒充风险（Authentication）**客户端可能连接到假的服务器（如钓鱼网站），服务器也可能被冒充。</li>
</ol>
</li>
<li><strong>HTTPS 通过 SSL&#x2F;TLS 协议解决了这三个问题：</strong><ol>
<li>加密通信内容，防止窃听；</li>
<li>使用消息认证码（MAC）等机制保证数据完整性；</li>
<li>通过数字证书验证通信双方的身份。</li>
</ol>
</li>
</ol>
</li>
<li><p>核心技术</p>
<ol>
<li><strong>对称加密（Symmetric Encryption）</strong><ol>
<li>加密和解密使用同一个密钥，效率高，互信安全。</li>
<li>但是如果对所有客户端都用同一个Key，就没用了；如果都唯一生成Key，服务端保存不了</li>
</ol>
</li>
<li><strong>非对称加密（Asymmetric Encryption）</strong><ol>
<li>使用一对密钥：公钥（public key）和私钥（private key）。</li>
<li>公钥加密的内容只能用私钥解密，反之亦然。用于安全地交换对称密钥，或进行身份验证。</li>
<li>非对称加密代价高</li>
</ol>
</li>
<li><strong>数字证书（Digital Certificate）</strong><ol>
<li>由权威的 <strong>CA（Certificate Authority，证书授权机构）</strong> 颁发。证明服务器的身份，包含服务器的公钥及身份信息，并经过 CA 私钥签名。客户端通过验证证书来确认服务器是否可信。用以解决中间人问题。</li>
</ol>
</li>
<li><strong>SSL&#x2F;TLS 协议</strong>是 HTTPS 的核心，负责加密通信的建立过程（握手）、密钥交换、数据加密传输等。</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>步骤 1：TCP 三次握手</p>
<ul>
<li>客户端与服务器先建立普通的 TCP 连接（这是所有应用层协议的基础）。</li>
</ul>
</li>
<li><p>步骤 2：TLS （Transport Layer Security，传输层安全协议）握手（核心步骤）</p>
<ul>
<li>目标是先用<strong>非对称加密</strong>协商出一个<strong>对称加密密钥</strong>，并验证对方身份。</li>
</ul>
<ol>
<li><strong>Client Hello</strong>：客户端向服务器发起请求，告知：<ol>
<li>支持的 TLS 版本</li>
<li>支持的加密算法（Cipher Suites）</li>
<li>随机数 Client Random</li>
</ol>
</li>
<li><strong>Server Hello</strong>：服务器回应：<ol>
<li>选择的 TLS 版本和加密算法</li>
<li>随机数 Server Random</li>
<li><strong>数字证书（含服务器公钥）</strong></li>
<li>（可选）服务器也可能会要求客户端证书（双向认证）</li>
</ol>
</li>
<li><strong>客户端验证证书</strong>：客户端用 <strong>CA 的公钥（预装在操作系统&#x2F;浏览器中）</strong> 验证服务器证书的合法性：<ol>
<li>证书是否过期</li>
<li>是否被吊销</li>
<li>是否由受信任的 CA 签发域名</li>
<li>是否匹配</li>
<li>如果证书合法，提取出服务器的公钥。</li>
</ol>
</li>
<li><strong>生成 Pre-Master Secret</strong>：客户端生成一个随机数：<strong>Pre-Master Secret</strong>，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。</li>
<li><strong>双方计算对称密钥</strong>：客户端和服务器根据以下三个随机数：<code>Client Random，Server Random，Pre-Master Secret</code>通过特定算法（如 PRF）计算得出相同的 <strong>对称密钥（Session Key）</strong>，用于后续通信的加密。</li>
<li><strong>握手完成</strong>双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。</li>
</ol>
<blockquote>
<p>🎯 <strong>为什么不用非对称加密传输全部数据？</strong></p>
<p>非对称加密计算开销大，效率低。对称加密速度快，适合大量数据传输。因此 HTTPS 利用非对称加密安全地传递对称密钥，之后用对称加密传输数据。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><ol>
<li><p>是什么</p>
<ol>
<li>TLS（Transport Layer Security，传输层安全协议）是一种加密通信协议，用于在互联网上安全地传输数据，防止数据被窃听、篡改或冒充。它为像 HTTP 这样的应用层协议提供了加密、身份认证和数据完整性保护。</li>
</ol>
</li>
<li><p>背景</p>
<ol>
<li><strong>SSL（Secure Sockets Layer，安全套接层）</strong> 是 TLS 的前身，最早由网景公司（Netscape）在1990年代初期提出，用于保护 Web 通信。</li>
<li>后来由于安全漏洞等问题，SSL 的多个版本（如 SSL 2.0、SSL 3.0）陆续被废弃。</li>
<li><strong>TLS 1.0</strong> 于 1999 年作为 <strong>SSL 3.0 的升级替代版</strong> 被提出，之后发展出：<strong>TLS 1.1</strong>（2006年）<strong>TLS 1.2</strong>（2008年，目前广泛使用）<strong>TLS 1.3</strong>（2018年，最新、最安全、性能最好，强烈推荐）</li>
</ol>
<blockquote>
<p> 现在应该避免使用 SSL，因为它已被证明是不安全的。我们现在说的“SSL”，很多其实指的是 TLS，比如“SSL 证书”其实就是“TLS 证书”。</p>
</blockquote>
</li>
<li><p>核心作用</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">说明</th>
<th align="left">为什么重要</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加密（Encryption）</strong></td>
<td align="left">对传输的数据进行加密，防止被第三方窃听</td>
<td align="left">保护隐私，比如密码、银行卡号等敏感信息</td>
</tr>
<tr>
<td align="left"><strong>身份认证（Authentication）</strong></td>
<td align="left">通过数字证书验证通信双方的身份，防止中间人冒充</td>
<td align="left">确保你连接的是真正的网站，而不是钓鱼网站</td>
</tr>
<tr>
<td align="left"><strong>数据完整性（Integrity）</strong></td>
<td align="left">确保传输的数据没有被篡改</td>
<td align="left">防止数据在传输过程中被恶意修改</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>步骤 1：客户端发起 Hello</p>
<p>客户端告诉服务器：</p>
<ul>
<li>我支持哪些 TLS 版本</li>
<li>我支持哪些加密算法</li>
<li>我生成了一个随机数（Client Random）</li>
</ul>
</li>
<li><p>步骤 2：服务器回应 Hello</p>
<p>服务器选择：</p>
<ul>
<li>一个 TLS 版本</li>
<li>一组加密算法</li>
<li>返回自己的随机数（Server Random）</li>
<li><strong>自己的数字证书（含公钥）</strong></li>
</ul>
</li>
<li><p>步骤 3：客户端验证证书</p>
<ol>
<li>客户端用本地信任的 CA（证书颁发机构）公钥，验证服务器证书是否合法，提取公钥。</li>
</ol>
</li>
<li><p>步骤 4：生成对称密钥</p>
<ol>
<li>客户端生成一个“预备主密钥”（Pre-Master Secret），用服务器的公钥加密后传给服务器。</li>
<li>然后双方根据 Client Random、Server Random 和 Pre-Master Secret，<strong>计算出相同的对称密钥（Session Key）</strong>。</li>
</ol>
</li>
<li><p>步骤 5：通信加密</p>
<ol>
<li>握手完成后，双方使用对称密钥加密实际传输的数据（如 HTTP 请求和响应），通信正式开始，安全又高效 ✅</li>
</ol>
</li>
</ol>
<blockquote>
<p>为什么不一直用非对称加密？因为非对称加密很慢，对称加密快，适合大数据量传输。</p>
</blockquote>
</li>
</ol>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ol>
<li><p>是什么：哈希算法（Hash Algorithm）是一种将任意长度的输入数据，通过特定计算，生成一个固定长度的、唯一性标识（通常称为“哈希值”或“摘要”）的算法。</p>
</li>
<li><p><strong>关键特性</strong>：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>确定性</strong></td>
<td align="left">相同的输入，总是产生相同的哈希值</td>
</tr>
<tr>
<td align="left"><strong>快速计算</strong></td>
<td align="left">输入数据后，可以快速计算出哈希值</td>
</tr>
<tr>
<td align="left"><strong>不可逆性（单向性）</strong></td>
<td align="left">你无法从哈希值反推出原始数据</td>
</tr>
<tr>
<td align="left"><strong>雪崩效应</strong></td>
<td align="left">输入数据的微小变化，会导致哈希值发生巨大改变</td>
</tr>
<tr>
<td align="left"><strong>固定长度输出</strong></td>
<td align="left">不管输入是 1bit 还是 1GB，输出的哈希值长度固定（如 256 位）</td>
</tr>
</tbody></table>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ol>
<li>为了保证获得服务端公钥的正确性，服务端公钥需要由CA证书认证。</li>
<li>为了保证CA公钥的正确性，需要由根证书认证</li>
<li>为了保证根证书的正确性，直接安装在操作系统中。</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ol>
<li>是什么<ol>
<li>IP 协议（Internet Protocol，互联网协议）是 TCP&#x2F;IP 协议簇中最重要的网络层协议，它负责在互联网上为数据包提供逻辑寻址（IP 地址）、路由选择和跨网络传输，是实现主机之间互联互通的基础。</li>
</ol>
</li>
<li>主要功能<ol>
<li><strong>逻辑寻址（Logical Addressing）</strong><ul>
<li>每台联网设备都会分配一个 IP 地址，用于在网络中唯一标识该设备。</li>
<li>IP 地址让数据包知道 <strong>“要发给谁”（哪个网络中的哪台设备）</strong>。</li>
</ul>
</li>
<li><strong>路由与转发（Routing &amp; Forwarding）</strong><ul>
<li>当数据包需要跨网络传输时（比如从你家到某个网站服务器），IP 协议会决定数据包该经过哪些 <strong>路由器（Router）</strong>，最终到达目标。</li>
<li>每个路由器根据 <strong>IP 地址</strong> 做出转发决策，选择最优路径。</li>
</ul>
</li>
<li><strong>分组传输（Packet Switching）</strong><ul>
<li>IP 协议将数据分割成一个个小的数据单元，称为 <strong>IP 数据包（或 IP 包 &#x2F; 数据报）</strong>，每个包都包含：源 IP 地址目标 IP 地址其他控制信息</li>
<li>这些包可以 <strong>独立地在网络中传输，并在终点重新组装</strong>。</li>
</ul>
</li>
<li><strong>跨网络通信（Inter-network Communication）</strong><ul>
<li>IP 协议使得不同类型的物理网络（如以太网、WiFi、光纤）能够互相连接，组成一个统一的互联网。</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">IP 地址</th>
<th align="left">MAC 地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全称</strong></td>
<td align="left">Internet Protocol Address</td>
<td align="left">Media Access Control Address</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">用于在 <strong>网络层</strong> 标识设备，用于跨网络寻址</td>
<td align="left">用于在 <strong>数据链路层（局域网）</strong> 标识设备，用于直接通信</td>
</tr>
<tr>
<td align="left"><strong>类型</strong></td>
<td align="left">逻辑地址（可变，可配置）</td>
<td align="left">物理地址（固化在网卡中，全球唯一）</td>
</tr>
<tr>
<td align="left"><strong>格式</strong></td>
<td align="left">点分十进制，如 <code>192.168.1.1</code></td>
<td align="left">16 进制，如 <code>00:1A:2B:3C:4D:5E</code></td>
</tr>
<tr>
<td align="left"><strong>工作范围</strong></td>
<td align="left">跨网络（互联网）</td>
<td align="left">局域网内（如家庭、公司网络）</td>
</tr>
<tr>
<td align="left"><strong>谁管理</strong></td>
<td align="left">由网络管理员或 DHCP 分配</td>
<td align="left">由网卡厂商固化，全球唯一</td>
</tr>
</tbody></table>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><ol>
<li>是什么<ol>
<li>ARP（Address Resolution Protocol，地址解析协议）是一个用于将 IP 地址解析为 MAC 地址的通信协议，它工作在 TCP&#x2F;IP 模型的 网络接口层（或数据链路层），是实现局域网内设备互相通信的重要基础协议。</li>
</ol>
</li>
<li>为什么需要ARP<ol>
<li>你访问 <code>www.baidu.com</code>，其实是访问它的 <strong>IP 地址</strong></li>
<li>但数据包在 <strong>局域网</strong>中传输时，并不是通过 IP 地址直接找到对方，而是通过 <strong>MAC 地址</strong></li>
</ol>
</li>
<li>工作原理</li>
<li>ARP 的工作原理<ol>
<li>场景：主机 A 想给同一局域网内的 主机 B（IP 已知）发送数据<ol>
<li>主机 A 检查自己的 ARP 缓存表。如果已经缓存了 目标 IP对应的 MAC 地址，那就直接使用，不用再问。</li>
<li>如果缓存中没有该 IP 的 MAC 地址，主机 A 就会发送一个 ARP 请求广播包：内容大致是：“请问，IP 地址是 192.168.1.100 的设备，你的 MAC 地址是多少？”这个 ARP 请求是以 <strong>广播形式</strong> 发送到当前局域网内的 所有设备。</li>
<li>局域网中的所有设备都会收到这个 ARP 请求，但只有 IP 地址匹配的设备（主机 B）会响应：主机 B 回复一个 ARP 响应包 给主机 A，内容是：“我的 IP 是 192.168.1.100，我的 MAC 地址是 00:1A:2B:3C:4D:5E”。</li>
<li>主机 A 收到响应后，就把这个 IP ↔ MAC 的对应关系保存到自己的 ARP 缓存表中，下次再访问这个 IP 时，就不用再问了。</li>
<li>然后主机 A 就可以使用这个 MAC 地址，将数据包正确地发送到主机 B。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="体系结构-1"><a href="#体系结构-1" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="简述OSI七层模型"><a href="#简述OSI七层模型" class="headerlink" title="简述OSI七层模型"></a>简述OSI七层模型</h3><h3 id="简述TCP-IP四层模型"><a href="#简述TCP-IP四层模型" class="headerlink" title="简述TCP&#x2F;IP四层模型"></a>简述TCP&#x2F;IP四层模型</h3><h3 id="简述五层模型"><a href="#简述五层模型" class="headerlink" title="简述五层模型"></a>简述五层模型</h3><h2 id="计算机综合"><a href="#计算机综合" class="headerlink" title="计算机综合"></a>计算机综合</h2><h3 id="浏览器输入URL到渲染主页的过程"><a href="#浏览器输入URL到渲染主页的过程" class="headerlink" title="浏览器输入URL到渲染主页的过程"></a>浏览器输入URL到渲染主页的过程</h3><ol>
<li><strong>URL 解析</strong></li>
<li><strong>DNS解析</strong>：将域名转换为IP地址。</li>
<li><strong>TCP连接</strong>：与服务器建立TCP三次握手连接（HTTPS还需TLS握手）。</li>
<li><strong>TLS链接</strong>（如果是HTTPS）</li>
<li><strong>发送HTTP请求</strong>：浏览器发送请求报文到服务器。</li>
<li><strong>服务器处理</strong>：服务器返回HTML响应。</li>
<li><strong>渲染页面</strong>：浏览器解析HTML，构建DOM树，加载CSS&#x2F;JS，渲染布局和绘制。</li>
</ol>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><ol>
<li>全流程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">本地电脑：用户输入域名 → 检查本地缓存 → 本地无缓存 → </span><br><span class="line">↓</span><br><span class="line">|  向配置的DNS服务器（如<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>）发起查询 <span class="comment">// 递归查询</span></span><br><span class="line">↓</span><br><span class="line">本地DNS服务器</span><br><span class="line">↓</span><br><span class="line">|  向其他DNS服务器发起查询  <span class="comment">// 迭代查询</span></span><br><span class="line">↓</span><br><span class="line">根DNS服务器（.）→ 返回 .com TLD 服务器地址 </span><br><span class="line">↓</span><br><span class="line">.com TLD 服务器 → 返回 example.com 权威DNS地址 </span><br><span class="line">↓</span><br><span class="line">权威DNS服务器 → 返回 www.example.com 的IP </span><br><span class="line">↓</span><br><span class="line">浏览器拿到IP，发起TCP连接访问网站！</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>递归查询（Recursive Query）</p>
<ol>
<li><p>定义：</p>
<ol>
<li>客户端（或本地DNS服务器）只发起一次请求，由DNS服务器（通常是递归DNS服务器）负责完成整个查询过程，并返回最终结果。</li>
<li>适用于普通用户（如你的电脑向ISP的DNS服务器查询）。</li>
</ol>
</li>
<li><p>流程（以用户查询 <code>www.example.com</code>为例）：</p>
<ol>
<li><strong>你的电脑</strong>向 <strong>本地DNS服务器</strong>（如ISP的DNS或8.8.8.8）发起 <strong>递归查询</strong>（请求：<code>请帮我查 www.example.com 的IP</code>）。</li>
<li>本地DNS服务器接到请求后，自己负责去根DNS、TLD、权威DNS逐层查询，直到拿到最终IP。</li>
<li>本地DNS服务器把 最终IP返回给你的电脑，你的电脑 不需要再做其他查询。</li>
</ol>
</li>
<li><p>特点：</p>
</li>
</ol>
<ul>
<li><p>用户只需发起一次请求，DNS服务器负责全部查询。</p>
</li>
<li><p>适用于普通用户（如家庭宽带、手机上网）。</p>
</li>
<li><p>递归DNS服务器（如8.8.8.8、114.114.114.114）通常提供递归查询服务。</p>
</li>
</ul>
<hr>
</li>
<li><p>迭代查询（Iterative Query）</p>
<ol>
<li>定义：<ol>
<li>DNS服务器不会直接返回最终结果，而是返回下一个可能知道答案的DNS服务器地址，由客户端（或上一级DNS）继续查询。</li>
<li><strong>适用于DNS服务器之间的查询</strong>（如根DNS、TLD、权威DNS之间的交互）。</li>
</ol>
</li>
</ol>
</li>
<li><p>流程（以本地DNS服务器查询 <code>www.example.com</code>为例）：</p>
<ol>
<li>你的本地DNS服务器向 根DNS服务器查询 <code>www.example.com</code>。根DNS服务器不知道具体IP，但知道 <code>.com</code>TLD服务器的地址，于是 返回 <code>.com</code>TLD服务器的IP。</li>
<li>本地DNS服务器再向 <code>.com</code>TLD服务器查询 <code>www.example.com</code>。<code>.com</code>TLD服务器不知道具体IP，但知道 <code>example.com</code>的权威DNS服务器地址，于是 返回 <code>example.com</code>权威DNS的IP。</li>
<li>本地DNS服务器再向 <code>example.com</code>权威DNS服务器查询 <code>www.example.com</code>。权威DNS服务器直接返回 <code>www.example.com</code>的IP。</li>
<li>最终，本地DNS服务器把IP返回给你的电脑。</li>
</ol>
</li>
<li><p>特点：</p>
<ol>
<li>DNS服务器之间互相“踢皮球”，每一步只返回下一个可能知道的服务器。</li>
<li>适用于DNS服务器之间的查询（如根→TLD→权威）。</li>
<li>你的电脑通常不直接使用迭代查询，而是依赖递归DNS服务器（如8.8.8.8）帮你完成。</li>
</ol>
</li>
</ol>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="简述IP协议作用"><a href="#简述IP协议作用" class="headerlink" title="简述IP协议作用"></a>简述IP协议作用</h3><p>负责<strong>网络层数据传输</strong>，提供：</p>
<ul>
<li><strong>逻辑寻址</strong>（通过IP地址定位设备）。</li>
<li><strong>路由选择</strong>（指导数据包跨网络传输路径）。</li>
<li><strong>无连接、不可靠的数据包交付</strong>（不保证顺序或到达，依赖上层协议如TCP）。</li>
</ul>
<h3 id="简述ARP工作流程"><a href="#简述ARP工作流程" class="headerlink" title="简述ARP工作流程"></a>简述ARP工作流程</h3><p><strong>地址解析协议（ARP）<strong>用于将</strong>IP地址映射为MAC地址</strong>：</p>
<ol>
<li>主机广播ARP请求（询问“谁是IP X？请回复MAC”）。</li>
<li>目标主机收到后单播回复自己的MAC地址。</li>
<li>发送方缓存该映射（ARP表），后续直接使用。（<em>注：同一局域网内有效，跨网段需通过网关。</em>）</li>
</ol>
<h2 id="HTTP（S）协议"><a href="#HTTP（S）协议" class="headerlink" title="HTTP（S）协议"></a>HTTP（S）协议</h2><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong>GET</strong></th>
<th align="left"><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>请求方式</strong></td>
<td align="left">从服务器 <strong>获取数据</strong>（幂等）</td>
<td align="left">向服务器 <strong>提交数据</strong>（非幂等）</td>
</tr>
<tr>
<td align="left"><strong>数据位置</strong></td>
<td align="left">数据放在 <strong>URL 参数</strong>（<code>?key=value</code>）</td>
<td align="left">数据放在 <strong>请求体（Body）</strong></td>
</tr>
<tr>
<td align="left"><strong>数据可见性</strong></td>
<td align="left"><strong>可见</strong>（URL 可见，可被缓存、历史记录保存）</td>
<td align="left"><strong>不可见</strong>（Body 不直接暴露）</td>
</tr>
<tr>
<td align="left"><strong>数据大小限制</strong></td>
<td align="left"><strong>较小</strong>（通常 ≤ 2KB~8KB，取决于浏览器&#x2F;服务器）</td>
<td align="left"><strong>较大</strong>（理论上无限制，但服务器可配置）</td>
</tr>
<tr>
<td align="left"><strong>缓存</strong></td>
<td align="left"><strong>可被缓存</strong>（浏览器、代理服务器可缓存）</td>
<td align="left"><strong>默认不被缓存</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>较低</strong>（参数暴露在 URL）</td>
<td align="left"><strong>相对较高</strong>（但 HTTPS 才是真正安全的）</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left"><strong>获取数据</strong>（如搜索、加载页面）</td>
<td align="left"><strong>提交数据</strong>（如登录、表单提交）</td>
</tr>
</tbody></table>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><ul>
<li>HTTP 报文分为 **请求报文（Request）**和 <strong>响应报文（Response）</strong>，基本结构类似：</li>
</ul>
<ol>
<li><strong>请求报文（Request）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span>      <span class="comment">// 请求行（方法 + URL + 协议版本）</span></span><br><span class="line">Host: www.example.com         <span class="comment">// 请求头（Header）</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span></span><br><span class="line">Accept: text/html</span><br><span class="line">Cookie: sessionid=<span class="number">123</span></span><br><span class="line"></span><br><span class="line">（空行）</span><br><span class="line">（可选请求体 Body，如 POST 数据）</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>组成部分</strong>：</p>
<ol>
<li><p><strong>请求行（Request Line）</strong>：<code>方法（GET/POST） + URL + HTTP版本</code>。注意，URL不包含域名。</p>
</li>
<li><p><strong>请求头（Headers）</strong>：键值对</p>
<ol>
<li><p>** <code>Host</code>（目标服务器）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ul>
<li><p>提供访问域名</p>
</li>
<li><p>没有 <code>Host</code>，服务器不知道你要访问哪个域名（比如 <code>example.com</code>还是 <code>api.example.com</code>）。</p>
</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com  # 告诉服务器你要访问哪个网站</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>** <code>User-Agent</code>（浏览器&#x2F;设备信息）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>服务器可以根据 <strong>浏览器类型、操作系统、设备</strong>返回不同的内容（比如移动端适配）。</li>
<li>用于 <strong>统计分析</strong>（如 Google Analytics 统计用户使用的浏览器）。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X)  # 表示是 iPhone 浏览器</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>** <code>Accept</code>（接受的响应类型）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>客户端告诉服务器 <strong>它能处理哪些格式</strong>（如 <code>text/html</code>、<code>application/json</code>）。</li>
<li>服务器可以据此 <strong>返回最适合的数据格式</strong>（比如 API 可以返回 JSON 而不是 HTML）。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/json  # 客户端希望服务器返回 JSON</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>** <code>Cookie</code>（发送会话信息）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>客户端把 <strong>之前服务器设置的 Cookie</strong>发回去，用于 <strong>维持登录状态、用户偏好</strong>。</li>
<li>是 **会话管理（Session）**的关键机制。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: sessionid=abc123; user_prefs=dark_mode  # 携带会话 ID 和用户偏好</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p><strong><code>Authorization</code>（身份认证）</strong></p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>用于 <strong>登录、API 访问控制</strong>（如 <code>Bearer Token</code>、<code>Basic Auth</code>）。</li>
<li>服务器验证后决定是否允许访问。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # JWT Token 认证</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>空行（CRLF）</strong>：分隔头部和 Body</p>
</li>
<li><p><strong>请求体（Body）</strong>（可选）：POST&#x2F;PUT 等方法携带的数据</p>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>响应报文（Response）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK               <span class="comment">// 状态行（协议版本 + 状态码 + 状态文本）</span></span><br><span class="line">Content-Type: text/html       <span class="comment">// 响应头（Header）</span></span><br><span class="line">Content-Length: <span class="number">1234</span></span><br><span class="line">Set-Cookie: sessionid=<span class="number">456</span></span><br><span class="line"></span><br><span class="line">（空行）</span><br><span class="line">&lt;html&gt;...（响应体 Body）&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>组成部分</strong>：</p>
<ul>
<li><strong>状态行（Status Line）</strong>：<code>HTTP版本 + 状态码（200/404/500） + 状态文本</code></li>
<li><strong>响应头（Headers）</strong>：键值对（如 <code>Content-Type</code>, <code>Set-Cookie</code>）</li>
<li><strong>空行（CRLF）</strong>：分隔头部和 Body</li>
<li><strong>响应体（Body）</strong>：返回的 HTML、JSON 等数据</li>
</ul>
<h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程***"></a>HTTPS工作流程***</h3><ul>
<li><p>主要介绍TCL连接流程</p>
</li>
<li><p>目标是先用<strong>非对称加密</strong>协商出一个<strong>对称加密密钥</strong>，并验证对方身份。</p>
</li>
</ul>
<ol>
<li><strong>Client Hello</strong>：客户端向服务器发起请求，告知：<ol>
<li>支持的 TLS 版本</li>
<li>支持的加密算法（Cipher Suites）</li>
<li><strong>随机数 Client Random</strong></li>
</ol>
</li>
<li><strong>Server Hello</strong>：服务器回应：<ol>
<li>选择的 TLS 版本和加密算法</li>
<li><strong>随机数 Server Random</strong></li>
<li><strong>数字证书（含服务器公钥）</strong></li>
<li>（可选）服务器也可能会要求客户端证书（双向认证）</li>
</ol>
</li>
<li><strong>客户端验证证书</strong>：客户端用 <strong>CA 的公钥（预装在操作系统&#x2F;浏览器中）</strong> 验证服务器证书的合法性：<ol>
<li>证书是否过期</li>
<li>是否被吊销</li>
<li>是否由受信任的 CA 签发域名</li>
<li>是否匹配</li>
<li>如果证书合法，提取出服务器的公钥。</li>
</ol>
</li>
<li><strong>生成 Pre-Master Secret</strong>：<strong>客户端</strong>生成一个随机数：<strong>Pre-Master Secret</strong>，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。</li>
<li><strong>双方计算对称密钥</strong>：客户端和服务器根据以下三个随机数：<code>Client Random，Server Random，Pre-Master Secret</code>通过特定算法（如 PRF）计算得出相同的 <strong>对称密钥（Session Key）</strong>，用于后续通信的加密。</li>
<li><strong>握手完成</strong>双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。</li>
</ol>
<h3 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h3><ol>
<li>基本概念<ol>
<li>Cookie（客户端存储）<ul>
<li>是什么：服务器通过 <code>Set-Cookie</code>响应头让浏览器存储的小段数据（通常 ≤ 4KB）。</li>
<li>存储位置：<strong>浏览器（客户端）</strong>（每次请求自动发送）。</li>
<li>用途：记住登录状态（如 <code>sessionid=123</code>）。用户偏好（如语言、主题）。</li>
<li>特点：明文存储。可设置过期时间。默认不安全。</li>
</ul>
</li>
<li>Session（服务器存储）<ul>
<li>是什么：服务器存储的用户会话数据（如 <code>session_id → 用户信息</code>）。</li>
<li>存储位置：<strong>服务器</strong>（如内存、Redis、数据库）。</li>
<li>用途：维持登录状态。存储临时数据。</li>
<li>特点：更安全（敏感数据在服务器）。依赖 Cookie 或 URL 传递 <code>session_id</code>（如 <code>PHPSESSID=abc123</code>）。服务器需管理生命周期（过期清理）。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table>
<thead>
<tr>
<th align="left"><strong>类别</strong></th>
<th align="left"><strong>第一位数字</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1xx</strong></td>
<td align="left"><code>100-199</code></td>
<td align="left"><strong>信息性状态码</strong></td>
<td align="left">请求已接收，继续处理（较少使用）</td>
</tr>
<tr>
<td align="left"><strong>2xx</strong></td>
<td align="left"><code>200-299</code></td>
<td align="left"><strong>成功状态码</strong></td>
<td align="left">请求成功，服务器正常处理</td>
</tr>
<tr>
<td align="left"><strong>3xx</strong></td>
<td align="left"><code>300-399</code></td>
<td align="left"><strong>重定向状态码</strong></td>
<td align="left">需要客户端进一步操作（如跳转）</td>
</tr>
<tr>
<td align="left"><strong>4xx</strong></td>
<td align="left"><code>400-499</code></td>
<td align="left"><strong>客户端错误</strong></td>
<td align="left">请求有误（如 404 找不到页面）</td>
</tr>
<tr>
<td align="left"><strong>5xx</strong></td>
<td align="left"><code>500-599</code></td>
<td align="left"><strong>服务器错误</strong></td>
<td align="left">服务器处理请求时出错</td>
</tr>
</tbody></table>
<ol>
<li>4xx（客户端错误）</li>
</ol>
<table>
<thead>
<tr>
<th align="left"><strong>状态码</strong></th>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>400 Bad Request</strong></td>
<td align="left">错误请求</td>
<td align="left">请求语法错误（如参数缺失、格式不对）</td>
<td align="left">JSON 格式错误、缺少必填字段</td>
</tr>
<tr>
<td align="left"><strong>401 Unauthorized</strong></td>
<td align="left">未授权</td>
<td align="left"><strong>需要登录</strong>（未提供有效的身份验证）</td>
<td align="left">未带 Token 或 Cookie</td>
</tr>
<tr>
<td align="left"><strong>403 Forbidden</strong></td>
<td align="left">禁止访问</td>
<td align="left"><strong>有权限问题</strong>（登录了但无权访问）</td>
<td align="left">普通用户访问管理员页面</td>
</tr>
<tr>
<td align="left"><strong>404 Not Found</strong></td>
<td align="left">未找到</td>
<td align="left"><strong>请求的资源不存在</strong></td>
<td align="left">访问不存在的页面（如 <code>/nonexistent</code>）</td>
</tr>
<tr>
<td align="left"><strong>429 Too Many Requests</strong></td>
<td align="left">请求过多</td>
<td align="left"><strong>限流</strong>（短时间内发送太多请求）</td>
<td align="left">API 调用频率超限</td>
</tr>
</tbody></table>
<ol start="2">
<li>5xx（服务器错误）</li>
</ol>
<table>
<thead>
<tr>
<th align="left"><strong>状态码</strong></th>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>500 Internal Server Error</strong></td>
<td align="left">服务器内部错误</td>
<td align="left"><strong>服务器代码出错</strong>（如 Python&#x2F;Java 异常）</td>
<td align="left">后端代码崩溃</td>
</tr>
<tr>
<td align="left"><strong>502 Bad Gateway</strong></td>
<td align="left">网关错误</td>
<td align="left"><strong>代理服务器（如 Nginx）收到无效响应</strong></td>
<td align="left">后端服务（如 Tomcat）崩溃</td>
</tr>
<tr>
<td align="left"><strong>503 Service Unavailable</strong></td>
<td align="left">服务不可用</td>
<td align="left"><strong>服务器暂时过载或维护</strong></td>
<td align="left">网站维护中</td>
</tr>
<tr>
<td align="left"><strong>504 Gateway Timeout</strong></td>
<td align="left">网关超时</td>
<td align="left"><strong>代理服务器等待后端响应超时</strong></td>
<td align="left">后端处理太慢</td>
</tr>
</tbody></table>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP &#x2F; UDP"></a>TCP &#x2F; UDP</h2><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong>TCP（传输控制协议）</strong></th>
<th align="left"><strong>UDP（用户数据报协议）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议类型</strong></td>
<td align="left"><strong>面向连接</strong>（可靠传输）</td>
<td align="left"><strong>无连接</strong>（不可靠传输）</td>
</tr>
<tr>
<td align="left"><strong>连接方式</strong></td>
<td align="left"><strong>三次握手建立连接</strong>，四次挥手断开</td>
<td align="left"><strong>直接发送数据，无需连接</strong></td>
</tr>
<tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠</strong>（确保数据完整、有序到达）</td>
<td align="left"><strong>不可靠</strong>（可能丢包、乱序）</td>
</tr>
<tr>
<td align="left"><strong>数据顺序</strong></td>
<td align="left"><strong>保证顺序</strong>（按发送顺序到达）</td>
<td align="left"><strong>不保证顺序</strong>（可能乱序）</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left"><strong>有</strong>（避免发送过快导致接收方缓冲区溢出）</td>
<td align="left"><strong>无</strong></td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>（动态调整发送速率）</td>
<td align="left"><strong>无</strong></td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left"><strong>较慢</strong>（因握手、确认、重传等机制）</td>
<td align="left"><strong>较快</strong>（无额外控制机制）</td>
</tr>
<tr>
<td align="left"><strong>头部大小</strong></td>
<td align="left"><strong>20~60字节</strong>（较复杂）</td>
<td align="left"><strong>8字节</strong>（非常轻量）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>需要可靠传输的应用</strong>（如网页、文件传输、邮件）</td>
<td align="left"><strong>实时性要求高的应用</strong>（如视频、语音、游戏）</td>
</tr>
<tr>
<td align="left"><strong>典型协议&#x2F;应用</strong></td>
<td align="left"><strong>HTTP、HTTPS、FTP、SSH、Email</strong></td>
<td align="left"><strong>DNS、视频会议（Zoom）、在线游戏、VoIP（Skype）</strong></td>
</tr>
</tbody></table>
<h3 id="UDP如何保证消息不丢失"><a href="#UDP如何保证消息不丢失" class="headerlink" title="UDP如何保证消息不丢失"></a>UDP如何保证消息不丢失</h3><ul>
<li>UDP不保证消息不丢失。</li>
<li>如果希望UDP可靠，可以在应用层实现</li>
</ul>
<h3 id="三次握手，为什么不是两次或四次握手"><a href="#三次握手，为什么不是两次或四次握手" class="headerlink" title="三次握手，为什么不是两次或四次握手"></a>三次握手，为什么不是两次或四次握手</h3><ol>
<li><p>为什么不是两次？</p>
<ol>
<li>本质是考虑数据报的丢失</li>
<li>假设：TCP 只用两次握手（客户端 SYN → 服务器 SYN-ACK）</li>
<li>问题：<strong>无法防止“历史连接”导致的资源浪费！</strong></li>
<li>*场景：<ol>
<li>客户端之前发送了一个连接请求，但由于 网络延迟，这个包 很久才到达服务器。</li>
<li>客户端早就 <strong>放弃了这次连接</strong>（超时重传或主动关闭），但 <strong>服务器</strong>现在才收到这个旧的 SYN。</li>
<li><strong>如果只有两次握手</strong>：服务器收到 SYN 后，会 <strong>直接认为这是一个新连接</strong>，并分配资源（如内存、端口）。服务器回复 SYN-ACK，然后等待客户端的 ACK（但客户端根本不会回复，因为它已经放弃了）。</li>
<li><strong>结果</strong>：<strong>服务器一直等待，浪费资源（内存、端口、CPU）</strong>，形成 “半连接”。</li>
</ol>
</li>
<li>三次握手如何解决？<ul>
<li>第三次握手（客户端 → 服务器 ACK）是 客户端对服务器 SYN 的确认。</li>
<li>如果客户端不发送第三次握手（说明它根本不想要这个连接），服务器 不会真正建立连接，避免资源浪费。</li>
<li>只有双方都确认了对方的初始序列号，连接才算真正建立。</li>
</ul>
</li>
<li>结论：</li>
</ol>
<ul>
<li>两次握手无法防止“历史无效连接”占用服务器资源。</li>
<li>三次握手确保双方都“真心想连接”，避免无效连接占用系统资源。</li>
</ul>
</li>
<li><p>为什么不是四次</p>
<ol>
<li><p>假设：TCP 用四次握手</p>
</li>
<li><p>问题：<strong>第三次握手已经足够，第四次是多余的！</strong></p>
</li>
<li><p>三次握手已经完成的任务：</p>
<ol>
<li>客户端 → 服务器 SYN（客户端说：“我想连接，我的序号是 x。”）。</li>
<li>服务器 → 客户端 SYN-ACK（服务器说：“我同意，我的序号是 y，我收到了你的 x。”）。</li>
<li>客户端 → 服务器 ACK（客户端说：“我收到了你的 y，我准备好了。”）。</li>
</ol>
<ul>
<li><p>此时：</p>
<ul>
<li><p>双方都已经确认了对方的初始序列号（ISN）。</p>
</li>
<li><p>连接已经可以安全传输数据。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第四次握手的作用？</p>
<ul>
<li>服务器再发一个 ACK 给客户端？→ 完全没必要，因为客户端已经确认了服务器的 SYN（第三次握手）。</li>
<li>这样只会增加 1 个 RTT（往返时间），降低连接效率。</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>三次握手已经足够保证可靠性，四次握手不会带来额外好处，反而降低效率。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><ol>
<li>回顾一下四次挥手的过程就知道了。本质还是考虑数据报的丢失。</li>
<li>客户端请求断开连接时，服务端可能还在发送数据。必须要等他发送完。</li>
<li>服务端如果不等待客户端的确认，可能导致客户端的半连接。</li>
</ol>
<h3 id="为什么要等待2MSL，才进入CLOSE"><a href="#为什么要等待2MSL，才进入CLOSE" class="headerlink" title="为什么要等待2MSL，才进入CLOSE"></a>为什么要等待2MSL，才进入CLOSE</h3><ul>
<li><strong>MSL（Maximum Segment Lifetime）<strong>是指一个TCP报文段在网络中</strong>最长可以存活的时间</strong>。超过这个时间，该报文段就会被网络丢弃。</li>
<li>在 <strong>第四次挥手后</strong>，<strong>客户端</strong>不会立刻关闭连接，而是进入 <strong><code>TIME_WAIT</code>状态（等待 2MSL）</strong></li>
<li><strong>防止服务端没有收到断开确认</strong></li>
</ul>
<ol>
<li>如果服务端没有收到断开确认，会在一定时间后重发FIN报文。客户端就是要等待这个报文。</li>
<li>如果不等，但是服务端又没有收到断开确认，会导致断开失败。</li>
<li>如果服务器在这个期间挂了怎么办？<ol>
<li>一般情况下，不会对客户端产生实质性的负面影响，客户端仍然会正常结束 TIME_WAIT 状态。</li>
<li>既然服务端挂了，就不会重发FIN了，客户端就会在2MSL自然断开连接</li>
</ol>
</li>
</ol>
<h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><table>
<thead>
<tr>
<th align="left">机制</th>
<th align="left">作用</th>
<th align="left">解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>确认应答（ACK）</strong></td>
<td align="left">接收方通知发送方数据已收到</td>
<td align="left">防止数据丢失，确保送达</td>
</tr>
<tr>
<td align="left"><strong>超时重传</strong></td>
<td align="left">没收到ACK就重发数据</td>
<td align="left">应对丢包</td>
</tr>
<tr>
<td align="left"><strong>序列号</strong></td>
<td align="left">给每个字节编号，用于排序和去重</td>
<td align="left">保证顺序、去重</td>
</tr>
<tr>
<td align="left"><strong>确认号</strong></td>
<td align="left">告诉发送方下一次该发哪个字节</td>
<td align="left">精准控制发送</td>
</tr>
<tr>
<td align="left"><strong>滑动窗口</strong></td>
<td align="left">动态控制发送速率，匹配接收能力</td>
<td align="left">流量控制，防止接收方过载</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left">根据网络状况调整发送速率</td>
<td align="left">避免网络拥堵，提高整体性能</td>
</tr>
<tr>
<td align="left"><strong>校验和</strong></td>
<td align="left">检测数据在传输中是否损坏</td>
<td align="left">数据完整性保护</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>确认应答机制（ACK - Acknowledgement）</strong></p>
<ul>
<li>原理：发送方每发送一段数据，接收方收到后都会返回一个 <strong>ACK（确认报文）</strong>，表示已经成功收到该数据。</li>
<li>作用：发送方通过是否收到 ACK 来判断数据是否成功到达对端。如果没有收到 ACK，发送方会认为数据可能丢失，进而<strong>重传</strong>。</li>
</ul>
</li>
<li><p><strong>超时重传机制（Retransmission Timeout, RTO）</strong></p>
<ul>
<li>原理：发送方在发出数据后，会<strong>启动一个定时器</strong>，如果在规定时间内（超时时间，RTO）<strong>没有收到对应的ACK</strong>，就认为该数据包可能丢失了，于是<strong>重新发送</strong>该数据。</li>
</ul>
</li>
<li><p><strong>序列号机制（Sequence Number）</strong></p>
<ul>
<li>原理：TCP 会给每个<strong>字节</strong>都分配一个唯一的编号，称为 <strong>序列号（Sequence Number）</strong>，而不是针对每个数据包。</li>
</ul>
</li>
<li><p><strong>确认号机制（Acknowledgement Number）</strong></p>
</li>
</ol>
<ul>
<li>原理：接收方在回复 ACK 时，会告诉发送方：“我已经成功收到了序号 X 之前的所有数据，你<strong>下一个可以发送序号 X 的数据</strong>”。</li>
<li>作用：让发送方知道哪些数据已经被成功接收，从而避免不必要的重传，提高效率。</li>
</ul>
<ol start="5">
<li><p><strong>流量控制（Flow Control）——滑动窗口机制</strong></p>
<ul>
<li>问题：接收方的处理能力有限，如果发送方发送得太快，接收方缓冲区可能会溢出。</li>
<li>解决方案：使用滑动窗口（Sliding Window）机制来进行流量控制。接收方会通过 TCP 报文中的 <strong>窗口大小字段</strong>告诉发送方：“我当前还能接收多少数据”。发送方根据这个窗口大小来调整自己的发送速率，避免淹没接收方。</li>
</ul>
<p>滑动窗口让发送和接收双方能够动态协调发送速率，既高效又不会出错。</p>
</li>
<li><p><strong>拥塞控制（Congestion Control）</strong></p>
<ul>
<li>问题：不仅是接收方，整个网络的承载能力也是有限的，如果发送方不顾网络拥堵而疯狂发包，会导致丢包、延迟剧增，甚至网络瘫痪。</li>
<li>解决方案：TCP 实现了多种拥塞控制算法，比如：慢启动（Slow Start）拥塞避免（Congestion Avoidance）快速重传（Fast Retransmit）快速恢复（Fast Recovery）</li>
</ul>
<blockquote>
<p>这些算法让发送方根据网络的实时状态（比如是否出现丢包）来动态调整发送窗口大小，从而避免网络过度拥挤，提升整体通信质量与稳定性。</p>
</blockquote>
<p> <strong>拥塞控制关注的是“整个网络的负载情况”，而流量控制关注的是“接收方的能力”。两者共同作用，保证发送既高效又可靠。</strong></p>
</li>
<li><p><strong>校验和（Checksum）</strong></p>
<ul>
<li>原理：TCP 报文头部包含一个<strong>校验和字段</strong>，用于校验<strong>报文在传输过程中是否发生了错误（比如比特翻转）</strong>。</li>
<li>作用：接收方收到数据后，会重新计算校验和并与报文中的校验和比对，如果不匹配，说明数据可能损坏，直接丢弃该报文，等待重传。</li>
</ul>
</li>
</ol>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ol>
<li><p>为什么需要流量控制？</p>
<ol>
<li>TCP 是全双工、基于字节流的协议，数据在发送时是连续不断的。但如果<strong>发送方不顾接收方的处理能力，疯狂地发数据</strong>，接收方的<strong>接收缓冲区（Receive Buffer）可能会被填满</strong>，导致错误。</li>
</ol>
</li>
<li><p>如何实现？—— 滑动窗口（Sliding Window）机制</p>
<ol>
<li><strong>接收窗口（RWND, Receive Window）</strong><ol>
<li>接收方在自己的 TCP 报文头部中，通过 **窗口大小字段（Window Size）**告诉发送方：“我当前还能接收多少字节的数据”。</li>
<li>这个值就是<strong>接收窗口（RWND）</strong>，代表接收方缓冲区中<strong>剩余可用的空间大小</strong>。</li>
</ol>
</li>
<li><strong>发送方根据接收窗口调整发送速率</strong><ol>
<li>发送方根据接收方通告的窗口大小，<strong>决定自己一次可以发送多少数据</strong>，而不会超过接收方的处理能力。</li>
<li>当接收方处理了一些数据，并腾出了缓冲区空间后，会再次通告一个更大的窗口，发送方就可以继续多发数据。</li>
</ol>
</li>
<li><strong>滑动窗口动态调整</strong><ol>
<li>接收窗口的值是<strong>动态变化</strong>的，随着接收方应用程序读取数据的速度而改变。</li>
<li>发送方维护一个<strong>发送窗口</strong>，只有在窗口允许的范围内才能发送数据，从而实现“边发边等确认”的高效可靠传输。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><ol>
<li><p>是什么？</p>
<ol>
<li>拥塞控制是 TCP 用来感知并应对网络中的拥塞状况，动态调整发送速率，以避免网络过载和丢包的一种机制。</li>
<li>简单来说：发送方根据网络的拥堵程度，自动调整自己发多少数据，以免把网络“堵死”。</li>
</ol>
</li>
<li><p>为什么需要拥塞控制？</p>
<ol>
<li>网络中的带宽是<strong>共享的、有限的</strong>，如果多个设备同时大量发包，或者某一发送方发得过快，就可能导致：<ol>
<li>路由器&#x2F;交换机队列满</li>
<li>网络丢包（数据包被丢弃）</li>
<li>延迟急剧上升</li>
<li>吞吐量反而下降（越快越堵）</li>
</ol>
</li>
</ol>
<p>如果不加以控制，发送方“自顾自地快速发包”，不仅影响自己，还会<strong>影响整个网络的通信质量</strong>。</p>
</li>
<li><p>如何实现</p>
<ol>
<li>TCP 拥塞控制的核心是：<strong>通过维护一个“拥塞窗口（cwnd, Congestion Window）”来限制发送方在单位时间内可以发送的数据量</strong>，并且这个窗口大小会根据网络状况<strong>动态调整</strong>。</li>
</ol>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">新建连接 → 慢启动（指数增长）→ 达到 ssthresh → 拥塞避免（线性增长）</span><br><span class="line">                     ↓</span><br><span class="line">                出现丢包或 3 个 Dup ACK</span><br><span class="line">                     ↓</span><br><span class="line">           快速重传 → （可能进入）快速恢复 → 拥塞避免</span><br><span class="line">                     ↓</span><br><span class="line">                拥塞后重置 cwnd = 1，重新慢启动</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>慢启动（Slow Start）</strong></p>
<ul>
<li>**初始状态：**连接刚建立时，发送方不知道网络状况，不敢发太多。</li>
<li>**策略：**从小窗口开始，<strong>每收到一个 ACK，cwnd 就指数级增长（翻倍）</strong>，即“慢慢提速”。</li>
<li>**触发条件：**刚开始发送，或网络发生丢包后重置。</li>
<li>**停止条件：**当 cwnd 达到一个阈值（ssthresh，慢启动阈值）时，进入拥塞避免阶段。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong></p>
<ul>
<li><strong>策略：<strong>当 cwnd 达到 ssthresh 后，不再指数增长，而是</strong>每 RTT（往返时间）只增加 1 MSS（最大报文段长度）</strong>，即线性增长，<strong>更稳、更温和</strong>。</li>
<li>**目标：**尽量利用网络带宽，但避免触发拥塞。</li>
</ul>
</li>
<li><p><strong>快速重传（Fast Retransmit）</strong></p>
<ul>
<li><strong>触发条件：<strong>发送方</strong>连续收到 3 个重复的 ACK</strong>（说明某个数据包可能丢了，但网络还没完全拥塞）。</li>
<li>**行为：**不等超时，<strong>立刻重传那个丢失的数据包</strong>，而不必等到超时重传。</li>
<li>**效果：**更快恢复，避免等待超时带来的延迟。</li>
</ul>
</li>
<li><p><strong>快速恢复（Fast Recovery）</strong>（部分实现，如 Reno）</p>
<ul>
<li>**触发条件：**在快速重传之后，进入此状态。</li>
<li><strong>策略：<strong>不直接回到慢启动，而是</strong>将 ssthresh 设为当前 cwnd 的一半，cwnd 也适当减小，然后进入拥塞避免</strong>。</li>
<li>**目标：**快速恢复传输，同时避免网络再次拥塞。</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/MatLab%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/MatLab%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MatLab笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li>clc：清除命令行</li>
<li>clear：清除工作区</li>
</ol>
<h3 id="二维绘图"><a href="#二维绘图" class="headerlink" title="二维绘图"></a>二维绘图</h3><ol>
<li><p>流程</p>
<ol>
<li>变量设置<ol>
<li>x &#x3D; 0 : 0.01 : 2*pi</li>
<li>y &#x3D; sin(x)</li>
<li>xlimiti</li>
</ol>
</li>
<li>幕布初始化（figure)</li>
<li>绘制：plot(x, y)，plotyy(x, y1, y2)</li>
<li>命名<ol>
<li>创立标题：title(‘y &#x3D; sin(x)’)</li>
<li>xlabel(‘x’)</li>
<li>ylabel(‘y’)</li>
<li>AX(1)表示左侧轴，AX(2)表示右侧轴<ul>
<li>set(get(AX(1), ‘YLabel’), ‘String Decay’)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>函数</p>
<ol>
<li>plot：ploy(x1, y1, s1, x2, y2, s2, …)</li>
<li>legend：图例</li>
</ol>
</li>
<li><p>参数：</p>
<ol>
<li>颜色<ul>
<li>红(r)，绿(g)，蓝(b)，黄(y)，粉红(m)，青(c)，白(w)，黑(k)</li>
</ul>
</li>
<li>线型：<ul>
<li>实线(-)，虚线(- -)，冒号线(:)，点画线(-.)</li>
</ul>
</li>
<li>数据标记点![屏幕截图 2024-10-16 120138](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-16 120138.png)</li>
</ol>
</li>
<li><p>样例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = 0:0.1:2*pi; % 创建 x 数据</span><br><span class="line"></span><br><span class="line">% 第一个图像：sin 函数曲线</span><br><span class="line">y1 = sin(x);     % 创建第一个 y 数据</span><br><span class="line">plot(x, y1);     % 绘制第一个图像</span><br><span class="line">hold on;         % 保持当前图形</span><br><span class="line"></span><br><span class="line">% 第二个图像：cos 函数曲线</span><br><span class="line">y2 = cos(x);     % 创建第二个 y 数据</span><br><span class="line">plot(x, y2);     % 绘制第二个图像</span><br><span class="line"></span><br><span class="line">xlabel(&#x27;X-axis&#x27;); % 添加 x 轴标签</span><br><span class="line">ylabel(&#x27;Y-axis&#x27;); % 添加 y 轴标签</span><br><span class="line">title(&#x27;Multiple Plots&#x27;); % 添加图标题</span><br><span class="line">legend(&#x27;sin(x)&#x27;, &#x27;cos(x)&#x27;); % 添加图例，说明各曲线含义</span><br><span class="line">grid on;         % 显示网格线</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h3><ol>
<li>函数：<ol>
<li>plot3</li>
<li>meshgrid</li>
<li>mesh：网格线</li>
<li>surf：曲面</li>
</ol>
</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>其实和python很像</li>
</ul>
<ol>
<li><p>其他：’ % ‘</p>
</li>
<li><p>运算：</p>
<ol>
<li>幂运算：2 ^ n</li>
</ol>
</li>
<li><p>循环结构</p>
<ol>
<li><p>for…end结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for n = 1:2:9</span><br><span class="line">	cnt = cnt + 1;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li><p>while…end结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while n&lt;=10</span><br><span class="line">	cnt = cnt + 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>分支结构</p>
<ol>
<li>if…else…end</li>
<li>swich…case…otherwise…end</li>
</ol>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li>rand:<ol>
<li>rand(m, n)：生成m行n列的伪随机数</li>
<li>randn：生成标准正态分布的伪随机数</li>
<li>randi：生成均匀的伪随机整数</li>
</ol>
</li>
<li>magic：生成幻方</li>
<li>deal：给多个变量赋值：<ul>
<li>[a, b, c] &#x3D; deal(1， 2， 3)</li>
</ul>
</li>
<li>num2cell：把向量变成单元数据，以便枚举</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>索引全部从1开始</li>
</ul>
<ol>
<li><p>矩阵：</p>
<ol>
<li><p>表示方法：A &#x3D; [1 2 3; 4 5 6; 7 8 9]。</p>
</li>
<li><p>操作</p>
<ul>
<li>操作是列优先的，例如find就是优先从一列中查找，sum就列求和</li>
</ul>
<ol>
<li>转置：B &#x3D; A’</li>
<li>拉长（注意，是一列一列的拉）：C &#x3D; A(:)</li>
<li>逆矩阵：C &#x3D; inv(A)</li>
<li>A * B：正常的矩阵乘法</li>
<li>A  .* B：对应项相乘</li>
<li>A  &#x2F;  B：A乘以B的逆，即A * inv(B)</li>
<li>A .&#x2F; B：对应项相除</li>
<li>取值：A(2, 3), A(2, :)</li>
<li>查找：find。返回符合条件的索引。</li>
<li>旋转：flidud(上下)，flidlr（左右）</li>
<li>求和：sum<ol>
<li>sum(A, 2)行求和</li>
</ol>
</li>
</ol>
</li>
<li><p>构造</p>
<ol>
<li>零矩阵：O &#x3D; zeros(2, 3, 4)<ul>
<li>2行，3列，4维</li>
</ul>
</li>
<li>单位矩阵：eye(3)，3维单位阵</li>
<li>随机生成：rand</li>
<li>“切片”：D &#x3D; 1: 2: 9<ul>
<li>在[1, 9]中以2为步长选取数字，构造行向量</li>
</ul>
</li>
<li>“复制”：repmat(B, 2, 3)<ul>
<li>把B横着复制1次，竖着复制2次</li>
</ul>
</li>
<li>全一阵：ones(4, 4)</li>
<li>幻方矩阵：magic(4)</li>
</ol>
</li>
</ol>
</li>
<li><p>元胞数组：</p>
<ul>
<li>类比数组</li>
</ul>
<ol>
<li>表示方法：A &#x3D; cell(1, 2)<ul>
<li>注意：索引从1开始！！！</li>
</ul>
</li>
</ol>
</li>
<li><p>结构体：</p>
<ul>
<li><p>类比字典</p>
<ol>
<li><p>表示方法：books &#x3D; (‘name’,  A, ‘price’, [30, 40])</p>
<p>​                                     ^           ^</p>
<p>​                                    键          值</p>
</li>
<li><p>小括号取的是cell，中括号是取出字符串</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="系统学习"><a href="#系统学习" class="headerlink" title="系统学习"></a>系统学习</h1><h2 id="第一章-·-基础知识"><a href="#第一章-·-基础知识" class="headerlink" title="第一章  · 基础知识"></a>第一章  · 基础知识</h2><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ol>
<li>搜索路径：<ol>
<li>先检查变量名，再检查内置函数，最后是文件</li>
</ol>
</li>
</ol>
<h3 id="数值数据"><a href="#数值数据" class="headerlink" title="数值数据"></a>数值数据</h3><ol>
<li>输出格式format命令：format后面跟输出格式参数，没有参数就是恢复默认</li>
<li>常用数学函数：<ol>
<li>sind, cosd, tand：角度制三角函数</li>
<li>abd：求负数的绝对值，复数的模，字符串的ASCll码</li>
<li>取整：<ol>
<li>round：四舍五入</li>
<li>ceil：向上取整</li>
<li>floor：向下取整</li>
<li>fix：向零取整（取整数部分）</li>
</ol>
</li>
<li>rem：取模求余。m &#x3D; rem(x, 10)</li>
<li>isprime：是否为素数。</li>
<li>sqrt</li>
<li>exp</li>
</ol>
</li>
</ol>
<h3 id="变量及其操作"><a href="#变量及其操作" class="headerlink" title="变量及其操作"></a>变量及其操作</h3><ol>
<li><p>who &#x2F; whos ：显示现存变量信息。后者更详细</p>
</li>
<li><p>内存变量文件：</p>
<ol>
<li><p>save：保存。</p>
<blockquote>
<p>save madata x y</p>
</blockquote>
</li>
<li><p>load：载入</p>
<blockquote>
<p>load mydata</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="矩阵的表示"><a href="#矩阵的表示" class="headerlink" title="矩阵的表示"></a>矩阵的表示</h3><ol>
<li><p>建立：</p>
<ol>
<li>直接输入<ol>
<li>元素之间可以用空格或逗号分隔</li>
</ol>
</li>
<li>现有矩阵拼接</li>
<li>实部矩阵和虚部矩阵合称<ol>
<li>实部虚部要同型</li>
</ol>
</li>
<li>冒号表达式：1:2:3</li>
<li>linspace：linspace(start, end, nr)</li>
</ol>
</li>
<li><p>结构矩阵</p>
<ol>
<li>格式：元素.成员名&#x3D;表达式</li>
</ol>
</li>
<li><p>单位矩阵</p>
<ol>
<li>用大括号</li>
<li>每个元素可以是不同数据类型</li>
</ol>
</li>
</ol>
<h3 id="矩阵元素的引用"><a href="#矩阵元素的引用" class="headerlink" title="矩阵元素的引用"></a>矩阵元素的引用</h3><ol>
<li><p>矩阵不会访问越界</p>
</li>
<li><p>矩阵的索引是列优先，先数第一列，再数第二列。</p>
<ul>
<li>$A_{3*3}$：A(1, 2)&#x3D;A(4)</li>
</ul>
</li>
<li><p>sub2ind（subscript to index）：根据下标获得索引。</p>
<blockquote>
<p>A &#x3D; [1, 2, 3; 4, 5, 6]</p>
<p>D &#x3D; sub2ind(size(A), 1, 2) &#x3D; 4</p>
</blockquote>
</li>
<li><p>ind2sub：根据索引获得下标</p>
</li>
<li><p>利用冒号获得子矩阵</p>
</li>
<li><p>end运算符：表示一维矩阵的末尾元素下标</p>
<blockquote>
<p>A：4*5</p>
<p>D &#x3D; A（end，：）</p>
</blockquote>
</li>
<li><p>删除：赋为空矩阵[]。</p>
</li>
<li><p>reshape：改变行数和列数，不改变元素个数。仍然是列优先</p>
</li>
<li><p>A（:）：把矩阵堆叠为一个列向量</p>
</li>
</ol>
<h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><ol>
<li><p>算术运算：是在矩阵的意义下定义的。</p>
<ol>
<li>加减<ol>
<li>标量可以和矩阵做加减</li>
</ol>
</li>
<li>乘法</li>
<li>除法<ol>
<li>右除（’&#x2F;‘）：如果A是非奇异方阵，则B&#x2F;A &lt;&#x3D;&gt; B*inv(A)</li>
<li>左除（’\‘）：如果B是非奇异方阵，则B&#x2F;A &lt;&#x3D;&gt; inv(B)*A</li>
</ol>
</li>
<li>乘方(^)</li>
<li>点运算<ol>
<li>注意，在表达式运算中要用点运算，否则就变成矩阵相乘了</li>
</ol>
</li>
</ol>
</li>
<li><p>关系运算</p>
<ol>
<li>不等于：~&#x3D;</li>
<li>如果符号两边是矩阵，必须同型，对矩阵中对应标量运算，返回一个01矩阵。注意，不能比较两个矩阵是否相同。</li>
<li>可以一边是标量</li>
</ol>
</li>
<li><p>逻辑运算</p>
<ol>
<li>&amp;，|，~</li>
<li>可以两边是同型矩阵</li>
</ol>
</li>
</ol>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><ol>
<li><p>表示和引用：</p>
<ol>
<li><p>字符串用单引号包裹</p>
</li>
<li><p>字符串内的单引号要用两个来表示</p>
<blockquote>
<p>‘I’’m a student.’</p>
</blockquote>
</li>
<li><p>字符串矩阵</p>
</li>
</ol>
</li>
<li><p>字符串处理和操作：</p>
<ol>
<li>反转：str(end:  -1: 1)</li>
<li>执行：eva(s)。把s的内容作为命令执行</li>
<li>字符和数值的转换：<ol>
<li>abs, double可以把字符串换成ASCII码矩阵</li>
<li>char函数可以反过来</li>
</ol>
</li>
<li>比较：<ol>
<li>直接比较：比较的是字符串中每个字符的ASCII码，关系成立为1，否则为0.</li>
<li>函数：<ol>
<li>strcmp</li>
<li>strncmp</li>
<li>strcmpi：忽略大小写的比较</li>
</ol>
</li>
</ol>
</li>
<li>查找<ol>
<li>findstr(s1, s2)：返回短字符串在长字符串中的起始位置</li>
<li>strrep(s1, s2, s3)：把s1中的s2换成s3</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="第二章-·-矩阵处理"><a href="#第二章-·-矩阵处理" class="headerlink" title="第二章 · 矩阵处理"></a>第二章 · 矩阵处理</h2><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><ol>
<li>通用特殊矩阵<ol>
<li>zeros</li>
<li>ones</li>
<li>eye：生成对角线为1的矩阵，可以不是方阵</li>
<li>rand：生成取值在(0, 1)区间内的随机矩阵</li>
<li>randn：生成方差为1，均值为0的标准正态分布随机矩阵</li>
</ol>
</li>
<li>专门学科的特殊矩阵 <ol>
<li>幻方：magic</li>
<li>范德蒙矩阵：vander(V)</li>
<li>希尔伯特矩阵：<ol>
<li>H(i, j) &#x3D; 1 &#x2F; (i+j-1)</li>
<li>H &#x3D; hilb（n)</li>
</ol>
</li>
<li>多项式伴随矩阵<ol>
<li>伴随矩阵的特征值，是多项式方程的根</li>
<li>compan(p)</li>
<li>p是多项式的系数向量</li>
</ol>
</li>
<li>帕斯卡矩阵<ol>
<li>就是把杨辉三角的顶角放在矩阵左上角。每个元素是其左方、上方元素的和</li>
<li>pascal(n)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><ol>
<li><p>对角阵</p>
<ol>
<li>提取对角阵：<ol>
<li>diag(A)：提取主对角线</li>
<li>diag(A, k)：提取第k条对角线。主对角线向上数为第1、2条，下方为-1、-2条。</li>
</ol>
</li>
<li>构造对角阵<ol>
<li>diag(V)</li>
<li>diag(V, k)</li>
</ol>
</li>
</ol>
</li>
<li><p>三角阵</p>
<ol>
<li><p>提取三角阵</p>
<ol>
<li><p>triu（tri - 三角，u - up）</p>
<blockquote>
<p>triu(A)</p>
<p>triu(A, k)</p>
</blockquote>
</li>
<li><p>tril（tri - 三角，l - low）</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>转置</p>
<ol>
<li>一般转置：.’（是点+单引号）</li>
<li>共轭转置：’ （只有单引号）</li>
</ol>
</li>
<li><p>旋转</p>
<ol>
<li>rot90(A, k)：逆时针旋转k个90度</li>
</ol>
</li>
<li><p>翻转：</p>
<ol>
<li>fliplr(A)（flip - 翻转，l - left，r - right）：左右翻转</li>
<li>flipud(A)：上下翻转</li>
</ol>
</li>
</ol>
<h3 id="矩阵求值"><a href="#矩阵求值" class="headerlink" title="矩阵求值"></a>矩阵求值</h3><ol>
<li>方阵的行列式：det(A)</li>
<li>矩阵的秩：rank(A)</li>
<li>矩阵的迹：trace(A)</li>
<li>范数：<ol>
<li>定义<ol>
<li>1-范数：向量元素的绝对值之和</li>
<li>2-范数：向量元素绝对值的平方和的平方根（像求距离）</li>
<li>无穷大-范数：所有向量元素的最大绝对值</li>
</ol>
</li>
<li>向量的3种常用范数<ol>
<li>norm(V, 1)：求1-范数</li>
<li>norm(V) 或 norm(V, 2)：求2-范数</li>
<li>norm(V, inf)：求无穷大范数</li>
</ol>
</li>
<li>矩阵的范数：从属于向量范数，调用格式相同<ol>
<li>矩阵的1-范数：矩阵列向量1-范数的最大值</li>
<li>矩阵的2-范数：A’A的最大特征值的平方根</li>
<li>矩阵的无穷大范数：行向量的绝对值之和的最大值</li>
</ol>
</li>
</ol>
</li>
<li>条件数：用于描述矩阵性能。条件数等于A的范数乘以inv(A)的范数，总是大于1。越接近1，性能越好。<ol>
<li>cond(A, 1)：1-范数下的条件数</li>
<li>cond(A, 2)</li>
<li>cond(A, inf)</li>
</ol>
</li>
</ol>
<h3 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h3><ol>
<li>特征值与特征向量：<ol>
<li>E &#x3D; eig(A)：得到全部特征值</li>
<li>[X, D] &#x3D; eig(A)：求矩阵的全部特征值，生成对角矩阵D，X的各列为对应的特征向量</li>
</ol>
</li>
<li>几何意义<ol>
<li>eigshow</li>
</ol>
</li>
</ol>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><ul>
<li>是指零元素个数远远大于非零元素个数</li>
</ul>
<ol>
<li>矩阵的存储方式<ol>
<li>完全存储方式：按列完全存储</li>
<li>稀疏存储方式：只存储非零元素的值和位置。也是按列存储</li>
</ol>
</li>
<li>稀疏存储方式的产生：<ol>
<li>full：转换为完全存储</li>
<li>sparse：转换为稀疏存储</li>
</ol>
</li>
</ol>
<h2 id="第三章-·-程序流程控制"><a href="#第三章-·-程序流程控制" class="headerlink" title="第三章 · 程序流程控制"></a>第三章 · 程序流程控制</h2><h3 id="文件的建立与调用"><a href="#文件的建立与调用" class="headerlink" title="文件的建立与调用"></a>文件的建立与调用</h3><ol>
<li><p>分类：</p>
<ol>
<li>脚本文件（能跑的文件）</li>
<li>函数文件</li>
</ol>
<blockquote>
<ul>
<li><p>建立函数文件</p>
<p>​    func C &#x3D; f(A, B)</p>
<p>A，B为输入参数，C为输出参数</p>
</li>
<li><p>调用函数文件</p>
<p>​    &gt;&gt; A &#x3D; [1 2 3]</p>
<p>​    &gt;&gt; B &#x3D; [4 5 6]</p>
<p>​    &gt;&gt; C &#x3D; f(A, B)</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><ol>
<li>输入函数：input</li>
<li>输出函数：disp</li>
<li>程序暂停：pause。接受参数为暂停秒数，若无参数，则暂停至用户按下任意键</li>
</ol>
<h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ol>
<li>if语句可以接矩阵，若矩阵非空且不包含零元素，则条件成立。</li>
<li>swich语句：<ol>
<li>case会自动跳出，即不用break</li>
<li>若有多中取值的情况，用大括号括起来</li>
</ol>
</li>
</ol>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for n = [1 2 3]</span><br></pre></td></tr></table></figure>

<p>n实际上被赋值为列向量，但是这个列向量只有一个元素</p>
</li>
<li></li>
</ol>
<h2 id="第四章-·-绘图"><a href="#第四章-·-绘图" class="headerlink" title="第四章 · 绘图"></a>第四章 · 绘图</h2><h3 id="二维曲线"><a href="#二维曲线" class="headerlink" title="二维曲线"></a>二维曲线</h3><ol>
<li>plot函数<ol>
<li><p>用例：</p>
<ol>
<li>plot(x, y），用坐标画曲线</li>
<li>plot(x)，以元素下标为横坐标，值为纵坐标</li>
</ol>
</li>
<li><p>参数：</p>
<ol>
<li>颜色<ul>
<li>红(r)，绿(g)，蓝(b)，黄(y)，粉红(m)，青(c)，白(w)，黑(k)</li>
</ul>
</li>
<li>线型：<ul>
<li>实线(-)，虚线(- -)，冒号线(:)，点画线(-.)</li>
</ul>
</li>
<li>数据标记点![屏幕截图 2024-10-16 120138](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-16 120138.png)</li>
</ol>
</li>
</ol>
</li>
<li>自适应调整采样间隔的绘图函数：fplot函数<ol>
<li>调用格式<ol>
<li>fplot(f, lims, 选项)：f代表一个函数，通常采用函数句柄的形式。lims代表取值范围。</li>
<li>双参数：fplot(funx, funy,  tlims, 选项)：参数方程可用</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="绘制图形的辅助操作"><a href="#绘制图形的辅助操作" class="headerlink" title="绘制图形的辅助操作"></a>绘制图形的辅助操作</h3><ol>
<li>图形标注：<ol>
<li>图形标题title：用于添加标题<ol>
<li>可以用LaTeX语言，要用大括号括起来</li>
</ol>
</li>
<li>xlabel, ylabel：横纵坐标标签</li>
<li>说明文本text：text(x, y, 文本)。<ol>
<li>gtext：不用手动设置坐标，用鼠标点</li>
</ol>
</li>
<li>legend图例</li>
</ol>
</li>
<li>坐标控制<ol>
<li>axis函数：控制坐标轴范围</li>
<li>grid on &#x2F; off：显示网格线</li>
<li>box on &#x2F; off：显示边框线</li>
</ol>
</li>
<li>图形保持：hold on &#x2F; off：保留原有图像</li>
<li>窗口分割：subplot</li>
</ol>
<h3 id="其他形式的二维曲线"><a href="#其他形式的二维曲线" class="headerlink" title="其他形式的二维曲线"></a>其他形式的二维曲线</h3><ol>
<li>其他坐标下的二维曲线<ol>
<li>对数坐标图<ol>
<li>semilogx &#x2F; semilogy：半对数坐标图。用法和plot一致</li>
<li>loglog：全对数坐标图</li>
</ol>
</li>
<li>极坐标图：polar</li>
</ol>
</li>
<li>统计图<ol>
<li><p>条形类</p>
<ol>
<li><p>柱状统计图</p>
<ol>
<li><p>bar (y, style)</p>
<ol>
<li>y为数据</li>
<li>style分为簇状分组（默认）和柱状分组</li>
</ol>
</li>
<li><p>bar(x, y, style)</p>
</li>
</ol>
</li>
<li><p>直方图</p>
<ol>
<li>hist(y)：y为数据</li>
<li>hist(y, x)： x为指定区间的划分方式，默认为10</li>
<li>rose(theta, x)，theta为角度，x为数据</li>
</ol>
</li>
</ol>
</li>
<li><p>面积类</p>
<ol>
<li><p>扇形图</p>
<ol>
<li>pie(x, explode)</li>
</ol>
</li>
<li><p>面积图</p>
<ol>
<li>area</li>
</ol>
</li>
</ol>
</li>
<li><p>散点类</p>
<ol>
<li><p>散点图：scatter</p>
<ol>
<li>scatter(x, y, 选项, ‘filled’（表示实心点）)</li>
</ol>
</li>
<li><p>阶梯图：stairs</p>
</li>
<li><p>杆图：stem</p>
</li>
</ol>
</li>
<li><p>矢量类</p>
<ol>
<li>罗盘图：compass</li>
<li>羽毛图：feather</li>
<li>箭头图：quiver</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三维绘图-1"><a href="#三维绘图-1" class="headerlink" title="三维绘图"></a>三维绘图</h3><ol>
<li>plot3函数</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/PA%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/PA%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">PA实验课笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-·-C语言拾遗"><a href="#第一章-·-C语言拾遗" class="headerlink" title="第一章 · C语言拾遗"></a>第一章 · C语言拾遗</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>宏（#define）和引用(#include)的本质是复制粘贴。在预编译的时候会把目标文件或宏定义粘贴到对应位置。</li>
<li>堆栈：在一个程序的进程空间中，栈是由高地址向低地址生长，堆则是由低向高。</li>
<li>从下往上的相对位置为：代码区，数据区，堆，栈</li>
</ol>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>源文件.c —预编译(-E)—&gt; .i —编译(-S)—&gt; .s —汇编(-c)—&gt; .o —链接—&gt; .out</p>
<ol>
<li>预编译：预编译的时候会把引用的目标文件和宏定义粘贴到对应位置。</li>
<li>链接：你的一些函数的实现在其他文件中，编译时找不到函数定义的入口，故用0来占位。链接之后把多个文件拼接成了.out文件，并把地址的偏移量填入，此过程称为重定位。这种方法是静态连接。<ul>
<li>动态链接的理解：如果我有多个进程，每个进程都要调用同一个函数，如果用静态连接的话，每一次都要把他写入ELF中，占用资源。动态链接就把函数放在了一个lib文件中，每次调用时调用其指向的函数即可。</li>
</ul>
</li>
<li>ELF文件：</li>
</ol>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol>
<li><p>mov：它的作用是将数据从源操作数复制到目的操作数。</p>
<ul>
<li><p>后缀：</p>
<ul>
<li><code>movb</code> 代表字节（8 位）</li>
<li><code>movw</code> 代表字（16 位）</li>
<li><code>movl</code> 代表双字（32 位，long）</li>
<li><code>movq</code> 代表四字（64 位，quad）</li>
</ul>
</li>
<li><p>例子：</p>
<ul>
<li>movl $10, %eax    ; 将立即数 10 加载到寄存器 eax</li>
<li>movl %eax, -4(%rbp) ; 将 eax 的值存入栈中的偏移 -4 的位置</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>push</code></strong>：将数据压入栈。</p>
</li>
<li><p><strong><code>pop</code></strong>：从栈中弹出数据。</p>
</li>
<li><p><strong><code>cmp</code></strong>：比较两个操作数。</p>
</li>
<li><p><strong><code>je</code></strong>：如果相等则跳转（zero flag 为 1）</p>
</li>
<li><p><strong><code>jg</code></strong>：如果大于则跳转。</p>
</li>
<li><p><strong><code>call</code></strong>：调用子程序</p>
</li>
<li><p><strong><code>ret</code></strong>：从子程序返回。</p>
</li>
<li><p><strong><code>nop</code></strong>：无操作，通常用于占位或对齐。</p>
</li>
<li><p><strong><code>int</code></strong>：调用中断，用于系统调用等操作。</p>
</li>
</ol>
<h3 id="特殊变量名"><a href="#特殊变量名" class="headerlink" title="特殊变量名"></a>特殊变量名</h3><ol>
<li><p>rbg：基址指针（Base Pointer）</p>
</li>
<li><p>edi：默认为函数的第一个参数</p>
</li>
<li><p>寄存器层次结构</p>
<p>在 x86 架构中，寄存器分为不同的宽度，以处理不同位数的数据。</p>
<ul>
<li><code>RAX</code> 是 64 位寄存器。</li>
<li><code>EAX</code> 是 <code>RAX</code> 的低 32 位。</li>
<li><code>AX</code> 是 <code>EAX</code> 的低 16 位。</li>
<li><code>AH</code> 和 <code>AL</code> 分别是 <code>AX</code> 的高 8 位和低 8 位</li>
</ul>
</li>
</ol>
<h1 id="第二章-·"><a href="#第二章-·" class="headerlink" title="第二章 ·"></a>第二章 ·</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h3><ol>
<li>符号”–”表示要把后面的参数当作文件名</li>
<li></li>
</ol>
<h1 id="第-章-·"><a href="#第-章-·" class="headerlink" title="第  章 ·"></a>第  章 ·</h1><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ol>
<li>内存空间：<img src="/home/mukongshan/.config/Typora/typora-user-images/image-20241023145612193.png" alt="image-20241023145612193"><ol>
<li>栈空间</li>
</ol>
</li>
<li>反序压栈：反序压栈（reverse stack pushing）通常是指在调用函数时，将参数或局部变量按照从高地址到低地址的顺序压入栈中。这样可以方便地管理函数的参数和返回地址。<ol>
<li><strong>从栈顶开始</strong>：首先确定栈指针（<code>sp</code>）的初始位置。</li>
<li><strong>逆序压入参数</strong>：如果函数有多个参数，可以从最后一个参数开始压栈。比如，对于一个接受三个参数的函数，可以按如下顺序压栈：<ul>
<li><code>push arg3</code></li>
<li><code>push arg2</code></li>
<li><code>push arg1</code></li>
</ul>
</li>
</ol>
</li>
<li>调用过程：<ol>
<li>反序压栈，压入参数</li>
<li>返回位置入栈</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
