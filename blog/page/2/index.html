<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"ebc5f2cd8493752a92129fa16b4bf1635308b0d6","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="kongshan&#39;s blog">
<meta property="og:url" content="https://kongshan.me/blog/page/2/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kongshan.me/blog/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"blog/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">kongshan's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Linux系统基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安装Linux虚拟机"><a href="#安装Linux虚拟机" class="headerlink" title="安装Linux虚拟机"></a>安装Linux虚拟机</h1><ol>
<li>~$ sudo apt update</li>
<li>~$ sudo apt upgrade</li>
<li>~$ sudo apt install openssh-server</li>
</ol>
<h1 id="ubuntu终端知识点"><a href="#ubuntu终端知识点" class="headerlink" title="ubuntu终端知识点"></a>ubuntu终端知识点</h1><ol>
<li>解释器为shell</li>
<li>三种指令格式：<ol>
<li>“&#x2F;usr&#x2F;ubuntu&#x2F;date”：绝对路径下的命令</li>
<li>“.&#x2F;date”：当前路径下的命令</li>
<li>“date”：从环境变量中找命令</li>
</ol>
</li>
<li>家目录快捷：’~’可以代替家目录</li>
<li>Linux指令是不可逆的，所以要养成备份的习惯，现在用git很方便</li>
<li>r：可读，w：可写，x：可执行·</li>
<li>对于一个文件，对其父目录可写，才可以删除这个文件</li>
<li>想要打开一个文件，必须对其所有上级目录可执行</li>
<li>重定向：e.g. echo hello &gt; file.txt，使得hello不输出到屏幕，而是写入file中去。e.g. cat &lt; hello.txt，使得cat不再等待键盘输入，而是读hello文件。e.g. echo &gt;&gt; file.txt，追加内容，而非覆盖</li>
<li>管道：’ | ‘ 将一个程序的输出和另一个程序的输入连接起来。注意，有的指令不接受输入，而是接受参数，直接把它串起来是没有用的。</li>
<li>对于一条程序指令，要搞清楚哪部分是命令去完成的，哪部分是由shell完成的。e.g. sudo echo 1 &gt; text.txt 其中sudo让echo指令以超级用户的身份运行，但是重定向&gt;是由shell完成的，所以如果身份权限不够，即使用了sudo也无法完成。</li>
<li>缓存：就是打开的文件</li>
<li>Linux 系统中，文件的格式并不是由文件名或文件扩展名决定的，而是由文件的内容和用来打开文件的程序决定的。后缀只是用来方便用户使用。</li>
<li>shell只能做整数计算，用库bc做小数运算</li>
</ol>
<h2 id="和windows的区别"><a href="#和windows的区别" class="headerlink" title="和windows的区别"></a>和windows的区别</h2><ol>
<li>文件系统：Linux是从根目录开始的树状结构，而windows是先分区</li>
<li>目录符号：Linux是正斜杠’&#x2F; ‘，Windows是反斜杠’\ ‘</li>
</ol>
<h1 id="Linux部分基础指令"><a href="#Linux部分基础指令" class="headerlink" title="Linux部分基础指令"></a>Linux部分基础指令</h1><ol>
<li>echo：回显</li>
<li>which：可以搜索到命令的位置（内置命令搜不到）</li>
<li>type：可以搜索到命令的位置和属性（包括内置命令）</li>
<li>pwd：打印目录（print working directory)</li>
<li>cd：切换路径</li>
<li>ls：列出目录（白色是文件，蓝色是文件夹，灰色是其他）</li>
<li>man：查手册（如：man ls）</li>
<li>–help：查帮助</li>
<li>tldr：快速查询（too long don’t read）</li>
<li>cat：查看文件（全部输出）</li>
<li>less：查看文件（一页一页看）</li>
<li>mv：重命名或移动</li>
<li>cp：复制</li>
<li>rm：删除文件</li>
<li>rmdir：删除空文件夹（-r：删除文件夹包括文件，-i 提示我是否删除）</li>
<li>Ctrl+l：清屏</li>
<li>重定向：<ol>
<li>e.g. echo hello &gt; file.txt，使得hello不输出到屏幕，而是写入file中去。</li>
<li>e.g. cat &lt; hello.txt，使得cat不再等待键盘输入，而是读hello文件。</li>
<li>e.g. echo &gt;&gt; file.txt，追加内容，而非覆盖</li>
</ol>
</li>
<li>xargs：把输入参数化，传给后面的命令</li>
<li>tail：展示最后的部分（默认是十行，-n1 改为一行）</li>
<li>sudo -i：模拟超级用户登录过程，环境变量变了</li>
<li>sudo su：切换为超级用户，但是你的环境变量没有变</li>
<li>tee：接受一个文件作为参数，把输入写入文件（-a 表示追加）</li>
<li>grep：查找文件内容。<ol>
<li>递归搜索目录：grep -R test .</li>
<li>获取匹配文本的上下文：grep -C 2 test *</li>
<li>输出不匹配的结果：grep -v test file</li>
</ol>
</li>
<li>wc：统计输出内容数据（-l 行数）</li>
<li>find：查找。e.g. 删除当前目录下后缀为.tmp的所有文件：find . -name ‘*.tmp’ -exec rm {} ;  。</li>
<li>history：列出历史记录（结合|，grep灵活应用）注：在命令前加一个空格，该命令就不会被记录。</li>
<li>！：<ol>
<li>！！：执行上一条命令</li>
<li>！cd：执行上一条cd命令</li>
</ol>
</li>
<li>Ctrl+r：进入搜索模式。</li>
<li>sed：文件内容的查找和替换。<ol>
<li>替换规则：sed -E ‘s&#x2F;查找的内容&#x2F;替换的内容&#x2F;‘（最后加个g表示持续替换）（-E表示让命令能够支持最新的正则表达式）</li>
<li>（somethong）称为捕获组，可以用 \1 表示第一捕获组的内容（如果有）。</li>
</ol>
</li>
<li>sort：<ol>
<li>不带参数：按字母顺序排序</li>
<li>-nk1,1：按照数值排序，关键词为第一个字段</li>
</ol>
</li>
<li>uniq：唯一化（只会检测相邻行，所以一般和sort联用）</li>
<li>awk：e.g. awk ‘{print $2}’ 打印第二个字段的内容</li>
<li>paste：粘贴。（-s，变为单行输出，“d，”表示用逗号分隔）</li>
<li>cut</li>
<li>tr：<ol>
<li>e.g. tr “[:upper:]” “[:lower:]” 大写转小写</li>
</ol>
</li>
<li>改变权限：chmod<ol>
<li>数字授权：r w x 分别赋予数字4 2 1，权限就是他们的总和</li>
<li>获权方：u拥有者，g同组成员（group），o其他组（other），a所有人（all）</li>
<li>示例：有权限-rwxrw-r–，前三位是拥有者，中三位是同组员，后三位是其他组</li>
<li>示例：chmod u&#x3D;rwx file,    chmod 764 file</li>
</ol>
</li>
<li>alias：取别名。e.g.  alias ll&#x3D;”ls -l”</li>
<li>time：得出命令运行的时间（为什么real &gt; user + sys ?因为还有其他程序在运行）</li>
</ol>
<h1 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h1><h2 id="vim基础"><a href="#vim基础" class="headerlink" title="vim基础"></a>vim基础</h2><h3 id="五大模式"><a href="#五大模式" class="headerlink" title="五大模式"></a>五大模式</h3><ol>
<li>正常模式</li>
<li>插入模式</li>
<li>可视化模式</li>
<li>命令模式</li>
<li>替换模式</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ol>
<li>用’ : ‘打开。</li>
<li>w：保存</li>
<li>q：退出</li>
<li>sp：水平分屏</li>
<li>vsp：上下分屏</li>
<li>Ctrl+w：切换窗口</li>
<li>tabnew：新建标签</li>
<li>tabnext &#x2F; tabn：下一个标签（或者快捷键gt）</li>
</ol>
<h4 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h4><ol>
<li>&#x2F; key :向后搜索</li>
<li>? key：向前搜索</li>
<li>[c+b]：向后翻页</li>
<li>[c+f]：向前翻页</li>
<li>e：单词末尾</li>
<li>b：前一个单词</li>
<li>（修饰语）i：内部 e.g.  ci( ：修改前方小括号内容</li>
<li>（修饰语）a：周围 e.g. da’  ：删除周围的单引号</li>
</ol>
<h1 id="shell脚本语法"><a href="#shell脚本语法" class="headerlink" title="shell脚本语法"></a>shell脚本语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>赋值时不要空格</p>
</li>
<li><p>获取变量：$foo</p>
</li>
<li><p>引号：单引号输出字面，双引号会取值。</p>
<p>“$foo” &#x3D;&#x3D;&gt; value, ‘$foo’ &#x3D;&#x3D;&gt; $foo</p>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ol>
<li>$?：查看上一个程序的退出状态。（0为成功，1为失败）</li>
<li></li>
</ol>
<h2 id="命令替换和进程替换"><a href="#命令替换和进程替换" class="headerlink" title="命令替换和进程替换"></a>命令替换和进程替换</h2><ol>
<li>foo&#x3D;$(pwd)</li>
<li>echo $foo</li>
<li>diff &lt;(ls) &lt;(ls ..)</li>
</ol>
<h2 id="通配"><a href="#通配" class="headerlink" title="通配"></a>通配</h2><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>见基础指令24~行</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li>. ：除换行符之外的任意单个字符 </li>
<li>*：匹配前面字符零次或多次 </li>
<li>+：匹配前面字符一次或多次</li>
<li>[abc]： 匹配 a、b、c 中的任意一个</li>
<li>？：匹配零次或一次</li>
<li>(RX1|RX2): 任何能够匹配RX1或RX2的结果</li>
<li>^ 行首 $ 行尾</li>
<li>{4}：重复4次</li>
</ol>
<p>注意：正则匹配都是“贪婪匹配”，即匹配的越多越好，所以会匹配到最后一个</p>
<p>第三天的课堂练习一定要掌握</p>
<h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><h2 id="signal信号"><a href="#signal信号" class="headerlink" title="signal信号"></a>signal信号</h2><ol>
<li>SIGQUIT：终止程序执行并生成一个核心转储。Ctrl+\。</li>
<li>SIGINT：中断程序。Ctrl+c。（与SIGTERM的区别在于可以用键盘发出）</li>
<li>SIGHUB：默认行为是Term行为，在退出时触发，终止所有程序。</li>
<li>SIGSTOP：Stop行为，暂停程序。</li>
<li>SIGCONT：Cont行为，继续程序。</li>
<li>SIGKILL：Term行为，</li>
<li>SIGTERM：通过kill命令发送，终止程序执行</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="守护进程（服务进程）"><a href="#守护进程（服务进程）" class="headerlink" title="守护进程（服务进程）"></a>守护进程（服务进程）</h3><ol>
<li>概念：在后台运行的程序。</li>
<li>执行方法：<ol>
<li>Ctrl+z。</li>
<li>“cmd &amp;”。</li>
<li>job：查看进程</li>
<li>“bg %1”：让第一个进程开始</li>
<li>“fg %1”：让第一个任务停止</li>
<li>“kill -STOP %1”：暂停</li>
<li>“kill -CONT %1”：继续</li>
<li>“kill -HUB %1”：终止</li>
<li>“nohub cmd”：让程序不接受HUB信号，退出终端时不会停止。</li>
<li>“kill -KILL”：强制终止。</li>
</ol>
</li>
</ol>
<h1 id="终端和后台分离"><a href="#终端和后台分离" class="headerlink" title="终端和后台分离"></a>终端和后台分离</h1><p>终端多路复用器：流行的是tmux</p>
<h2 id="tmux知识"><a href="#tmux知识" class="headerlink" title="tmux知识"></a>tmux知识</h2><ol>
<li>会话–&gt;窗口–&gt;面板</li>
<li>会话：</li>
<li>窗口：</li>
</ol>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><ol>
<li>tmux new –s NAME 以指定名称开始一个新的会话</li>
<li>tmux ls 列出当前所有会话 </li>
<li>&lt;C+b&gt; d ：在tmux中按下该组合键，将当前会话分离</li>
<li>tmux a 重新连接最后一个会话，可以通过-t参数指定具体的会话</li>
</ol>
<h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><ol>
<li>&lt;C+b&gt; c： 创建一个新的窗口</li>
<li>&lt;C+b&gt;  p： 切换到上一个窗口 </li>
<li>&lt;C+b&gt;  n： 切换到下一个窗口 </li>
<li>&lt;C+b&gt;  ,： 重命名当前窗口 </li>
<li>&lt;C+b&gt;  w ：列出当前所有窗口</li>
</ol>
<h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><ol>
<li>&lt;C+b&gt; “ ：水平分割 </li>
<li>&lt;C+b&gt;  % ：垂直分割 </li>
<li>&lt;C+b&gt;  &lt;方向键&gt; ：切换到指定方向的面板 </li>
<li>&lt;C+b&gt;  z ：切换当前面板的缩放 </li>
<li>&lt;C+b&gt;  &lt;空格&gt; ：在不同的面板布局间切换</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/PA%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/PA%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">PA小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><ol>
<li>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?<ul>
<li>在 NEMU 项目中的 cmd_c() 函数调用 cpu_exec(-1) 时，传入的 -1 参数表示让模拟器持续执行指令，直到某种停止条件（如断点或异常）发生。</li>
</ul>
</li>
</ol>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ol>
<li><p>用gdb调试NEMU：</p>
<ul>
<li>在nemu下执行make gdb</li>
<li>在一个高度较高的窗口中运行GDB后, 输入<code>layout split</code>就可以切换到TUI, 这样你就可以同时从源代码和指令的角度来观察程序的行为了.</li>
</ul>
</li>
<li><p>core文件：放在了&#x2F;tmp里面</p>
<ol>
<li>用gdb分析：格式gdb &lt;可执行程序&gt; &lt;核心转储文件&gt;</li>
</ol>
</li>
<li><p>RISC-32的指令格式</p>
<p>![截图 2024-10-22 12-00-03](&#x2F;home&#x2F;mukongshan&#x2F;图片&#x2F;截图&#x2F;截图 2024-10-22 12-00-03.png)</p>
<p>完整opcode编码表</p>
<p><img src="/home/mukongshan/.config/Typora/typora-user-images/image-20241022120735922.png" alt="image-20241022120735922"></p>
</li>
</ol>
<h1 id="NEMU结构"><a href="#NEMU结构" class="headerlink" title="NEMU结构"></a>NEMU结构</h1><h2 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><ol>
<li>word_t：表示与ISA字长等长的无符号类型, 在32位的ISA中为<code>uint32_t</code>, 在64位的ISA中为<code>uint64_t</code>.</li>
<li>sword_t：表示与ISA字长等长的有符号类型, 在32位的ISA中为<code>int32_t</code>, 在64位的ISA中为<code>int64_t</code></li>
<li>char *FMT_WORD：word_t<code>类型对应的十六进制格式化说明符, 在32位的ISA中为</code>“0x%08x”<code>, 在64位的ISA中为</code>“0x%016lx”</li>
<li>CPU_state cpu：寄存器结构的全局定义.</li>
</ol>
<h3 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h3><ul>
<li>涉及到了很多宏，详见手册RTFSC（2）</li>
</ul>
<ol>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; ISADecodeInfo;</span><br><span class="line">用于存放ISA相关的译码信息, 会嵌入在译码信息结构体Decode的定义中.</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>INSTPAT</code>：(意思是instruction pattern)是一个宏(在<code>nemu/include/cpu/decode.h</code>中定义), 它用于定义一条模式匹配规则. 其格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Decode：</p>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Decode &#123;                                   </span><br><span class="line">   vaddr_t pc;                                </span><br><span class="line">   vaddr_t snpc; // static next pc</span><br><span class="line">   vaddr_t dnpc; // dynamic next pc</span><br><span class="line">   ISADecodeInfo isa;        </span><br><span class="line">   IFDEF(CONFIG_ITRACE, char logbuf[128]);</span><br><span class="line">&#125; Decode;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><h3 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h3><ol>
<li><p>engin</p>
<ul>
<li><p>cpu_exec: 模拟cpu执行命令。包括检查nemu_state。参数n表示要执行的代码量。若n&#x3D;-1，则意思是让cpu一直执行下去，直到某种停止条件。</p>
<ul>
<li>exec_once: 执行一次命令。</li>
</ul>
</li>
<li><p>sdb_loop：负责调试机的运行，包括读取指令</p>
<ul>
<li><p>rl_gets：读取字符串</p>
</li>
<li><p>cmd_c: 继续（continue）的意思。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getopt_long: <code>getopt_long</code> 是一个 C 语言标准库函数，用于解析命令行参数。与 <code>getopt</code> 不同的是，它支持 <strong>长选项</strong>（如 <code>--option</code>）以及短选项（如 <code>-o</code>）。长选项非常适合复杂的命令行工具，使选项的含义更具可读性。</p>
<ol>
<li><p>参数</p>
<ul>
<li><p><strong><code>argc</code></strong>: 参数个数（通常来自 <code>main</code> 函数的 <code>argc</code>）。</p>
</li>
<li><p><strong><code>argv</code></strong>: 参数列表（通常来自 <code>main</code> 函数的 <code>argv</code>）。</p>
</li>
<li><p><strong><code>optstring</code></strong>: 短选项的字符串定义，每个字符表示一个选项。如果某个选项需要参数，在其后加上 <code>:</code>（如 <code>-f filename</code>）。</p>
</li>
<li><p><strong><code>longopts</code></strong>: 长选项的定义，是一个 <code>struct option</code> 类型的数组，每个选项有四个字段：</p>
<ol start="2">
<li>返回值：</li>
</ol>
<ul>
<li>如果解析到短选项或长选项，则返回选项对应的字符（短选项）或 <code>val</code>（长选项）。</li>
<li>如果遇到非选项参数，返回 <code>1</code>。</li>
<li>当所有参数解析完毕时，返回 <code>-1</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>paddr.c：内存相关的函数</p>
<ol>
<li>paddr_read：接受一个起始地址和长度，读取内存</li>
<li>paddr_write</li>
<li>guest_to_host：地址映射</li>
</ol>
</li>
</ol>
<h3 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2"></a>PA2</h3><ol>
<li><figure class="highlight plaintext"><figcaption><span>isa_exec_once(Decode *s);</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int isa_exec_once(Decode *s);</span><br><span class="line">取出s-&gt;pc指向的指令并译码执行, 同时更新s-&gt;snpc.</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h1 id="gdb用法"><a href="#gdb用法" class="headerlink" title="gdb用法"></a>gdb用法</h1><ol>
<li><p>启动GDB</p>
<ul>
<li><p>用-g：<br>gcc -g -o myprogram myprogram.c</p>
</li>
<li><p>用-ggdb：<br>gcc -ggdb -o myprogram myprogram.c</p>
</li>
</ul>
</li>
<li><p>启动GDB：</p>
<p>gdb .&#x2F;myprogram</p>
</li>
<li><p>常用命令:</p>
<ol>
<li>运行程序：<br>run 或 r：启动程序。<br>run <args>：带参数启动程序，例如 run arg1 arg2。</li>
<li>设置断点：<br>break <line>：在指定行设置断点，例如 break 10。<br>break <function>：在指定函数设置断点，例如 break main。<br>break <file>:<line>：在指定文件的指定行设置断点，例如 break main.c:10。</li>
<li>查看断点：<br>info breakpoints：列出所有断点。</li>
<li>删除断点：<br>delete <breakpoint_number>：删除指定编号的断点。<br>delete：删除所有断点。</li>
<li>单步执行：<br>next 或 n：执行下一行（不会进入函数）。<br>step 或 s：执行下一行（会进入函数）。<br>continue 或 c：继续执行程序直到下一个断点。</li>
<li>查看代码：<br>list 或 l：显示当前代码段。<br>list <line>：显示指定行附近的代码。<br>list <function>：显示指定函数的代码。</li>
<li>打印变量：<br>print <variable> 或 p <variable>：打印变量的值。<br>print&#x2F;x <variable>：以十六进制显示变量值。</li>
<li>查看栈信息：<br>backtrace 或 bt：查看当前函数调用栈。<br>frame <frame_number>：切换到指定的栈帧，例如 frame 2。<br>info frame：查看当前栈帧的信息。</li>
<li>查看变量：<br>info locals：查看当前栈帧中的局部变量。<br>info variables：查看所有变量。</li>
<li>修改变量：<br>set variable <variable>&#x3D;<value>：修改变量值，例如 set variable x&#x3D;10。</li>
<li>退出GDB：<br> quit 或 q：退出GDB。</li>
<li>其他技巧<br>  条件断点：使用 condition <breakpoint_number> <condition>，例如 condition 1 x&#x3D;&#x3D;5。<br>  断点命令：使用 commands <breakpoint_number> 在指定断点触发时执行命令。</li>
</ol>
</li>
</ol>
<h1 id="gcc用法"><a href="#gcc用法" class="headerlink" title="gcc用法"></a>gcc用法</h1><ol>
<li>基本编译命令<ol>
<li>编译一个 C 源文件生成可执行文件:<br>gcc -o program main.c</li>
<li>编译多个源文件并生成一个可执行文件：<br>gcc -o program main.c utils.c</li>
<li>将源文件编译为目标文件（.o 文件），而不是直接生成可执行文件：<br>gcc -c main.c<br>gcc -c utils.c</li>
<li>将多个目标文件链接成一个可执行文件：<br>gcc -o program main.o utils.o</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">互联网计算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第零章-·-计算机网络及其参考模型"><a href="#第零章-·-计算机网络及其参考模型" class="headerlink" title="第零章 · 计算机网络及其参考模型"></a>第零章 · 计算机网络及其参考模型</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>LAN（局域网，Local Area Networks）</li>
<li>WLAN（无线局域网， Wireless Local Area Networks)</li>
<li>WAN（广域网，Wide Area Networks）</li>
<li>NAP（网络接入点，network access point）</li>
<li>ISP  (互联网服务提供商，Internet Service Provider)</li>
<li>Modem（调制解调器） 调制解调器用于将数字信号和模拟信号之间相互转换。它在数字设备（如计算机）与模拟通信线路（如电话线）之间充当桥梁。</li>
<li>CSU &#x2F; DSU（通道服务单元 &#x2F; 数据服务单元）：CSU&#x2F;DSU设备用于将局域网与广域网连接，通常用于专用数据线路（如T1、E1线路）。它在数字信号和物理线路之间进行信号匹配。</li>
<li>TA &#x2F; NT1（终端适配器 &#x2F; 网络终端1）：TA&#x2F;NT1是ISDN（综合业务数字网）中的设备，用于连接ISDN终端设备（如电话、计算机）与ISDN网络。</li>
<li>Ethernet（以太网）</li>
<li>ISDN（综合业务数字网）：ISDN提供数字传输服务，能够同时传输语音、视频和数据。</li>
<li>RFC：RFC（Request for Comments）文档是一系列正式的文档，用于描述互联网技术和协议的标准、建议、方法和创新。</li>
<li>TCP(传输控制协议，Transmission Control Protocol) ***</li>
<li>UDP（用户数据报协议，Uesr Datagram Protocol）</li>
<li>IP（互联网协议，Internet Protocol) ***</li>
<li>HTTP （超文本传输协议，Hypertext  Transfer Protocol）***</li>
<li>SMTP （简单邮件传输协议，Simple Mail  Transfer protocol ）***</li>
<li>DNS （域名系统，Domain Name  System）***</li>
<li>TFTP （简单文件传输协议，Trivial File Transfer Protocol）***</li>
</ol>
<h2 id="互联网发展的三个阶段"><a href="#互联网发展的三个阶段" class="headerlink" title="互联网发展的三个阶段"></a>互联网发展的三个阶段</h2><ol>
<li>从单个网络ARPAnet向互联网发展。<ol>
<li>1969年ARPAnet诞生</li>
<li>1983年TCP&#x2F;IP协议成为ARPAnet的标准协议。这使得所有使用TCP&#x2F;IP协议的计算机都可以通过互联网通信。<ul>
<li>1983年互联网诞生</li>
</ul>
</li>
</ol>
</li>
<li>建成三级结构的互联网<ol>
<li>1986年围绕六个大型计算机中心建设计算机网络，即NSFnet</li>
<li>分为主干网，地区网和校园网（或企业网）</li>
<li>1990年ARPAnet退役</li>
</ol>
</li>
<li>形成多层次ISP结构的互联网</li>
</ol>
<h2 id="基于ISP的三层结构"><a href="#基于ISP的三层结构" class="headerlink" title="基于ISP的三层结构 ***"></a>基于ISP的三层结构 ***</h2><p>主干ISP &lt;–&gt; 第二层ISP &lt;–&gt; 本地ISP &lt;–&gt; 主机</p>
<h2 id="OSI模型的七个层次"><a href="#OSI模型的七个层次" class="headerlink" title="OSI模型的七个层次 ***"></a>OSI模型的七个层次 ***</h2><ol>
<li><strong>物理层（Physical Layer）</strong><ul>
<li><strong>功能</strong>: 定义硬件设备和传输介质的物理特性，如电缆、网络接口、信号电平等。</li>
<li><strong>例子</strong>: 以太网电缆、光纤、无线电波。</li>
</ul>
</li>
<li><strong>数据链路层（Data Link Layer）</strong><ul>
<li><strong>功能</strong>: 负责在物理层之上建立、维护和断开物理链路（介质访问控制？），处理帧的错误检测和纠正。</li>
<li><strong>例子</strong>: 以太网协议（Ethernet）、Wi-Fi协议（IEEE 802.11）。</li>
</ul>
</li>
<li><strong>网络层（Network Layer）</strong><ul>
<li><strong>功能</strong>: 负责数据包的路由和转发（跨链路的），选择数据传输的路径（由中间设备处理），处理逻辑地址（如IP地址）。</li>
<li><strong>例子</strong>: IP协议（Internet Protocol）、ICMP协议（Internet Control Message Protocol）。</li>
</ul>
</li>
<li><strong>传输层（Transport Layer）</strong><ul>
<li><strong>功能</strong>: 提供端到端的通信服务，确保数据的可靠性和完整性（由终端判断可靠性），处理数据的分段和重组。</li>
<li><strong>例子</strong>: TCP协议（Transmission Control Protocol）、UDP协议（User Datagram Protocol）。</li>
</ul>
</li>
<li><strong>会话层（Session Layer）</strong><ul>
<li><strong>功能</strong>: 管理应用程序之间的会话，处理会话的建立、管理和终止，支持会话恢复和同步。</li>
<li><strong>例子</strong>: 会话恢复协议（Session Initiation Protocol, SIP）。</li>
</ul>
</li>
<li><strong>表示层（Presentation Layer）</strong><ul>
<li><strong>功能</strong>: 负责数据的格式化和转换，确保不同系统之间的数据能够被正确解释和显示。</li>
<li><strong>例子</strong>: 数据加密（如SSL&#x2F;TLS）、数据压缩。</li>
</ul>
</li>
<li><strong>应用层（Application Layer）</strong><ul>
<li><strong>功能</strong>: 提供网络服务和应用程序之间的接口，处理用户直接交互的数据。</li>
<li><strong>例子</strong>: HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）。</li>
</ul>
</li>
</ol>
<h2 id="OSI模型的作用"><a href="#OSI模型的作用" class="headerlink" title="OSI模型的作用"></a>OSI模型的作用</h2><ul>
<li><strong>标准化</strong>: 提供一个标准化的框架，使不同设备和系统能够通过通用的协议进行互操作。</li>
<li><strong>分层管理</strong>: 通过分层结构，简化了网络通信的复杂性，使得问题的排查和协议的开发变得更加容易。</li>
<li><strong>协议互通</strong>: 各层协议可以独立开发和更新，而不影响其他层的功能。</li>
</ul>
<p>OSI模型帮助网络工程师和开发人员理解和设计网络系统，使得网络协议和设备的互操作性得以实现。</p>
<h2 id="LAN（局域网）-WAN（广域网）"><a href="#LAN（局域网）-WAN（广域网）" class="headerlink" title="LAN（局域网）&#x2F; WAN（广域网）"></a>LAN（局域网）&#x2F; WAN（广域网）</h2><ol>
<li>局域网（LANs）<ol>
<li>在本地操作（覆盖小范围区域）</li>
<li>支持多用户访问</li>
<li>预期具有较高的速度（可达Gbps&#x2F;10Gbps）</li>
<li>错误率容易控制</li>
</ol>
</li>
<li>广域网（WANs）<ol>
<li>在更大范围内操作</li>
<li>通过串行链路、光纤链路等进行访问</li>
<li>传统上速度较低</li>
<li>错误率不易控制</li>
</ol>
</li>
</ol>
<h2 id="LAN-Device"><a href="#LAN-Device" class="headerlink" title="LAN Device"></a>LAN Device</h2><ol>
<li><p>集线器（hub）</p>
<ol>
<li><p>功能: 集线器是最简单的网络连接设备，用于将多台设备（如计算机、打印机等）连接在一起，形成一个局域网。</p>
</li>
<li><p>工作方式: 它在物理层（OSI模型第1层）工作，将接收到的数据广播到所有连接的端口，而不区分目标设备。</p>
</li>
</ol>
</li>
<li><p>网桥（Bridge）</p>
<ol>
<li><p>功能: 网桥用于将两个或多个局域网连接起来，并对数据流进行过滤和转发。它能分隔网络，减少冲突域。</p>
</li>
<li><p>工作方式: 在数据链路层（OSI模型第2层）工作，根据设备的MAC地址表转发数据包，从而减少不必要的数据广播。</p>
</li>
</ol>
</li>
<li><p>交换机（Switch）</p>
<ol>
<li><p>功能: 交换机是高级的集线器，用于在多个设备之间高效地转发数据。它是局域网的核心设备。</p>
</li>
<li><p>工作方式: 在数据链路层（OSI模型第2层）工作，利用MAC地址表智能地将数据帧发送到目标设备的端口。高端交换机也支持网络层（第3层）功能，如VLAN和路由。</p>
</li>
</ol>
</li>
<li><p>路由器（Router）</p>
<ol>
<li><p>功能: 路由器用于连接不同的网络（如LAN与WAN），并在它们之间转发数据包。它是互联网连接的核心设备。</p>
</li>
<li><p>工作方式: 在网络层（OSI模型第3层）工作，根据IP地址进行数据包的路由选择。可以执行更复杂的任务，如NAT（网络地址转换）、防火墙功能和VPN支持。</p>
</li>
</ol>
</li>
</ol>
<ul>
<li>注：高层设备可以识别底层设备的信号（数据逻辑），反之不行。</li>
</ul>
<h2 id="Data-Packets"><a href="#Data-Packets" class="headerlink" title="Data Packets"></a>Data Packets</h2><ol>
<li><p>为了传输，计算机数据通常被分割成小且易于传输的单元。在OSI模型中，这些单元可以被称为数据包、帧或段。（赛博快递）</p>
</li>
<li><p>为什么使用数据包？</p>
<ol>
<li>计算机可以轮流发送数据包。</li>
<li>如果数据包丢失，只需重新传输少量数据。</li>
<li>数据可以通过不同的路径传输。</li>
</ol>
</li>
<li><p>段放在包中，包放在帧中（段&lt;包&lt;帧）</p>
</li>
<li><p>数据包（Packets）</p>
</li>
</ol>
<ul>
<li><strong>所在层</strong>: 网络层（第3层）</li>
<li><strong>作用</strong>: 数据包是在网络层处理的数据单元，用于在网络间进行路由和传输。它们包含网络层的头部信息，包括源和目的IP地址，用于决定数据的传输路径。</li>
<li>组成:<ul>
<li><strong>头部（Header）</strong>: 包含源IP地址、目的IP地址和其他路由信息。</li>
<li><strong>数据（Payload）</strong>: 传输的数据内容，可能是从传输层传递下来的段。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>帧（Frames）</li>
</ol>
<ul>
<li><strong>所在层</strong>: 数据链路层（第2层）</li>
<li><strong>作用</strong>: 帧是数据链路层的基本传输单元，负责在局域网内的物理传输，包括错误检测和帧的同步。帧通过链路层协议，如以太网，进行局部网络的通信。</li>
<li>组成:<ul>
<li><strong>头部（Header）</strong>: 包含源MAC地址、目的MAC地址等信息，用于确定帧在局域网中的传输路径。</li>
<li><strong>数据（Payload）</strong>: 包含来自网络层的数据包。</li>
<li><strong>尾部（Trailer）</strong>: 包含错误检测信息（如CRC），用于确保数据的完整性。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>段（Segments）</li>
</ol>
<ul>
<li><strong>所在层</strong>: 传输层（第4层）</li>
<li><strong>作用</strong>: 段是在传输层处理的数据单元，用于端到端的传输控制。段负责分割应用层的数据，确保数据的可靠性、顺序和流量控制。</li>
<li>组成:<ul>
<li><strong>头部（Header）</strong>: 包含源端口号、目的端口号、序列号和确认号等信息，用于传输控制。</li>
<li><strong>数据（Payload）</strong>: 包含来自应用层的数据。</li>
</ul>
</li>
</ul>
<h2 id="Bandwidth-Throughput"><a href="#Bandwidth-Throughput" class="headerlink" title="Bandwidth &amp; Throughput"></a>Bandwidth &amp; Throughput</h2><ol>
<li><p>Bandwidth（带宽）：</p>
<ul>
<li><p>带宽是指网络连接或传输介质的最大数据传输能力，即在单位时间内能够传输的最大数据量。</p>
</li>
<li><p>带宽通常以比特每秒（bps）、千比特每秒（Kbps）、兆比特每秒（Mbps）、千兆比特每秒（Gbps）等单位来表示。</p>
</li>
<li><p>可以比喻为高速公路的宽度，决定了能同时通过的车辆（数据包）的最大数量。</p>
<ol start="2">
<li>Throughput（吞吐量）：</li>
</ol>
</li>
<li><p>吞吐量是指实际传输的有效数据量，即单位时间内成功传输的数据量。</p>
</li>
<li><p>吞吐量受多种因素的影响，如网络延迟、丢包率、网络拥塞、协议开销等。</p>
</li>
<li><p>可以比喻为高速公路上实际行驶的车辆数量，往往低于带宽，特别是在存在网络干扰或其他瓶颈时。</p>
</li>
</ul>
<ol start="3">
<li>关系：</li>
</ol>
<ul>
<li>理论上，吞吐量不应超过带宽，它是带宽的实际利用率。</li>
<li>吞吐量受到带宽的限制，但不会等于带宽。即使带宽很高，如果网络条件不好，如高延迟、丢包、网络拥堵等，吞吐量可能会显著低于带宽。</li>
</ul>
</li>
</ol>
<h2 id="一个功能的标准化过程"><a href="#一个功能的标准化过程" class="headerlink" title="一个功能的标准化过程"></a>一个功能的标准化过程</h2><p>个人草案 –&gt; 工作组草案 –&gt; 成为标准</p>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型 ***"></a>TCP&#x2F;IP模型 ***</h2><ol>
<li>TCP&#x2F;IP模型只有四层<ol>
<li><p>Application</p>
<ul>
<li>负责处理特定的网络应用程序数据。</li>
<li>包含许多协议，如HTTP（用于网页浏览）、FTP（文件传输）、SMTP（电子邮件传输）、DNS（域名解析）等。</li>
<li>直接与用户进行交互，提供应用服务。</li>
</ul>
</li>
<li><p>Transport</p>
<ul>
<li>负责数据传输可靠性，数据流控制，纠错。</li>
<li>主要协议是TCP（传输控制协议）和UDP（用户数据报协议）。</li>
<li>把Application Layer的数据打包为segments(段)。</li>
</ul>
</li>
<li><p>Internet</p>
<ul>
<li>负责跨网络传输数据包，负责最佳路径和数据包交换。</li>
<li>使用IP协议（例如IPv4或IPv6）来处理路由和寻址。</li>
<li>主要协议：IP</li>
</ul>
</li>
<li><p>Network Access</p>
<ul>
<li><p>也被称为 host-to-network layer.</p>
</li>
<li><p>负责在本地网络中传输数据。</p>
</li>
<li><p>包含物理网络接口，如以太网、Wi-Fi等。</p>
</li>
<li><p>处理数据帧的发送和接收，并管理MAC地址。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构 ***"></a>拓扑结构 ***</h2><ol>
<li>定义了互联网的结构类型</li>
<li>物理拓扑：如bus（总线型）, star（星型）, ring（环形）, extended star（拓展星型）, hierarchical（分层拓扑）, mesh（网型）</li>
</ol>
<h2 id="终端设备"><a href="#终端设备" class="headerlink" title="终端设备 ***"></a>终端设备 ***</h2><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><ol>
<li>Media</li>
</ol>
<p>即介质（线路）。把零一序列转化为介质的信号来传输。</p>
<ol start="2">
<li>Repeater</li>
</ol>
<p>中继器。</p>
<p>一对一的</p>
<ol start="3">
<li>hub</li>
</ol>
<p>集线器。广播型的</p>
<ol>
<li>物理上是星型，逻辑上是总线型</li>
<li>放大型号并转发，和中继器相比就是能连接多个端口</li>
<li>因为逻辑上是总线型，就可能会产生冲突。把冲突的区域称为冲突域。但是冲突域的管理不由hub管理。</li>
</ol>
<h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><p>特点：能够把比特流结构化成帧。流量的管理与控制工作。</p>
<ol>
<li><p>NIC</p>
<ol>
<li>作用：把host连接至网络</li>
<li>每个NIC都有一个MAC地址</li>
<li>计算机中母线是并行通讯，网线却是串行通讯。NIC要切换信息的并串型。</li>
<li>NIC不仅在终端上有，线路上也会有。</li>
<li>“只要是把信息接入介质，都需要网卡</li>
</ol>
</li>
<li><p>MAC</p>
</li>
</ol>
<p>MAC（Media Access Control，媒体访问控制）地址是用于标识网络设备的硬件地址。它是网络接口卡（NIC）在链路层使用的唯一标识符，常用于局域网（LAN）中的数据链路层通信。</p>
<ol start="3">
<li><p>bridges</p>
<ol>
<li><p>有两个端口，会根据设备的mac地址把网络分为两个分段，生成地址表（MacTable)。如果发现目的地址不在本端，就会转发信号，反之不会。</p>
</li>
<li><p>把网络分成了两个冲突域。</p>
</li>
</ol>
</li>
<li><p>switch</p>
<ol>
<li><p>结合了hub和bridge的功能。</p>
</li>
<li><p>可以隔离冲突域(collision)，不能隔离广播域(broadcast)</p>
</li>
<li><p>当一台主机发送消息到交换机上的另一台主机时，交换机将接受并解码帧，以读取消息的物理 (MAC) 地址部分。</p>
</li>
<li><ul>
<li><p>交换机上含有一个 MAC 地址表，其中列出了包含所有活动端口以及与交换机相连主机的 MAC 地址。当消息在主机之间发送时，交换机将检查该表中是否存在目的 MAC 地址。</p>
</li>
<li><p>如果存在，交换机就会在源端口与目的端口之间创建一个临时连接，称为电路、虚电。这一新电路为两台主机的通信提供一个专用通道。</p>
</li>
<li><p>如果目的 MAC 地址不在表中，交换机就没有创建电路所需的信息。当交换机无法确定目的主机的位置时，就会采用“泛洪”处理方式将消息转发到所有连接的主机。</p>
</li>
</ul>
</li>
<li><p>新主机的 MAC 地址如何进入 MAC 地址表？交换机检查主机之间发送的每个帧的源 MAC 地址，然后创建 MAC 地址表。当新主机发送消息或响应“泛洪”式消息时，交换机就会立即获取其 MAC 地址及其连接的端口。交换机每次读取新的源 MAC 地址时，地址表都会自动更新。</p>
</li>
<li><p>对于每一个端口来说，交换机的功能和网桥是一样的。</p>
</li>
</ol>
</li>
</ol>
<h3 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h3><ol>
<li>router<ol>
<li>基于IP地址做网段分逻辑划分。路由器可以做</li>
<li>报文识别，路径选择，报文转发。</li>
</ol>
</li>
</ol>
<h1 id="第一章-·-物理层"><a href="#第一章-·-物理层" class="headerlink" title="第一章 · 物理层"></a>第一章 · 物理层</h1><h2 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>STP &#x2F; UTP(有屏蔽双绞线Shielded Twisted Pair &#x2F; 无屏蔽双绞线Unshielded Twisted Pair)</li>
<li>coaxial</li>
<li>fiber-optics</li>
<li></li>
</ol>
<h2 id="Type-of-Network"><a href="#Type-of-Network" class="headerlink" title="Type of Network"></a>Type of Network</h2><ol>
<li>多路复用，共享介质（Multiple Access, Shared Media)</li>
<li>点对点(Point-to-Point)</li>
</ol>
<h2 id="LAN-Media"><a href="#LAN-Media" class="headerlink" title="LAN Media"></a>LAN Media</h2><p>传输方式：</p>
<ul>
<li>电信号</li>
<li>光信号</li>
<li>电磁波</li>
</ul>
<h3 id="有线传输"><a href="#有线传输" class="headerlink" title="有线传输"></a>有线传输</h3><ol>
<li>UTP（无屏蔽双绞线，Unshielded Twisted Pair)：<ol>
<li>八根子线，两个一对。</li>
<li>优点：<ul>
<li>易部署</li>
<li>低成本</li>
</ul>
</li>
<li>缺点：<ul>
<li>容易受到电磁波干扰</li>
<li>电信号损失快，传输距离较短。一般认为传输距离是100米。</li>
</ul>
</li>
</ol>
</li>
<li>Coaxial(同轴电缆)：<ol>
<li>结构：从内向外是铜线，绝缘膜，金属网，塑料套。</li>
<li>传输距离一般认为是500米。</li>
<li>成本介于双绞线和光缆之间。</li>
</ol>
</li>
<li>Fiber-Optics(光缆)<ol>
<li>结构：从内向外是二氧化硅，塑料套。接口分为两部分，一个接收，一个发送。</li>
<li>传输距离为公里级，但是成本高。</li>
<li>分类<ol>
<li>Single Mode(单模)：<ul>
<li>光导体很细，可以认为光在其中几乎没有反射，所以损失较慢，传输距离远。一般用于广域网。</li>
</ul>
</li>
<li>Multimode(多模)：<ul>
<li>光导体较粗，可以根据射入角度不同，同时传输多路信号。信号损失较快。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h3><p>分类：陆生（利用基站），卫星（如GPS）。</p>
<ol>
<li>激光：通讯双方约定好通讯方案和频率范围。中间要求无遮挡。</li>
<li>红外：成本较低，不能跨障碍物。</li>
<li>无线电波：可以衍射（跨障碍物）。易受干扰（如在雨天，大功率设备旁）。</li>
</ol>
<h2 id="Category-of-UTP"><a href="#Category-of-UTP" class="headerlink" title="Category of UTP"></a>Category of UTP</h2><ul>
<li>一到七类线加超五类线。</li>
<li>从三类线开始出现以太网</li>
<li>从五类线开始以太网达到百兆<ul>
<li>五类线相比于三类线具有更高的绞合度</li>
</ul>
</li>
<li>超五类线达到千兆，现在很常用</li>
<li>六类线性能高于超五类线</li>
</ul>
<h2 id="Catrgory-og-Cable"><a href="#Catrgory-og-Cable" class="headerlink" title="Catrgory og Cable"></a>Catrgory og Cable</h2><ol>
<li>Staight Cable(直通线)<ol>
<li><p>有八根子线，每根子线有不同颜色，不同规格标准的配色不同。(记住颜色，配对和型号)</p>
<p>![屏幕截图 2024-09-23 222304](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-23 222304.png)</p>
<ul>
<li>T568A和T568B的区别在于pair2和pair3换位置了。</li>
</ul>
</li>
<li><p>如果一根线的两段都是T568A或都是T568B，则为直通线。</p>
</li>
<li><p>路由器和交换机，交换机和终端之间用直通线连接。</p>
</li>
</ol>
</li>
<li>Rollover Cable(反转线)：<ol>
<li>别名：console cable</li>
<li>两段的子线排列是反的。1对8，2对7，等等。</li>
<li>路由器如果和终端直接连接，则用反转线。</li>
</ol>
</li>
<li>Cross-over Cable（交叉线）：<ol>
<li>两个相同的设备之间用交叉线。</li>
<li>特点是一端是T568A，另一端是T568B。和直通线相对。</li>
</ol>
</li>
</ol>
<h2 id="信号传输的问题"><a href="#信号传输的问题" class="headerlink" title="信号传输的问题"></a>信号传输的问题</h2><ol>
<li><p>一般</p>
<ol>
<li>衰竭</li>
<li>反射</li>
<li>电磁干扰（噪声）</li>
<li>散射</li>
<li>抖动（不同步）</li>
<li>延时</li>
</ol>
</li>
<li><p>冲突和冲突域</p>
<ol>
<li>冲突会影响数据传输</li>
<li>repeater和hub会使得冲突域变大</li>
<li>bridge和switch和router能控制冲突域。</li>
<li>bridge和switch虽然将网络分段，不代表分成多个局域网。router才可以划分局域网。</li>
</ol>
</li>
</ol>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ol>
<li>信号：数据的电气或电磁的表现。<ol>
<li>模拟的：参数的取值是连续的。模拟信号是随时间变化而平稳变化的连续波形式</li>
<li>数字的：参数的取值是离散的，包含了有限种可能的预设值。</li>
</ol>
</li>
<li>码元：在使用时间域（或称时域）的波形表示数字信号时，代表不同离数值的基本波形。<ul>
<li>理解：用波形来表示信息。想要在一个时域内传输3个bit，码元就应该为2^3 &#x3D; 8。每个波形表示一种取值。</li>
</ul>
</li>
<li><strong>电平数量</strong>指信号所支持的电平数，即逻辑状态的种类。</li>
</ol>
<h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ol>
<li><p>信号分类</p>
<ol>
<li>简单信号：正（余）弦波</li>
<li>复合信号的分解：傅里叶分析</li>
</ol>
</li>
<li><p>信号处理</p>
<ol>
<li><p>数字信号通常在传输介质上表现为方波。可以用无穷多个谐波来拟合。</p>
</li>
<li><p>码元传输速率越高，传输距离越远，信号畸变越严重</p>
</li>
<li><p>传输速率的理论上限（无噪声干扰）：<br>$$<br>C&#x3D;W·log_2L （W为带宽（单位：Hz），L为信号电平数量）<br>$$</p>
</li>
<li><p>噪声信道的最高传输速率（香农公式）：<br>$$<br>C&#x3D;W·log_2(1+\frac{S}{N})<br>（W为带宽，S为信号的平均功率，N为平均高斯噪声功率）<br>$$</p>
<ul>
<li>带宽和信噪比越大，极限越高</li>
<li>注意，即使带宽、信噪比和码元速率已经确定，仍然可以提高信号传输速率，依靠编码让每个码元的识别率更大，从而携带更多的比特数。</li>
</ul>
</li>
</ol>
</li>
<li><p>波特率和比特率</p>
<ol>
<li>波特率：每秒波形的变化次数</li>
<li>比特率：每秒传送的二进制位数</li>
</ol>
</li>
<li><p>数据通信系统的模型</p>
<p>![屏幕截图 2024-09-23 225726](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-23 225726.png)</p>
</li>
</ol>
<h2 id="编码（encoding）"><a href="#编码（encoding）" class="headerlink" title="编码（encoding）***"></a>编码（encoding）***</h2><ul>
<li>把数字信号转换成物理信号的过程。</li>
<li>基带：基本频带，之传输变换前所占用的频带，是原始信号所固有的频带。数字信号一般属于基带信号。基带信号往往具有低频成分，甚至有直流成分，导致许多信道不能直接传输的，需要调频。</li>
<li>调制：把数字信号转换到模拟信号。</li>
</ul>
<ol>
<li><p>单极性编码 ***<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211171801260.png" alt="image-20241211171801260"></p>
<ol>
<li>原理：用0电平表示“0”，用正电平表示“1”。</li>
<li>缺点：<ol>
<li>难以分辨每个信号的开始和结束</li>
<li>必须时钟同步</li>
<li>若信号中“0”或“1”连续出现，信号直流分量将累加，直流问题严重</li>
</ol>
</li>
<li>结论：容易产生传播错误</li>
</ol>
</li>
<li><p>极化编码——不归零制码（NRZ）</p>
<ol>
<li><p>不归零电平编码<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211171842572.png" alt="image-20241211171842572"></p>
<ol>
<li><p>原理：负电平表示“0”，正电平表示“1”</p>
</li>
<li><p>缺点：和单极性编码一样</p>
</li>
</ol>
</li>
<li><p>不归零反相编码<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211171856668.png" alt="image-20241211171856668"></p>
<ol>
<li>原理：电平翻转表示“1”，不变化表示“0”</li>
<li>稍微缓解了电荷累加导致直流的问题</li>
</ol>
</li>
</ol>
</li>
<li><p>极化编码——归零编码（RZ）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211171941111.png" alt="image-20241211171941111"></p>
<ol>
<li>原理：负电平表示“0”，正电平表示“1”，比特中位跳变到零电平。</li>
</ol>
</li>
<li><p>极化编码——曼彻斯特码 ***<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211172112011.png" alt="image-20241211172112011"></p>
<ol>
<li><p>原理：每一位中间都会有一个跳变，从低到高表示“0”，从高到低表示“1”</p>
</li>
<li><p>优势：</p>
<ol>
<li><p>每一位中间的跳变既可以作为数据，又可以作为时钟，能够自同步。</p>
</li>
<li><p>只采用两个电平，跳变相对于RZ码少，效率更高</p>
</li>
<li><p>每次跳变都自中和，不会导致电荷积累。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>极化编码——差分曼彻斯特码 ***![屏幕截图 2024-12-11 172227](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-12-11 172227.png)</p>
<ol>
<li>原理：<ul>
<li>每一位中间跳变：表示时钟</li>
<li>每一位位前跳变：表示数据<ul>
<li>有跳变表示“0”，无跳变表示“1”</li>
</ul>
</li>
</ul>
</li>
<li>优势：<ol>
<li>时钟和数据分离，便于提取</li>
</ol>
</li>
</ol>
</li>
<li><p>双极性编码——双极性传号交替反转码（AMI）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241211172556233.png" alt="image-20241211172556233"></p>
<ol>
<li>原理：采用三个电平：零电平表示“0”，正负电平的跃迁表示“1”，实现对“1”电平的交替反转。</li>
<li>优点：<ul>
<li>“1”的正负交替，使得直流分量为零。</li>
<li>虽然连续的“0”不能同步，但连续的“1”可以同步</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><ul>
<li>由于一条传输路线的能力远远超过传输一个用户信号所需的能力，<strong>为了提高线路利用率，经常让多个信号共用一条物理线路</strong></li>
<li>信号 –&gt; 复用器 –&gt; 信道 –&gt; 分解器 –&gt; 信号</li>
<li>注：频率带宽和速度带宽<ul>
<li>频率带宽‌：主要描述的是信号的频率范围，即信号中所包含的最高频率和最低频率之间的差异。在通信领域，频率带宽指的是信道能够传输的频率范围，这个范围越大，信道的容量越大，意味着可以传输更多的信息。</li>
<li>速度带宽‌：更多关联于数据的传输速率，即单位时间内能够传输的数据量。在数字设备中，带宽通常用bps（bits per second）来表示，即每秒可传输的位数。速度带宽可以理解为网络的传输速度，即网络中信号从发送节点到达接收节点的速度，或者网络的每秒中能传输的数据位的能力‌。</li>
<li>频率带宽关注的是信号的频率响应能力，而速度带宽关注的是数据的传输速率‌。</li>
</ul>
</li>
</ul>
<ol>
<li><p>时分复用（TDM，Time DIvision Multiplexing)</p>
<ol>
<li><p>原理： </p>
<ul>
<li><strong>将时间等分为时分复用帧，每个用户在每个TDM帧中占用固定序号的时隙</strong>。</li>
<li><strong>每个用户所占用的时隙周期性出现</strong></li>
<li><strong>所有用户在不同时间占用同样的频带宽度</strong></li>
</ul>
</li>
<li><p>缺点：造成浪费。可能某个用户在某个时隙里没有数据。</p>
</li>
<li><p>改进：统计时分复用（STDM，Statistic TDM）：</p>
<ul>
<li><p>不再固定的把时间分出去，而是谁先来就先服务谁。</p>
</li>
<li><p>因为时隙不固定，所以每个子帧必须带有自己的身份信息。</p>
</li>
<li><p>效率降低了，但是资源利用率提高了</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>频分复用（FDM，Frrquency Division Multiplexing）</p>
<ol>
<li>原理：<ul>
<li>用户在分到一定的频带后，就使用占用这个频带</li>
<li>所有用户在1相同时间占用不同的带宽资源（带宽指频率带宽）</li>
</ul>
</li>
</ol>
</li>
<li><p>波分复用（WDM，Wavelength D M）</p>
<ul>
<li>实际上就是频分复用的光传输场景</li>
<li>把光分为不同波长</li>
</ul>
</li>
<li><p>码分复用（CDM，Code D M)</p>
<ol>
<li>又称码分多址</li>
<li>原理：传输信号时采用相同的频率，不同的编码。各用户使用挑选过的不同码型，要求编码相互正交，也就是互不影响。</li>
<li>优势：<ul>
<li>抗干扰能力强</li>
<li>频谱类似于白噪音，不易被敌人发现。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="第二章-·-数据链路层"><a href="#第二章-·-数据链路层" class="headerlink" title="第二章 · 数据链路层"></a>第二章 · 数据链路层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>形成数据帧，对上层提供的数据封装，然后传输。</li>
<li>能够校验帧是否正确。</li>
<li>不能跨链路。</li>
<li>在数据链路层，”procedure” &#x3D; “protocol”</li>
<li>主要任务：<ol>
<li>校验，即错误识别</li>
<li>网络拓扑控制</li>
<li>节点之间流的控制</li>
</ol>
</li>
<li>与物理层的区别：<ol>
<li>Layer 1不能与上层交流；Layer 2 通过LLC(Logical Link Control)与上层交流</li>
<li>如果是总线拓扑，Layer 1 无法识别主机和接受机，Layer 2 通过MAC(Media Access Control)控制</li>
<li>Layer 1 不能组织发出的数据，Layer 2 组织为帧</li>
</ol>
</li>
</ol>
<h3 id="第二层提供的服务"><a href="#第二层提供的服务" class="headerlink" title="第二层提供的服务"></a>第二层提供的服务</h3><ol>
<li>通讯之前没有确认连接关系，而且通讯无确认（数据发出去就不管了），应用场景：<ul>
<li>多用在局域网</li>
<li>可靠的链路</li>
<li>对于实时的任务</li>
</ul>
</li>
<li>通讯之前没有确认连接关系，且通讯有确认。可用于不太可靠的链接，如无线网络。这样做效率降低了，因为需要确认。</li>
<li>面向连接的，需要确认连接关系，且通讯要确认。如蓝牙连接。</li>
</ol>
<h3 id="MAC（介质访问控制）的标准"><a href="#MAC（介质访问控制）的标准" class="headerlink" title="MAC（介质访问控制）的标准"></a>MAC（介质访问控制）的标准</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>Ethernet（以太网）：逻辑上是总线型，物理上是星型或拓展星型。</li>
<li>Token Ring：逻辑上是环形，物理上是星型。</li>
<li>FDDI：逻辑上是环形，物理上是双环形。</li>
</ol>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li>Deterministic——taking turns：Token Ring 和 FDDI。终端形成令牌环网，依次获得令牌。发送数据，有顺序发送。</li>
<li>Non-deterministic——first come, first served：Ethernet。无顺序，谁先到谁先用。<ol>
<li><strong>CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection）</strong>*** ：用这个解决方案来避免冲突。</li>
</ol>
</li>
</ol>
<h3 id="局域网通讯的分类"><a href="#局域网通讯的分类" class="headerlink" title="局域网通讯的分类"></a>局域网通讯的分类</h3><ol>
<li>单播（unicast)：点对点</li>
<li>组播（multicast）：一个节点发给一组特定的节点。</li>
<li>广播（broadcast）：一个节点给所有节点</li>
</ol>
<h2 id="以太网规范"><a href="#以太网规范" class="headerlink" title="以太网规范"></a>以太网规范</h2><h3 id="局域网标准"><a href="#局域网标准" class="headerlink" title="局域网标准"></a>局域网标准</h3><ol>
<li>任务：<ol>
<li>局域网由一个单位控制，决定了物理介质来无线组网并控制连接。</li>
<li>定义了数据链路层帧的规范</li>
<li>第二层约定如何利用介质来传输数据，同时避免冲突</li>
<li>第二层开始对上层服务，处理上层的要求</li>
</ol>
</li>
<li>两个子层的方案：<ol>
<li>Media Access Control(MAC)：不同介质，不同网线的访问</li>
<li>Logic Link Control(LLC)：有关链路服务</li>
</ol>
</li>
</ol>
<h3 id="帧结构规范（MAC子层）"><a href="#帧结构规范（MAC子层）" class="headerlink" title="帧结构规范（MAC子层）"></a>帧结构规范（MAC子层）</h3><ol>
<li>以字节为单位做帧的表述</li>
<li>结构：<ol>
<li>前导码(Preamble)（8字节）：给一个缓冲，让接收方知道有一个帧要过来了。前导码为10101011。</li>
<li>MAC地址(Dest.add. Source add.)(6+6&#x3D;12字节)：<ol>
<li>6字节目的地址，后接6字节发送地址。</li>
<li>目的方可能是单播，组播和广播（111111），发送方总是单播</li>
</ol>
</li>
<li>长度(Length)（2字节）：<ul>
<li>数据段的长度，2字节。</li>
<li>要求Length的范围是46~1500字节，保证整个帧除了前导段的长度最小为64，最长为1518.</li>
<li>在以太网二(Ethernet 2)种，用类型（Type）替代长度，Type可以指定数据类型是IP还是IPX，所以这样也可以确认长度。</li>
</ul>
</li>
<li>数据(Data)</li>
<li>FCS(循环冗余校验)（<strong>FCS（Frame Check Sequence）是循环冗余校验（CRC）</strong>）（4字节）：接收方用于校验</li>
</ol>
</li>
</ol>
<p>![屏幕截图 2024-09-30 091038](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-30 091038.png)</p>
<h3 id="LLC子层"><a href="#LLC子层" class="headerlink" title="LLC子层"></a>LLC子层</h3><p>![屏幕截图 2024-09-30 091749](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-30 091749.png)</p>
<ul>
<li>LLC放在帧的数据部分，放在包的前面</li>
<li>基于SAP（Service Access Point）识别地址</li>
</ul>
<h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h2><ol>
<li>MAC地址：48位标准，烧在网卡芯片上的。用十二个十六进制位表示<ol>
<li>OUI标准下，第一位有意义：0代表单播，1代表组播或广播</li>
<li>第二位：0代表全球唯一设备，1表示地区唯一地址</li>
<li>广播地址为全一，即12个F。</li>
</ol>
</li>
<li>以太网操作原理<ol>
<li>拓扑方式：总线拓扑。</li>
<li>传输的一些细节：<ol>
<li>所以当A发送信号给D时，B,C都会收到电信号。此时会检查信号的MAC地址，若不是自己的，则丢弃。</li>
<li>监听信号，避免冲突</li>
<li>若发生冲突，接收方会广播一个Jam Signal，全一信号，这样会让其他准备发送数据的设备回退一个时间</li>
</ol>
</li>
<li>流程：![屏幕截图 2024-09-30 094626](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-30 094626.png)</li>
</ol>
</li>
</ol>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><ol>
<li>分类：<ol>
<li>有基础固定设施的无线网络：预先设下基站，覆盖一定范围，有距离限制</li>
<li>无基础设施的拓扑网络：自组网络（？）</li>
</ol>
</li>
<li>无线通讯是有确认的</li>
</ol>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><ol>
<li>IEEE 802.11<ol>
<li>拓扑方式：星型拓扑，以基站为中心节点</li>
<li>直接序列扩频技术（DSSS，Direct Sequence Spread Spectrum）</li>
<li>又叫Wi-Fi</li>
</ol>
</li>
<li>IEEE 802.11b<ol>
<li>速度可达11Mbps</li>
<li>工作频率在2.4GHz</li>
</ol>
</li>
<li>IEEE 802.11a<ol>
<li>正交频率复用技术</li>
<li>工作功率在5GHz</li>
</ol>
</li>
<li>IEEE 802.11g</li>
<li>IEEE 802.11n<ol>
<li>速度可达500Mbps</li>
</ol>
</li>
</ol>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>有基础设施的无线网络结构![屏幕截图 2024-10-11 024154](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-11 024154.png)<ol>
<li>星型拓扑</li>
<li>基本服务集（BSS）：主机和AP的连接。服务于多个无线网设备，每个AP都有一个IP</li>
<li>扩展服务集（ESS）：多个BSS通过分配系统（DS）相连，组成ESS。</li>
<li>scanning：<ul>
<li>一个移动客户端要加入BSS就要和AP建立连接关系，即”associate”，需要建立虚拟连接线路。有两种做法：<ol>
<li>Active Scanning：<ol>
<li>设备发出请求帧。请求帧包含SSID信息。</li>
<li>AP收到SSID的信息后，AP进行————</li>
<li>身份确认后建立连接</li>
</ol>
</li>
<li>Passive Scanning：<ol>
<li>AP周期性地发送信标帧，包含SSID信息</li>
<li>移动设备可以选择加入以建立连接关系</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="无线局域网的帧"><a href="#无线局域网的帧" class="headerlink" title="无线局域网的帧"></a>无线局域网的帧</h3><ol>
<li>与Ether的802.3不一样，WLAN用的802.11</li>
<li>有三种帧：<ul>
<li>控制帧</li>
<li>管理帧</li>
<li>数据帧</li>
</ul>
</li>
<li>一个Ether的帧不能超过1518字节，但是WLAN的帧上限可以达到2346字节。</li>
<li>结构：![屏幕截图 2024-10-11 030557](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-11 030557.png)<ol>
<li>帧控制（2字节）：16位继续分段，各有意义。</li>
<li>持续期（2字节）</li>
<li>地址1,2,3（6*3&#x3D;18字节）：有基础设施链接时用。</li>
<li>序号控制（2字节）：无线连接是有确认的，用这个字段来控制。</li>
<li>地址4（6字节）：用于自组网络（无线设备之间直接连接）</li>
<li>帧主体</li>
<li>FCS（4字节）</li>
<li>![屏幕截图 2024-10-11 031402](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-11 031402.png)</li>
</ol>
</li>
</ol>
<h2 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h2><ol>
<li><p>为什么不用CSMA&#x2F;CD：</p>
<ol>
<li>Hidden Station Problem：基站只能服务周围的设备，监听不到远处的信号，可能导致两个基站的信息同时到达某个设备，造成冲突。</li>
<li>Exposed Station Probilem：当A,B在基站X内，B,C在基站Y内，当X向A发送时，Y为了避免冲突就不向C发送信息了。但事实上本是不会冲突的。</li>
</ol>
</li>
<li><p>Ether和WLAN的多路复用机制对比：</p>
<ol>
<li><p>Ether所有节点都可以收到线路上的信号，WLAN不行，有距离限制。</p>
</li>
<li><p>Ether通过发送节点信息来监听冲突，WLAN做不到</p>
</li>
<li><p>Ether同时只能有一路信号传输，WLAN有多路</p>
</li>
</ol>
</li>
<li><p>CSMA&#x2F;CA</p>
<ul>
<li>时间控制来避免冲突<ol>
<li>发送站点在发送数据前，以控制短帧刺激接受站点发送应答短帧，使接受站点周围的站点监听到该帧，从而在一定时间内避免数据发送</li>
<li>过程：<ol>
<li>A向B发送RTS（Request To Send）帧，A周围的站点在一定时间内部发送数据，以保证CTS帧返回给A</li>
<li>B向A发送CTS（Clear To Send）帧，B周围的站点在一定时间内不发送数据，以保证A发送完整数据。</li>
<li>A开始发送</li>
<li>若RTS或CTS发生冲突，采用二进制质数后退算法等待随机事件，再重新开始。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>![屏幕截图 2024-10-14 084317](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-14 084317.png)</p>
<ol start="3">
<li>问题：<ol>
<li>由于有应答过程，实际带宽是理想带宽的50%。</li>
</ol>
</li>
</ol>
<h2 id="第二层设备"><a href="#第二层设备" class="headerlink" title="第二层设备"></a>第二层设备</h2><ol>
<li>网卡</li>
<li>网桥：<ol>
<li>工作原理补充<ol>
<li>计时与刷新：网桥每个一段时间就会刷新一次，重新看看连接的MAC地址，以适应动态网络拓扑。</li>
</ol>
</li>
<li>限制：<ol>
<li>收到一个没被记录的MAC地址，则会把它广播到全局。可能导致网络延时，传输降速，资源浪费，性能下降</li>
</ol>
</li>
</ol>
</li>
<li>交换机<ol>
<li>功能<ol>
<li>帧转发</li>
<li>MAC表的生成和维护，包括MAC回路的处理</li>
<li>冲突域的隔离</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第三章-·-网络层"><a href="#第三章-·-网络层" class="headerlink" title="第三章 · 网络层"></a>第三章 · 网络层</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol>
<li>用IP地址定位主机</li>
<li>功能：<ol>
<li>不同网段（广播域）的通讯</li>
<li>有层次的地址逻辑，和第二层的MAC地址相对</li>
<li>流量控制</li>
<li>屏蔽了的二层的不同帧的类型，统一用IP形成数据报</li>
</ol>
</li>
<li>设备：路由器<ol>
<li>连接不同网段</li>
<li>基于IP地址划分</li>
<li>选择最佳路线</li>
</ol>
</li>
</ol>
<h2 id="IP和数据报"><a href="#IP和数据报" class="headerlink" title="IP和数据报"></a>IP和数据报</h2><ul>
<li>IP是报文里的一部分，每个IP占32bit</li>
</ul>
<ol>
<li><p>报文结构：注意这里的单位是bit，不是字节![屏幕截图 2024-10-18 024313](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-18 024313.png)</p>
<ol>
<li>首部：报文一定有首部，首部还分为固定部分和可变部分。主要解释固定部分：<ol>
<li>版本（IPv4为4位）</li>
<li>首部长度（4位）：最多表示15个单位长度，一个单位为4字节，所以首部最长为60字节</li>
<li>服务类型（8位）</li>
<li>总长度（16位）：理论上数据报的最大长度为65535字节，但是我们要把数据报放在帧里，所以一般不超过1500字节.</li>
<li>标识（16位）：传输时可能要把报文拆开，为了能够再和上，用标识来确认身份。</li>
<li>标志位（3位）：最高位（DF位）为零表示可以分配，MF为零表示这是最后一个分片</li>
<li>片偏移（13位）：传输不一定是按顺序的，为了合并时顺序不乱，有了片偏移。以8字节为单位计算。所以同时要求子报文的分段要是8的倍数。</li>
<li>生存时间（TTL，Time To Live，8位）：表示报文能通过的路由器数的最大值。</li>
<li>协议（8位）：决定用那种协议处理数据，指出应该将数据交给那个进程去处理。</li>
<li>首部地址校验和（16位）：反码算数求和运算。智能校验首部内容。在接收端的结果为0则保留。</li>
<li>IP地址（32*2&#x3D;64位）：源地址和目的地址。</li>
</ol>
</li>
</ol>
</li>
<li><p>IP地址：</p>
<ol>
<li><p>结构</p>
<ol>
<li><p>32位</p>
</li>
<li><p>写成四个字节分开的形式</p>
</li>
<li><p>分为网络ID和主机ID，一般前面是网络，后面是主机，但不一定是平分</p>
</li>
<li><p>分类</p>
<ul>
<li>用第一个字节的取值范围来区分（实际上就是A类以0开头，B类以10开头，C类是110开头，等）</li>
</ul>
<ol>
<li>A类地址：四个字节为NHHH（N代表网络地址，H代表主机地址）</li>
<li>B类：NNHH</li>
<li>C类：NNNH</li>
</ol>
</li>
<li><p>规范：</p>
<ol>
<li>主机地址若为全0串，表示网络地址</li>
<li>主机地址若为全1串，表示广播地址</li>
<li>使得每个类型的可表示主机数量应该减2.</li>
<li>保留网段：只会在局域网内部使用，不会转发到互联网<ol>
<li>10.xxx.xxx.xxx</li>
<li>172.16.xxx.xxx</li>
<li>192.168.xxx.xxx</li>
</ol>
</li>
<li>172.16.2.1&#x2F;23：后面的&#x2F;23是子网掩码，表示前23位全1。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><ol>
<li><p>概述</p>
<ol>
<li><p>从host段中借出几位来作为子网段</p>
</li>
<li><p>子网之间也是不同的网段，和网络地址一个标准。即使在同一个网段，之间不能广播。</p>
</li>
<li><p>借位：</p>
<ul>
<li>最少2位。因为子网段也不能全1或全0。</li>
</ul>
<ol>
<li>A类：最多22位</li>
<li>B类：最多14位</li>
<li>C类：最多6位</li>
</ol>
</li>
<li><p>子网划分的优缺点：优点是增加了划分的灵活性，缺点是会有浪费</p>
</li>
</ol>
</li>
<li><p>掩码：</p>
<ol>
<li>和母网的掩码不一样，母网的主机地址部分全零，但是子网不是。</li>
<li>把掩码和IP地址做与运算，可以得到对应的网络地址</li>
</ol>
</li>
</ol>
<h2 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h2><ol>
<li>路由器每个端口都有网卡，要配一个和端口相同网络地址的地址。不同端口是不同网段。<ol>
<li>A1向B5发送报文，报文中的目的地址IP是B5的，但是形成的帧的目的地址却是路由器的A端口。因为A1和B5不在同一个网段，B5的MAC地址对A!来说是无意义的。同理，B5收到的帧的源地址是B端口的地址。</li>
<li>其实就是默认网关</li>
</ol>
</li>
<li>地址分配：<ol>
<li>静态地址分配：</li>
<li>动态地址分配：DHCP、RARP</li>
</ol>
</li>
</ol>
<h2 id="ARP协议、网关"><a href="#ARP协议、网关" class="headerlink" title="ARP协议、网关"></a>ARP协议、网关</h2><ul>
<li>知道IP地址，但是不知道MAC地址。</li>
</ul>
<ol>
<li>APR缓存<ol>
<li>主机或设备都会在RAM中存储IP地址，称为ARP Table。但是如果长时间不刷新、激活的话，会被删除。如果目的地在ARP Table中，则转发数据，否则，进入ARP Request。</li>
</ol>
</li>
<li>APR Request<ol>
<li>流程：<ol>
<li>request：A把目的MAC设为全一（广播地址），发给所有设备。</li>
<li>Checking：接收方检查报文中的IP地址，若不是自己就丢弃，若是则进入下一步。</li>
<li>Reply：目的主机B发送一个报文给发送方A。因为帧中包含了源地址，所以让A知道了B的MAC地址。</li>
<li>Caching：把B的地址写入ARP缓存。然后发送数据。</li>
</ol>
</li>
<li>如果目的主机不在同网段内呢？<ol>
<li>Default Gateway：默认网关<ol>
<li>如果没有配网关，则不能跨网段交流。</li>
<li>默认网关就是所连路由器的端口的IP地址。</li>
</ol>
</li>
<li>ARP代理（Proxy ARP）<ol>
<li>在路由器上启动</li>
<li>主机不必配置默认网关</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h2><ol>
<li>面向连接的网络服务vs虚电路交换<ol>
<li>在发送数据之前，要先建立连接</li>
<li>虚电路交换：建立连接后就完全在这条电路上传输信息，要强于面向连接的，传输更加可靠，保证传输先后关系。</li>
</ol>
</li>
<li>无连接VS.报文交换<ol>
<li>无连接（Connectionless）：<ol>
<li>不需要事先建立连接</li>
<li>把每个数据包分开传输</li>
<li>不用维护上下文</li>
<li>IP就是一个无连接系统</li>
</ol>
</li>
<li>报文交换（Packet switching）<ol>
<li>把原始报文分成多个报文，每个报文独立发送，可以走不同路径，乱序到达。</li>
<li>当某个数据包传输失败，只需要重传这个数据包就好了</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="网络协议操作"><a href="#网络协议操作" class="headerlink" title="网络协议操作"></a>网络协议操作</h2><ol>
<li>Routed protocol 被动可路由协议：<ol>
<li>为网络层提供支持的协议称为路由协议或可路由协议。</li>
<li>IP是网络层协议，因此，它可以通过互联网络进行路由。</li>
</ol>
</li>
<li>Non-routable protocol 不可路由协议<ol>
<li>不可路由协议是不支持第3层的协议。</li>
<li>这些不可路由协议中最常见的是NetBEUI。<ol>
<li>直接根据目的方的地址在局域网中进行生成定位</li>
<li>这个协议不支持第三层，也就是跨局域网是不可以的。</li>
<li>NetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行</li>
</ol>
</li>
</ol>
</li>
<li>被动可路由的寻址<ol>
<li>路由器连接三个网段(列出来的是网络号)</li>
<li>将目的主机和掩码进行逻辑AND操作，得到对应的网段</li>
<li>然后请求路由表可以发现E2端口为目的网段</li>
<li>再次将报文封装转发给对应的主机</li>
<li>路由表是存储在内存中的</li>
</ol>
</li>
<li>路由协议的分类<ol>
<li>静态路由：网络管理员在路由器中手动输入路由信息。</li>
<li>动态路由<ol>
<li>路由器可以在运行过程中互相学习信息。</li>
<li>使用路由协议更新路由信息。</li>
<li>RIP, IGRP, EIGRP, OSPF …</li>
<li>人工维护的代价比较大</li>
</ol>
</li>
<li>区别：<ol>
<li>静态路由<ol>
<li>用于隐藏部分网络。安全(不必进行路由表的交换)</li>
<li>测试网络中的特定链接。</li>
<li>用于仅在到达目标网络的路径时维护路由表。</li>
</ol>
</li>
<li>动态路由<ol>
<li>维护路由表。</li>
<li>以路由更新的形式及时分发信息。</li>
<li>依靠路由协议共享知识。</li>
<li>路由器可以调整以适应不断变化的网络状况。</li>
<li>打开后会启动<strong>进程</strong>，按照不同的协议，和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li>
</ol>
</li>
</ol>
</li>
<li>Routing protocol 主动路由协议(Routing)<ol>
<li>路由协议确定路由协议遵循的到达目的地的路径。</li>
<li>是用来构建路由表的，所以叫做routing</li>
<li>公平、简单、适应变化等特点</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Routed-and-Routing-Proyocal"><a href="#Routed-and-Routing-Proyocal" class="headerlink" title="Routed  and Routing Proyocal"></a>Routed  and Routing Proyocal</h2><ol>
<li>Routed：在路由器之间运作，保证连接，完成转发</li>
<li>Routing：在路由器之间制路由表，并且路由器彼此之间交换信息，以此实现Routed<ol>
<li>路由表：</li>
<li>动态路由分类<ol>
<li>自治系统：一个逻辑划分出来的系统。</li>
<li>IGP（内部网关协议）：一个自治系统下统一的网络管理规范<ol>
<li>DVP（距离矢量协议，Distance Vector Protocal）：<ol>
<li>特点<ol>
<li>基于邻居的视角获得网络获得拓扑信息。</li>
<li>基于跳数作为选择路径的评判标准</li>
<li>定时交换Routing Table</li>
<li>会生成路由回路</li>
</ol>
</li>
<li>代表：<ol>
<li>RIP（Route Info Prot）<ol>
<li>最受欢迎。(实现算法简单，更加靠谱)</li>
<li>最远可达跳数为15</li>
<li>唯一的指标是跳数。</li>
<li>每30秒广播以更新</li>
<li>产生大量的网络流量。</li>
</ol>
</li>
<li>IGRP<ol>
<li>思科知识产权的。</li>
<li>基于距离矢量的内部网关协议。</li>
<li>IGRP最大跳数为255。</li>
<li>每90秒更新一次。</li>
<li>EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议(不全是根据跳数来计算)。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>LSP（链路状态协议，Link State Protocal）<ol>
<li>特性：<ol>
<li>基于全局，使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li>
<li>基于带宽来计算代价，根据代价来判断路径</li>
<li>触发事件更新信息，链路改变时会更新信息</li>
</ol>
</li>
<li>代表：<ol>
<li>OSPF(Open Shortest Path First)<ol>
<li>最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。</li>
<li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>EGP（BGP）（外部网关协议）：用于在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
</li>
<li>Routing protocals dtermine how routed protocals are routed.</li>
</ol>
<h2 id="可变长度子网掩码VLSM-Variable-Length-Subnet-Mask"><a href="#可变长度子网掩码VLSM-Variable-Length-Subnet-Mask" class="headerlink" title="可变长度子网掩码VLSM(Variable Length Subnet Mask)"></a>可变长度子网掩码VLSM(Variable Length Subnet Mask)</h2><ol>
<li>经典路由(Classful routing) 无子网掩码<ol>
<li>有类的路由协议要求单个网络使用相同的子网掩码。</li>
<li>例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。</li>
<li>会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。</li>
<li>特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化</li>
</ol>
</li>
<li>VLSM<ol>
<li>作用<ol>
<li>VLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。</li>
<li>有效的解决网络号浪费的问题</li>
<li>使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性)</li>
<li>如果路由协议允许VLSM<ol>
<li>在路由网络连接上使用30位子网掩码255.255.255.252</li>
<li>用户网络的24位掩码255.255.255.0</li>
<li>或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位)</li>
</ol>
</li>
<li>在CIDR的基础上发展的，报文中包含有子网掩码</li>
<li>实施VLSM通常被称为”子网划分”，可用于最大化寻址效率。</li>
<li>VLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。</li>
</ol>
</li>
<li>优点：<ol>
<li>高效使用IP地址</li>
<li>更好的路由聚合(aggregation):构建超网</li>
</ol>
</li>
<li>缺点：<ol>
<li>会导致地址空间的浪费:广播地址和网络号都无法被使用。</li>
</ol>
</li>
<li>划分流程：<ol>
<li>先划分大的子网，再划分小的子网。每次划分会剩下一些没有用到的子网，留给后面用。</li>
<li>如果使用了子网中的任何地址，则该子网不能再进行子网划分。</li>
</ol>
</li>
<li>路由聚集(Route Aggregation)<ol>
<li>使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。</li>
<li>多个路由条目汇聚成小的路由条目</li>
<li>比如如下图就是讲3个&#x2F;24的子网合并成一个&#x2F;16的网络高速远端</li>
<li>优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111162549494.png" alt="image-20241111162549494"></li>
<li>例子：多层聚集</li>
<li>做法：在网络地址中找到尽可能多的前置位数，作为新的网络位，从必须有差异的地方开始，作为新的主机位</li>
<li>优点：<ol>
<li>减少路由表条目的数量。</li>
<li>可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息)</li>
</ol>
</li>
<li>注意：<ol>
<li>为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。</li>
<li>VLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。</li>
<li>路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同</li>
<li>VLSM是不做连续性检验的，也就是就算不连续也会进行聚集</li>
<li>全0子网会在题目中说是否可用</li>
<li>全1子网尽量不要使用</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议 ICMP"></a>因特网控制报文协议 ICMP</h2><ol>
<li><p>概述：</p>
<ol>
<li>ICMP (Internet Control Message Protocol)：<strong>为了提高 IP 数据报交付成功的机会</strong>(消息管理和协商)</li>
<li>ICMP <strong>允许主机或路由器报告差错情况和提供有关异常情况的报告</strong></li>
<li>ICMP 只是IP层的协议</li>
<li>ICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去</li>
<li>一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文。</li>
</ol>
</li>
<li><p>格式：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111163851827.png" alt="image-20241111163851827"></p>
<ol>
<li>前四个字节是一样的(格式化的)</li>
<li>后面都是个根据类型</li>
</ol>
</li>
<li><p>两种ICMP报文<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111163946171.png" alt="image-20241111163946171"></p>
<ol>
<li>差错报告报文:一般这种类型会多一些<ol>
<li>目的站不可达：<ol>
<li><strong>网络</strong>不可到达(net unreachable)</li>
<li><strong>主机</strong>不可到达(host unreachable)</li>
<li><strong>协议</strong>不可到达(protocol unreachable)</li>
<li><strong>端口</strong>不可到达(port unreachable)</li>
<li><strong>源路由选择</strong>不能完成(source route failed)</li>
<li>目的网络<strong>不可知</strong>(unknown destination network)</li>
<li>目的主机<strong>不可知</strong>(unknown destination host)</li>
<li>不可知是完全不可以解析，不可达是可以解析但是不可以到达</li>
</ol>
</li>
<li>差错报告报文数据部分的格式<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111164231814.png" alt="image-20241111164231814"><ol>
<li>一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分</li>
<li>ICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)</li>
<li>然后添加一个首部作为IP数据报进行发送。</li>
</ol>
</li>
</ol>
</li>
<li>查询报文：一般这种情况不是很多</li>
</ol>
</li>
<li><p>不应发送ICMP差错报文的情况</p>
<ol>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)</li>
<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li>
<li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文<ol>
<li>127.0.0.0:逻辑回路地址</li>
<li>0.0.0.0:确认路由地址</li>
</ol>
</li>
</ol>
</li>
<li><p>PING (Packet InterNet Groper)</p>
<ol>
<li>PING 是用ICMP的”Echo request”和”Echo reply”消息来实现的</li>
<li>PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。</li>
<li>PING 使用了ICMP回送请求与回送回答报文</li>
<li>PING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP</li>
</ol>
</li>
</ol>
<h1 id="第四章-·-运输层"><a href="#第四章-·-运输层" class="headerlink" title="第四章 · 运输层"></a>第四章 · 运输层</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ol>
<li>第4层执行多项功能：<ol>
<li>分割上层应用程序数据(新的数据单元-数据段)</li>
<li>建立端到端(end to end)的运营</li>
<li>从一个终端主机向另一个终端主机发送段(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传)</li>
<li>流量控制和可靠性<ol>
<li>可以比喻为与外国人交谈:通常，您会要求外国人重复他&#x2F;她的话(可靠性)并慢声说话(流量控制)</li>
<li>双方主机的网络的处理能力不同，缓存能力不同</li>
</ol>
</li>
</ol>
</li>
<li>两个特别重要的第4层协议：<ol>
<li>传输控制协议(TCP, Transmission Control Protocol)</li>
<li>用户数据报协议(UDP, User Datagram Protocol)</li>
</ol>
</li>
<li>将传出邮件分成多个部分,在目标站重新组合消息</li>
<li>TCP: 可靠(效率比较低，早期网络应用少，需要可靠性)<ol>
<li>面向连接，使用确认机制，提供流量控制</li>
<li>软件检查细分</li>
<li>重新发送丢失或错误的任何内容</li>
</ol>
</li>
<li>UDP: 不可靠<ol>
<li>无连接，不使用确认，不进行流量控制</li>
<li>不提供用于细分的软件检查</li>
<li>直接丢弃错误的报文，而不进行其他操作。</li>
</ol>
</li>
<li>SCTP(Stream Control Transmission Protocol)：流控制传输协议，为了进行视频和音频的传输</li>
</ol>
<h2 id="服务模型（Service-Model）"><a href="#服务模型（Service-Model）" class="headerlink" title="服务模型（Service Model）"></a>服务模型（Service Model）</h2><ol>
<li>TCP和UDP都使用**端口（port）**来跟踪(track)同时穿越网络的不同会话</li>
<li>端口分配规范<ol>
<li>低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)</li>
<li>0-1023是熟知端口，有分发的规范，不应当被随意使用</li>
<li>1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突</li>
<li>基于端口号的不同，进行不同的包的分发</li>
</ol>
</li>
</ol>
<h2 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h2><ol>
<li><p>要解决的问题</p>
<ol>
<li>可靠传输</li>
<li>流传输<ol>
<li>滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)</li>
<li>避免拥塞</li>
</ol>
</li>
<li>连接控制<ol>
<li>建立连接:三次握手</li>
<li>断开连接:四次握手</li>
</ol>
</li>
</ol>
</li>
<li><p>TCP数据段的格式</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111172358408.png" alt="image-20241111172358408"></p>
<ol>
<li><p>固定首部长度位20字节</p>
<ol>
<li><p>源端口和目的端口（各16位）</p>
<ol>
<li>端口是运输层与应用层的服务接口</li>
<li>运输层的复用和分用功能都要通过端口才能实现</li>
</ol>
</li>
<li><p>序号（32位）(4G &#x3D; 2^32^ bit的地址空间)：</p>
<ol>
<li>TCP 传送的数据流中的每一个字节都编上一个序号</li>
<li>序号字段的值指本报文段所发送的数据的第一个字节的序号</li>
<li>通过序号字段做可靠传输的保证，指示的是一个<strong>TCP传输的bit编码</strong>，而不是地址。</li>
<li>我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。</li>
</ol>
</li>
<li><p>确认号（32位）：是期望收到对方的下一个报文段的数据的第一个字节的序号</p>
<ol>
<li>确认对方的数据号(发送同时对上一次传输进行确认)</li>
<li>体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701</li>
</ol>
</li>
<li><p>数据偏移（4位）</p>
<ol>
<li>指出 TCP 报文段的数据起始处距 TCP 报文段的起始处的长度(Data部分从什么地方开始算)</li>
<li>单位是 32 位字(以 4 字节为计算单位)</li>
<li>不满足的话使用填充位保证为4字节的整数倍(保证对齐问题)</li>
</ol>
</li>
<li><p>保留字段（6位）</p>
</li>
<li><p>标记位（共6位）</p>
<ol>
<li>URG（紧急位）：为1时表示紧急，优先传送</li>
<li>ACK（有效位）：为1时表示确认号有效</li>
<li>PSH（推送位）：<ol>
<li>接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将<strong>缓存所有部分</strong>都传输，而并不是只将这个报文段的信息进行传输。</li>
<li>TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</li>
</ol>
</li>
<li>RST（复位位）：ReSeT &#x3D; 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</li>
<li>SYN（同步位）：同步 SYN &#x3D; 1:表示这是一个连接请求或连接接受报文(初始的时候才出现)</li>
<li>FIN（终止位）：用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了)</li>
</ol>
</li>
<li><p>窗口（16位）：占 2 字节，用来让对方设置<strong>发送窗口</strong>的依据，单位为字节。表示可以进行传输的窗口大小是多少。</p>
</li>
<li><p>检验和（16位）</p>
</li>
<li><p>紧急指针（16位）：指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)</p>
</li>
</ol>
</li>
<li><p>可变部分</p>
<ol>
<li>选项<ol>
<li>TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)</li>
<li>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</li>
<li>数据字段加上 TCP 首部才等于整个的 TCP 报文段</li>
</ol>
</li>
<li>填充字段：这是为了使整个首部长度是 4 字节的整数倍。</li>
</ol>
</li>
</ol>
</li>
<li><p>TCP协议</p>
<ol>
<li><p>概述</p>
<ol>
<li>主机使用网段(TPDU)交换数据</li>
<li>每个段都有：<ol>
<li>标头为20个字节(可选部分除外)</li>
<li>0或更多数据字节(请求连接的时候)</li>
</ol>
</li>
<li>段的大小必须与IP数据包匹配，并且还必须满足底层的需求<ol>
<li>例如，以太网的MTU(最大传输单位)为1500字节</li>
<li>是面向字节的传输。</li>
</ol>
</li>
<li>每个字节都有一个32位序号<ol>
<li>通讯中商定初识序号，确认到每一位</li>
<li><strong>面向字节</strong>:TCP传输的数据块和上层数据给的数据块的大小可以不对应(通过商量解决)</li>
<li>根据网络条件，对<strong>每一个字节</strong>进行确认</li>
</ol>
</li>
</ol>
</li>
<li><p>三次握手（可靠连接）：</p>
<ol>
<li><p>红蓝两军问题：无论通信多少次，都不能确定一个完全可信的时间。</p>
</li>
<li><p>建立过程：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241115111431299.png" alt="image-20241115111431299"></p>
<ol>
<li><p>第一次握手：</p>
<ul>
<li>服务器等待，客户端请求</li>
</ul>
<ol>
<li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li>
<li>客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求</li>
</ol>
</li>
<li><p>第二次握手：服务器检查是否存在监视端口的服务进程</p>
<ol>
<li>如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段</li>
<li>如果存在进程，则决定拒绝或接受请求</li>
<li>如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段</li>
</ol>
</li>
<li><p>第三次握手：</p>
<ol>
<li>客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接</li>
<li>为了避免出现延时之类的情况，执行第三次握手(如果只有两次会浪费服务器资源)</li>
</ol>
</li>
<li><p>通知上层应用，准备传输数据</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>停止等待协议</p>
<ol>
<li>发送段后，暂时保留备份<ol>
<li>在发送后没有收到确认的时候，要保存备份来重传</li>
<li>收到确认的时候，抛弃备份</li>
<li>超时计时器:如果对方的应答超过一定时间后则直接进行重发(时间要比正常往返时间稍微长一点)</li>
</ol>
</li>
<li>每个网段和ACK必须具有ID</li>
<li>重新发送时间必须<strong>大于</strong>平均传输时间 * 2</li>
<li>停止等待协议是一个简单的协议，但是效率很低</li>
<li>实施控制，来进行错误处理</li>
<li>丢失确认，确认延迟：<ol>
<li>发过去没有应答或者丢失:进行重传</li>
<li>应答超时，有收到请求立即重传</li>
<li>晚到的应答直接丢弃(不做处理)</li>
</ol>
</li>
</ol>
</li>
<li><p>可靠通信：</p>
<ul>
<li>ARQ (Automatic Repeat reQuest) 自动重传请求：这表示”重新发送请求”为自动发送并且接收方无需请求发送方重新发送错误段</li>
</ul>
<ol>
<li>连续ARQ协议<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241115112910520.png" alt="image-20241115112910520"><ol>
<li>多个数据同时发送过去(一次发送多个)</li>
<li>窗口大小是双方协商的，通过TCP报文中的窗口字段表示</li>
<li>例子： <img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241115113525029.png" alt="image-20241115113525029"></li>
</ol>
</li>
</ol>
</li>
<li><p>释放链接（四次握手）： <img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241115114157641.png" alt="image-20241115114157641"></p>
<ol>
<li>为什么B最后要等待2倍最大等待时间（2MSL，Max Seg Livetime）？<ol>
<li>第三次挥手发过去再收到回复，两个过程的最长时间为2MSL</li>
<li>如果2MSL之后还没有收到回复，B就重发</li>
<li>目的是为了确保A发送的最后一个ACK可以到达B，确保AB断开连接，连接上的所有段均已消失</li>
</ol>
</li>
</ol>
</li>
<li><p>TCP中的计时器</p>
<ol>
<li>重传计时器:多长时间进行重传</li>
<li>坚持计时器:避免死锁(WIN &#x3D; 0的时候修改WIN但是没有办法发送过去)：收到WIN &#x3D; 0 的时候，开始进行计时，到时间主动询问</li>
<li>保持计时器:<ol>
<li>发送数据段后，刷新</li>
<li>如果到达一定的时间，则再次询问是不是还要保持连接。</li>
</ol>
</li>
<li>时间等待计时器</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h2><ol>
<li><p>概况：</p>
<ol>
<li>为什么我们需要UDP？<ol>
<li>没有建立连接(避免延时)</li>
<li>简单：发送方，接收方无连接状态</li>
<li>小段标题</li>
<li>没有拥塞控制：UDP可以按照期望的速度传输</li>
</ol>
</li>
<li>无连接：没有复杂控制，头部简单<ol>
<li>UDP发送方，接收方之间没有握手(HandShake，包含进程等信息的)</li>
<li>每个UDP段都独立处理</li>
</ol>
</li>
<li>常用于流媒体(Stream)多媒体(multimedia)应用<ol>
<li>容忍损失:无非就是降低帧率</li>
<li>这类应用是<strong>速率敏感</strong>的应用，而不一定是质量敏感的应用。</li>
</ol>
</li>
<li>UDP用于：<ol>
<li>RIP:定期发送路由信息(periodically)</li>
<li>DNS:避免延迟建立TCP连接(DNS需要快速找到)</li>
<li>SNMP：拥塞时(congestion)，SNMP必须仍然可运行。在没有拥塞和可靠性控制机制的情况下，UDP在这种情况下的性能要优于TCP。(主播和多播，大量信息传输)</li>
<li>其他协议包括TFTP，DHCP</li>
</ol>
</li>
<li>必要时增加<strong>应用层</strong>的可靠性</li>
<li>流媒体就算有数据丢失也问题不大(对屏幕进行模糊化处理就行),但是发送速率是很重要的！(就算丢包了，也可以模糊处理)</li>
</ol>
</li>
<li><p>UDP数据帧格式</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241122103126108.png" alt="image-20241122103126108"></p>
<ol>
<li>UDP的数据段很简单</li>
<li>UDP只有8个字节的首部</li>
<li>源端口、目的端口、长度、校验(data)、Data</li>
<li>校验也要对data一并校验，如果出现错误，直接丢弃。</li>
<li>应用层进行数据切片，决定如何进行发送，UDP直接发送</li>
</ol>
</li>
</ol>
<ul>
<li>TCP和UDP的不同点<ol>
<li>TCP：<ol>
<li>不是立即交给上层校验，而是需要先和对方沟通</li>
<li>缓存满了才统一交付。</li>
</ol>
</li>
<li>UDP：<ol>
<li>直接转发报文，保留报文边界（不做合并）</li>
<li>IP进行划分</li>
<li>应用程序会发送比较合适的UDP报文大小进行发送</li>
</ol>
</li>
</ol>
</li>
<li>相同点：校验是相同的。</li>
</ul>
<h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT (Network Address Translation)"></a>NAT (Network Address Translation)</h2><ol>
<li><p>NAT，是在IP数据包头中将一个地址交换为另一个地址的过程</p>
<ol>
<li>网络地址转换(映射)</li>
<li>是网络地址即将用完的解决方案</li>
</ol>
</li>
<li><p>实际上，NAT用于允许私下寻址的主机访问Internet。</p>
</li>
<li><p>IP地址耗尽的解决方案之一</p>
<ol>
<li>保留注册(合法)地址</li>
<li>连接到Internet时增加灵活性</li>
</ol>
</li>
<li><p>作用：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241122103959939.png" alt="image-20241122103959939"></p>
<ol>
<li>NAT需要一个路由器来实现</li>
<li>左侧是一个局域网</li>
<li>在NAT 路由器将局部地址 转换成 网络上的地址(双向转换，有一个NAT表)</li>
</ol>
</li>
<li><p>类型：</p>
<ol>
<li>静态NAT：构建一张静态NAT表。这样是不能新增地址的。</li>
<li>动态NAT：指定一个地址池，在池内的地址可以上网。上网时建立临时记录。先来先服务，满了只能等。</li>
<li>PAT：第一个是IP。可以有不同的端口。同样的出口IP</li>
</ol>
</li>
<li><p>NAT地址类型：</p>
<ol>
<li>内部本地地址(Inside Local address)：内网IP</li>
<li>内部全局地址(Inside Global address)：注册IP，是对外展示的IP地址</li>
<li>外部全局地址(Outside Global adress)：由主机所有者分配的IP地址。通常是注册地址</li>
</ol>
</li>
<li><p>PAT</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241122105510210.png" alt="image-20241122105510210"></p>
<ol>
<li>本地内部地址的各个主机IP不同，端口号可以相同或不同。</li>
<li>转换成内部全局地址，IP都一样了，端口号不同</li>
</ol>
</li>
</ol>
<h1 id="第五章-·-会话层，展示层，应用层"><a href="#第五章-·-会话层，展示层，应用层" class="headerlink" title="第五章 · 会话层，展示层，应用层"></a>第五章 · 会话层，展示层，应用层</h1><h2 id="第五层：会话层"><a href="#第五层：会话层" class="headerlink" title="第五层：会话层"></a>第五层：会话层</h2><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol>
<li>基于令牌进行交互发言，通过数据同步保证数据完整性(应用逻辑)</li>
<li>进行数据分段、拼接，保证传输的有效。</li>
<li>同步技术，保证故障恢复。</li>
</ol>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ol>
<li>双向同步通讯？<ol>
<li>全双工通信</li>
<li>半双工通信</li>
<li>单工通信</li>
</ol>
</li>
<li>双向交替控制？<ol>
<li>会话连接、活动开始、数据校验(同步)</li>
<li>令牌转换等</li>
</ol>
</li>
<li>是否同步了您的会话的主题？<ol>
<li>**同步点(CheckPoint)**用于分隔会话的各个部分，以前称为对话(dialogues)<ol>
<li>同步点:发送一定数据后设置同步点</li>
<li>次同步点:作为同步点的一个子集，进行数据校验</li>
<li>主同步点:按照主同步点进行校验确认</li>
<li>如果错误，恢复到上次都已经同步的主同步点</li>
</ol>
</li>
<li>对话分离(Seperation)是通信的有序启动，终止和管理</li>
<li>尽量保证了通话的效率和可靠性。</li>
</ol>
</li>
</ol>
<h2 id="第六层：表示层"><a href="#第六层：表示层" class="headerlink" title="第六层：表示层"></a>第六层：表示层</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>表示层负责以接收</p>
<p>设备可以理解</p>
<p>的形式表示数据。</p>
<ol>
<li>传送语法协商</li>
<li>接受语法协商</li>
</ol>
</li>
<li><p>表示层具有3个主要功能：</p>
<ol>
<li>数据格式(format)</li>
<li>数据压缩(compression):早期网络比较慢，倾向于先压缩在发送</li>
<li>数据加密(encryption)</li>
</ol>
</li>
<li><p>协商编码方式可以在会话层中实现</p>
</li>
<li><p>数据编码格式</p>
</li>
<li><p>图形文件格式</p>
</li>
<li><p>多媒体文件格式</p>
</li>
<li><p>数据加密和压缩</p>
</li>
</ol>
<h2 id="第七层：应用层"><a href="#第七层：应用层" class="headerlink" title="第七层：应用层"></a>第七层：应用层</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ol>
<li>上图中各层的一些协议和使用：对端口进行管理</li>
<li>应用程序层(最接近用户)支持应用程序的通信组件</li>
</ol>
<h3 id="职责-1"><a href="#职责-1" class="headerlink" title="职责"></a>职责</h3><ol>
<li>定并确定预期的通信合作伙伴的可用性</li>
<li>同步合作的应用程序</li>
<li>同步协作的应用</li>
<li>建立有关错误恢复程序的协议</li>
<li>控制数据完整性</li>
<li>通过网络应用(network applications)为OSI模型的其余部分提供一个直接接口，或是通过独立应用提供非直接接口，如文字处理，电子表格，演示管理器(presentation managers)，网络重定向器</li>
<li>不同应用不同情况</li>
</ol>
<h3 id="超文本传输协议-HTTP，HyperText-Transfer-Protocol"><a href="#超文本传输协议-HTTP，HyperText-Transfer-Protocol" class="headerlink" title="超文本传输协议 (HTTP，HyperText Transfer Protocol)"></a>超文本传输协议 (HTTP，HyperText Transfer Protocol)</h3><ol>
<li><p>概述</p>
<ol>
<li>和电视的播放比较类似，通过浏览器界面切换内容，通过URL切换</li>
<li>多源点传输，内容规范</li>
<li>如何实现URL的转发:HTTP</li>
<li>如何完成界面:html</li>
<li>如何整合和查询:搜索引擎</li>
</ol>
</li>
<li><p>统一资源定位符 URL(Uniform Resource Locator)</p>
<ol>
<li><pre><code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;
</code></pre>
<ol>
<li>访问方式:协议HTTPS 或者 HTTP</li>
<li>主机:域名的方式</li>
<li>端口对应进程</li>
<li>路径对应具体的文件</li>
</ol>
</li>
</ol>
</li>
<li><p>HTTP</p>
<ol>
<li><strong>HTTP 是面向事务的客户服务器协议</strong>。</li>
<li>HTTP 1.0 协议是无状态的(stateless)。<ol>
<li>每一次请求是独立的，不记录上一次请求信息。</li>
<li>Cookie是征求同意的存储(维持登录状态)，可以保证在多个应用之间维持登录状态。</li>
</ol>
</li>
<li>HTTP 协议本身也是<strong>无连接</strong>的，虽然它使用了面向连接的 TCP 向上提供的服务。</li>
<li>万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为HTTP daemon， 有的文献将它缩写为 HTTPD。</li>
<li>HTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户。</li>
</ol>
</li>
<li><p>报文结构</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241122115929627.png" alt="image-20241122115929627"></p>
<ol>
<li>报文由三个部分组成，即开始行、首部行和实体主体。</li>
<li>在请求报文中，开始行就是请求行。</li>
<li>请求报文和应答报文的应答结构都是一样的</li>
<li>应答码：<ol>
<li>2xx:成功</li>
<li>3xx:重定向</li>
<li>4xx:错误</li>
<li>5xx:服务器内部错误</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="FTP（File-Transfer-Protocol）-和-TFTP（Trivial-File-Transfer-Protocol）"><a href="#FTP（File-Transfer-Protocol）-和-TFTP（Trivial-File-Transfer-Protocol）" class="headerlink" title="FTP（File Transfer Protocol） 和 TFTP（Trivial File Transfer Protocol）"></a>FTP（File Transfer Protocol） 和 TFTP（Trivial File Transfer Protocol）</h3><ol>
<li>概述<ol>
<li>FTP是一种可靠的，面向连接的服务，它使用TCP传输文件。<ol>
<li>FTP首先在客户端和服务器(端口21)之间建立<strong>控制连接</strong></li>
<li>然后，建立第二个连接，这是计算机之间通过其传输数据的链接。(端口20)</li>
<li>有安全认证</li>
</ol>
</li>
<li>TFTP是使用UDP的无连接服务(简化的FTP)<ol>
<li>体积小，易于实施。更加方便</li>
<li>例如： TFTP在路由器上用于传输配置文件和Cisco IOS映像</li>
<li>不支持交互，没有目录浏览功能</li>
</ol>
</li>
<li>互联网早期的时候，文件传输量是很大的。</li>
</ol>
</li>
<li>主进程工作步骤<ol>
<li>打开熟知端口(端口号为 21)，使客户进程能够连接上。(可以修改熟知端口)</li>
<li>等待客户进程发出连接请求。</li>
<li>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。<ol>
<li>控制连接</li>
<li>数据连接:数据通信</li>
<li>需要建立上面两个连接才能完成传输</li>
</ol>
</li>
<li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</li>
</ol>
</li>
</ol>
<h3 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h3><p>远程登录：Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能。用服务器运行本地输入的指令。</p>
<h3 id="SMTP和POP3"><a href="#SMTP和POP3" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3><ol>
<li>电子邮件服务器使用SMTP发送和POP接收邮件相互通信。<ol>
<li>SMTP (Simple Mail Transfer Protocol) 邮件发送，登录发送等操作</li>
<li>POP3 (Post Office Protocol version 3) 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125163103685.png" alt="image-20241125163103685"></li>
</ol>
</li>
<li>MIME（Multipurpose Internet Mail Extensions）<ol>
<li>MIME标准扩充了SMTP标准</li>
<li>很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如下图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125163325803.png" alt="image-20241125163325803"></li>
</ol>
</li>
</ol>
<h3 id="简单网络管理协议（SNMP，Simple-Network-Management-Protocol）"><a href="#简单网络管理协议（SNMP，Simple-Network-Management-Protocol）" class="headerlink" title="简单网络管理协议（SNMP，Simple Network Management Protocol）"></a>简单网络管理协议（SNMP，Simple Network Management Protocol）</h3><ol>
<li>简单网络管理协议(SNMP)是一种应用程序层协议，可简化网络设备之间的管理信息交换。</li>
<li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li>
<li>通过管理数据库(MIB)进行信息交流</li>
<li>使用UDP通过广播进行实现。</li>
</ol>
<h3 id="域名系统-DNS-Domain-Name-System"><a href="#域名系统-DNS-Domain-Name-System" class="headerlink" title="域名系统(DNS, Domain Name System)"></a>域名系统(DNS, Domain Name System)</h3><ol>
<li>概述：域名系统(DNS)是网络上的服务，该服务管理域名并响应客户端将域名转换为关联IP地址的请求。早期是用IP地址以及Host文件来进行访问</li>
<li>域名：<ol>
<li>概述：<ol>
<li>使用<code>.</code>将字符串进行分隔开，字符串不应该太长</li>
<li>越靠后域名级别越高</li>
<li>www就是对应到主机群</li>
</ol>
</li>
<li>顶级域TLD（Top Level Domain）<ol>
<li>国家TLD(nTLD)<ol>
<li>.cn(CHINA) 中国</li>
</ol>
</li>
<li>通用TLD(gTLD)，最早的域包括：<ol>
<li>.com Enterprises and companies 企业和公司</li>
<li>.edu Educational facilities 教育机构</li>
</ol>
</li>
<li>Infrastructure domain 基础设施领域<ol>
<li>Only one: arpa, for resolving domain names reversely 仅一个：arpa，用于反向解析域名</li>
</ol>
</li>
<li>Recently, new TLD domain added</li>
</ol>
</li>
<li>域名服务器（Domain Name System）<ol>
<li>顶级域名底下的域名就是由顶级域名下面进行管理</li>
<li>根域名服务器存储位置，所以子服务器知道根服务器的地址即可</li>
</ol>
</li>
<li>结合域名服务器查找IP地址<ol>
<li>DNS系统以层次(hierarchy)结构设置，该层次结构创建不同级别的DNS服务器。</li>
<li>此级别的DNS服务器判断其自身是否能够将域名转换为关联的IP地址：<ol>
<li>如果可以，则将结果返回给客户端</li>
<li>如果没有，它将请求发送到更高级别。(向上级请求)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125164918106.png" alt="image-20241125164918106"><ul>
<li>请求分为两种:<ul>
<li>能够应答</li>
<li>不能够应答</li>
</ul>
</li>
<li>从主机的视角看，这是一个递归的过程：先问本地DNS，本地DNS若不知道再问其他的</li>
<li>从本地DNS的视角看，这是一个迭代的过程：先访问根DNS，得到顶级域的位置，再去问顶级域，得到二级域的位置，等等。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="沟通的方式"><a href="#沟通的方式" class="headerlink" title="沟通的方式"></a>沟通的方式</h3><ol>
<li>无上下文，请求后就断开：<ol>
<li>当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端。</li>
<li>处理完成后，连接断开</li>
</ol>
</li>
<li>有上下文：<ol>
<li>作为Telnet和FTP，建立与服务器的连接并保持该连接，直到执行所有处理。</li>
<li>当用户确定他&#x2F;她已完成时，客户端将终止连接。</li>
</ol>
</li>
<li>所有的交流活动都属于这两类之一</li>
</ol>
<h3 id="动态主机配置协议（DHCP，Dynamic-Host-Configuration-Protocol）"><a href="#动态主机配置协议（DHCP，Dynamic-Host-Configuration-Protocol）" class="headerlink" title="动态主机配置协议（DHCP，Dynamic Host Configuration Protocol）"></a>动态主机配置协议（DHCP，Dynamic Host Configuration Protocol）</h3><ol>
<li><p>概述：</p>
<ol>
<li>一个协议软件在使用之前先作正确协议配置，具体配置内容取决于协议。</li>
<li>接到因特网的计算机的协议软件需要配置的项目包括：<ol>
<li>IP 地址</li>
<li>子网掩码</li>
<li>默认路由器的 IP 地址</li>
<li>域名服务器的 IP 地址</li>
</ol>
</li>
<li>Dynamic Host Configuration Protocol可以高效地分配IP地址<ol>
<li>局域网的网络协议</li>
<li>使用UDP来实现</li>
</ol>
</li>
<li>目前一般都是自动获取IP地址，而不需要手动去获取IP地址等信息</li>
</ol>
</li>
<li><p>DHCP工作过程</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170149909.png" alt="image-20241125170149909"></p>
<ol>
<li><p>发现阶段<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170529753.png" alt="image-20241125170529753"></p>
<ol>
<li>广播携带地址是MAC地址</li>
</ol>
</li>
<li><p>响应阶段<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170615658.png" alt="image-20241125170615658"></p>
</li>
<li><p>选择阶段<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170711415.png" alt="image-20241125170711415"></p>
</li>
<li><p>租约确认阶段<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170752508.png" alt="image-20241125170752508"></p>
</li>
<li><p>租期续约：在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP 参数更新自己的配置，IP租用更新完成</p>
</li>
<li><p>租期释放：</p>
<ul>
<li><p>当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约</p>
</li>
<li><p>到时间后，Server会主动询问，如果没有应答会自动释放</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>DHCP报文结构<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125170942701.png" alt="image-20241125170942701"></p>
</li>
<li><p>报文类型</p>
<ol>
<li>DHCP Discover：发现</li>
<li>DHCP Offer：提供</li>
<li>DHCP Request：告知决定</li>
<li>DHCP ACK：租约确认</li>
<li>DHCP NAK：租约不确认</li>
<li>DHCP Release：释放租约</li>
<li>DHCP Decline:收到Ack后，Client告诉服务器不接受</li>
<li>DHCP Inform:客户端向服务器端请求详细信息</li>
</ol>
</li>
<li><p>DHCP欺骗与防范</p>
<ol>
<li>欺骗<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125171431223.png" alt="image-20241125171431223"><ol>
<li>客户端以广播的方式来寻找服务器，并且只接收第一个到达的服务器提供的网络配置参数。</li>
<li>非授权的DHCP服务器先应答，客户端最后获得的网络参数即是非授权的，客户端即被欺骗。(恶意服务器把自己作为默认网关)</li>
<li>在实际应用DHCP的网络中，基本上都会采用DHCP中继，因此本网络的非授权DHCP服务器一般都会先于其余网络的授权DHCP服务器的应答(由于网络传输的延迟)，在这样的应用中，DHCP欺骗更容易完成。</li>
</ol>
</li>
<li>防范<ol>
<li>在交换机上启用DHCP Snooping功能 DHCP Snooping技术通过建立和维护DHCP Snooping绑定表过滤不可信任的DHCP信息:比如B的DHCP不能通过认证，交换机拒绝进行转发<ol>
<li>在交换机的全局配置模式中启用DHCP Snooping:<code>switch (config)# ip dncp snooping</code></li>
<li>在交换机的全局配置模式中开启需要启用DHCP Snooping 的VLAN”:<code>switch (config)# ip dhcp snooping vlan vlan号</code></li>
<li>在端口配置子模式中将授权DHCP服务器所连的端口设为信任端口(缺省都是非信任的端口):就是连接到DHCP Server的端口:<code>switch (config-if)# ip dhcp snooping trust</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第六章-·-路由器和网络"><a href="#第六章-·-路由器和网络" class="headerlink" title="第六章 · 路由器和网络"></a>第六章 · 路由器和网络</h1><h2 id="路由器基础"><a href="#路由器基础" class="headerlink" title="路由器基础"></a>路由器基础</h2><ol>
<li><p>内部组件<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125171736811.png" alt="image-20241125171736811"></p>
<ul>
<li>特殊组件的计算机</li>
<li>console口进行具体的调试</li>
<li>辅助口(Auxiliary):一般不用，但是可能会用到</li>
</ul>
<ol>
<li>RAM（随机存取存储器）<ol>
<li>路由器配置文件的临时存储，一般做为内存使用</li>
<li>断电或重新启动时RAM内容丢失</li>
<li>存储:<ol>
<li>路由表</li>
<li>ARP缓存</li>
<li>快速切换缓存</li>
<li>报文缓存:可能前面有正在处理的，需要等待</li>
<li>数据包保留队列</li>
</ol>
</li>
<li>根据地址位就可以读到地址内容(访问比较快)</li>
</ol>
</li>
<li>非易失随机存取存储器(NVRAM, Non-volatile RAM)<ol>
<li>存储备份(backup)&#x2F;启动(startup)配置文件</li>
<li>路由器掉电或重启时内容不会丢失。</li>
<li>内置电池的方式来保证不断电，这一部分可以整体单独拿出来</li>
<li>保证快速访问，但是存储空间有限。</li>
</ol>
</li>
<li>Flash (相当于台式机硬盘)<ol>
<li>电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)</li>
<li>存储了Cisco IOS(互联网操作系统)</li>
<li>允许更新软件而无需更换闪存芯片</li>
<li>可以存储多个版本的IOS</li>
<li>断电保持</li>
</ol>
</li>
<li>只读存储器(ROM, Read-Only Memory)<ol>
<li>包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。</li>
<li>引导程序(加载Cisco IOS)</li>
<li>作系统软件<ol>
<li>IOS的备份，精简(trimmed down)版本</li>
<li>升级需要安装新的芯片组</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>接口</p>
<ol>
<li>数据包通过其进入和离开路由器的网络连接口</li>
<li>附在主板(motherboard)上或作为单独的模块。</li>
<li>大部分是网口，主要是用来支持网络的</li>
<li>0&#x2F;0第一个，串口接口可能还分多个</li>
</ol>
</li>
</ol>
<h2 id="路由器启动-startup-步骤"><a href="#路由器启动-startup-步骤" class="headerlink" title="路由器启动(startup)步骤"></a>路由器启动(startup)步骤</h2><ol>
<li>系统启动程序<ol>
<li>执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查</li>
<li>验证CPU，内存和网络接口端口的基本操作。</li>
<li>软件初始化。</li>
</ol>
</li>
<li>软件启动程序<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125173124621.png" alt="image-20241125173124621"><ol>
<li>步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。</li>
<li>步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。</li>
<li>步骤3:加载操作系统映像。<ol>
<li>先从Flash找，也就只有一个image文件，将image导入内存</li>
<li>如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image</li>
<li>如果TFTP也没有配置，则去ROM中导出IOS</li>
</ol>
</li>
<li>步骤4:将保存在NVRAM中的配置文件加载到主存储器中，并一次执行一行。<ol>
<li>先看NVRAM中有没有配置(start.config)</li>
<li>然后看TFTP Server有没有配置，如果有则下载一个</li>
<li>如果都没有，用console进行配置</li>
</ol>
</li>
<li>步骤5-如果NVRAM中<strong>没有</strong>有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为<strong>设置模式</strong>。</li>
</ol>
</li>
<li>查看和修改基本的路由器配置</li>
</ol>
<h2 id="路由和配置"><a href="#路由和配置" class="headerlink" title="路由和配置"></a>路由和配置</h2><ol>
<li><p>使用网络寻址进行路由</p>
<ol>
<li>路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。<ol>
<li><strong>交换功能</strong>允许路由器在一个接口上<strong>接受数据包</strong>并<strong>通过第二个接口转发。</strong></li>
<li><strong>路径确定</strong>功能使路由器能够选择<strong>最合适的接口</strong>来<strong>转发数据包</strong>。</li>
</ol>
</li>
<li>路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器</li>
<li>地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。</li>
</ol>
</li>
<li><p>静态路由<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241128163353972.png" alt="image-20241128163353972"></p>
<ol>
<li>尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。</li>
<li>当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问)</li>
<li>这种只有一个出口的网络分区称为末节网络(Stub Network)</li>
</ol>
</li>
<li><p>管理距离</p>
<ol>
<li>**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)</li>
<li>数字越大，可信度(trustworthiness)越低。</li>
<li>因此静态路由的管理距离通常很短(默认值为1)</li>
<li>管理距离是0的路由是直连网段，是最可信的，比静态路由还高</li>
</ol>
</li>
<li><p>动态路由</p>
<ol>
<li>动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare))</li>
<li>往往网络是冗余的，保证连通性</li>
<li>静态路由的问题:如果指定的路径中出现故障就会出问题，而动态路由就避免了这个问题。</li>
</ol>
</li>
<li><p>收敛时间</p>
<ol>
<li>收敛时间:<ol>
<li>从刚启动到网络达到稳定的时间</li>
<li>从发生变化到再次稳定的时间</li>
</ol>
</li>
<li>收敛时间越短，路由协议越强，需要路由器的基本硬件支持。</li>
</ol>
</li>
<li><p>动态路由协议</p>
<ol>
<li>分类<ol>
<li>距离矢量(DV,Distance Vector)</li>
<li>链路状态(LS,Link State)</li>
<li>混合路由(HR,Hybird Routing)</li>
</ol>
</li>
<li>距离矢量协议（DVP）<ol>
<li>协议内容<ol>
<li>距离矢量算法不允许路由器知道互联网络的<strong>确切拓扑</strong></li>
<li>基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。<ol>
<li>大家交换Routing Table</li>
<li>只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑</li>
</ol>
</li>
</ol>
</li>
<li>路由回路问题：<ol>
<li>是DV的缺陷</li>
<li>例子：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241128164612339.png" alt="image-20241128164612339"><ol>
<li><strong>稳定之后</strong>,如果NetWork1不可到达</li>
<li>B发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，D就以为可以通过C到达，这样子就可能循环下去，然后不收敛。</li>
</ol>
</li>
<li>解决方案<ol>
<li>定义最大值(Maximum）：设置最大跳数，比如最多转发15跳，16跳以上为不可达</li>
<li>路由中毒(Route Poisoning)<ol>
<li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li>
<li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li>
<li>最终所有的路由器都知道不可达</li>
<li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li>
</ol>
</li>
<li>水平分割(Split Horizon)<ol>
<li>从某个端口收到的报文信息，不能再从端口发送回去</li>
<li>比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的</li>
<li>如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的</li>
<li><strong>有名词解释题目</strong></li>
</ol>
</li>
<li>计时器(Hold-Down Timers)<ol>
<li>我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)</li>
<li>如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。</li>
<li>计时器结束后，删除掉对应的条目，避免出现问题</li>
<li>每一条路由表的记录都有<strong>有效时间</strong></li>
</ol>
</li>
</ol>
</li>
<li>阻止发送路由更新<ol>
<li>接受路由表的更新，但是不发送报文出去</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>链路状态协议(LSP, Link-state Protocol)<ol>
<li>内容<ol>
<li>基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题</li>
<li>链接状态路由使用：<ol>
<li>链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息)</li>
<li>拓扑数据库(有LSA组成，每个结点都持有)</li>
<li>根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的)</li>
<li>每个网络的路径和端口的路由表</li>
</ol>
</li>
<li>RFC 1583包含对OSPF链路状态概念和操作的描述。</li>
</ol>
</li>
<li>问题：<ol>
<li>处理和存储要求<ul>
<li>在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算</li>
</ul>
</li>
<li>带宽要求<ol>
<li>在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。</li>
<li>一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力)</li>
<li>注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>比较DV和LS：<ol>
<li>DV:距离矢量<ol>
<li>视野窄，代价小</li>
<li>基于跳数</li>
<li>定期交换路由表，收敛慢</li>
<li>交换路由表</li>
</ol>
</li>
<li>LS:链路状态<ol>
<li>视野宽，有一定代价</li>
<li>基于带宽</li>
<li>初期充分交换，收敛快</li>
<li>交换Linked State的数据库</li>
</ol>
</li>
</ol>
</li>
<li>混合协议(Hybrid Protocols)</li>
</ol>
</li>
<li><p>主动路由协议</p>
<ol>
<li>IP主动路由协议的示例包括：</li>
</ol>
<table>
<thead>
<tr>
<th>英文缩写</th>
<th>英文解释</th>
<th>中文解释</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>RIP</td>
<td>a distance-vector routing protocol</td>
<td>距离矢量协议</td>
<td>DV</td>
</tr>
<tr>
<td>IGRP</td>
<td>Cisco’s distance-vector routing protocol IGRP</td>
<td>思科的距离矢量路由协议</td>
<td>DV，基本启用</td>
</tr>
<tr>
<td>OSPF</td>
<td>Open Shortest Path First</td>
<td>开放式最短路径优先</td>
<td>LSP</td>
</tr>
<tr>
<td>EIGRP</td>
<td>-</td>
<td>平衡的混合路由协议</td>
<td>杂合</td>
</tr>
</tbody></table>
<ol>
<li>工作在第三层</li>
</ol>
</li>
</ol>
<h2 id="主动路由协议"><a href="#主动路由协议" class="headerlink" title="主动路由协议"></a>主动路由协议</h2><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ol>
<li><p>其他内容详见实验笔记</p>
</li>
<li><p>OSPF具有七个状态。简而言之，它们是：</p>
<ol>
<li>Init, 2Way, Ex Start, Exchange, Loading, Full</li>
<li>初始化，双向操作，预先启动，交换，加载，完成</li>
</ol>
</li>
<li><p>环回接口：是一个虚拟接口。可以看做是路由器背后的一台PC，可以通过任意端口访问到。</p>
</li>
<li><p>DR，BDR</p>
<ol>
<li>DR是DR的备份，其他路由器之间就不用通信了</li>
<li>如果有DR则需要至少4条连接，DR和BDR之间必然有连接</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/23.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/23.png" alt="img"></a></p>
<blockquote>
<p><strong>只有多路复用的实现方式需要DR和BDR</strong></p>
</blockquote>
<ol>
<li>然后，每个路由器与DR和BDR形成邻接关系</li>
<li>对于所有OSPF路由器，DR使用224.0.0.5(自己的IP)的<strong>主播地址</strong>向该网段上的所有其他路由器发送链接状态信息。</li>
<li>为确保DR&#x2F;BDR看到所有路由器在网段上发送的链接状态，使用了所有DR&#x2F;BDR的多播地址224.0.0.6。(DR和BDR之间)</li>
<li>选举<ol>
<li>优先级+路由器ID，最大的是DR，第二大的是BDR。</li>
<li>优先级：1-255，默认值:1</li>
<li>路由器ID<ol>
<li>环回IP地址(逻辑端口)，避免端口宕机出现问题。(3中描述的问题)，需要手动配置</li>
<li>如果没有环回IP地址，则物理接口IP为最高值地址(Active的端口上的IP作为参考)</li>
<li>如果接口出现故障，则路由器必须重新建立邻接关系并重新转换(readvertising)LSA</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>报文</p>
<ol>
<li>OSPF只有5个类型的报文</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/26.png" alt="img"></a></p>
<ul>
<li>DBD:LSA,发现没有发送LSR</li>
<li>由于传输要求比较高，所以设计了LSAck</li>
</ul>
</li>
<li><p>OSPF Hello协议</p>
<ol>
<li>路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔(intervals)发送hello。</li>
<li>控制(govern)OSPF hello数据包交换的规则称为Hello协议。</li>
<li>Hello数据包的地址为224.0.0.5。</li>
<li>默认情况下，广播多路访问和点对点网络上<strong>每10秒</strong>发送一次Hello报文。</li>
<li>在连接到NBMA网络的接口(例如帧中继)上，默认时间是30秒。</li>
<li>保持心跳，确定还活着。Hello几乎是空报文，给所有跑OSPF的路由器发送</li>
<li>Hello报文的Type字段设置为1</li>
</ol>
</li>
<li><p>OSPF操作的完整步骤</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/29.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/29.png" alt="img"></a></p>
<ul>
<li>一开始的状态是Down State</li>
<li>然后发送Hello报文(Init State)</li>
<li>B收到A的报文(收到报文一定是邻居):Hello报文的TTL是1，所以不会跨路由器传播，收到即丢弃。</li>
<li>收到后，B也会发送自己的Hello，然后A收到后进入Two Way状态</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/30.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/30.png" alt="img"></a></p>
<ul>
<li>准备交换数据库(Exstart Starts)</li>
<li>首先确认主方(发送方)、从方(接受方)，保证数据有序，简单就是谁的Router ID高</li>
<li>Router ID高的(主方)发送自己DBD报文，从方对主方发送的DBD接受处理并发送</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/31.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/31.png" alt="img"></a></p>
<ul>
<li>交换完成后，各自检查自己是不是有全部的信息<ul>
<li>如果有完整的信息，则发送LSAck</li>
<li>如果发现有没有的，则发送LSR，等待LSU(整个链路的详细信息，不是LSA)来进行学习，之后收到完成后发送LSAck</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>工作步骤</p>
<ol>
<li><h3 id="步骤1：建立路由器邻接"><a href="#步骤1：建立路由器邻接" class="headerlink" title="步骤1：建立路由器邻接"></a>步骤1：建立路由器邻接</h3><ol>
<li>路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播。</li>
<li>如果邻居被发现了：将邻居添加到邻居数据库</li>
<li>发现网络类型<ol>
<li>如果是多路复用网络，进入DR&#x2F;BDR选举过程，然后进入步骤2。</li>
<li>如果是点对点或点对多点网络，则不会举行DR&#x2F;BDR选举过程，并跳过步骤2。</li>
<li>如果hello数据包标头中的DR&#x2F;BDR字段已被占用(即DR &#x2F; BDR对已经存在)，则不会进行DR&#x2F;BDR选举，并跳过步骤2。</li>
</ol>
</li>
<li>如果对方的DP&#x2F;BDP优于我的DP&#x2F;BDP，则接受对方的。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/28.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/28.png" alt="img"></a></p>
<blockquote>
<p>Hello Interval:如果不同不能建立关系,Hello报文包含了DR信息在内的必要的参数</p>
</blockquote>
<h3 id="2-13-2-步骤2：选举DR和BDR"><a href="#2-13-2-步骤2：选举DR和BDR" class="headerlink" title="2.13.2. 步骤2：选举DR和BDR"></a>2.13.2. 步骤2：选举DR和BDR</h3><ol>
<li>如果没有其他路由器联机，则该路由器将成为DR。下一个要”启动”的路由器将是BDR。</li>
<li>如果多个路由器(两个或更多)同时联机，则<ol>
<li>优先级最高的路由器成为DR：优先级为零表示”从不DR”</li>
<li>如果存在平局，则具有最高路由器ID的路由器将成为DR：路由器ID是最高的环回或接口IP地址</li>
<li>具有第二高优先级或路由器ID的路由器成为BDR</li>
</ol>
</li>
<li>如果DR无效，则BDR变为DR。</li>
<li>然而<ol>
<li>如果新的OSPF路由器以更高的优先级或路由器ID加入网络，则当前的DR和BDR<strong>不会更改</strong>。</li>
<li>仅当当前DR失败时，它才成为新的BDR；或者仅当当前DR和BDR失败时，才成为新的DR。</li>
</ol>
</li>
</ol>
<h3 id="2-13-3-步骤3：发现路线"><a href="#2-13-3-步骤3：发现路线" class="headerlink" title="2.13.3. 步骤3：发现路线"></a>2.13.3. 步骤3：发现路线</h3><ol>
<li>这一步从Ex Start状态转换到完整状态</li>
<li>路由器确定”主&#x2F;从(master&#x2F;slave)”关系</li>
<li>多路复用网络中的DR&#x2F;BDR交换LSA，并且所有其他DR将其Type 2 DBD发送给DR&#x2F;BDR。</li>
<li>如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态:所有路由器必须在”加载状态”中等待，直到完全更新请求的路由器。</li>
<li>路由器现在进入完整状态</li>
</ol>
<h3 id="2-13-4-步骤4：选择适当的路线"><a href="#2-13-4-步骤4：选择适当的路线" class="headerlink" title="2.13.4. 步骤4：选择适当的路线"></a>2.13.4. 步骤4：选择适当的路线</h3><ol>
<li>现在，将与网络上的所有其他路由器并行地计算SPF算法。<ol>
<li>切记：在发生这种情况之前，所有路由器必须具有相同的链接状态数据库。</li>
<li>SPF使用Cost作为指标</li>
<li>SPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树</li>
<li>OSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享</li>
</ol>
</li>
</ol>
<h3 id="2-13-5-步骤5-维护路由信息"><a href="#2-13-5-步骤5-维护路由信息" class="headerlink" title="2.13.5. 步骤5:维护路由信息"></a>2.13.5. 步骤5:维护路由信息</h3><ol>
<li>常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制。</li>
<li>根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)<ol>
<li>对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接</li>
<li>对于小于T1的链接，每30秒：非广播多路访问链接</li>
<li>“死间隔”是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)</li>
</ol>
</li>
</ol>
<h3 id="2-13-6-链路状态变化出现"><a href="#2-13-6-链路状态变化出现" class="headerlink" title="2.13.6. 链路状态变化出现"></a>2.13.6. 链路状态变化出现</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/32.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/32.png" alt="img"></a></p>
<ul>
<li>Router A tells all OSPF DRs on 224.0.0.6</li>
<li>Event触发交换:比如A连接的网段断掉了</li>
<li>A使用LSU告知<strong>DR</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/33.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/33.png" alt="img"></a></p>
<ul>
<li>DR tells others on 224.0.0.5</li>
<li>DR 通过LSU告知所有的路由器</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/34.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/34.png" alt="img"></a></p>
<ul>
<li>如果B连接了别的Area，则继续进行交换</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/35.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/35.png" alt="img"></a></p>
<ul>
<li>所有的路由信息交换完毕后，同时更新路由表。</li>
</ul>
</li>
</ol>
</li>
<li><p>配置OSPF</p>
<ol>
<li>在路由器上启动OSPF<ol>
<li><code>Router (config)# router ospf process-id</code></li>
<li>进程号:process-id<ol>
<li>取值: 1 ~ 65535</li>
<li>在一台路由器上识别多个OSPF进程</li>
<li>通常在整个AS(自治系统)中保持相同的进程ID</li>
</ol>
</li>
</ol>
</li>
<li>在路由器上识别IP网络<ol>
<li><code>Router (config-router) # network address wildcardmask area area-id</code></li>
<li>网络地址可以是整个网络，子网或接口的地址。</li>
<li>address:IP地址</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/36.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec08/36.png" alt="img"></a></p>
<ul>
<li>只有一个Area，则为0</li>
<li><strong>Wild-card Mask和子网掩码相反</strong>:子网掩码是255.255.255.0，则Wild-card Address就是0.0.0.255</li>
<li>写IP和写网段最后都是一样的</li>
</ul>
</li>
</ol>
<h1 id="第七章-·-局域网交换与VLAN"><a href="#第七章-·-局域网交换与VLAN" class="headerlink" title="第七章 · 局域网交换与VLAN"></a>第七章 · 局域网交换与VLAN</h1><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ol>
<li>基本功能：<ol>
<li>根据MAC地址建立和维护<strong>交换表</strong>(类似于网桥表)</li>
<li>将帧切换出接口到目标</li>
</ol>
</li>
<li>对称交换<ol>
<li>对称交换可在具有相同带宽(10&#x2F;10 Mbps或100&#x2F;100 Mbps)的端口之间提供交换连接</li>
<li>多个用户尝试某个服务器时，可能会导致瓶颈(对称交换可能会导致带宽不足)。因为多个客户端向服务器访问的话，服务器端口流量会比较阻塞(在对称切换中，双端的带宽是完全对称的)，这是一个瓶颈。</li>
</ol>
</li>
<li>非对称交换<ol>
<li>通过将带有服务器的网段连接到更高带宽的端口(100 Mbps)，非对称交换(asymmetric switching)减少了服务器上潜在瓶颈的可能性</li>
<li>非对称交换需要在交换器中进行内存缓冲</li>
<li>非对称交换端口解决对称交换端口中的对称阻塞问题(进一步保证了服务器的稳定实现)</li>
</ol>
</li>
<li>内存缓冲：<ol>
<li>交换机中存储目标和传输数据的内存区域，直到可以将其切换出正确的端口为止。<ol>
<li>基于端口(Port)的内存缓冲<ol>
<li>数据包存储在每个端口的队列中</li>
<li>由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输</li>
<li>其他端口存在不均衡的问题。</li>
</ol>
</li>
<li>共享(Shared)内存缓冲<ol>
<li>所有端口共享的公用内存缓冲</li>
<li>允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。</li>
<li>需要自己记录端口的信息</li>
</ol>
</li>
</ol>
</li>
<li>发生阻塞的时候，根据情况按照端口或者内存将包缓存下来</li>
</ol>
</li>
<li>交换方式<ol>
<li>储存转发（Store-and-Forward）<ol>
<li>交换机<strong>接收整个帧</strong>，最后将其计算为CRC，然后再将其发送到目的地</li>
<li>接收后，校验，正确再发送</li>
<li>效率比较低</li>
</ol>
</li>
<li>Cut-through 直通<ol>
<li>转发会增加延迟:通过使用直通切换方法可以减少它</li>
<li>快速转发切换:仅在立即转发帧之前检查目标MAC(只看到帧的目的地址就转发，而不看帧的后面的部分)</li>
</ol>
</li>
<li>Segment-free Switching 无碎片转发<ol>
<li>碎片释放:在转发帧之前读取前64个字节以减少错误:避免碰撞和帧碎</li>
<li>若前64个字节是正常的，说明没有碰撞问题</li>
</ol>
</li>
<li>三个方法查看到的位置如下<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241129133557313.png" alt="image-20241129133557313"></li>
</ol>
</li>
<li>多层交换机<ol>
<li>二层交换机<ol>
<li>大规模集成电路,保证链路效率,低时延,低成本</li>
<li>有一个MAC地址</li>
</ol>
</li>
<li>三层交换机<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241129133734398.png" alt="image-20241129133734398"><ol>
<li>基于硬件的帧转发机制，较高的帧转发性能，低时延</li>
<li>较高速的计算</li>
<li>每一个端口的代价低</li>
<li>流控制</li>
<li>安全性更高</li>
<li>对数据流进行路由，生成MAC和IP的映射</li>
<li>MAC地址过来的时候直接根据表从二层进行通过</li>
<li>与路由器不同的是，路由表是通过软件的方式生成路由表，而第三层交换机通过硬件生成MAC和IP的映射表。而且，而且MAC地址在通过时，走第二层而不是路由。</li>
</ol>
</li>
<li>第四层交换机<ol>
<li>数据段在数据报里面，数据报在数据帧里面</li>
<li>只要交换机可以看到数据帧的数据部分的首部</li>
<li>可以根据端口主机的应用特点进行一定的流量控制</li>
<li>和Net OS是不一样的,没有那么智能</li>
<li>识别到前80个字节的数据报长度，对指定应用进行管理</li>
</ol>
</li>
<li>总结<ol>
<li>一般我们只是用二层交换机</li>
<li>交换机可以简单识别第三层和第四层信息</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="生成树协议（STP）"><a href="#生成树协议（STP）" class="headerlink" title="生成树协议（STP）"></a>生成树协议（STP）</h2><ol>
<li><p>概述</p>
<ol>
<li>桥回路<ol>
<li>出于各种原因，网络中可能会出现环路。<ol>
<li>通常，网络中的环路是故意(deliberate)提供冗余的结果。</li>
<li>也可能由于配置错误而发生:在桥接网络中，环路可能是绝对灾难性的两个主要原因：<ol>
<li>广播回路(广播风暴)，没有TTL</li>
<li>路由表的错误</li>
</ol>
</li>
</ol>
</li>
<li>往往是<strong>第二层交换机</strong>的冗余导致的桥回路。</li>
<li>接入层到核心层的接入往往<strong>要有冗余</strong>，这个区域是主干网(backbone)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241129134410294.png" alt="image-20241129134410294"></li>
<li>设备通过backbone和远端设备进行链接</li>
</ol>
</li>
<li>第二层路由回路<ol>
<li>广播和第2层循环可能是危险的组合。</li>
<li>以太网帧没有TTL字段</li>
<li>以太网帧开始循环后，它可能会继续下去，直到有人关闭其中一台交换机或断开链路为止(外部条件)</li>
<li>交换机将抖动(flip flop)主机A的桥接表条目(创建极高的CPU利用率)。</li>
<li>消耗CPU和内存</li>
<li>例子：泛洪单播帧<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241129134619425.png" alt="image-20241129134619425"><ol>
<li>过一段时间CAT-1和CAT-2没有收到Host-B的信息，删除表中的对应记录</li>
<li>在这之后，Host A发送给Host B信息，然后在CAT-1和CAT-2之间进行循环</li>
</ol>
</li>
</ol>
</li>
<li>综述<ol>
<li>桥协议数据单元-BPDU</li>
<li>生成树协议的元素<ol>
<li>主要功能：在<strong>交换&#x2F;桥接网络</strong>中允许<strong>冗余路径</strong>，而不会因环路的影响而引起延迟。</li>
<li>STP通过计算<strong>稳定的生成树</strong>网络拓扑来防止环路</li>
<li><strong>生成树帧</strong>(称为桥协议数据单元-BPDU)用于确定生成树拓扑</li>
</ol>
</li>
<li>在正常情况下禁用一些端口来防止出现冗余综述</li>
</ol>
</li>
</ol>
</li>
<li><p>STP决策顺序</p>
<ol>
<li><p>生成树始终使用相同的四步决策序列：</p>
<ol>
<li>选举根交换机：在拓扑里面最低的root BID(网桥标识)作为根交换机</li>
<li>找到 Root bridgh的最低路径成本</li>
<li>每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子</li>
<li>选举根端口：对于每个非根交换机，每个路径再指定一个最低的ID端口</li>
</ol>
</li>
<li><p>如果觉得上边的工作步骤不好理解，可以看下面的三个步骤：</p>
<ol>
<li>选举根交换机</li>
<li>选举根端口，就是到根交换机代价最小的端口</li>
<li>选举指定端口并且阻塞备用端口：<ol>
<li>根端口的对端一定是另一个交换机的指定端口</li>
<li>根交换机的端口都是指定端口</li>
<li>每个网段一定有一个指定端口，计算从哪边发BPDU到根交换机的路径成本最小</li>
<li>若都相同，则找ID小的</li>
<li>剩下的都是备用端口，要阻塞</li>
</ol>
</li>
</ol>
</li>
<li><p>BPDUs(Bridge Protocol Data Unit)</p>
<ul>
<li>注意，与OSPF不同的是，STP不是以自己为根，而是以选举出来的BID为根</li>
</ul>
<ol>
<li>BPDU是交换机之间的流量；它们不承载最终用户(end-user)流量。</li>
<li>STP建立一个称为<strong>根网桥的根节点</strong>，生成的树源自根桥。</li>
<li>不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)</li>
<li>在阻塞的链接上收到的数据帧将被丢弃。</li>
<li>交换机发送的允许形成无环逻辑拓扑的消息是BPDU</li>
</ol>
</li>
</ol>
</li>
<li><p>五个状态：</p>
<ol>
<li>通过根据策略配置每个端口来建立状态</li>
<li>然后，STP根据流量模式(traffic Patterns)和潜在环路(Protential Loops)修改状态</li>
<li>STP状态的默认顺序为：<ol>
<li>阻塞:没有转发帧，听到了BPDU</li>
<li>监听:不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了</li>
<li>学习:不转发帧，学习地址</li>
<li>转发:转发帧，学习地址</li>
<li>禁用:没有转发帧，没有听到BPDU</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/13.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/13.png" alt="img"></a></p>
<blockquote>
<p>STP过程:Blocking -&gt; 20s Listening -&gt; 15s Learning -&gt; 15s Fowarding或者Disabled</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/37.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/37.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/38.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/38.png" alt="img"></a></p>
<ul>
<li>2s可以调整</li>
<li>老化时间:保存的时间</li>
</ul>
</li>
<li><p>初始STP收敛</p>
<ol>
<li><p>步骤1：根交换机决定</p>
<ol>
<li>布自己为根</li>
<li>检查端口上收到的所有BPDU以及将在该端口上发送的BPDU</li>
<li>对于每个到达的BPDU，如果其值小于为端口保存的现有BPDU</li>
<li>旧值被替换</li>
<li>BPDU的发送者被接受为新的根</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/14.png" alt="img"></a></p>
<ul>
<li>BC收到后将根修改为A</li>
<li>比如在BC链路中，B的MAC地址比较小，作为链路的Sender BID，这个port是指定端口</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><ol>
<li><p>骨干网</p>
<ol>
<li>VLAN配置需要支持互连的路由器和交换机之间的骨干数据传输。</li>
<li>骨干网是用于VLAN间通信的区域</li>
<li>骨干网应该是高速链路，通常为100Mbps或更高</li>
<li>BackBone可以跑多个VLAN，是骨干网</li>
</ol>
</li>
<li><p>帧的使用：</p>
<ol>
<li><p>交换机根据帧中的数据做出过滤和转发决策。</p>
</li>
<li><p>使用了两种技术</p>
<ol>
<li>帧过滤：检查有关每个帧的特定信息(MAC地址或第3层协议类型),特定的VLAN记录或者映射</li>
<li>帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符</li>
</ol>
</li>
<li><p>帧过滤<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/25.png" alt="img"></p>
<ol>
<li>收到帧转发后，发现都不在一个LAN上，然后通过Backbone转发</li>
<li>Frame Table在交换机上传输</li>
</ol>
</li>
<li><p>帧标记</p>
<ol>
<li>帧标记实施过程：<ol>
<li>在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符。</li>
<li>每个开关都可以理解和检查标识符。</li>
<li>当帧离开网络骨干网时，交换机会在帧发送到目标终端站之前删除标识符。只和端口绑定，而不影响主机</li>
</ol>
</li>
<li>帧标记在第2层起作用，并且几乎不需要处理或管理开销。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/26.png" alt="img"></a></p>
<ol>
<li>从主机到了交换机端口，交换机端口进行标记，然后进行转发。</li>
</ol>
</li>
</ol>
</li>
<li><p>VLAN到实现</p>
<ol>
<li><p>概述：</p>
<ol>
<li>实现VLAN的两种方法<ol>
<li>静态的</li>
<li>动态的</li>
</ol>
</li>
<li>每一个端口绑定给一个VLAN<ol>
<li>确保不共享同一VLAN的端口不共享广播。</li>
<li>确保共享相同VLAN的端口将共享广播。</li>
</ol>
</li>
<li>实现途径:<ol>
<li>基于端口的虚拟局域网</li>
<li>基于MAC地址的虚拟局域网</li>
<li>基于IP地址的虚拟局域网</li>
<li>基于上层协议的虚拟局域网</li>
</ol>
</li>
</ol>
</li>
<li><p>静态VLAN</p>
<ol>
<li><p>定义：静态VLAN是指将交换机上的端口管理性地分配给VLAN的时间</p>
</li>
<li><p>优点：</p>
<ol>
<li>安全，易于配置和监控</li>
<li>在控制移动的网络中效果很好</li>
</ol>
</li>
<li><p>端口是写死在交换机的端口上的</p>
</li>
</ol>
</li>
<li><p>动态VLAN</p>
<ol>
<li>由服务器配置VLAN信息</li>
<li>交换机通过MAC地址或者哪一个协议，指定是哪一个VLAN</li>
<li>当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口</li>
<li>优点<ol>
<li>添加或移动用户时减少管理(更多前期工作)</li>
<li>集中通知未授权用户</li>
</ol>
</li>
</ol>
</li>
<li><p>以端口为中心的VLAN</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/30.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/30.png" alt="img"></a></p>
<ul>
<li>实际的网络是有层次的</li>
<li>static的物理的接入层(physical Layer)</li>
<li>不同电脑在一个房间内</li>
<li>不同房间的不同电脑组成一个VLAN</li>
<li>路由器网关来处理</li>
<li>优点：<ul>
<li>同一VLAN中的所有节点都连接到同一路由器接口</li>
<li>使管理更容易，因为…<ol>
<li>通过路由器端口分配用户</li>
<li>VLAN易于管理。</li>
<li>提供更高的安全性</li>
<li>数据包不会”泄漏”到其他域</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两种链路</p>
<ol>
<li><p>访问链接Access：</p>
<ol>
<li>访问连接是仅作为一个VLAN成员的交换机上的连接。</li>
<li>此VLAN被称为端口的本机VLAN，连接到端口的任何设备都完全不知道VLAN存在</li>
</ol>
</li>
<li><p>主干链路：</p>
<ol>
<li>主干链路能够支持多个VLAN。</li>
<li>主干链路通常用于将交换机连接到其他交换机或路由器。</li>
<li>交换机在快速以太网和千兆位以太网端口上都支持骨干链路。</li>
<li>也存在访问和骨干链接</li>
<li>一般Trunk就是BackBone</li>
</ol>
</li>
</ol>
</li>
<li><p>在局域网之间的路由</p>
<ol>
<li>每个端口连接一个VLAN，每个IP和一个VLAN连接，就需要很多线，浪费了</li>
<li>我们可以使用串口线，物理上是一个接口，逻辑划分成多个IP和子接口，就相当于trunk线</li>
<li><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/36.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec09/36.png" alt="img"></a><ol>
<li>物理上一个，划分成Fa0&#x2F;1、Fa0&#x2F;2和Fa&#x2F;3</li>
<li>涉及到的是单臂路由</li>
</ol>
</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>同一VLAN中的两台主机可以跨越多台交换机</li>
<li>必须是第三层及以上的交换机才能用来构建VLAN</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第八章-·-广域网WAN"><a href="#第八章-·-广域网WAN" class="headerlink" title="第八章 · 广域网WAN"></a>第八章 · 广域网WAN</h1><h2 id="广域网技术和设备"><a href="#广域网技术和设备" class="headerlink" title="广域网技术和设备"></a>广域网技术和设备</h2><ol>
<li><p>广域网服务</p>
<ol>
<li>定义:WAN是通过WAN服务提供商连接LAN的通信网络。</li>
<li>一般不是一个单位来做，而是由运营商完成，而在运营商之间沟通好相互的接入问题。</li>
<li>WAN在OSI的前三层运行，但<strong>主要集中在物理和数据链路层</strong>。</li>
<li>广域网和局域网相比相对低效</li>
<li>广域网位于物理层和数据链路层</li>
</ol>
</li>
<li><p>广域网的最小单位是公司</p>
</li>
<li><p>物理结构</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241130110327699.png" alt="image-20241130110327699"></p>
<ul>
<li>涉及到具体一个公司的接入</li>
<li>通过NetWork远程接入，通过WSP提供的CO Swtich来连接到中心局</li>
<li>CPE:位于公司本地的设备(主要是接入设备)，可以向ISP购买或者租用，购买上网服务(猫)</li>
<li>CPE和远端通过Local loop连接(最后一公里)，ISP做解决方案。</li>
<li>Demarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理</li>
</ul>
</li>
</ol>
</li>
<li><p>虚拟电路</p>
<ol>
<li>交换虚拟电路(SVC，Switched Virtual Circuits)是到目的地的WAN路径，可根据需要建立(established)和终止(terminated)。</li>
<li>三个阶段<ol>
<li>电路建立–创建虚拟电路(逻辑确定)</li>
<li>数据传输–发送和接收用户数据(含有虚电路号等)</li>
<li>电路中断–拆除虚拟电路</li>
</ol>
</li>
</ol>
</li>
<li><p>调制解调器</p>
<ol>
<li>通道服务单元 CSU,Channel Service Units&#x2F;数字服务单元 DSU,Digital Service Units</li>
<li>与语音级(voice-grade)连接接口，以便将模拟信号转换为数字信号。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/6.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/6.jpg" alt="img"></a></p>
<ol>
<li>CPE(左边的用户网关路由器，作为终端数据单元(DTE)):往往是路由器</li>
<li>DCE:将信号转换成运营商可以接受的信号发送给远端。</li>
</ol>
</li>
</ol>
<h2 id="广域网和OSI模型"><a href="#广域网和OSI模型" class="headerlink" title="广域网和OSI模型"></a>广域网和OSI模型</h2><ol>
<li><p>广域网标准</p>
<ol>
<li>WAN标准主要描述OSI模型的哪些层？<strong>物理层和数据链路层</strong>，物理层提供电器标准，数据链路层封装到远程的部分:帧标准</li>
<li>连接通信服务提供商提供的服务所需的电气、机械、操作和功能特性。</li>
<li>描述DTE和DCE之间的接口</li>
</ol>
</li>
<li><p>物理层</p>
<ol>
<li>描述如何为WAN服务提供电气，机械，操作和功能连接的协议。</li>
<li>这些服务通常是从WAN服务提供商，备用运营商，电话后和电报(PTT)机构获得的。</li>
<li>描述数据终端设备(DTE, Data Terminal Equipment)和数据电路终端设备(DCE. Data Circuit-terminating Equipment)之间的接口。</li>
<li>通常，DCE是服务提供商，而DTE是连接的设备。</li>
<li>在此模型中，通过调制解调器或 CSU &#x2F; DSU 提供给DTE的服务。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/8.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/8.jpg" alt="img"></a></p>
<blockquote>
<p>一般以用户路由器作为DTE，运营商提供的Modem做信号转换，作为DCE</p>
</blockquote>
</li>
<li><p>数据链路层的帧封装</p>
<ol>
<li>WAN数据链路层定义了如何封装数据以传输到远程站点<ol>
<li><strong>点对点协议(PPP,Point-to-Point Protocol)</strong>:由IETF开发。PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议)</li>
<li><strong>高级数据链路控制(HDLC, High-Level Data Link Control)</strong>:ISO标准，不同供应商之间不兼容的HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点&#x2F;多点配置(抽象规范和约束，各个厂商不同)</li>
<li><strong>帧中继(Frame Relay)</strong>：使用简化的封装，对高质量的数字设备不进行纠错。(比较高速)</li>
<li><strong>ISDN</strong>：通过现有电话线传输语音和数据的一组数字服务。</li>
<li><strong>平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)</strong>：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="点对点协议-PPP-Point-to-Point-Protocol-（本次考试重点）"><a href="#点对点协议-PPP-Point-to-Point-Protocol-（本次考试重点）" class="headerlink" title="点对点协议(PPP,Point-to-Point Protocol) *** （本次考试重点）"></a>点对点协议(PPP,Point-to-Point Protocol) *** （本次考试重点）</h2><ol>
<li><p>概述 ***</p>
<ol>
<li>点对点的标准</li>
<li>以思科厂商为标准</li>
<li>工作在串行链路上的</li>
<li>如果都是同一个厂商的可以用HDLC，不然使用PPP</li>
</ol>
</li>
<li><p>串行线框字段</p>
<ol>
<li>两种最常见的点对点WAN封装是HDLC(High-level Data Protocol)和PPP(Point to Poing Protocol)</li>
<li>所有串行线封装共享一个通用的帧格式，该格式具有以下字段</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/9.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/9.jpg" alt="img"></a></p>
<blockquote>
<p>封装协议的选择取决于WAN技术和通信设备</p>
</blockquote>
</li>
<li><p>PPP和HDLC</p>
<ol>
<li><strong>PPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法</strong>。<ol>
<li>由IETF(The Internet Engineering Task)开发;取代SLIP(Serial Line Internet Protocol)</li>
<li>包含标识网络层协议的字段</li>
<li>PPP可以在建立连接期间检查链接质量</li>
<li><strong>通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证</strong>。</li>
</ol>
</li>
<li>HDLC是Cisco串行线的默认封装<ol>
<li>没有窗口或流量控制</li>
<li>框架中插入了专有类型(所有权)代码，这意味着HDLC帧不能与其他供应商的设备互操作。</li>
<li>当专用线路连接的两端是运行Cisco IOS的路由器时使用</li>
<li>不做出窗口控制和流控制</li>
</ol>
</li>
<li>比较：<ol>
<li>HDLC是面向位的链路层协议，通常用于专有环境。</li>
<li>HDLC不支持多协议封装，通常用于固定类型的网络。</li>
<li>PPP相比HDLC更灵活，支持多种协议和认证功能，因此更适合异构网络。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="PPP点对点协议"><a href="#PPP点对点协议" class="headerlink" title="PPP点对点协议"></a>PPP点对点协议</h3><ol>
<li><p>概述</p>
<ol>
<li>串行链路上使用最广泛的第2层协议</li>
<li>从SLIP开发，<ol>
<li>仅支持IP协议</li>
<li>不支持动态IP分配</li>
<li>不支持身份验证</li>
<li>不支持压缩</li>
<li>不支持错误检测</li>
</ol>
</li>
<li>PPP提供以下功能<ol>
<li>网络协议多路复用</li>
<li>动态分配IP地址</li>
<li>验证：PAP，CHAP</li>
<li>压缩</li>
<li>错误检测</li>
</ol>
</li>
</ol>
</li>
<li><p>PPP组件</p>
<ol>
<li>使用HDLC(ISO HDLC，而非Cisco HDLC)作为封装第3层数据报的基础</li>
<li>实现LCP(链接控制协议)以：<ol>
<li>建立连接</li>
<li>连接配置选项</li>
<li>链接质量测试</li>
</ol>
</li>
<li>实施NCP(网络控制协议，Network Control Protocol)以选择和配置第3层协议。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241130152243250.png" alt="image-20241130152243250"></li>
</ol>
</li>
<li><p>PPP帧格式<a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/10.jpg"><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/10.jpg" alt="img"></a></p>
<blockquote>
<p>数字的单位是字节</p>
</blockquote>
<ol>
<li>Flag: 01111110，0x7E 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li>
<li>Address：11111111, 0xFF，广播地址</li>
<li>Control：00000011, 0x03，用户数据作为无序帧传输</li>
<li>Protocol: 数据字段中的协议类型</li>
<li>Data: 数据报，最大默认值为1500字节</li>
<li>FCS: 2或者4字节，循环冗余校验位</li>
</ol>
</li>
<li><p>PPP会话建立&#x2F;终止</p>
<ol>
<li>为了通过点对点链路建立通信，PPP经历四个不同的阶段：<ol>
<li>步骤一: 链接建立和配置协商(negotiation)(链路控制协议，LCP)。</li>
<li>步骤二: 链接质量测试。</li>
<li>步骤三: 网络层协议配置(NCP)。</li>
<li>步骤四: 链接终止。</li>
</ol>
</li>
<li>阶段一：连接建立<ol>
<li>建立链接是交换任何网络层数据报之前的第一阶段<ol>
<li>每个PPP设备发送LCP来打开连接</li>
<li>LCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如<strong>压缩和身份验证协议</strong>等。</li>
<li>如果LCP数据包中未包含配置选项，则采用该配置选项的<strong>默认值</strong>。</li>
<li>当已发送和接收配置<strong>确认</strong>帧时，此阶段完成。</li>
</ol>
</li>
<li>在完成这个步骤前不会传输具体数据帧的。</li>
</ol>
</li>
<li>第二阶段：链路质量确定<ol>
<li>发送和接收LCP数据包以测量链路上的错误率(如果已配置)</li>
<li>身份验证(如果使用)在网络层协议配置阶段开始之前进行。(可选)</li>
<li>LCP可以延迟网络层协议信息的传输，直到完成此阶段。</li>
<li>在这之前不能传输网络帧。</li>
</ol>
</li>
<li>第三阶段：网络层协议配置<ol>
<li>在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。</li>
<li>配置了每个选定的网络层协议后，可以通过链接发送来自每个网络层协议的数据报。</li>
</ol>
</li>
<li>第四阶段：链接终止<ol>
<li>LCP可以随时终止链接：<ol>
<li>应用户要求；(一方请求终止)</li>
<li>链接质量</li>
<li>超时</li>
</ol>
</li>
<li>当LCP关闭链接时，它将通知网络层协议，以便它们可以采取适当的措施。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="PAP安全认证协议"><a href="#PAP安全认证协议" class="headerlink" title="PAP安全认证协议"></a>PAP安全认证协议<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/12.jpg" alt="img"></h3><ol>
<li>PAP由一方向另一方发起请求，另一方选择是否接受，双方具有<strong>相同</strong>的用户名和密码,发起方可以多次尝试</li>
<li>链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。</li>
<li>远程节点使用双向握手PAP建立其身份。</li>
<li>远程节点<strong>重复</strong>发送用户名&#x2F;密码对，直到确认身份验证或连接终止</li>
<li>密码以明文形式通过链接发送。</li>
<li>在建立连接阶段之后，仅对远程节点进行一次身份验证。</li>
</ol>
<h3 id="CHAP"><a href="#CHAP" class="headerlink" title="CHAP"></a>CHAP<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/13.jpg" alt="img"></h3><ol>
<li><p>概述</p>
<ol>
<li>避免明文发送,三阶段握手,发起方是HQ，找一个时间来Challenge，然后由用户进行response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。</li>
<li>被叫方使用三向握手CHAP协议定期验证主叫方。</li>
<li>CHAP不允许呼叫者在没有Challenge(随机数)的情况下尝试进行身份验证。(Challenge-&gt;随机数)</li>
<li>主机(称为参与者)将质询消息发送到远程节点。</li>
<li>远程节点以一个值(加密的值，包括：接收到的质询，其用户名和密码)进行响应:value是challenge和密钥生成的</li>
<li>主机根据自己的价值检查响应<ol>
<li>如果值匹配，则确认身份验证</li>
<li>否则，连接终止</li>
</ol>
</li>
</ol>
</li>
<li><p>流程：</p>
<ol>
<li><p>挑战：</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/14.jpg"><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/14.jpg" alt="img"></a></p>
<ul>
<li>RTB请求连接RTA</li>
<li>他们都存储一个用户名密码，但是用户名不同，密码相同</li>
<li>RTB发送一个连接请求</li>
<li>RTA找一个时间来发起挑战</li>
<li>挑战中内容:<ul>
<li>编号</li>
<li>id是第几次挑战</li>
<li>random:生成的随机数</li>
<li>RTA:谁发起的挑战</li>
</ul>
</li>
</ul>
</li>
<li><p>应答：</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/15.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/15.jpg" alt="img"></a></p>
<ul>
<li>RTB进行应答，</li>
<li>RTB操作:pass + random 使用 MD5 算法 -&gt; 哈希值</li>
</ul>
</li>
<li><p>验证确认：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/16.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/16.jpg" alt="img"></a><ul>
<li>RTA收到RTB的回复，然后比较是否相同</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="综合数字服务网络-ISDN-Integrated-Services-Digital-Networks"><a href="#综合数字服务网络-ISDN-Integrated-Services-Digital-Networks" class="headerlink" title="综合数字服务网络(ISDN, Integrated Services Digital Networks)"></a>综合数字服务网络(ISDN, Integrated Services Digital Networks)</h2><ol>
<li><p>概述</p>
<ol>
<li>集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接</li>
<li>ISDN具有以下优点：<ol>
<li>可以携带语音，视频和数据</li>
<li>使用带外D(或Delta)信道比调制解调器(有时&lt;1s)更快的呼叫建立</li>
<li>使用B(或屏障)通道以64kps提供更快的数据传输</li>
</ol>
</li>
<li>ISDN服务有两种：<ol>
<li>BRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP</li>
<li>PRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD</li>
</ol>
</li>
<li>ISDN BRI服务提供两个B通道和一个D通道。</li>
<li>ISDN BRI将144kbps(2B + D &#x3D; 144kps)线路的总带宽传送到三个单独的通道中。</li>
<li>BRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。</li>
<li>第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。</li>
<li>BRI和DRI都是基于电话信道的</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/17.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/17.jpg" alt="img"></a></p>
<ul>
<li>B信道传递HDLC和PPP数据帧</li>
<li>D信道传递LAPD数据帧</li>
</ul>
</li>
<li><p>BRI</p>
<ol>
<li>ISDN BRI服务提供两个B通道和一个D通道。</li>
<li>BRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。</li>
<li>第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。</li>
</ol>
</li>
</ol>
<h2 id="非对称数字用户线路-ADSL-Asymmetric-Digital-Subscriber-Line"><a href="#非对称数字用户线路-ADSL-Asymmetric-Digital-Subscriber-Line" class="headerlink" title="非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)"></a>非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)</h2><ol>
<li>概述<ol>
<li>xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</li>
<li>DSL的前缀 x 表示在数字用户线上实现的不同宽带方案</li>
<li>虽然标准模拟电话信号的频带限制在 300~3400kHz 范围内，但用户线本身实际可通过的信号频率仍超过 1 MHz</li>
<li>xDSL 技术把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用</li>
<li>DSL:数字用户线(Digital Subscriber Line)</li>
</ol>
</li>
<li>ADSL 的极限传输距离：ADSL 的极限传输距离与<strong>数据率</strong>以及<strong>用户线的线径</strong>都有很大的关系(用户线越细，信号传输时的衰减就越大)</li>
<li>ADSL 的特点<ol>
<li>上行和下行带宽不对称:上行指从用户到 ISP，而下行指从 ISP 到用户</li>
<li>ADSL 在用户线(铜线)的两端各安装一个 ADSL 调制解调器。</li>
<li>上行下行不对称，下行大于上行</li>
</ol>
</li>
<li>第二代 ADSL<ol>
<li>通过提高调制效率得到了更高的数据率。</li>
<li>采用了<strong>无缝速率自适应技术 SRA</strong> (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</li>
<li>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</li>
</ol>
</li>
</ol>
<h2 id="SONET"><a href="#SONET" class="headerlink" title="SONET"></a>SONET</h2><ol>
<li><p>同步数字系统的2种标准：同步光纤网SONET和同步数字系列SDH</p>
<ol>
<li>旧的数字传输系统存在着许多缺点。其中最主要的是以下两个方面：</li>
<li>速率标准不统一：如果不对高次群的数字传输速率进行标准化，国际范围的高速数据传输就很难实现。</li>
<li>不是同步传输： 在过去相当长的时间，为了节约经费，各国的数字网主要是采用准同步方式。</li>
</ol>
</li>
<li><p>同步光纤网 SONET</p>
<ol>
<li>同步光纤网 SONET (Synchronous Optical Network) 的各级时钟都来自一个非常精确的主时钟(铯原子钟，精度优于10-11秒)</li>
<li>第 1 级同步传送信号 STS-1 (Synchronous Transport Signal)的传输速率是 51.84 Mb&#x2F;s。</li>
</ol>
</li>
<li><p>同步数字系列 SDH</p>
<ol>
<li>ITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH (Synchronous Digital Hierarchy)。</li>
<li>一般可认为 SDH 与 SONET 是同义词。</li>
<li>SDH 的基本速率为 155.52 Mb&#x2F;s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。</li>
</ol>
</li>
<li><h3 id="SONET-的-OC-级-STS-级与-SDH-的-STM-级的对应关系"><a href="#SONET-的-OC-级-STS-级与-SDH-的-STM-级的对应关系" class="headerlink" title="SONET 的 OC 级&#x2F;STS 级与 SDH 的 STM 级的对应关系"></a>SONET 的 OC 级&#x2F;STS 级与 SDH 的 STM 级的对应关系</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/20.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/20.jpg" alt="img"></a></p>
</li>
<li><h3 id="SONET-的体系结构"><a href="#SONET-的体系结构" class="headerlink" title="SONET 的体系结构"></a>SONET 的体系结构</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/21.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/21.jpg" alt="img"></a></p>
<ul>
<li>SDH也是光传输</li>
<li>路径很长，分为一段一段的线路。</li>
<li>线路中复用器和复用器之间分成段，使用转发器</li>
</ul>
</li>
<li><p>同步光纤网 SONET</p>
<ol>
<li>SONET 第 1 级同步传送信号 STS-1 ( Synchronous Transport Signal) 的传输速率为 51.84 Mb&#x2F;s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的3倍，为155.52 Mb&#x2F;s， …，等等，依此类推。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/22.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/22.jpg" alt="img"></a></p>
<ol>
<li>STS帧为时分复用幀，8000帧&#x2F;秒，每帧125 μS</li>
<li>其对应的光信号则称为第 1 级光载波 OC-1 (OC表示 Optical Carrier)，第 3 级光载波 OC-3， …，等</li>
</ol>
</li>
<li><p>SONET 标准的四个光接口层</p>
<ol>
<li>光子层(Photonic Layer)：处理跨越光缆的比特传送。</li>
<li>段层(Section Layer)：在光缆上传送 STS-N 帧。</li>
<li>线路层(Line Layer)：负责路径层的同步和复用</li>
<li>路径层(Path Layer)：处理路径端接设备 PTE (Path Terminating Element)之间的业务的传输。</li>
</ol>
</li>
</ol>
<h2 id="光纤同轴混合网HFC-Hybrid-Fiber-Coax"><a href="#光纤同轴混合网HFC-Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网HFC(Hybrid Fiber Coax)"></a>光纤同轴混合网HFC(Hybrid Fiber Coax)</h2><ul>
<li>主要链路用光纤，到户用同轴电缆</li>
</ul>
<ol>
<li><p>内容：</p>
<ol>
<li>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</li>
<li>HFC 网除可传送 CATV 外，还提供电话、数据和 其他宽带交互型业务。</li>
<li>现有的 CATV 网是树形拓扑结构的同轴电缆网络， 它采用模拟技术的频分复用对电视节目进行单向传 输。而 HFC 网则需要对 CATV 网进行改造</li>
</ol>
</li>
<li><p>HFC 的主要特点</p>
<ol>
<li>HFC网的<strong>主干线</strong>路采用光纤</li>
<li>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</li>
<li>在模拟光纤中采用光的振幅调制 AM，这比使用数字 光纤更为经济。</li>
<li>模拟光纤从头端连接到<strong>光纤结点(fiber node)</strong>，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。(光信号转换成点信号)<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/23.jpg" alt="img">到小区前是光传输，之后是电传输</li>
<li>具有比 CATV 网更宽的频谱，且具有双向传输功能</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/24.jpg"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/24.jpg" alt="img"></a></p>
</li>
<li><p>用户接口盒UIB (User Interface Box)</p>
<ol>
<li>每个家庭要安装一个用户接口盒</li>
<li>用户接口盒要提供三种连接，即：<ol>
<li>使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。</li>
<li>使用双绞线连接到用户的电话机。</li>
<li>使用电缆调制解调器连接到用户的计算机。</li>
</ol>
</li>
</ol>
</li>
<li><p>电缆调制解调器(Cable Modem)</p>
<ol>
<li>电缆调制解调器是为 HFC 网而使用的调制解调器。</li>
<li>电缆调制解调器最大的特点就是<strong>传输速率高</strong>。其下行速率一般在 3∼10 Mb&#x2F;s之间，最高可达 30 Mb&#x2F;s，而上行速率一般为 0.2∼2 Mb&#x2F;s，最高可达 10 Mb&#x2F;s。</li>
<li>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在<strong>用户端</strong>。(远端是光，不是电）</li>
</ol>
</li>
<li><p>HFC 网的最大优点</p>
<ol>
<li>具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。</li>
<li>要将现有的 450 MHz 单向传输的有线电视网络改造为 750 MHz 双向传输的 HFC 网(还要将所有的用户服务区互连起来而不是一个个 HFC 网的孤岛)， 也需要相当的资金和时间。</li>
<li>在电信政策方面也有一些需要协调解决的问题。</li>
<li>电信也在跨界到视频</li>
</ol>
</li>
<li><p>FTTx 技术</p>
<ol>
<li>FTTx(光纤到……)也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。<ol>
<li>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</li>
<li>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li>
<li>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="考试要求"><a href="#考试要求" class="headerlink" title="考试要求"></a>考试要求</h2><ol>
<li>名词解释</li>
<li>ADSL意义、实现和B和D信道的带宽使用等</li>
</ol>
<h1 id="第九章-·-网络安全"><a href="#第九章-·-网络安全" class="headerlink" title="第九章 · 网络安全"></a>第九章 · 网络安全</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ol>
<li>计算机网络上的通信面临以下的四种威胁：</li>
</ol>
<table>
<thead>
<tr>
<th>威胁</th>
<th>解释</th>
<th>攻击类型</th>
</tr>
</thead>
<tbody><tr>
<td>截获</td>
<td>从网络上窃听他人的通信内容。</td>
<td>被动攻击</td>
</tr>
<tr>
<td>中断</td>
<td>有意中断他人在网络上的通信。</td>
<td>主动攻击</td>
</tr>
<tr>
<td>篡改</td>
<td>故意篡改网络上传送的报文。</td>
<td>主动攻击</td>
</tr>
<tr>
<td>伪造</td>
<td>伪造信息在网络上传送。</td>
<td>主动攻击</td>
</tr>
</tbody></table>
<ol>
<li>被动攻击<ol>
<li>截获信息的攻击称为被动攻击(并不改变通讯的过程)</li>
<li>在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU而不干扰信息流。</li>
</ol>
</li>
<li>主动攻击<ol>
<li>更改信息和拒绝用户使用资源的攻击称为主动攻击。(修改了通信的构成)</li>
<li>主动攻击是指攻击者对某个连接中通过的PDU进行各种处理(理解PDU后)<ol>
<li>更改报文流</li>
<li>拒绝报文服务</li>
<li>伪造连接初始化</li>
</ol>
</li>
</ol>
</li>
<li>计算机网络通信安全的目标<ol>
<li>防止析出报文内容</li>
<li>防止通信量分析(通信的习惯)</li>
<li>检测更改报文流</li>
<li>检测拒绝报文服务</li>
<li>检测伪造初始化连接</li>
</ol>
</li>
<li>报文应该具有的性质<ol>
<li>保密性</li>
<li>完整性</li>
<li>可用性</li>
<li>鉴别性</li>
<li>不可否认(抵赖)性:确认是特定的发送方</li>
</ol>
</li>
<li>恶意程序(malicious program)<ol>
<li>计算机病毒:会”传染”其他程序的程序，“传染” 通过修改其他程序来把自身或其变种复制进去而完成。</li>
<li>计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)</li>
<li>特洛伊木马:一种程序，它执行的功能超出所声称的功能（伪装成正常程序，但是留了后门）。运作木马获得特殊的权限<ol>
<li>逻辑程序:逻辑下载程序</li>
<li>控制器程序:远程控制</li>
</ol>
</li>
<li>逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li>
</ol>
</li>
<li>计算机网络安全的内容<ol>
<li>保密性</li>
<li>安全协议的设计</li>
<li>访问控制</li>
</ol>
</li>
</ol>
<h2 id="一般的数据加密模型"><a href="#一般的数据加密模型" class="headerlink" title="一般的数据加密模型"></a>一般的数据加密模型</h2><ol>
<li>概述：<ol>
<li><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/2.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/2.png" alt="img"></a><ol>
<li>不确定有没有人修改:使用密文发送</li>
<li>最早的是凯撒密码:<ol>
<li>加密：明文按照数字mod的值进行偏移，得到密文</li>
<li>解密：密文反向偏移数字mod的值进行偏移，得到明文</li>
</ol>
</li>
</ol>
</li>
<li>密码相关的重要概念<ol>
<li><strong>密码编码学</strong>(cryptography)是密码体制的设计学(设计密码)</li>
<li><strong>密码分析学</strong>(cryptanalysis)则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。</li>
<li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<strong>无条件安全</strong>的，或称为<strong>理论上是不可破</strong>的。</li>
<li>如果密码体制中的密码不能被可使用的计算资源破译，则这一密码体制称为在<strong>计算上安全</strong>的。(目前一般的密码体系能够达到的标注)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="对称密钥和公钥密码体制"><a href="#对称密钥和公钥密码体制" class="headerlink" title="对称密钥和公钥密码体制"></a>对称密钥和公钥密码体制</h2><ol>
<li><p>对称密钥密码体系</p>
<ol>
<li>概述<ol>
<li>所谓常规密钥密码体制，即加密密钥与解密密钥是<strong>相同</strong>的密码体制。</li>
<li>这种加密系统又称为<strong>对称密钥系统</strong>。</li>
</ol>
</li>
<li>数据加密标准 （DES Data Encryption Standard）<ol>
<li>数据加密标准DES属于常规密钥密码体制，是一种分组密码(对称加密算法)</li>
<li>在加密前，先对整个明文进行分组。每一个组长为64位。</li>
<li>然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。</li>
<li>最后将各组密文串接起来，即得出整个的密文。</li>
<li>使用的密钥为64位(实际密钥长度为56位，有8位用于奇偶校验)。</li>
<li>对于64位密码有编排的过程，详细自己查找学习</li>
<li>密钥长度不会太长，算法复杂度比较低</li>
</ol>
</li>
<li>DES 的保密性<ol>
<li>DES的保密性仅取决于对密钥的保密，而算法是公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。</li>
<li>DES 是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献。</li>
<li>目前较为严重的问题是DES的密钥的长度(算力提升)<ol>
<li>由于算力的提升，破解DES所需的时间进一步降低，不再是计算上安全的了。</li>
<li>通过增加DES密钥的长度来提高安全性。</li>
</ol>
</li>
<li>现在已经设计出来搜索DES密钥的专用芯片(硬件层面的解决方案)</li>
</ol>
</li>
</ol>
</li>
<li><p>公钥密码体制</p>
<ol>
<li><p>公钥密码体制使用</p>
<p>不同的加密密钥与解密密钥</p>
<p>，是一种”由已知加密密钥推导出解密密钥在</p>
<p>计算上是不可行</p>
<p>的”密码体制。(非对称密码体系)</p>
<ol>
<li>经典算法:密钥E和N，明文是一个数字，加密时用明文做E的指数次方之后mod N得到密文C，解密是D和N，密文C做D次方再mod N得到明文</li>
<li>例子:密钥是7和187，明文88，88的7次方mod187 &#x3D; 11(密文)，解密密钥23和187，11的23次方mod187得到88(明文)</li>
</ol>
</li>
</ol>
<p>88(明文)7 mod 187&#x3D;11(密文)88(明文)7 mod 187&#x3D;11(密文)<br>11(密文)23 mod 187&#x3D;88(明文)11(密文)23 mod 187&#x3D;88(明文)</p>
<ol>
<li><p>公钥密码体制的产生主要是因为两个方面的原因，一是由于常规密钥密码体制的密钥分配问题，另一是由于对数字签名的需求。</p>
<ol>
<li>一个机构可以发送自己的公钥，保留自己的密钥。接收者受到密钥加密的就知道是谁发送的，保证机构可以发送安全认证，接受者使用公钥解密知道是谁发送的，做到密钥的分配</li>
<li>私钥加密的是机构的签名，大量数据传输使用对称密钥体系传输，公钥发送比较少的数据，因为公钥密码体系算法复杂度比较高，加密的时候是很多位的明文，计算量太大。</li>
</ol>
</li>
<li><p>现有最著名的公钥密码体制是RSA体制，它基于数论中大数分解问题的体制，由美国三位科学家Rivest，Shamir和Adleman于1976年提出并在1978年正式发表。</p>
</li>
<li><p>公钥算法的例子</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/3.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/3.png" alt="img"></a></p>
<ol>
<li>在公钥密码体制中，加密密钥(即公钥)PK是公开信息，而解密密钥(即私钥或秘钥)SK是需要保密的</li>
<li>加密算法E和解密算法D也都是公开的</li>
<li>虽然SK是由PK决定的，但却不能根据PK计算出SK(单向的)</li>
<li>公钥和私钥是成对生成的</li>
</ol>
</li>
<li><p>公钥算法的特点</p>
<ol>
<li><p>发送者A用B的公钥</p>
<p>PKBPKB</p>
<p>对明文X加密(E运算)后，在接收者B用自己的私钥</p>
<p>SKBSKB</p>
<p>解密(D 运算)，即可恢复出明文：</p>
<ul>
<li>DSKB(Y)&#x3D;DSKB(EPKB(X))&#x3D;XDSKB(Y)&#x3D;DSKB(EPKB(X))&#x3D;X</li>
</ul>
</li>
<li><p>解密密钥是接收者专用的秘钥，对其他人都保密。</p>
</li>
<li><p>加密密钥是公开的，但不能用它来解密，即</p>
<ul>
<li>DPKB(EPKB(X))≠XDPKB(EPKB(X))&#x3D;X</li>
</ul>
</li>
<li><p>加密和解密的运算可以对调，即(用私钥进行加密，意义有差别:这样子证明是B发送的，但是别人都知道公钥，相当于明文发送)</p>
<ul>
<li>EPKB(DSKB(X))&#x3D;DSKB(EPKB(X))&#x3D;XEPKB(DSKB(X))&#x3D;DSKB(EPKB(X))&#x3D;X</li>
</ul>
</li>
<li><p>在计算机上可容易地产生成对的PK和SK</p>
</li>
<li><p>从已知的PK实际上不可能推导出SK，即从PK到SK是”计算上不可能的”</p>
</li>
<li><p>加密和解密算法都是公开的</p>
</li>
</ol>
</li>
<li><p><strong>应当注意：</strong></p>
<ol>
<li>任何加密方法的安全性取决于<strong>密钥的长度</strong>，以及<strong>攻破密文所需的计算量</strong></li>
<li>在这方面，公钥密码体制并不比传统加密体制更加优越</li>
<li>由于目前公钥加密算法的开销较大，在可见的将来还不会放弃传统的加密方法</li>
<li>公钥需要密钥分配协议，具体的分配过程并不比采用传统加密方法时更简单</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ol>
<li><p>概述：</p>
<ol>
<li>数字签名必须保证以下三点：<ol>
<li>报文鉴别:接收者能够核实发送者对报文的签名</li>
<li>报文的完整性:发送者事后不能抵赖对报文的签名</li>
<li>不可否认:接收者不能伪造对报文的签名</li>
</ol>
</li>
<li>现在已有多种实现各种数字签名的方法。但采用<strong>公钥算法</strong>更容易实现</li>
</ol>
</li>
<li><p>数字签名的实现</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/4.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/4.png" alt="img"></a></p>
<ol>
<li>因为除A外没有别人能具有A的私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的。</li>
<li>若A要抵赖曾发送报文给B，B可将明文和对应的密文出示给第三者。第三者很容易用A的公钥去证实A确实发送X给B。</li>
<li>反之，若B将X伪造成Y，则B不能在第三者前出示对应的密文。这样就证明了B伪造了报文。</li>
</ol>
</li>
</ol>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ol>
<li><p>概述</p>
<ol>
<li>防火墙是由软件、硬件构成的系统，是一种特殊编程(ACL)的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。</li>
<li>防火墙内的网络称为<strong>可信赖的网络</strong>(trusted network)，而将外部的因特网称为<strong>不可信赖的网络</strong>(untrusted network)。</li>
<li>防火墙可用来解决内联网和外联网的<strong>安全问题</strong>。</li>
</ol>
</li>
<li><p>防火墙在互连网络中的位置</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/6.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/6.png" alt="img"></a></p>
<ol>
<li>其实只用一个路由器就可以完成防火墙的划分。</li>
<li>例子中:应用网关，可以内部外部进行访问过滤。</li>
<li>优点:在防火墙中的外局域网和内局域网都可以放置一些服务器，由左侧过滤的路由器控制访问，而右侧的路由控制内部网络的访问，从而达成一个访问权限控制</li>
<li>内网络安全也是一个问题</li>
</ol>
</li>
<li><p>防火墙的功能</p>
<ol>
<li>防火墙的功能有两个：阻止和允许。<ol>
<li><strong>阻止</strong>就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)：比如阻止内部的对迅雷的请求向外发送</li>
<li><strong>允许</strong>的功能与<strong>阻止</strong>恰好相反。</li>
</ol>
</li>
<li>防火墙必须能够识别通信量的各种类型。不过在<strong>大多数情况下防火墙的主要功能</strong>是<strong>阻止</strong>。</li>
</ol>
</li>
<li><p>防火墙技术一般分为两类</p>
<ol>
<li>网络级防火墙:用来防止整个网络出现外来非法的入侵。属于这类的有分组过滤和授权服务器<ol>
<li>前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据</li>
<li>后者则检查用户的登录是否合法</li>
</ol>
</li>
<li>应用级防火墙:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过</li>
</ol>
</li>
</ol>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><ol>
<li><p>访问控制列表ACL(Access Control Lists)</p>
<ol>
<li>ACL是指令列表，它告诉路由器允许或拒绝什么类型的数据包。</li>
<li>如果要让路由器拒绝某些数据包，则必须配置ACL。否则，只要链路打开，路由器将接受并转发所有数据包</li>
<li>您可以根据以下情况允许或拒绝数据包：<ol>
<li>源地址</li>
<li>目的地址</li>
<li>上层的协议，比如TCP或UDP端口</li>
</ol>
</li>
<li>为了确定是允许还是拒绝数据包，请按顺序对ACL语句进行测试。<ol>
<li>当一个语句”匹配”时，<strong>不再评估后面的语句</strong>。(前面的语句先匹配，处理掉)</li>
<li>允许或拒绝该数据包。</li>
</ol>
</li>
<li>默认：ACL末尾有一个隐含的”deny any”语句:如果数据包与ACL中的任何语句都不匹配，则将其丢弃。</li>
</ol>
</li>
<li><p>路由器如何使用出站ACL</p>
<ol>
<li>检查数据包是否可路由。如果是这样，请在路由表中查找路由</li>
<li>检查出站接口的ACL<ol>
<li>如果没有ACL，则将数据包切换出目标接口</li>
<li>如果是ACL，请按照ACL语句顺序检查数据包-根据匹配的条件拒绝或允许。</li>
</ol>
</li>
<li>如果没有语句匹配，会发生什么？拒绝所有没有匹配的包</li>
</ol>
</li>
<li><p>出站标准ACL流程</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/7.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/7.png" alt="img"></a></p>
<ol>
<li>收到packet，确定路由表确认路由表看能够转发</li>
<li>可以转发的话，进入ACL确认<ol>
<li>如果当前端口没有ACL配置，则直接进行转发</li>
<li>如果当前端口有ACL配置，开始匹配source地址(标准的ACL，只能对原地址进行判断)<ol>
<li>语句满足条件，<ol>
<li>deny</li>
<li>premit</li>
</ol>
</li>
<li>语句不满足条件，看下一条，如果没有下一条，则默认deny</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>access-list-number参数</p>
<ol>
<li>ACL有很多类型。访问列表号指定什么类型。</li>
<li>下表显示了常见的访问列表类型。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/8.png" alt="img"></a></p>
<ul>
<li>注意默认的取值(扩展ACL不仅仅局限于源地址)</li>
</ul>
</li>
<li><p>test-condition参数</p>
<ol>
<li>在ACL的{test condition}部分中，大多数访问列表的共同点是源地址的IP掩码和通配符掩码。</li>
<li>源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为ip掩码。</li>
<li>通配符掩码告诉路由器要检查哪些位。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/10.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/10.png" alt="img"></a></p>
<blockquote>
<ol>
<li>Ip mask:Ipv4的地址</li>
<li><strong>Wilcard mask</strong>:和netmask是不同的，指示哪些位置被检查</li>
</ol>
</blockquote>
</li>
<li><p>通配符掩码 Wildcard Mask</p>
<ol>
<li>编写通配符掩码以告知路由器地址中要匹配的位以及要忽略的位。<ol>
<li>0位表示检查该位位置</li>
<li>表示忽略该位位置</li>
</ol>
</li>
<li>我们先前的192.5.5.10 0.0.0.0示例可以用二进制重写为：<ol>
<li>11000000.00000101.00000101.00001010 (Source address)</li>
<li>00000000.00000000.00000000.00000000 (Wildcard mask)</li>
</ol>
</li>
<li>通配符掩码的例子<ol>
<li>编写一个IP掩码和通配符掩码以检查网络上的所有主机：192.5.5.0 255.255.255.0(检查这一个网段)</li>
<li>Answer: 192.5.5.0 0.0.0.255(<strong>和net mask是取反的</strong>)<ol>
<li>请注意，此通配符掩码是C类地址的默认子网掩码的镜像。</li>
<li>警告：<strong>仅当查看整个网络或子网时，这才是有用的规则。</strong></li>
</ol>
</li>
<li>编写一个IP掩码和通配符掩码以检查子网中的所有主机：192.5.5.32 255.255.255.224<ol>
<li>If you answered 192.5.5.32 0.0.0.31</li>
<li>0.0.0.31 是 255.255.255.224 的镜像地址</li>
<li>二进制标识<ol>
<li>11111111.11111111.11111111.11100000 (255.255.255.224)</li>
<li>00000000.00000000.00000000.00011111 (0.0.0.31)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>省时：any命令<ol>
<li>由于ACL末尾有一个隐含的”deny any”语句，<strong>因此您必须编写语句以允许其他人通过。</strong></li>
<li>使用我们前面的示例，如果学生被拒绝访问而所有其他学生都被允许访问，则您将编写以下两个语句：</li>
<li><code>Lab-A(config)#access-list 1 deny 192.5.5.0 0.0.0.127</code>:拒绝一个</li>
<li><code>Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255</code></li>
<li>由于最后一条语句通常用于覆盖”拒绝任何”，因此思科为您提供了一个选项-any命令：</li>
<li><code>Lab-A(config)#access-list 1 permit any</code> &#x3D;&#x3D; <code>Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255</code></li>
</ol>
</li>
<li>省时：主机名支持<ol>
<li>很多时候，网络管理员将需要编写ACL来允许特定主机(或拒绝主机)。该语句可以用两种方式编写。<ol>
<li><code>Lab-A(config)#access-list 1 permit 192.5.5.10 0.0.0.0</code></li>
<li><code>Lab-A(config)#access-list 1 permit host 192.5.5.10(host 专指 192.5.5.10)</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>标准ACL的配置位置</p>
<ol>
<li>标准ACL没有目标参数。因此，您将标准ACL放置在尽可能靠近目标的位置。</li>
<li>要了解原因，请问自己，如果在Lab-A的E0上放置” deny 192.5.5.0 0.0.0.255”语句，将会对所有IP流量产生什么影响？</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/11.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/12.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/12.png" alt="img"></a></p>
<ul>
<li>如果放到Lab A的E0口则会导致无法访问Lab B&#x2F;C,应该放到Lab D的E0</li>
<li>约定:将标准ACL放到与将要生效的主机越近越好，但是其实会对带宽有一定的损耗</li>
</ul>
</li>
<li><p>扩展ACL</p>
<ol>
<li><p>概述：</p>
<ol>
<li>扩展ACL的编号范围为100-199，并”扩展”了标准ACL的功能。</li>
<li>扩展功能包括基于过滤流量的功能。<ol>
<li>目的地址</li>
<li>ip协议的部分(更加细分):您可以编写语句以仅拒绝”ICMP”等协议或”RIP”和”IGRP”之类的路由协议</li>
<li>协议套件的上层<ol>
<li>您可以编写语句以仅拒绝诸如”TFTP”或”HTTP”之类的协议</li>
<li>您可以使用eq，gt，lt和neq(等于，大于，小于和不等于)之类的操作数来指定如何处理特定协议。</li>
<li>例如，如果您希望访问列表允许除http访问之外的所有流量，则可以使用” permit ip any neq 80”(允许来自任意源地址和目的地址的不是80<strong>端口</strong>的信息)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>端口号</p>
<ol>
<li>查看tcp和udp协议的各种端口号，并了解以下最常见的端口号。</li>
<li>您还可以在{protocolspecific options}中键入名称(telnet)而不是数字(23)。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/13.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/13.png" alt="img"></a></p>
</li>
<li><p>配置扩展ACL的位置</p>
<ol>
<li>在下图中，我们要拒绝网络221.23.123.0访问服务器198.150.13.34</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/14.png" alt="img"></a>。</p>
<ol>
<li>访问列表应应用于什么路由器和接口？<ol>
<li>将访问列表写在路由器C上，将其应用于E0，并在</li>
<li>这将使网络不受221.23.123.0发往198.150.13.34的访问，但仍允许221.23.123.0访问Internet</li>
</ol>
</li>
</ol>
<blockquote>
<p>按照标准的原则，应该放置到Route A，而用扩展的放置的是Route C的E0上，放置对应的命令</p>
</blockquote>
<ul>
<li>由于扩展的ACL具有目标信息，因此<strong>您希望将其放置在尽可能靠近源的位置。</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec11/15.png" alt="img"></a></p>
</li>
</ol>
</li>
</ol>
<h1 id="笔记-·-实验笔记"><a href="#笔记-·-实验笔记" class="headerlink" title="笔记 · 实验笔记"></a>笔记 · 实验笔记</h1><h2 id="05：动态-RIP"><a href="#05：动态-RIP" class="headerlink" title="05：动态 RIP"></a>05：动态 RIP</h2><ol>
<li>目的：以跳数为依据，让路由器互联</li>
<li>工作原理：<ol>
<li>跳数：直连网络为一，其他情况为中间的路由器数加一。</li>
<li>最大为15跳，16为不可达</li>
<li>和谁交换信息？只和相邻路由器交换信息</li>
<li>交换什么信息？路由表</li>
<li>何时交换信息？周期性定期交换</li>
<li>怎么更新信息？收到邻居路由器的路由表并且处理好跳数后，与现有路由表比较。<ol>
<li>到达相同网络，相同的下一跳，保留最小跳数。若相同，保留新消息</li>
<li>到达相同网络，不同的下一跳，保留最小跳数。若相同，两个都要保留。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="06：配置单域-OSPF"><a href="#06：配置单域-OSPF" class="headerlink" title="06：配置单域 OSPF"></a>06：配置单域 OSPF</h2><ol>
<li>目的：动态地获得完整的网络拓扑结构</li>
<li>关键概念：<ol>
<li>OSPF（Open Shortest Path First）：是一种常见的内部网关协议（IGP），用于在一个自治系统（AS）内的<strong>路由器之间交换路由信息</strong>。适用于复杂的网络拓扑。</li>
<li>cost：指标由<strong>带宽</strong>，速度，流量，可靠性和安全性计算，本科阶段只考虑带宽因素。</li>
<li>LSA（链路状态广告）**：一旦建立邻接，OSPF路由器就会交换链路状态广告（LSA），以便所有路由器了解网络拓扑。</li>
<li>LSDB（链路状态数据库）： 每个路由器维护一个链路状态数据库（LSDB），该数据库包含了网络中所有LSA的副本，表示了当前网络拓扑。</li>
<li>DR：指定路由器，只有在多路复用的情况下使用</li>
<li>BDR：如果DR坏了，再次选举会出现问题，如果DR损坏，BDR立即成为DR</li>
<li>Hello Interval：发送hello报文的时间间隔</li>
<li>Dead Interval：能容忍的收到回复的最大时间间隔。一般是hello interval的4倍。</li>
<li>Router ID：选择所有环回接口中的IP地址最大的作为ID。若没有环回接口，则从当前活跃的物理接口中找到IP最大的作为ID。</li>
</ol>
</li>
<li>工作原理：<ol>
<li>每台路由器都有与自己直连的路由器的信息（邻居的信息），他们之间互相交换LSA，最终构建起整个网络的路由信息。</li>
<li>为了避免大量重复的泛洪造成的资源浪费，会选举出DR和BDR。大家把信息全部发给DR，DR整合好之后再发还给其他路由器。BDR是DR的备份。</li>
<li>为了减轻存储信息的压力，会对网络拓扑分区。<ol>
<li>区域0（Area 0）：OSPF的骨干区域，所有其他区域必须与区域0相连接。</li>
<li>普通区域（Normal Area）：区域0之外的其他区域，可以包含普通路由信息。</li>
<li>边界路由器：处于骨干区域边界的路由器，与骨干区域和其他区域都是相连的。要维护两个LSDB。</li>
<li>一个Area中不能有超过<strong>50</strong>台路由器，否则会导致SPF算法产生的计算量和内存过大</li>
</ol>
</li>
<li>通过Hello报文互相打招呼，以确保维持链路。若没能受到回复，则认为它“死”了。</li>
</ol>
</li>
<li>工作步骤：<ol>
<li>步骤1：建立邻接关系</li>
<li>步骤2：选择DR和BDR(如果需要):多路复用的时候才需要</li>
<li>步骤3：发现路线</li>
<li>步骤4：选择适当的路线</li>
<li>步骤5：维护路线信息</li>
</ol>
</li>
</ol>
<h2 id="07：VLAN-间路由"><a href="#07：VLAN-间路由" class="headerlink" title="07：VLAN 间路由"></a>07：VLAN 间路由</h2><ol>
<li>目的：隔离广播域</li>
<li>关键概念：<ol>
<li>VLAN：虚拟局域网。是一种隔离广播域的技术。</li>
<li>交换机不能隔离广播域，路由器天生就能够隔离广播域。</li>
<li>Access接口：只连接到单一VLAN</li>
<li>Trunk链路：可以同时承载多个VLAN的流量</li>
</ol>
</li>
</ol>
<h2 id="08：NAT网络地址转换"><a href="#08：NAT网络地址转换" class="headerlink" title="08：NAT网络地址转换"></a>08：NAT网络地址转换</h2><ol>
<li>目的：让内部的私网可以通过转换变成公网来上网</li>
</ol>
<h2 id="09：ACL-实验"><a href="#09：ACL-实验" class="headerlink" title="09：ACL 实验"></a>09：ACL 实验</h2><ol>
<li>目的：筛选数据流</li>
<li>关键概念：<ol>
<li>ACL：访问控制列表</li>
</ol>
</li>
<li>要点：<ol>
<li>标准的ACL要放在靠近目标的位置，扩展到ACL要放在靠近源的位置</li>
<li>对于 ACL，有个非常重要的特性， 他不能过滤本地数据流。即ACL所在的路由器不能控制过滤自己发出的信息。</li>
<li>设置了 2 种 ACL，但是得到的效果却不一样。如果是使用了扩展的 ACL，那么它的提示是“% Destination unreachable; gateway or host down”,说明 23 号端口根本不可达。如果是使用了标准的 ACL 放置在 VTY 线路中，则提示“%  Connection refused by remote host”，说明的确是到达了 23 号端口，只不过被拒绝 了。在实际使用中最好使用扩展的 ACL，减少 23 号端口的负担。</li>
</ol>
</li>
<li>语句解释：<ol>
<li>line vty 0 4：在路由器或交换机上配置虚拟终端 (VTY) 线路，用于远程访问设备（例如，使用 Telnet 或 SSH）。通过配置 <code>line vty</code>，可以控制对设备的远程访问权限。配置 VTY 线路 0 至 4（即最多支持 5 个并发的远程连接）。</li>
<li><code>ip access-group 100 out</code> ：是用来在 Cisco 设备上将访问控制列表 (ACL) 应用到接口的命令。这个命令的作用是将编号为 100 的访问控制列表应用到接口的 <strong>输出流量</strong>，即所有通过该接口发送出去的数据包。</li>
</ol>
</li>
</ol>
<h2 id="10：PPP-验证实验"><a href="#10：PPP-验证实验" class="headerlink" title="10：PPP 验证实验"></a>10：PPP 验证实验</h2><ol>
<li><p>目的：为点对点连接提供一种可靠、灵活且标准化的通信方式。</p>
</li>
<li><p>关键概念：</p>
<ol>
<li>PPP：点对点协议。PPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法。</li>
<li>LCP：链路控制协议。可以动态地协商链路参数，管理链路的建立、维护和终止。可以看做是面向物理层的接口。</li>
<li>NCP：网络控制协议。动态协商和分配IP地址。可以看做是面向网络层的接口。</li>
<li>PAP：基于密码的简单认证协议（Password Authentication Protocol）。</li>
<li>CHAP：动态加密挑战机制。更安全，采用动态加密挑战机制来验证身份，避免了密码在传输过程中的明文暴露。</li>
</ol>
</li>
<li><p>工作流程和状态</p>
<ol>
<li><p>静止状态：开始和结束状态都是静止状态，没有物理层链接</p>
</li>
<li><p>建立状态：检测到载波信号，建立物理层链接，进入建立状态。然后LCP开始协商配置选项：</p>
<ul>
<li>配置选项：<ul>
<li>最大帧长</li>
<li>鉴别协议<ul>
<li>无鉴别</li>
<li>PAP</li>
<li>CHAP</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>协商成功，进入鉴别状态</li>
<li>失败则回到静止状态</li>
</ol>
</li>
<li><p>鉴别状态：根据协议鉴别身份。</p>
<ol>
<li>若鉴别成功或无鉴别，则进入网络状态</li>
<li>失败则进入终止状态</li>
</ol>
</li>
<li><p>网络状态：进行NCP配置。完成后进入打开状态。</p>
</li>
<li><p>打开状态：可以进行数据传输。</p>
<ol>
<li>出现故障或收到终止请求，进入终止状态。</li>
</ol>
</li>
<li><p>终止状态：当载波停止后，回到静止状态。</p>
</li>
</ol>
</li>
</ol>
<h2 id="12：DHCP-欺诈保护"><a href="#12：DHCP-欺诈保护" class="headerlink" title="12：DHCP 欺诈保护"></a>12：DHCP 欺诈保护</h2><ol>
<li><p>概念：</p>
<ol>
<li>DHCP：动态主机配置协议(Dynamic Host Configuration Protocol)用于动态地为网络上的设备分配 IP 地址和其他网络配置（如子网掩码、网关和 DNS 服务器）。DHCP 使得设备能够在连接到网络时自动获取配置，避免了手动设置 IP 地址和其他参数的繁琐。</li>
</ol>
</li>
<li><p>DHCP工作原理：</p>
<ol>
<li>发现阶段：客户端设备在启动时会向网络发送一个 <strong>DHCP Discover</strong> 广播消息，表示其请求获取 IP 地址。这个消息在网络中广播，以便找到 DHCP 服务器。</li>
<li>提供：网络中的 DHCP 服务器收到 Discover 消息后，会向客户端返回一个 <strong>DHCP Offer</strong> 消息，内含一个可用的 IP 地址、子网掩码、默认网关、DNS 等信息。此消息也会通过广播发送。</li>
<li>选择并请求：客户端收到 DHCP 服务器的多个 <strong>Offer</strong> 后，会选择一个并发送 <strong>DHCP Request</strong> 消息，告诉 DHCP 服务器其选择的 IP 地址，并请求确认。此请求是广播的。</li>
<li>确认：DHCP 服务器确认客户端的请求后，会向客户端发送 <strong>DHCP Ack</strong> 消息，正式确认分配给客户端的 IP 地址和其他配置信息。此时，客户端开始使用该 IP 地址。</li>
</ol>
</li>
<li><ol>
<li><ul>
<li></li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="笔记-·-名词解释"><a href="#笔记-·-名词解释" class="headerlink" title="笔记 · 名词解释"></a>笔记 · 名词解释</h1><h2 id="第一章：网络概述"><a href="#第一章：网络概述" class="headerlink" title="第一章：网络概述"></a>第一章：网络概述</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li>是一组相连接的系统，终端可以是物、人、设备。计算机网络终端是计算机，传输01序列，为了共享资源</li>
</ul>
<h3 id="LAN"><a href="#LAN" class="headerlink" title="LAN"></a>LAN</h3><ul>
<li>local area network</li>
</ul>
<ul>
<li>局域网，工作范围较小，采用广播式的传输方式，多个用户同时复用一个链路介质，提高效率</li>
<li>设备：集线器（hub）、网桥（bridge）、交换机（switch）、路由器（router）</li>
</ul>
<h3 id="WAN"><a href="#WAN" class="headerlink" title="WAN"></a>WAN</h3><ul>
<li>wide area network</li>
</ul>
<ul>
<li>广域网，工作范围大，采用点对点的传输方式，多单位合作实现与维护</li>
<li>设备：路由器（router）、调制解调器（modem）</li>
</ul>
<h3 id="internet"><a href="#internet" class="headerlink" title="internet"></a>internet</h3><ul>
<li>互联网，有若干个网络连接而成的网络</li>
</ul>
<h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><ul>
<li>因特网，世界上最大的互联网。采用TCP&#x2F;IP协议为通信规则，前身是美国的ARPANET</li>
</ul>
<h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul>
<li>Internet Service Providers，网络服务供应商。ISP从因特网管理机构申请多个IP地址、通信线路和路由器等设备。机构或个人通过ISP接入因特网。</li>
<li>ISP分为三层，在低层ISP可以解决的问题不会进入上层ISP，以此来进行流量分流</li>
</ul>
<h3 id="NAP"><a href="#NAP" class="headerlink" title="NAP"></a>NAP</h3><ul>
<li>network access point，网络接入点。向各ISP提供交换设备，使他们能够互相通信</li>
</ul>
<h3 id="data-packet"><a href="#data-packet" class="headerlink" title="data packet"></a>data packet</h3><ul>
<li>数据报文，为了传输，数据总是被分解为小、易于传输的单元。OSI模型中称为报文、帧或段</li>
<li>优点：1. 可以发呢还是偏处理不同进程的报文；2. 即使链路故障，只需要重传小部分报文；3. 可以走不同路径最有到达</li>
</ul>
<h3 id="bandwidth-throughout"><a href="#bandwidth-throughout" class="headerlink" title="bandwidth &amp; throughout"></a>bandwidth &amp; throughout</h3><ul>
<li>带宽：给定时间可传输的数据量</li>
<li>吞吐量：实际的数据量</li>
</ul>
<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><ul>
<li>open system interconnection，开放系统互联基本参考模型。由国际标准化组织ISO提出，使得不同体系结构的计算机能够互连</li>
<li>七层简述：<ol>
<li>物理层（physical）：解决二进制传输问题——信号与介质的规范——只传递信号，不做正确性判断</li>
<li>数据链路层（data link）：帧和介质访问控制——点对点的一个链路——确保可靠传输</li>
<li>网络层（network）：路径选择与最佳路径——基于ip地址逻辑定位设备、多个链路——可达传输，不做复杂校验</li>
<li>传输层（transport）：终端与终端之间的连接——可靠性、流控制、错误校正</li>
<li>会话层（session）：内部host的对话与交流——会话管理、同步校验</li>
<li>表示层（presentation）：数据加密与显示——通用格式、数据结构与传输语法的协商</li>
<li>应用层（application）：用户界面——浏览器、面向用户</li>
</ol>
</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230105100005103.png" alt="image-20230105100005103" style="zoom:67%;float:left" /></li>
</ul>
<h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h3><ul>
<li>Transmission Control Protocol&#x2F;Internet Protocol</li>
<li>由美国防部DoD创建，希望数据报任何情况下都能从一个点传输到另一个点</li>
<li>四层简述：<ol>
<li>网络接口层（network access）：相当于OSI物理层+数据链路层</li>
<li>互联网层（internet）：相当于OSI网络层</li>
<li>传输层（transport）：相当于OSI传输层</li>
<li>应用层（application）：相当于OSI会话层、表示层、应用层</li>
</ol>
</li>
</ul>
<h3 id="各层网络设备"><a href="#各层网络设备" class="headerlink" title="各层网络设备"></a>各层网络设备</h3><ul>
<li>第一层：介质（media）、集线器（hub）、中继器（repeater）、<em>网卡（NIC）</em></li>
<li>第二层：网卡（NIC）、交换机（switch）、网桥（bridge）</li>
<li>第三层：路由器（router）</li>
</ul>
<h3 id="NIC网卡"><a href="#NIC网卡" class="headerlink" title="NIC网卡"></a>NIC网卡</h3><ul>
<li>network interface controller，网路终端设备</li>
<li>拥有一个MAC地址，表明主机身份，帮助主机接入网络</li>
<li>成帧：打包比特流进行传输</li>
<li>LLC+MAC</li>
<li>控制数据流（接受和发送数据）、实现串行信号（用于发送）与并行信号（电脑产生）的转化</li>
</ul>
<h3 id="Repeater中继器"><a href="#Repeater中继器" class="headerlink" title="Repeater中继器"></a>Repeater中继器</h3><ul>
<li>网络中间设备，用于延长网络的长度。整理、放大、重发信号，不做逻辑过滤，不划分冲突域</li>
</ul>
<h3 id="Hub集线器"><a href="#Hub集线器" class="headerlink" title="Hub集线器"></a>Hub集线器</h3><ul>
<li>网络中间设备，多端口的<strong>中继器</strong></li>
</ul>
<h3 id="Bridge网桥"><a href="#Bridge网桥" class="headerlink" title="Bridge网桥"></a>Bridge网桥</h3><ul>
<li>网络中间设备。</li>
<li>过滤信息，划分<strong>冲突域</strong></li>
<li>通过MAC地址实现多个LAN之间设备的连接（接两个不同局域网）</li>
</ul>
<h3 id="Switch交换机"><a href="#Switch交换机" class="headerlink" title="Switch交换机"></a>Switch交换机</h3><ul>
<li>网络中间设备，多端口的<strong>网桥</strong></li>
<li>可以隔离冲突域，但不能隔离广播域</li>
</ul>
<h3 id="Router路由器"><a href="#Router路由器" class="headerlink" title="Router路由器"></a>Router路由器</h3><ul>
<li>网络中间设备，进行网段的划分，选择路径并转发报文到最佳路径</li>
<li>路由器的每个端口都有一个网卡，我们给路由器的每一个端口也分配一个IP地址，使其可以通过IP协议栈与网段中其他设备通信</li>
</ul>
<hr>
<h2 id="第二章：物理层"><a href="#第二章：物理层" class="headerlink" title="第二章：物理层"></a>第二章：物理层</h2><h3 id="UTP"><a href="#UTP" class="headerlink" title="UTP"></a>UTP</h3><ul>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230219114452931.png" alt="image-20230219114452931" style="zoom:80%;float:left" /></li>
<li>Unshielded <strong>Twisted Pair</strong>，无屏蔽<strong>双绞线</strong>。八根子线，两两一组（抵消彼此电磁影响和外部电磁波干扰），每组为Twisted Pair</li>
<li>比**STP（有屏蔽双绞线）**便宜，容易部署；但是抗干扰能力弱于STP</li>
</ul>
<h3 id="Coaxial"><a href="#Coaxial" class="headerlink" title="Coaxial"></a>Coaxial</h3><ul>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230219114622137.png" alt="image-20230219114622137" style="zoom:80%;float:left" /></li>
<li>同轴电缆，传输距离比UTP远，成本略高但小于光纤</li>
<li>中间为铜导线（传输电信号），外包绝缘膜（减少干扰），外包一层金属网（一定程度屏蔽外界电磁干扰），最外层塑胶套（保护内部不受侵蚀）</li>
</ul>
<h3 id="Fiber-Optic"><a href="#Fiber-Optic" class="headerlink" title="Fiber-Optic"></a>Fiber-Optic</h3><ul>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230219114654717.png" alt="image-20230219114654717" style="zoom:80%;float:left" /></li>
<li>光纤，中间光导体（二氧化硅），外包塑料套（包装与保护），<strong>不受电磁干扰</strong>，更远效率更高，更贵</li>
<li>单模：用于广域网，直径更小，传播距离更长；多模：用于局域网，入射角度区分，同时传多路光线</li>
</ul>
<h3 id="Wireless-Communication"><a href="#Wireless-Communication" class="headerlink" title="Wireless Communication"></a>Wireless Communication</h3><ul>
<li>无线通讯，通过频率区分不同电磁波</li>
<li>无线传输方法：<ol>
<li>激光通信（lasers）——军用，受雨雾干扰影响大：电磁波频率相同</li>
<li>红外通信（infrared）——遥控器，实现漫反射：不能透过不透明物体</li>
<li>无线电通信（radio）——民用，受雨雾干扰影响小 携带可以穿墙的数据信号 陆地和卫星无线电技术</li>
</ol>
</li>
</ul>
<h3 id="双绞线类型"><a href="#双绞线类型" class="headerlink" title="双绞线类型"></a>双绞线类型</h3><ul>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230219115536883.png" alt="image-20230219115536883" style="zoom:80%;float:left" /></li>
<li>Straight cable，直通线（用于同类设备）：两端标准相同</li>
<li>rollover cable，反转线（用于控制台端口与与PC串口连接）：两端标准相同，但插脚对应反过来</li>
<li>crossover cable，交叉线（连接集线器、交换机）：两端标准相反（T568-A、T568-B）</li>
</ul>
<h3 id="比特率与波特率"><a href="#比特率与波特率" class="headerlink" title="比特率与波特率"></a>比特率与波特率</h3><ul>
<li>波特率(baud)和比特率(bit)<ul>
<li>波特率(调制速率)：波信号每秒钟变化的次数</li>
<li>比特率：每秒钟传送的二进制位数</li>
</ul>
</li>
<li>波特率与比特率的关系取决于信号值与比特位的关系<ul>
<li>例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同</li>
<li>对于比特率为a bps的信道，发送8位所需的时间为 8&#x2F;a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f &#x3D; a&#x2F;8 Hz</li>
</ul>
</li>
</ul>
<h3 id="多路复用-（Multiplexing）"><a href="#多路复用-（Multiplexing）" class="headerlink" title="多路复用 （Multiplexing）"></a>多路复用 （Multiplexing）</h3><ul>
<li><p>TDM：时分复用（time division）：将时间划分为一段段等长的时分复用帧，每个用户占用固定序号的时隙</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20220926111356968.png" alt="image-20220926111356968" style="zoom:80%;float:left" />

<ul>
<li>TDM会造成线路资源的浪费，对此统计时分复用STDM一旦充足就组织发送，不以时间区分用户所以需要每个帧携带自己用户的信息</li>
</ul>
</li>
<li><p>FDM：频分复用（frequency division）：用户分配一定频带后，始终占用这个频带</p>
</li>
<li><p>WDM：波分复用（wavelength division）：光的频分复用</p>
</li>
<li><p>CDM：码分复用（code division）：用户使用经过特殊挑选的不同码型，不会彼此干扰</p>
</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li>单工（simplex）：信号单向传输</li>
<li>半双工（half-duplex）：可双向传输，但不可同时</li>
<li>全双工（full-duplex）：可同时双向传输</li>
</ul>
<hr>
<h2 id="第三章：数据链路层"><a href="#第三章：数据链路层" class="headerlink" title="第三章：数据链路层"></a>第三章：数据链路层</h2><h3 id="MAC（控制）"><a href="#MAC（控制）" class="headerlink" title="MAC（控制）"></a>MAC（控制）</h3><ul>
<li>media access control，局域网的介质访问控制，用来确定共享介质环境中哪个计算机允许传输数据的协议</li>
<li>三种常见MAC<ol>
<li>以太网（Ethernet）：逻辑总线拓扑，物理星型或扩展星型拓扑</li>
<li>令牌环（token ring）：逻辑环形拓扑，物理星型拓扑</li>
<li>光纤分布式数据接口（FDDI）：逻辑环形拓扑，物理双环</li>
</ol>
</li>
<li>分为两类控制方法：<ol>
<li>确定性轮流（deterministic），通过令牌决定能否发送——令牌环、FDDI</li>
<li>争用式（non-deterministic），先来先服务——以太网<ul>
<li>即：CSMA&#x2F;CD，见下</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="LLC-MAC（子层）"><a href="#LLC-MAC（子层）" class="headerlink" title="LLC &amp; MAC（子层）"></a>LLC &amp; MAC（子层）</h3><ul>
<li>IEEE标准将数据链路层分为两子层：<ul>
<li>MAC（meida access control）介质访问控制，定义帧如何在<strong>物理层</strong>传输</li>
<li>LLC（logical link control）逻辑链路控制<ol>
<li>获取网络协议数据（packet），并添加更多控制信息来帮助包到达目的地，后交给MAC子层</li>
<li>向<strong>网络层</strong>提供服务（有无应答、有无连接，三种）</li>
<li>可以对应不同MAC子层</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="SAP-DSAP-SSAP"><a href="#SAP-DSAP-SSAP" class="headerlink" title="SAP &amp; DSAP &amp; SSAP"></a>SAP &amp; DSAP &amp; SSAP</h3><ul>
<li>这三个是LLC子层的寻址组件</li>
<li>SAP：service access point，服务接入点</li>
<li>DSAP：destination SAP，目的服务接入点</li>
<li>SSAP：Source SAP，源服务接入点</li>
</ul>
<h3 id="MAC地址（地址）"><a href="#MAC地址（地址）" class="headerlink" title="MAC地址（地址）"></a>MAC地址（地址）</h3><ul>
<li>48位，始终表示12个十六进制数</li>
<li>前6位十六进制数表示制造商、供应商，并包含组织唯一标识符</li>
<li>其余六位包括接口序列号，由特定供应商管理</li>
<li>广播地址（全1，FFFF.FFFF.FFFF）</li>
</ul>
<h3 id="CSMA-CD-1"><a href="#CSMA-CD-1" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><ul>
<li>Carrier Sense Multiple Access with Collision Detection 带冲突检测的载波侦听多路访问</li>
<li>用于有线网络</li>
</ul>
<ol>
<li>首先设备要发送数据</li>
<li>开始侦听链路是否忙，如果忙，则过一阵来再看看</li>
<li>如果不忙，则开始准备发送<ul>
<li>如果有错误，表示有冲突发生，广播一个jam sighnal，把自己尝试的次数 + 1（重发有一定限度）</li>
<li>尝试次数过多，会向上层协议传输网络不可用</li>
<li>尝试次数还可，则计算一个回退时间，来再次尝试，回退时间单位，会保证时间差能保证第一个人已经用完电路来避免冲突。</li>
</ul>
</li>
<li>如果没有错误，则一直传输到结束为止</li>
</ol>
<h3 id="CSMA-MA"><a href="#CSMA-MA" class="headerlink" title="CSMA&#x2F;MA"></a>CSMA&#x2F;MA</h3><ul>
<li>Carrier Sense Multiple Access with Collision Avoidance</li>
<li>用于无线网络</li>
<li>带冲突避免的载波侦听多路访问。由于无线局域网只能知道边上站点的传输情况，所以只能避免冲突没不能想CSMA&#x2F;CD一样检测冲突。</li>
<li>发送站点在发送数据前，以<strong>控制短帧</strong>刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送</li>
</ul>
<h3 id="BSS-BS-AP-SSID-ESS"><a href="#BSS-BS-AP-SSID-ESS" class="headerlink" title="BSS &amp; BS &amp; AP &amp; SSID &amp; ESS"></a>BSS &amp; BS &amp; AP &amp; SSID &amp; ESS</h3><ul>
<li>BSS：Basic service set，基本服务集，包含一个基站BS（Basic Station）和若干无线主机<ul>
<li>所有主机都可以在本地BSS中借助基站直接相互通信</li>
<li>基站范围内其他两个主机之间是不互相连接的，只能借助基站通信</li>
</ul>
</li>
<li>当一个接入点AP（access point）安装后，一个服务集标识SSID（service set Identifier）和一个通道就会被分配到该接入点</li>
<li>一个基本服务集BSS可以通过分布式系统DS（distribution system）和其他BSS连接构建一个扩展服务集ESS</li>
</ul>
<h3 id="无线局域网的CSMA-CA"><a href="#无线局域网的CSMA-CA" class="headerlink" title="无线局域网的CSMA&#x2F;CA"></a>无线局域网的CSMA&#x2F;CA</h3><ul>
<li><p>Carrier Sense Multiple Access with Collision Avoidance 带冲突避免的载波侦听多路访问</p>
</li>
<li><p>为什么无线局域网（WLAN）使用CSMA&#x2F;CA而不是CSMA&#x2F;CD？</p>
<ul>
<li>无线局域网站只能知道边上站的传输情况，不知道其他站，所以只能“避免”，无法“检测”</li>
</ul>
</li>
<li><p>两个问题</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230120122932471.png" alt="image-20230120122932471" style="zoom:80%;float:left" />

<ul>
<li>隐藏站问题：当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生冲突（听不到应该听到的信息）</li>
<li>暴露站问题：当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(听到不应该听到的信号)</li>
</ul>
</li>
<li><p>发送站点在发送数据前，以<strong>控制短帧</strong>刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送</p>
</li>
<li><p>基本过程</p>
<ol>
<li>A向B发送RTS（Request To Send，请求发送）帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A；</li>
<li>B向A回答CTS（Clear To Send，清除发送）帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据；</li>
<li>A开始发送</li>
<li>若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。（A和C同时发送RTS）</li>
</ol>
</li>
</ul>
<h3 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h3><ul>
<li>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。透明网桥是一种即插即用设备，是目前以太网中使用得最多的网桥</li>
</ul>
<hr>
<h2 id="第四章：网络层"><a href="#第四章：网络层" class="headerlink" title="第四章：网络层"></a>第四章：网络层</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><p>32位，网络号（network ID）+主机号（host ID）</p>
</li>
<li><p>网络号由ARIN（american registry for internet numbers分配）</p>
</li>
<li><p>划分（第一个字节）与格式</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127091637566.png" alt="image-20230127091637566" style="zoom:80%;float:left" />

<ul>
<li>0-127：A类地址</li>
<li>128-191：B类地址</li>
<li>192-223：C类地址</li>
</ul>
</li>
<li><p><strong>注意</strong>：每个网段中，有两个地址不能划分给主机</p>
<ul>
<li>全0保留用于网络地址</li>
<li>全1保留用于广播地址</li>
</ul>
</li>
<li><p>专用地址空间（用作局域网的内部网段）</p>
<ul>
<li>A：10.0.0.0 - 10.255.255.255</li>
<li>B：172.16.0.0 - 172.31.255.255</li>
<li>C：192.168.0.0 - 192.168.255.255</li>
</ul>
</li>
<li><p>IP地址耗尽的解决办法</p>
<ol>
<li>NAT，即使用私有IP地址（见运输层）</li>
<li>CIDR，无类域间选路</li>
<li>IPv6，长期解决办法</li>
</ol>
</li>
</ul>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><ul>
<li>从host为中借几位用于单位内部划分子网，减少冲突域</li>
<li>是逻辑上的，到达本地路由器之后再根据子网号交付</li>
<li>可借位数：2 ~ host位数-2</li>
<li>子网划分会带来地址浪费（本来只有两个不能划分，现在每个子网里都有两个不能划分，另外子网全0全1也不能使用）</li>
</ul>
<h3 id="路由转发过程"><a href="#路由转发过程" class="headerlink" title="路由转发过程"></a>路由转发过程</h3><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127100713106.png" alt="image-20230127100713106" style="zoom:80%;float:left" />

<ol>
<li>A5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧（这个帧的目的地址是A1端口），然后放到总线上</li>
<li>路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)</li>
<li>路由器检查自己的路由表，找到对应的端口B1，形成新的帧（这个帧的源地址为B1端口，目的址是B1的MAC地址）</li>
</ol>
<h3 id="IP地址动态分配（RARP、BOOTP、DHCP）"><a href="#IP地址动态分配（RARP、BOOTP、DHCP）" class="headerlink" title="IP地址动态分配（RARP、BOOTP、DHCP）"></a>IP地址动态分配（RARP、BOOTP、DHCP）</h3><ul>
<li>RARP：reverse address resolution protocol，反向地址解析协议</li>
<li>BOOTP：BOOTstrap protocol，BOOTstrap协议</li>
<li>DHCP：dynamic host configuration，动态主机配置协议</li>
</ul>
<h3 id="Default-gateway-默认网关"><a href="#Default-gateway-默认网关" class="headerlink" title="Default gateway 默认网关"></a>Default gateway 默认网关</h3><ul>
<li><strong>默认网关是路由器上连接到源主机所在网段的接口的IP地址</strong></li>
<li>为了使设备能与另一网络上的设备通信，则必须为其提供默认网关，源设备将数据发送到默认网关</li>
</ul>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul>
<li><p>address resolution protocol，地址解析协议，根据IP地址信息来获取MAC地址</p>
</li>
<li><p>过程：</p>
<ul>
<li><p>查找本地ARP table有无相关条目（条目具有时效性）</p>
</li>
<li><p>如果没有：</p>
<ol>
<li><p>发出广播，向目的方请求MAC地址</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127153450640.png" alt="image-20230127153450640" style="zoom:80%;float:left" />
</li>
<li><p>各主机接受帧，解析报文内容，若主机发现IP地址与自己匹配，则根据帧中发送方的IP地址与MAC地址准备应答，同时更新自己的ARP table</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127153511503.png" alt="image-20230127153511503" style="zoom:80%;float:left" />
</li>
<li><p>目标主机把自己的MAC地址填入后，进行回复</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127153918560.png" alt="image-20230127153918560" style="zoom:80%;float:left" />
</li>
<li><p>请求方接受到回复后，更新ARP table，并发出正常数据帧</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230127154121003.png" alt="image-20230127154121003" style="zoom:80%;float:left" /></li>
</ol>
</li>
</ul>
</li>
<li><p>上述过程使用了广播操作，而广播操作只能在本网段内进行，如果需要跨网段则通过<strong>默认网关</strong>或<strong>ARP代理</strong>来实现</p>
<ul>
<li>默认网关：发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发</li>
<li>ARP代理（Proxy ARP）：中间设备（比如路由器）代表目的端发送一个ARP应答给发送请求的主机。</li>
<li>ARP代理的应用场景是源主机未配置默认网关，在本网段广播时，路由器返回自己端口的MAC地址，是的源主机能够通过网关转发</li>
</ul>
</li>
</ul>
<h3 id="Routed-protocol-Routing-protocol"><a href="#Routed-protocol-Routing-protocol" class="headerlink" title="Routed protocol &amp; Routing protocol"></a>Routed protocol &amp; Routing protocol</h3><ul>
<li>Routed protocol，被动路由协议，用于路由器之间<strong>基于路由表进行转发判断</strong></li>
<li>Routing protocol，路由协议，用于路由器之间，用作于彼此交换信息，<strong>进行各自路由表的生成</strong></li>
</ul>
<h3 id="Static-routes-Dynamic-routes"><a href="#Static-routes-Dynamic-routes" class="headerlink" title="Static routes &amp; Dynamic routes"></a>Static routes &amp; Dynamic routes</h3><ul>
<li>Static routes，静态路由，网络管理员手动输入路由信息</li>
<li>Dynamic routes，动态路由，使用路由协议自动更新路由信息</li>
</ul>
<h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3><ul>
<li>自治系统是一个主管部门下的路由器网络，例如公司、学校、政府机构等网络。自治系统内部的路由器了解内部全部网络的路由信息</li>
</ul>
<h3 id="IGP-EGP"><a href="#IGP-EGP" class="headerlink" title="IGP &amp; EGP"></a>IGP &amp; EGP</h3><ul>
<li>是动态路由协议的两类</li>
<li>IGP（interior gateway protocol）内部网关协议，自治系统内部</li>
<li>EGP（exterior gateway protocol）外部网关协议，自治系统之间</li>
</ul>
<h3 id="DVP-LSP"><a href="#DVP-LSP" class="headerlink" title="DVP &amp; LSP"></a>DVP &amp; LSP</h3><ul>
<li>是内部网关协议的两类</li>
<li>DVP（distance vector protocol）距离矢量协议，基于邻居获取网络拓扑信息<ul>
<li>以跳数为评判依据，只知道到达一个网段的最少跳数；定期更新</li>
</ul>
</li>
<li>LSP（link state protocol）链路状态协议，基于全局获取网络拓扑通用视图<ul>
<li>基于cost 最小生成树；一开始就交换信息形成拓扑图们稳定后事件触发更新</li>
</ul>
</li>
</ul>
<h3 id="RIP-1"><a href="#RIP-1" class="headerlink" title="RIP"></a>RIP</h3><ul>
<li>Routing information protocol，路由信息协议，DV的代表</li>
<li>是基于距离矢量的内部网关协议，以跳数为唯一指标，最大跳数为15，30更新一次</li>
<li>由于其简单、靠谱，广收欢迎</li>
</ul>
<h3 id="IGRP"><a href="#IGRP" class="headerlink" title="IGRP"></a>IGRP</h3><ul>
<li>Interior Gateway Routing Protocol</li>
<li>是基于距离矢量的内部网关协议，思科知识产权的，最大跳数为255，90秒更新一次</li>
</ul>
<h3 id="EIGRP"><a href="#EIGRP" class="headerlink" title="EIGRP"></a>EIGRP</h3><ul>
<li>Enhanced IGRP</li>
<li>高级版本，混合路由协议（由带宽、负载、延迟、可靠性等加权得到评判标准）</li>
</ul>
<h3 id="OSPF-1"><a href="#OSPF-1" class="headerlink" title="OSPF"></a>OSPF</h3><ul>
<li>Open Shortest Path First，开放最短路径优先</li>
<li>是基于链路状态的内部网关协议</li>
<li>指标由<strong>带宽</strong>，速度，流量，可靠性和安全性组成</li>
</ul>
<h3 id="VLSM"><a href="#VLSM" class="headerlink" title="VLSM"></a>VLSM</h3><ul>
<li>Variable Length Subnet Mask，可变长度子网掩码</li>
<li>经典路由会造成网络号的浪费，VLSM允许不同子网用不同长度的子网掩码，可以保证子网的划分效率</li>
<li>VLSM 提高了灵活性，可以更为高效地使用IP地址，进行更好的路由聚集</li>
</ul>
<h3 id="路由聚集"><a href="#路由聚集" class="headerlink" title="路由聚集"></a>路由聚集</h3><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230129141037973.png" alt="image-20230129141037973" style="zoom:80%;float:left" />

<ul>
<li>将尽可能多的相同位进行聚集，作为net位，一定有差异的位将其从网络位变为host位</li>
<li>可以减少路由表的条目数，隔离拓扑变化</li>
<li>用的是SIDR记法，异曲同工</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul>
<li>Internet control message protocol，因特网控制报文协议</li>
<li>为提高IP数据报交付成功的机会，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告</li>
<li>ICMP数据报的组成：数据报首部+IP数据报的数据</li>
<li>一般路由器在丢弃报文时，会返回一个ICMP差错报文</li>
<li>不发送的几种情况：<ol>
<li>对差错报文不再发送差错报文</li>
<li>对第一个分片的后续报文后不发送（每次传输值发送一次）</li>
<li>对多播数据报和具有特殊地址的数据报不发送</li>
</ol>
</li>
</ul>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><ul>
<li>Time To Live，生存时间（更像跳数？）</li>
</ul>
<hr>
<h2 id="第五章：运输层"><a href="#第五章：运输层" class="headerlink" title="第五章：运输层"></a>第五章：运输层</h2><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><ul>
<li>端口，用于一个主机传输多个进程数据时区分不同的进程，可以认为是一个指示符</li>
<li>0-255：public，保留给TCP和UDP公共应用程序</li>
<li>0-1023：熟知端口</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul>
<li>套接字</li>
<li>指电脑联网的一个连接口，表示为（IP address，port）。一个连接表示为<br>（socket_sourse,socket_des)。</li>
<li>表示为<code>(IP_address, port)</code></li>
<li>套接字对<code>(socket source, socket destination)</code>，是一个点对点的全双工通道</li>
<li>通讯被认为是一个socket和另一个socket的连接</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>Transmission Control protocol，传输控制协议</li>
<li>是<strong>面向连接的</strong>，带有确认机制，提供流量控制</li>
<li>重传所有丢失的或出错的报文</li>
<li>提供流控制</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>User datagram protocol，用户数据报协议</li>
<li>是无连接，不使用确认的，不进行流量控制</li>
<li>直接丢弃错误报文</li>
</ul>
<h3 id="TCP的三次握手建立连接"><a href="#TCP的三次握手建立连接" class="headerlink" title="TCP的三次握手建立连接"></a>TCP的三次握手建立连接</h3><ol>
<li><p>第一次握手</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103103012579.png" alt="image-20221103103012579"></p>
<ul>
<li>服务器：执行LISTEN和ACCEPT原语，并进行被动监视</li>
<li>客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求</li>
</ul>
</li>
<li><p>第二次握手</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103103041829.png" alt="image-20221103103041829"></p>
<ul>
<li>服务器检查是否存在监视端口的服务进程<ol>
<li>如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段</li>
<li>如果存在进程，则决定拒绝或接受请求</li>
<li>如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段</li>
</ol>
</li>
</ul>
</li>
<li><p>第三次握手</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103103131647.png" alt="image-20221103103131647"></p>
<ul>
<li>客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接</li>
<li>为了避免出现延时之类的情况（如果只有两次会浪费服务器资源）</li>
</ul>
</li>
<li><p>通知上层应用，准备数据传输</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103103729224.png" alt="image-20221103103729224"></p>
<ul>
<li>服务器收到确认后，会通知上层应用程序</li>
</ul>
</li>
<li><p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103103808686.png" alt="image-20221103103808686"></p>
<ul>
<li>默认三次握手就认为可靠了，之后就进行数据传输</li>
<li>有时候我们会选择，第三次握手的时候同时携带数据。</li>
</ul>
</li>
</ol>
<h3 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h3><ul>
<li>Automatic Repeat reQuest，自动重传请求：是一种在OSI模型中数据链路层和传输层使用的错误纠正协议</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103105733830.png" alt="image-20221103105733830" style="zoom:80%;float:left" /></li>
</ul>
<h3 id="TCP的四次握手释放连接"><a href="#TCP的四次握手释放连接" class="headerlink" title="TCP的四次握手释放连接"></a>TCP的四次握手释放连接</h3><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221103112339199.png" alt="image-20221103112339199" style="zoom:80%;float:left" />

<ul>
<li>第一次：客户端 → 服务器， FIN &#x3D; 1</li>
<li>第二次：服务器 → 客户端， ACK &#x3D; 1</li>
<li>第三次：服务器 → 客户端， FIN &#x3D; 1， ACK &#x3D; 1</li>
<li>第四次：客户端 → 服务器， ACK &#x3D; 1</li>
</ul>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul>
<li>network address translation，网络地址转换</li>
<li>是在IP数据包头中将一个地址交换为另一地址的过程，允许了私有地址（192.168.……）访问因特网，是IP地址耗尽的解决方法之一</li>
<li>需要一个路由器：通过NAT表将局部地址与网络上的地址进行双向转换</li>
<li>静态与动态<ul>
<li>静态NAT表一开始将内部地址与注册地址写死</li>
<li>动态NAT以先到先得的方式动态进行</li>
</ul>
</li>
<li>可以使用少量全局唯一地址池服务大量私有寻址主机，但仍然是一一映射，同时接入有限</li>
</ul>
<h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><ul>
<li>port address translation，端口地址转换</li>
<li>采用端口多路复用方式，内部网络的所有主机均可共享一个合法外部 IP 地址实现对 Internet 的访问，从而可以最大限度地节约 IP 地址资源。</li>
<li>同时，又可隐藏网络内部的所有主机，有效避免来自 internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式</li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/28.png" alt="img" style="zoom:40%;float:left" /></li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><ul>
<li>（Open System Interconnect），开放式系统互连。</li>
</ul>
<h3 id="FCS"><a href="#FCS" class="headerlink" title="FCS"></a>FCS</h3><ul>
<li>FCS（Frame Check Sequence）帧检测序列，俗称帧尾。</li>
<li>在MAC最后4字节，采用是循环冗余校验（CRC）</li>
</ul>
<h3 id="flow-control"><a href="#flow-control" class="headerlink" title="flow control"></a>flow control</h3><ul>
<li>流控制，对数据的传输进行控制、检查，发现出错后的处理</li>
</ul>
<h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><ul>
<li>Reverse Address Resolution Protocol，反向地址解析协议</li>
<li>发出要反向解析的MAC地址并希望返回其对应的IP地址</li>
</ul>
<h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><ul>
<li>Classless Inter-Domain Routing，无类域间路由</li>
<li>消除了传统ABC类地址以及划分子网的概念，可以将多个IP网络结合在一起，减少路由表中条目</li>
<li>可以更有效的分配IPv4地址</li>
<li>CIDR与路由汇总两者的功能的都是为了减少路由条目，将多个网络汇总为一个路由条目，但路由汇总一般是在主类网络的边界内进行,而CIDR可以合并多个网络,CIDR没有类的的概念,它是个纯数字概念。</li>
<li>CIDR记法：在IPv4地址后面加斜杠，斜杠后跟网络前缀的位数。即：192.168.1.0 &#x2F; 24.这就是SIDR记法</li>
<li>可读作“side r”</li>
<li>与之相关的还有VLSM，路由聚集</li>
</ul>
<h3 id="split-horizon"><a href="#split-horizon" class="headerlink" title="split horizon"></a>split horizon</h3><ul>
<li>水平分割，避免Routing loops环路问题的方法之一，指从某个端口收到的报文信息，不能再从该端口发送回去。但如果告知一条更好的到达路径，是会接受的</li>
</ul>
<h3 id="Routing-Poisioning"><a href="#Routing-Poisioning" class="headerlink" title="Routing Poisioning"></a>Routing Poisioning</h3><ul>
<li>路由毒化，避免Routing loops环路的方法之一。如果不可达，则将条目置为16（大于最大跳数）跳到达，而非删除条目，之后在讲信息公布出去，使相邻路由器得知这条路由无效</li>
<li>与之相关还有Hold-Down Timers</li>
<li>详细：</li>
<li>路由中毒(Route Poisoning)<ol>
<li>当网络5发生故障时，路由器E通过将网络5的表条目设置为<strong>16或不可访问</strong>来启动路由中毒。(而不是删除条目)</li>
<li>、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。</li>
<li>最终所有的路由器都知道不可达</li>
<li>路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了</li>
</ol>
</li>
</ul>
<h3 id="Hold-Down-Timers"><a href="#Hold-Down-Timers" class="headerlink" title="Hold-Down Timers"></a>Hold-Down Timers</h3><ul>
<li>抑制定时器，一条路由信息无效后，一段时间内该路由处于抑制状态（不接收关于同一目的地址的路由更新），计时结束后一起删除该条目</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul>
<li>domain name system，域名系统。</li>
<li>是因特网上作为域名和IP地址相互映射的一个分布式<strong>数据库</strong>。</li>
<li>分为三级域名、二级域名和顶级域名。通过DNS服务器将域名转换为IP地址，然后访问</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HyperText Transfer Protocol，超文本传输协议，面向事务的无状态、无连接客户服务器协议</li>
<li>“超文本”意味着更为丰富的内容</li>
<li>和电视播放相似，通过浏览器界面显示内容，通过URL（统一资源定位符）进行切换</li>
</ul>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><ul>
<li>Uniform resource Locator，统一资源定位符，是对可以从因特网上得到的资源位置和访问方式的一种简洁表示。相当于一个文件名在网络范围的扩展<code>&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></li>
</ul>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>Hyper Text Markup Language，超文本标记语言，定义了许多用于排版的命令，浏览器针对HTML文档中的各种标签，根据显示器尺寸与分辨率，重新排版并恢复所读取页面</li>
</ul>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><ul>
<li>File Transfer Protocol，基于TCP实现的可靠的面向连接的文件传输服务</li>
</ul>
<h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><p>（Trivial File Transfer Protocol,简单<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/0?fromModule=lemma_inlink">文件传输协议</a>）是TCP&#x2F;IP协议族中的一个用来在客户机与<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/0?fromModule=lemma_inlink">服务器</a>之间进行简单文件传输的协议，提供不复杂、开销不大的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1/5389842?fromModule=lemma_inlink">文件传输服务</a>。<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658?fromModule=lemma_inlink">端口号</a>为69。</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><ul>
<li>simple mail transfer protocol，简单邮件传输协议，进行连接、登陆与发送邮件等操作</li>
</ul>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><ul>
<li>dynamic host configuration protocol，动态主机配置协议。基于UDP实现的，可以高效分配IP地址</li>
<li>过程：<ol>
<li>AB是两个Server</li>
<li>Client先Discover去搜索</li>
<li>Server返回一个Offer报文</li>
<li>Client选择优先返回的Offer来优先服务</li>
<li>Client进行广播，告知到底服务了谁</li>
<li>然后B返回一个Ack报文</li>
<li>到了时间之后，选择release或者续租</li>
<li>AB的信息不对称不同步(局域网的地址B分配完成了但是A不知道，广播里面会携带分配的地址信息，告知A进行同步)</li>
</ol>
</li>
</ul>
<h3 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h3><ul>
<li>spanning tree protocol，生成树协议，该协议可应用于在网络中建立树形拓扑，消除网络中的环路，并且可以通过一定的方法实现路径冗余，但不是一定可以实现路径冗余</li>
</ul>
<h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><ul>
<li>point-to-point protocol，点对点协议。是一种标准的串行线路封装方式</li>
<li>由IETF开发，用来替代SLIP，能在连接建立时检查链路质量，通过PAP（密码验证协议）和CHAP（询问握手验证协议）提供认证<ul>
<li>PAP（<strong>Password Authentication Protocol</strong>）：一方向另一方发送请求，另一方选择是否接受，双方有相同用户名和密码，发送方可多次尝试；密码明文发送</li>
<li>CHAP（Challenge Handshake Authentication Protocol）：链路建立阶段结束之后，认证者向对端点发送“challenge”消息；对端点用经过单向哈希函数计算出来的值做应答；认证者根据它自己计算的哈希值来检查应答，如果值匹配，认证得到承认，否则连接应该终止；避免明文发送，密码密文发送比较安全，而且更加合理的设计</li>
</ul>
</li>
<li>PPP会话的建立：<ul>
<li>链接建立和配置协商（每个PPP设备发送LCP数据包）</li>
<li>链接质量测试</li>
<li>网络层协议配置（PPP设备发送NCP数据包来选择和配置网络层协议）</li>
<li>链接终止（可以随时终止，并通知网络层协议）</li>
</ul>
</li>
</ul>
<h3 id="ISDN"><a href="#ISDN" class="headerlink" title="ISDN"></a>ISDN</h3><ul>
<li>Integrated Service Digital Networks，综合服务数字网络，允许现有电话线传输数字信号，提供远程端点的连接。<ul>
<li><strong>ISDN BRI （Basic Rate Interface）端口</strong>用于 ISDN 线路通过路由器实现与 Internet 或其他远程网络的连接。<ul>
<li>ISDN BRI 的三个通道总带宽为 144 kbps<ul>
<li>其中两个通道称为B（荷载 Bearer）通道，速率为 64 kbps，用于承载声音、影像和数据通信</li>
<li>第三个通道是D（数据）通道，是16 kbps 信号通道，用于告诉公用交换电话网如何处理每个B通道</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><ul>
<li>Asymmetric Digital Subscriber Line，非对称数字用户线路。</li>
<li>xDSL是对模拟电话数据线进行改造，使其能承受宽带业务。ADSL——非对称用户数字线，上行（用户到ISP）和下行（ISP到用户）带宽不对等</li>
<li>意义：使用户可以使用模拟电话线承受宽带业务</li>
</ul>
<h3 id="VLAN-1"><a href="#VLAN-1" class="headerlink" title="VLAN"></a>VLAN</h3><ul>
<li>virtual LAN，虚拟局域网络，进行逻辑的网络设备或用户分组，来产生单一的广播域</li>
</ul>
<h3 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h3><ul>
<li>病毒，编制或者在计算机程序中插入的<strong>破坏计算机功能</strong>或者<strong>破坏数据</strong>，影响计算机使用并且能够<strong>自我复制</strong>的一组计算机指令或者程序代码</li>
<li>与之相关的还有<ul>
<li>计算机蠕虫（通过网络通信将自身从一节点发送到另一节点并启动）</li>
<li>特洛伊木马（权限比声明高）</li>
<li>逻辑炸弹（特定条件触发特殊功能）</li>
</ul>
</li>
</ul>
<h3 id="SMTP和POP3-1"><a href="#SMTP和POP3-1" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3><ol>
<li>电子邮件服务器使用SMTP发送和POP接收邮件相互通信。<ol>
<li>SMTP (Simple Mail Transfer Protocol) SMTP(简单邮件传输协议)邮件发送，登录发送等操作</li>
<li>POP3 (Post Office Protocol version 3) 邮局协议版本3，邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125163103685.png" alt="image-20241125163103685"></li>
</ol>
</li>
</ol>
<h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><ol>
<li>Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型</li>
<li>MIME标准扩充了SMTP标准</li>
<li>很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如下图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241125163325803.png" alt="image-20241125163325803"></li>
</ol>
<h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><ol>
<li>简单网络管理协议(SNMP，Simple Network Management Protocol)是一种应用程序层协议，可简化网络设备之间的管理信息交换。</li>
<li>NMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)</li>
<li>通过管理数据库(MIB)进行信息交流</li>
<li>使用UDP通过广播进行实现。</li>
</ol>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>组管理协议称为<em>IGMP</em>协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</p>
<h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><ul>
<li>防火墙，是由硬件和软件构成的系统，是一种特殊编程的路由器，用于两个网络之间实施接入控制策略</li>
</ul>
<h3 id="ACL-1"><a href="#ACL-1" class="headerlink" title="ACL"></a>ACL</h3><ul>
<li>access control list，访问控制列表，一些告诉路由哪些包该拒绝那些包能通过的序列集</li>
<li>标准ACL放置在目的地路由（1-99以及1300-1999）；扩展ACL放在离江北拒绝数据流信源尽可能近的地方</li>
</ul>
<h3 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h3><ul>
<li>Link-State Advertisement，链路状态通告。</li>
<li>是链接状态协议使用的一个分组，它包括有关邻居和通道成本的信息。</li>
</ul>
<h1 id="笔记-·-计网各类数据格式"><a href="#笔记-·-计网各类数据格式" class="headerlink" title="笔记 · 计网各类数据格式"></a>笔记 · 计网各类数据格式</h1><h2 id="一、以太网的MAC帧结构（数据链路层MAC子层）"><a href="#一、以太网的MAC帧结构（数据链路层MAC子层）" class="headerlink" title="一、以太网的MAC帧结构（数据链路层MAC子层）"></a>一、以太网的MAC帧结构（数据链路层MAC子层）</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241213104901790.png" alt="image-20241213104901790"></p>
<h3 id="1-1-preamble-前导码（8字节）"><a href="#1-1-preamble-前导码（8字节）" class="headerlink" title="1.1 preamble 前导码（8字节）"></a>1.1 preamble 前导码（8字节）</h3><ul>
<li>固定为（7 * “10101010” + “10101011”）</li>
<li>告知接受方有帧来了（缓冲作用）</li>
</ul>
<h3 id="1-2-Dest-add-Source-add-目标和源物理地址（各6字节）"><a href="#1-2-Dest-add-Source-add-目标和源物理地址（各6字节）" class="headerlink" title="1.2 Dest add &amp; Source add 目标和源物理地址（各6字节）"></a>1.2 Dest add &amp; Source add 目标和源物理地址（各6字节）</h3><ul>
<li><strong>先放目的地址</strong>，目的地址可以是单播、组播、广播地址</li>
</ul>
<h3 id="1-3-Length-长度（2字节）"><a href="#1-3-Length-长度（2字节）" class="headerlink" title="1.3 Length 长度（2字节）"></a>1.3 Length 长度（2字节）</h3><ul>
<li>早期以太网标准：整个帧的长度</li>
<li>以太网二代标准：曼彻斯特编码（有信号的时候有电平）使得接收方可以确定长度，所以这两个字节使用“Type”，标明后面的数据是哪个协议的要求</li>
</ul>
<h3 id="1-4-Data数据"><a href="#1-4-Data数据" class="headerlink" title="1.4 Data数据"></a>1.4 Data数据</h3><h3 id="1-5-FCS（4字节）"><a href="#1-5-FCS（4字节）" class="headerlink" title="1.5 FCS（4字节）"></a>1.5 FCS（4字节）</h3><ul>
<li>frame check sequence，帧校验序列，用于循环冗余校验</li>
</ul>
<hr>
<h2 id="二、无线局域网的MAC帧结构"><a href="#二、无线局域网的MAC帧结构" class="headerlink" title="二、无线局域网的MAC帧结构"></a>二、无线局域网的MAC帧结构</h2><ul>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241223152723312.png" alt="image-20241223152723312">ad hoc(无基础设施)用地址4，有基础设施用的是地址1、2、3</p>
</li>
<li><p>例子</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241223152748588.png" alt="image-20241223152748588"></p>
</li>
</ul>
<hr>
<h2 id="三、IPv4报文格式（网络层）"><a href="#三、IPv4报文格式（网络层）" class="headerlink" title="三、IPv4报文格式（网络层）"></a>三、IPv4报文格式（网络层）</h2><p>报文结构：注意这里的单位是bit，不是字节![屏幕截图 2024-10-18 024313](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-18 024313.png)</p>
<ul>
<li>首部部分分为固定部分和可变长部分，下主要讨论首部</li>
<li>首部每4个字节（32bit）为一行，最大值为60字节，即15行</li>
</ul>
<h3 id="3-1-版本号（4bit）"><a href="#3-1-版本号（4bit）" class="headerlink" title="3.1 版本号（4bit）"></a>3.1 版本号（4bit）</h3><ul>
<li>值IP协议的版本号，目前IP协议版本号为4，即IPv4</li>
</ul>
<h3 id="3-2-首部长度（4bit）"><a href="#3-2-首部长度（4bit）" class="headerlink" title="3.2 首部长度（4bit）"></a>3.2 首部长度（4bit）</h3><ul>
<li>4位：0~15，每单位为4字节，所以一次IP的首部长度最大为60字节</li>
<li>首部长不定，所以需要标识</li>
</ul>
<h3 id="3-3-服务类型（8bit）"><a href="#3-3-服务类型（8bit）" class="headerlink" title="3.3 服务类型（8bit）"></a>3.3 服务类型（8bit）</h3><ul>
<li>现在用于区分服务</li>
</ul>
<h3 id="3-4-总长度（16bit）"><a href="#3-4-总长度（16bit）" class="headerlink" title="3.4 总长度（16bit）"></a>3.4 总长度（16bit）</h3><ul>
<li>指首部和数据部分的长度之和</li>
</ul>
<h3 id="3-5-标识（16bit）"><a href="#3-5-标识（16bit）" class="headerlink" title="3.5 标识（16bit）"></a>3.5 标识（16bit）</h3><ul>
<li>计数器，用于做报文分片，接受方依据此合并报文</li>
</ul>
<h3 id="3-6-标志（3bit）"><a href="#3-6-标志（3bit）" class="headerlink" title="3.6 标志（3bit）"></a>3.6 标志（3bit）</h3><ul>
<li>最高位为0</li>
<li>DF（Don’t fragement？）：是否允许做分片，0允许做分片，1不允许做分片</li>
<li>MF（More fragment？）：MF为0表示最后一个分片,1是指后面还有分片</li>
</ul>
<h3 id="3-7-片偏移（13bit）"><a href="#3-7-片偏移（13bit）" class="headerlink" title="3.7 片偏移（13bit）"></a>3.7 片偏移（13bit）</h3><ul>
<li>相同标识号的报文，根据片偏移进行重排，偏移小的靠前</li>
<li>偏移以字节为单位</li>
</ul>
<h3 id="3-8-生存时间（8bit）"><a href="#3-8-生存时间（8bit）" class="headerlink" title="3.8 生存时间（8bit）"></a>3.8 生存时间（8bit）</h3><ul>
<li>记为TTL（time to live），标识可通过路由器的最大值</li>
<li>路由器每转发一次，就会对TTL-1，小于0则丢弃并告知发送方</li>
<li>避免回路问题</li>
</ul>
<h3 id="3-9-协议（8bit）"><a href="#3-9-协议（8bit）" class="headerlink" title="3.9 协议（8bit）"></a>3.9 协议（8bit）</h3><ul>
<li>指出此数据报携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个处理过程</li>
</ul>
<h3 id="3-10-首部检验和（16bit）"><a href="#3-10-首部检验和（16bit）" class="headerlink" title="3.10 首部检验和（16bit）"></a>3.10 首部检验和（16bit）</h3><ul>
<li>只检验首部</li>
</ul>
<h3 id="3-11-源地址与目的地址（各4字节）"><a href="#3-11-源地址与目的地址（各4字节）" class="headerlink" title="3.11  源地址与目的地址（各4字节）"></a>3.11  源地址与目的地址（各4字节）</h3><hr>
<h2 id="四、TCP数据段格式"><a href="#四、TCP数据段格式" class="headerlink" title="四、TCP数据段格式"></a>四、TCP数据段格式<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241111172358408.png" alt="image-20241111172358408"></h2><ul>
<li>一行共计4个字节，段首在前，固定首部长度为20字节</li>
</ul>
<h3 id="4-1-源端口和目的端口（2字节）"><a href="#4-1-源端口和目的端口（2字节）" class="headerlink" title="4.1 源端口和目的端口（2字节）"></a>4.1 源端口和目的端口（2字节）</h3><ul>
<li>端口是运输层与应用层的服务接口</li>
<li>运输层的复用和分用功能都要通过端口才能实现</li>
</ul>
<h3 id="4-2-序号（4字节）"><a href="#4-2-序号（4字节）" class="headerlink" title="4.2 序号（4字节）"></a>4.2 序号（4字节）</h3><ul>
<li>TCP 传送的数据流中的<strong>每一个字节都编上一个序号</strong></li>
<li>序号字段的值指本报文段所发送的数据的第一个字节的<strong>序号</strong></li>
<li>通过序号字段做可靠传输的保证，指示的是一个<strong>TCP传输的bit编码</strong>，而不是地址。</li>
<li>我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。</li>
</ul>
<h3 id="4-3-确认号（4字节）"><a href="#4-3-确认号（4字节）" class="headerlink" title="4.3 确认号（4字节）"></a>4.3 确认号（4字节）</h3><ul>
<li>是期望收到对方的下一个报文段的数据的第一个字节的序号</li>
<li>确认对方的数据号(发送同时对上一次传输进行确认)</li>
<li><strong>体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701</strong></li>
</ul>
<h3 id="4-4-数据偏移（4位）"><a href="#4-4-数据偏移（4位）" class="headerlink" title="4.4 数据偏移（4位）"></a>4.4 数据偏移（4位）</h3><ul>
<li>指出TCP报文段的数据起始处距TCP报文段的起始处的长度（Data部分从什么地方开始算）</li>
<li>单位是32位字（以4字节为计算单位）</li>
<li>不满足的话使用填充位保证为4字节的整数倍（保证对齐问题）</li>
</ul>
<h3 id="4-5-保留字段（6位）"><a href="#4-5-保留字段（6位）" class="headerlink" title="4.5 保留字段（6位）"></a>4.5 保留字段（6位）</h3><ul>
<li>保留为今后使用，目前置 0，说截止到现在也没有使用这部分的字段</li>
</ul>
<h3 id="4-6-URG（urgent）"><a href="#4-6-URG（urgent）" class="headerlink" title="4.6 URG（urgent）"></a>4.6 URG（urgent）</h3><ul>
<li>紧急 URG &#x3D; 1时，表明紧急指针字段有效</li>
<li>告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）</li>
</ul>
<h3 id="4-7-ACK（acknowledge）"><a href="#4-7-ACK（acknowledge）" class="headerlink" title="4.7 ACK（acknowledge）"></a>4.7 ACK（acknowledge）</h3><ul>
<li>ACK &#x3D; 1 时确认号字段有效</li>
<li>ACK &#x3D; 0 时确认号字段无效</li>
<li>正常连接以后一般都置1</li>
</ul>
<h3 id="4-8-PSH（push）"><a href="#4-8-PSH（push）" class="headerlink" title="4.8 PSH（push）"></a>4.8 PSH（push）</h3><ul>
<li>推送PSH（PuSH）——接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将<strong>缓存所有部分</strong>都传输，而并不是只将这个报文段的信息进行传输。</li>
<li>TCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送</li>
</ul>
<h3 id="4-9-RST（ReSeT）"><a href="#4-9-RST（ReSeT）" class="headerlink" title="4.9 RST（ReSeT）"></a>4.9 RST（ReSeT）</h3><ul>
<li>ReSeT &#x3D; 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</li>
<li>就是重新来过，如果请求方发送的请求，如果应答方不想连接则将ReSet置为1</li>
</ul>
<h3 id="4-10-SYN（synchronize）"><a href="#4-10-SYN（synchronize）" class="headerlink" title="4.10 SYN（synchronize）"></a>4.10 SYN（synchronize）</h3><ul>
<li>同步 SYN &#x3D; 1:表示这是一个连接请求或连接接受报文（初始的时候才出现）</li>
</ul>
<h3 id="4-11-FIN（FINis）"><a href="#4-11-FIN（FINis）" class="headerlink" title="4.11 FIN（FINis）"></a>4.11 FIN（FINis）</h3><ul>
<li>用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了)</li>
</ul>
<h3 id="4-12-窗口（2字节）"><a href="#4-12-窗口（2字节）" class="headerlink" title="4.12 窗口（2字节）"></a>4.12 窗口（2字节）</h3><ul>
<li><p>用来让对方设置<strong>发送窗口</strong>的依据，单位为字节。</p>
</li>
<li><p>表示可以进行传输的窗口大小是多少。</p>
</li>
<li><p>（告诉接收方最多能发给我多长的数据）</p>
</li>
</ul>
<h3 id="4-13-检验和（2字节）"><a href="#4-13-检验和（2字节）" class="headerlink" title="4.13 检验和（2字节）"></a>4.13 检验和（2字节）</h3><ul>
<li>检验和字段检验的范围包括<strong>首部和数据</strong>这两部分</li>
<li>IP报文中的地址等伪首部进行校验</li>
</ul>
<h3 id="4-14-紧急指针（2字节）"><a href="#4-14-紧急指针（2字节）" class="headerlink" title="4.14 紧急指针（2字节）"></a>4.14 紧急指针（2字节）</h3><ul>
<li>指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)</li>
</ul>
<h3 id="4-15-选项（长度可变）"><a href="#4-15-选项（长度可变）" class="headerlink" title="4.15 选项（长度可变）"></a>4.15 选项（长度可变）</h3><ul>
<li>TCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)</li>
<li>MSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节</li>
<li>数据字段加上 TCP 首部才等于整个的 TCP 报文段</li>
</ul>
<h3 id="4-16-填充字段"><a href="#4-16-填充字段" class="headerlink" title="4.16 填充字段"></a>4.16 填充字段</h3><ul>
<li>为使整个首部长度是4字节的整数倍</li>
</ul>
<h2 id="五、UDP数据段格式"><a href="#五、UDP数据段格式" class="headerlink" title="五、UDP数据段格式"></a>五、UDP数据段格式</h2><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec05/23.png" alt="img" style="zoom:50%;float:left" />

<ul>
<li>8字节首部</li>
<li>源端口、目的端口、长度、校验(data)、Data</li>
<li>校验也要<strong>对data一并校验</strong>，如果出现错误，直接丢弃。<ul>
<li>计算检验和时，添加12位的伪首部（伪首部既不下传也不向上递交）</li>
<li>伪首部包含源和目的的IP地址，表示UDP类型的字节、长度</li>
</ul>
</li>
<li>怎么判断是客户端发的还是服务端发的：<ul>
<li>看端口号的大小，0-255是保留的一般是服务端</li>
</ul>
</li>
</ul>
<h2 id="六、PPP帧格式"><a href="#六、PPP帧格式" class="headerlink" title="六、PPP帧格式"></a>六、PPP帧格式</h2><p>PPP帧格式<a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/10.jpg"><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec10/10.jpg" alt="img"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250101172916567.png" alt="image-20250101172916567"></a></p>
<blockquote>
<p>数字的单位是字节</p>
</blockquote>
<ol>
<li>Flag: 01111110，0x7E 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧</li>
<li>Address：11111111, 0xFF，广播地址</li>
<li>Control：00000011, 0x03，用户数据作为无序帧传输</li>
<li>Protocol: 数据字段中的协议类型</li>
<li>Data: 数据报，最大默认值为1500字节</li>
<li>FCS: 2或者4字节，循环冗余校验位</li>
</ol>
<h1 id="笔记-·-错题本"><a href="#笔记-·-错题本" class="headerlink" title="笔记 · 错题本"></a>笔记 · 错题本</h1><ol>
<li><p>三种交换方式</p>
<ol>
<li>电路交换<ol>
<li>电话交换机接通电话线的方式就是电路交换</li>
<li>交换就是按照某种方式动态的分配传输线路资源</li>
<li>电路交换的三个步骤<ol>
<li>建立连接（分配通信资源）</li>
<li>通话（一直占用通信资源）</li>
<li>释放链接（归还通信资源）</li>
</ol>
</li>
<li>缺点：当使用电路交换来传送计算机数据时，效率很低</li>
</ol>
</li>
<li>分组交换</li>
<li>报文交换</li>
</ol>
</li>
<li><p>在STP中，10Mbps对应的cost为100</p>
</li>
<li><p>socket套接字：可以看做是网络通讯的接口，是应用层与TCP&#x2F;IP协议簇的中间层，允许两台设备之间通讯。常见的协议有TCP，UDP。</p>
</li>
<li><p>三次握手，要注意每次发送的报文的关键位<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241209214836387.png" alt="image-20241209214836387"></p>
</li>
<li><p>常见的使用TCP的协议：</p>
<ol>
<li><strong>HTTP</strong>（超文本传输协议）</li>
<li><strong>HTTPS</strong>（安全的HTTP）</li>
<li><strong>FTP</strong>（文件传输协议）</li>
<li><strong>SMTP</strong>（简单邮件传输协议）</li>
<li><strong>POP3</strong>（邮局协议版本3）</li>
<li><strong>Telnet</strong>（远程登录协议）</li>
</ol>
</li>
<li><p>常见使用 <strong>UDP</strong> 的协议：</p>
<ol>
<li><strong>DNS</strong>（域名系统）</li>
<li><strong>DHCP</strong>（动态主机配置协议）</li>
<li><strong>TFTP</strong>（简易文件传输协议）</li>
<li><strong>SNMP</strong>（简单网络管理协议）</li>
</ol>
</li>
</ol>
<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><ol>
<li><p>当用户在浏览器中首次输入网址并请求显示主页时，浏览器会经历一系列的步骤以获取并显示该页面。以下是简要描述这个过程的8个主要步骤：</p>
<ol>
<li><h3 id="1-域名解析-DNS-查询-："><a href="#1-域名解析-DNS-查询-：" class="headerlink" title="1. 域名解析 (DNS 查询)："></a>1. <strong>域名解析 (DNS 查询)</strong>：</h3><ul>
<li>用户输入的网址（例如 <code>www.example.com</code>）是一个域名，需要解析为服务器的 IP 地址。</li>
<li>浏览器首先检查本地 DNS 缓存中是否已有该域名的 IP 地址。如果没有，它会向配置的 DNS 服务器发送查询请求，询问该域名对应的 IP 地址。</li>
<li>DNS 服务器返回相应的 IP 地址，浏览器使用这个地址来与目标服务器建立连接。</li>
</ul>
<h3 id="2-建立-TCP-连接-三次握手-："><a href="#2-建立-TCP-连接-三次握手-：" class="headerlink" title="2. 建立 TCP 连接 (三次握手)："></a>2. <strong>建立 TCP 连接 (三次握手)</strong>：</h3><ul>
<li>使用获得的 IP 地址，浏览器通过 TCP 协议与目标服务器建立连接。为了确保可靠性，TCP 使用三次握手过程：<ol>
<li>浏览器发送一个 SYN 请求，表示希望建立连接。</li>
<li>服务器收到 SYN 请求后，发送 SYN-ACK 响应，表示同意建立连接。</li>
<li>浏览器收到 SYN-ACK 后，发送 ACK 响应，连接建立成功。</li>
</ol>
</li>
</ul>
<h3 id="3-发送-HTTP-请求："><a href="#3-发送-HTTP-请求：" class="headerlink" title="3. 发送 HTTP 请求："></a>3. <strong>发送 HTTP 请求</strong>：</h3><ul>
<li>一旦 TCP 连接建立，浏览器通过 HTTP 协议向服务器发送请求，通常是一个 GET 请求，要求获取主页内容（如 <code>GET / HTTP/1.1</code>）。</li>
<li>请求中包括一些头信息（如浏览器类型、语言偏好、缓存控制等）以及可能的 Cookies 信息。</li>
</ul>
<h3 id="4-服务器处理请求："><a href="#4-服务器处理请求：" class="headerlink" title="4. 服务器处理请求："></a>4. <strong>服务器处理请求</strong>：</h3><ul>
<li>服务器接收到请求后，处理请求并生成响应。这可能包括：<ol>
<li>查找请求的网页文件（例如 HTML 文件）。</li>
<li>运行服务器端代码（如 PHP、Node.js 等）以动态生成网页内容。</li>
<li>查询数据库等资源，生成最终的 HTML 内容。</li>
</ol>
</li>
</ul>
<h3 id="5-服务器返回-HTTP-响应："><a href="#5-服务器返回-HTTP-响应：" class="headerlink" title="5. 服务器返回 HTTP 响应："></a>5. <strong>服务器返回 HTTP 响应</strong>：</h3><ul>
<li>服务器将生成的网页内容封装在 HTTP 响应中返回给浏览器。响应头包含状态码（如 200 表示成功），以及其他信息（如响应类型、内容长度等）。</li>
<li>响应体部分包含网页的 HTML 代码。</li>
</ul>
<h3 id="6-浏览器解析-HTML-内容："><a href="#6-浏览器解析-HTML-内容：" class="headerlink" title="6. 浏览器解析 HTML 内容："></a>6. <strong>浏览器解析 HTML 内容</strong>：</h3><ul>
<li>浏览器接收到 HTTP 响应后，开始解析响应体中的 HTML 内容。浏览器会根据 HTML 标签结构逐步构建页面的 DOM（文档对象模型）树。</li>
<li>同时，浏览器会解析页面中的外部资源（如 CSS 文件、JavaScript 文件、图片等）。</li>
</ul>
<h3 id="7-请求并加载外部资源："><a href="#7-请求并加载外部资源：" class="headerlink" title="7. 请求并加载外部资源："></a>7. <strong>请求并加载外部资源</strong>：</h3><ul>
<li>如果 HTML 内容中引用了外部资源（如 CSS 文件、JS 文件、图片等），浏览器会发出额外的 HTTP 请求，获取这些资源。</li>
<li>每个外部资源的加载也需要通过 TCP 连接进行传输。</li>
</ul>
<h3 id="8-页面渲染与显示："><a href="#8-页面渲染与显示：" class="headerlink" title="8. 页面渲染与显示："></a>8. <strong>页面渲染与显示</strong>：</h3><ul>
<li>当所有的资源都加载完毕，浏览器开始渲染页面。浏览器会结合 DOM 和 CSSOM（CSS对象模型）树，生成渲染树，并计算布局和样式，最后绘制到屏幕上。</li>
<li>如果页面包含 JavaScript，浏览器还会执行 JavaScript 代码，这可能会修改 DOM 和样式，进而影响页面的呈现。</li>
</ul>
</li>
</ol>
</li>
<li><p>可以从UDP帧的头部的端口号区分客户端和服务端</p>
<ol>
<li><h4 id="消息是由客户端还是服务器发送的？"><a href="#消息是由客户端还是服务器发送的？" class="headerlink" title="消息是由客户端还是服务器发送的？"></a>消息是由客户端还是服务器发送的？</h4><p>通常情况下，端口号 <code>53</code> 是用于 <strong>DNS（域名系统）服务</strong>，用于查询域名。端口号 <code>53</code> 是 DNS 服务器监听的端口号。</p>
<ul>
<li><strong>源端口号是 1586</strong>，而端口号 <code>1586</code> 通常不是 DNS 服务器的默认端口，因此可以推测消息是 <strong>由客户端发送</strong>，它向 DNS 服务器（目标端口号 <code>53</code>）发送请求。</li>
</ul>
<p>所以，消息是 <strong>由客户端发送的</strong>。</p>
</li>
<li><h4 id="消息涉及的网络服务类型？"><a href="#消息涉及的网络服务类型？" class="headerlink" title="消息涉及的网络服务类型？"></a>消息涉及的网络服务类型？</h4><p>从目标端口号 <code>53</code> 可以推断，这个消息涉及到 <strong>DNS（域名系统）服务</strong>。DNS 使用 UDP 协议，通常用于解析域名和 IP 地址之间的映射。</p>
<p>因此，<strong>消息涉及的网络服务是 DNS</strong>。</p>
</li>
</ol>
</li>
<li><p><strong>TCP&#x2F;IP模型中的网络层协议提供的是？</strong></p>
<ul>
<li><strong>答案：</strong> A. 无连接且不可靠的分组服务<br>解释：网络层（特别是IP）是无连接的且不可靠的。</li>
</ul>
</li>
<li><p><strong>以下协议不属于网络层的是？</strong></p>
<ul>
<li><strong>答案：</strong> D. DHCP<br>解释：DHCP（动态主机配置协议）属于应用层，而ICMP、IGMP和ARP都属于网络层。</li>
</ul>
</li>
<li><p><strong>哪种网络地址转换（NAT）可以使一个IP地址允许多个用户连接到全球互联网？</strong></p>
<ul>
<li><strong>答案：</strong> D. PAT<br>解释：端口地址转换（PAT）允许多个用户共享一个公共IP地址。</li>
</ul>
</li>
<li><p><strong>什么组成了一个套接字？</strong></p>
<ul>
<li><strong>答案：</strong> B. IP地址和端口号</li>
</ul>
</li>
<li><p><strong>以下哪个选项不是使用静态路由的优势？</strong></p>
<ul>
<li><strong>答案：</strong> A. 快速收敛（Fast convergence）<br>解释：静态路由的收敛速度较慢，相比动态路由，静态路由通常不会自动调整。</li>
</ul>
</li>
<li><p><strong>为什么交换机永远不会学习广播地址？</strong></p>
<ul>
<li><strong>答案：</strong> C. 广播地址永远不会是帧的源地址。<br>解释：广播地址是发送给所有主机的，而不是特定的主机，因此交换机不会学习广播地址。</li>
</ul>
</li>
<li><p><strong>哪种拓扑具有最高的可靠性？</strong></p>
<ul>
<li><strong>答案：</strong> D. 网状拓扑（  mesh topology）<br>解释：网状拓扑通过多个冗余路径提供最高的可靠性。</li>
</ul>
</li>
<li><p><strong>以下哪些陈述是正确的？</strong></p>
</li>
</ol>
<ul>
<li><strong>答案：</strong> A、B、D<br>解释：MAC地址是48位的，交换机使用MAC地址过滤流量，端口号可以在TCP段和UDP段的头部找到。</li>
</ul>
<ol start="11">
<li><p>指令ip route 172.16.3.0 255.255.255.0 192.168.2.4，注意：</p>
<ol>
<li>它建立了一条指向 172.16.3.0 网络的静态路由</li>
<li><strong>它使用默认的管理距离</strong>：静态路由的默认管理距离为 <strong>1</strong>。</li>
<li>静态路由通常具有 <strong>最小的管理距离（1）</strong>，如果有多个路由指向同一目的地，路由器会<strong>优先使用静态路由</strong>，除非有更具体的匹配。</li>
</ol>
</li>
<li><p><strong>WAN操作的OSI模型层次是哪些？</strong></p>
<ul>
<li><strong>答案：</strong> E、F<br>解释：WAN操作涉及到OSI模型的数据链路层和物理层。</li>
</ul>
</li>
<li><p><strong>以下哪些服务使用TCP协议？</strong></p>
<ul>
<li><strong>答案：</strong> B、C、E<br>解释：SMTP、HTTP和FTP使用TCP协议，而DHCP和TFTP使用UDP协议。</li>
</ul>
</li>
<li><p>一些熟知端口：</p>
<ol>
<li><p><strong>HTTP</strong></p>
<ul>
<li><strong>端口号：</strong> 80</li>
<li><strong>协议：</strong> TCP</li>
<li><strong>说明：</strong> 用于网页浏览（Hypertext Transfer Protocol）。</li>
</ul>
<p><strong>FTP（文件传输协议）</strong></p>
<ul>
<li><strong>端口号：</strong> 20（控制）&#x2F; 21（数据）</li>
<li><strong>协议：</strong> TCP</li>
<li><strong>说明：</strong> 用于文件传输（File Transfer Protocol），使用端口21来建立控制连接。</li>
</ul>
<p><strong>Telnet</strong></p>
<ul>
<li><strong>端口号：</strong> 23</li>
<li><strong>协议：</strong> TCP</li>
<li><strong>说明：</strong> 远程登录协议，用于远程访问命令行界面。</li>
</ul>
<p><strong>SMTP（简单邮件传输协议）</strong></p>
<ul>
<li><strong>端口号：</strong> 25</li>
<li><strong>协议：</strong> TCP</li>
<li><strong>说明：</strong> 用于发送电子邮件（Simple Mail Transfer Protocol）。</li>
</ul>
<p><strong>DNS（域名系统）</strong></p>
<ul>
<li><strong>端口号：</strong> 53</li>
<li><strong>协议：</strong> TCP&#x2F;UDP</li>
<li><strong>说明：</strong> 用于解析域名到IP地址。</li>
</ul>
<p><strong>DHCP（动态主机配置协议）</strong></p>
<ul>
<li><strong>端口号：</strong> 67（服务器端） &#x2F; 68（客户端）</li>
<li><strong>协议：</strong> UDP</li>
<li><strong>说明：</strong> 用于动态分配IP地址给客户端。</li>
</ul>
<p><strong>TFTP（简单文件传输协议）</strong></p>
<ul>
<li><strong>端口号：</strong> 69</li>
<li>**协议：**UDP</li>
<li><strong>说明：</strong> 提供简单的无连接的文件传输服务</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><ol>
<li>IPv4为32位，IPv6为128 位。</li>
<li>socket的结构不单单只有IP地址和port端口。</li>
<li>热点名词解释：<ol>
<li>PPP：<ol>
<li>点对点协议</li>
<li>PPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法。</li>
<li>通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证。</li>
</ol>
</li>
<li>CSMA&#x2F;CD：<ol>
<li>带有冲突检测的载波侦听多路存取</li>
<li>用于有线网络</li>
<li>在主机发送数据前会检测总线是否有数据正在传输，若有则等一段时间后再来</li>
</ol>
</li>
<li>SMTP<ol>
<li>简单邮件传输协议</li>
<li>负责邮件发送，将邮件从发送方传输到接收方的邮件服务器</li>
</ol>
</li>
<li>CHAP<ol>
<li>挑战握手认证协议</li>
<li>通过三次握手周期性的校验对端的身份，在初始链路建立时完成，可以在链路建立之后的任何时候重复进行</li>
</ol>
</li>
<li>ICMP<ol>
<li>因特网控制报文协议</li>
<li>用于在IP主机、路由器之间传递控制消息。</li>
<li>为了提高 IP 数据报交付成功的机会，允许主机或路由器报告差错情况和提供有关异常情况的报告</li>
</ol>
</li>
<li>TDM<ol>
<li>时分复用</li>
<li>将时间等分为时分复用帧，每个用户在每个TDM帧中占用固定序号的时隙。</li>
<li>每个用户所占用的时隙周期性出现</li>
<li>所有用户在不同时间占用同样的频带宽度</li>
</ol>
</li>
<li>ARP<ol>
<li>地址解析协议</li>
<li>根据IP地址信息来获取MAC地址</li>
</ol>
</li>
<li>HTTP<ol>
<li>超文本传输协议</li>
<li>HTTP 是面向事务的客户服务器协议。</li>
<li>它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</li>
</ol>
</li>
<li>HTML<ol>
<li>超文本标记语言</li>
<li>定义了许多用于排版的命令，浏览器针对HTML文档中的各种标签，根据显示器尺寸与分辨率，重新排版并恢复所读取页面</li>
</ol>
</li>
<li>CIDR<ol>
<li>无类域间路由</li>
<li>消除了传统ABC类地址以及划分子网的概念，可以将多个IP网络结合在一起，减少路由表中条目</li>
<li>可以更有效的分配IPv4地址</li>
</ol>
</li>
<li>ISP<ol>
<li>网络服务供应商</li>
<li>ISP从因特网管理机构申请多个IP地址、通信线路和路由器等设备。机构或个人通过ISP接入因特网。</li>
<li>ISP分为三层，在低层ISP可以解决的问题不会进入上层ISP，以此来进行流量分流</li>
</ol>
</li>
<li>URL<ol>
<li>统一资源定位符</li>
<li>是因特网的万维网服务程序上用于指定信息位置的表示方法。</li>
</ol>
</li>
<li>MAC<ol>
<li>介质访问控制</li>
<li>MAC子层负责决定哪一个设备可以在共享的通信介质（例如以太网或Wi-Fi）上发送数据。</li>
</ol>
</li>
</ol>
</li>
<li>RIP表的更新</li>
<li>描述通过透明网关访问 Web 站点的过程（以太网环境），也就是ARP或者RARP的过程。<ol>
<li>PC给路由器，路由器转发。</li>
<li>注意，不同的帧的目的和源IP、MAC不一样</li>
<li>未知的MAC用广播：FF;FF;FF;FF;FF;FF</li>
</ol>
</li>
</ol>
<h2 id="2010年"><a href="#2010年" class="headerlink" title="2010年***"></a>2010年***</h2><ol>
<li><p>OSI各层协议：详见名词解释</p>
</li>
<li><p>Router和Switch</p>
<ol>
<li>Router的组成部分，启动过程</li>
<li>Switch</li>
</ol>
</li>
<li><p>routing and routed：记住IP是routed，（包括IPv4，IPv6，IPX），其他都是routing</p>
</li>
<li><p>802.11a, 802.11b, 802.3</p>
<ol>
<li><h3 id="802-11a"><a href="#802-11a" class="headerlink" title="802.11a"></a><strong>802.11a</strong></h3><ul>
<li><p><strong>类型</strong>: 无线局域网 (WLAN) 标准</p>
</li>
<li><p><strong>频段</strong>: 5 GHz</p>
</li>
<li><p><strong>最大速率</strong>: 54 Mbps</p>
</li>
<li><p><strong>信道带宽</strong>: 20 MHz</p>
</li>
<li><p>特点</p>
<p>:</p>
<ul>
<li>使用 5 GHz 频段，干扰较少，但穿透能力较弱。</li>
<li>适用于对速度要求较高、干扰较少的环境。</li>
<li>信号范围较短，适合小型室内环境。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-802-11b"><a href="#2-802-11b" class="headerlink" title="2. 802.11b"></a><strong>2. 802.11b</strong></h3><ul>
<li><strong>类型</strong>: 无线局域网 (WLAN) 标准</li>
<li><strong>频段</strong>: 2.4 GHz</li>
<li><strong>最大速率</strong>: 11 Mbps</li>
<li><strong>信道带宽</strong>: 22 MHz</li>
<li>特点:<ul>
<li>使用 2.4 GHz 频段，穿透能力较强，但易受干扰（如微波炉、蓝牙设备）。</li>
<li>数据速率较低，但覆盖范围较广。</li>
<li>是早期广泛使用的无线网络标准。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-802-3"><a href="#3-802-3" class="headerlink" title="3. 802.3"></a><strong>3. 802.3</strong></h3><ul>
<li><strong>类型</strong>: 有线局域网 (LAN) 标准</li>
<li><strong>频段</strong>: 不适用（有线）</li>
<li>最大速率: 多种速率：<ul>
<li>10 Mbps（早期版本）</li>
<li>100 Mbps (Fast Ethernet)</li>
<li>1 Gbps (Gigabit Ethernet)</li>
<li>10 Gbps 及以上（现代版本）</li>
</ul>
</li>
<li><strong>传输介质</strong>: 双绞线、电缆或光纤</li>
<li>特点:<ul>
<li>基于 CSMA&#x2F;CD (载波监听多路访问&#x2F;碰撞检测) 媒体访问控制机制。</li>
<li>提供稳定、低延迟的有线网络连接。</li>
<li>主要用于固定设备的高速网络连接。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>在交换机或路由器上，同一网段的两个端口<strong>可以是不同的冲突域</strong>.</p>
</li>
<li><p>数冲突域和广播域的时候，数端口就好</p>
</li>
<li><p>remote是主叫方，cenetral是被叫方。PAP是主叫方给出信息，CHAP是被叫方发起挑战</p>
</li>
</ol>
<h2 id="小测"><a href="#小测" class="headerlink" title="小测"></a>小测</h2><ol>
<li>AP的作用：让无线设备连接上无线网</li>
<li>私有地址：<ol>
<li>10.开头所有</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.开头所有</li>
</ol>
</li>
<li>多播地址（组播地址）：224.0.0.0 ~ 239.255.255.255</li>
<li>OSPF 中的 Type 1 LSA（Router LSA）是由每台路由器生成的，而 Router ID 就是用来标识该 LSA 来源的唯一标识符。</li>
<li>OSPF端口选择：优先选择环回接口，然后选择IP大的<strong>逻辑</strong>端口。<ol>
<li>注意，在STP中是选择IP小的</li>
</ol>
</li>
<li>OSPF 路由器之间必须属于同一个子网（即 IP 地址和子网掩码匹配）。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-·-导论"><a href="#第一章-·-导论" class="headerlink" title="第一章 · 导论"></a>第一章 · 导论</h1><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构涉及三个方面： </p>
<ul>
<li>数据的逻辑结构—–从用户视图看，是面向问题的。 </li>
<li>数据的物理结构—–从具体实现视图看，是面向计算机的。 </li>
<li>相关的操作及其实现。</li>
</ul>
<p>注意：非线性逻辑结构的物理结构不一定是非线性的，反之亦然。</p>
<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><ol>
<li><p>ADTs: Abstract Data Types </p>
<p>是将类型和与这个类型有关的操作集合封装在一起的数据模型。</p>
<p>如：栈，字典，列表等等</p>
</li>
<li><p>思想：将数据类型的使用与它的表示（机内存储）、实现（机内操作的 实现）分开。更确切的说，把一个数据类型的表示及在这个类型 上的操作实现封装到一个程序模块中，用户不必知道它。</p>
</li>
</ol>
<h2 id="OO"><a href="#OO" class="headerlink" title="OO"></a>OO</h2><ol>
<li>OO：object-oriented＝object＋class＋inherit＋ communicate</li>
<li>面向对象编程核心思想：<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
</ol>
<h2 id="算法思想：递归（Recursion"><a href="#算法思想：递归（Recursion" class="headerlink" title="算法思想：递归（Recursion)"></a>算法思想：递归（Recursion)</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol>
<li>基本情况：考虑“第一项”</li>
<li>递归过程：考虑第n项和第n-1项之间的关系<ul>
<li>注：递归过程一定要最终落在基本情况上，否则该递归是错误的</li>
</ul>
</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>直接递归（自递归）：自己调用自己</li>
<li>简介递归（互递归）：多个函数相互调用形成回路的递归</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li>理解：其实就是代码复用。有时候会通过模版来实现。java中看到的<Object>就是泛型的的例子</li>
<li>定义：泛型（Generics）是一种编程语言的特性，允许在定义函数、类或数据结构时使用类型参数，以便这些代码可以适用于多种数据类型，而不需要为每一种类型编写单独的代码。</li>
</ol>
<h1 id="第二章-·-算法分析"><a href="#第二章-·-算法分析" class="headerlink" title="第二章 · 算法分析"></a>第二章 · 算法分析</h1><ul>
<li>只关注量级，不太关心细节</li>
<li>计算机领域默认log的底数为2</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ul>
<li>数变量的时候多一个少一个也没关系，不影响数量级就好</li>
</ul>
<ol>
<li><p>组成：</p>
<ol>
<li><p>指令空间</p>
</li>
<li><p>数据空间：</p>
<ol>
<li>常量</li>
<li>简单变量</li>
<li>组件变量</li>
</ol>
</li>
<li><p>环境栈空间</p>
</li>
</ol>
</li>
<li><p>两个部分：</p>
<ol>
<li>固定部分：指令空间，简单变量等等，在程序加载的时候就已经确定，大小是固定的。</li>
<li>可变部分：包括组件变量，动态分配，递归栈等等。</li>
</ol>
</li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ol>
<li>关注关键步骤，忽略次要步骤（都是相对而言），如：关注比较，忽略赋值；关注元素比较，忽略下标比较；</li>
<li>最优最差平均复杂度：以查找为例，最优为1，第一个就找到了，最坏是n，遍历全部，平均为（n+1)&#x2F;2。</li>
</ol>
<h2 id="基本思想：分治-divide-and-conquer"><a href="#基本思想：分治-divide-and-conquer" class="headerlink" title="基本思想：分治(divide-and -conquer)"></a>基本思想：分治(divide-and -conquer)</h2><ol>
<li>两个阶段：<ol>
<li>分阶段：把问题分成两个大致相等的子问题，然后递归地 对它们求解。 </li>
<li>治阶段： 将两个子问题的解合并到一起，可能再做些少 量的附加工作，最后得到整个问题的解。</li>
</ol>
</li>
</ol>
<h2 id="表示法"><a href="#表示法" class="headerlink" title="表示法"></a>表示法</h2><ol>
<li>大O表示法：表示量级上界</li>
<li>Omega表示法：表示量级下界</li>
<li>θ表示法：表示量级</li>
</ol>
<h1 id="第三章-·-列表，栈和队列"><a href="#第三章-·-列表，栈和队列" class="headerlink" title="第三章 · 列表，栈和队列"></a>第三章 · 列表，栈和队列</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表 ***"></a>线性表 ***</h2><ol>
<li><p>逻辑层：</p>
<p>定义和功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractDateType LinearList&#123; </span><br><span class="line">instances</span><br><span class="line">	ordered finite collections of zero or more elements</span><br><span class="line">operations</span><br><span class="line">	<span class="title function_">Create</span><span class="params">()</span>; Destroy();</span><br><span class="line">	IsEmpty(); Length();</span><br><span class="line">	Find(k,x); Search(x);</span><br><span class="line">	Delete(k,x); Insert(k,x);</span><br><span class="line">	Output(out);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>物理层：</p>
<ol>
<li>用数组表示线性表<ol>
<li>根据索引访问：O(1)</li>
<li>查找：O(len)</li>
<li>根据索引删除：O(n)。因为需要挪动数据。</li>
<li>特点：<ol>
<li>优势：查找很快，O(1)</li>
<li>缺点：插入，删除慢</li>
</ol>
</li>
</ol>
</li>
<li>用链表表示<ol>
<li>时间复杂度<ol>
<li>访问：O(n)</li>
<li>查找：O(n)</li>
<li>删除：O(1)</li>
<li>插入：O(1)</li>
</ol>
</li>
<li>有表头节点的单链表：<ul>
<li>在第一个节点之前有一个header节点，不储存数据。它被header指针指向。</li>
<li>first是指第一个数据指针</li>
</ul>
</li>
<li>有游标的单链表<ul>
<li>定义了游标类LinkedListItr。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈 ***"></a>栈 ***</h2><ol>
<li><p>逻辑层：</p>
<ol>
<li><p>理解：实际上是对线性表做了限制，只允许有一端可以增添，删除和查找，其他地方都不行。活动端叫栈顶，另一端叫栈底。</p>
</li>
<li><p>操作：</p>
<ol>
<li>push：压栈（添加）</li>
<li>pop：出栈（删除）</li>
<li>peek：查看栈顶元素</li>
<li>isEmpty</li>
</ol>
</li>
</ol>
</li>
<li><p>物理层：和线性表一致。</p>
</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列 ***"></a>队列 ***</h2><ol>
<li>逻辑层：<ol>
<li>理解：像水管一样，一头进数据，一头出数据。出数据的叫队首，进数据的叫队尾。</li>
<li>操作：<ol>
<li>enqueue：入队</li>
<li>dequeue：出队</li>
<li>peek：查看队首数据</li>
</ol>
</li>
</ol>
</li>
<li>物理层：和线性表一致<ol>
<li>用数组表示：要把数组看成环形。表示下一个位置时，表示为front &#x3D; (front + 1) % arr.length。</li>
</ol>
</li>
</ol>
<h1 id="第四章-·-树"><a href="#第四章-·-树" class="headerlink" title="第四章 · 树"></a>第四章 · 树</h1><ul>
<li>主要研究二叉树</li>
</ul>
<h2 id="性质补充"><a href="#性质补充" class="headerlink" title="性质补充"></a>性质补充</h2><ol>
<li>根节点的高度为0</li>
<li>一棵树的叶有n个，有m个度数为2的节点，则：n&#x3D;m+1</li>
<li>如果对完全二叉树按层标号，则可以根据标号算出某个节点的子节点和父节点</li>
</ol>
<h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ol>
<li>用数组表示</li>
<li>用广义表：A（B，C，（D，E））</li>
<li>用双亲表示法</li>
<li>左子女，右兄弟法：注意，这种方法的逻辑层和物理层都是树</li>
</ol>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol>
<li><p>二叉树遍历算法：</p>
<ol>
<li>深度优先：先序、中序、后序。用递归实现，也可以用栈。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BinaryNode&lt;T&gt;* t)</span><br><span class="line">&#123;// preorder traversal of *t.</span><br><span class="line">	if(t)&#123; </span><br><span class="line">		visit(t);</span><br><span class="line">		PreOrder(t-&gt;Left);</span><br><span class="line">		PreOrder(t-&gt;Right);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>广度优先：按层次遍历。用队列实现</li>
</ol>
</li>
<li><p>一般树遍历：</p>
<ol>
<li>深度优先：<ol>
<li>逻辑上先根遍历（物理上先序遍历）</li>
<li>逻辑上后根遍历（物理上<strong>中序</strong>遍历）</li>
</ol>
</li>
</ol>
</li>
<li><p>森林遍历：</p>
<ol>
<li>先根&#x3D;&gt;先序</li>
<li>中根&#x3D;&gt;中序</li>
<li>后根&#x3D;&gt;后序</li>
</ol>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol>
<li>完全二叉树：除了最后一层，其它层节点都是满的</li>
<li>满二叉树：其中每个节点要么是叶子节点，要么是有两个子节点（即每个非叶子节点都有两个子节点）。每一层的节点数都达到了该层的最大节点数。</li>
<li>满二叉树<strong>一定</strong>是完全二叉树，完全二叉树也不一定是满二叉树</li>
</ol>
<h2 id="线索树"><a href="#线索树" class="headerlink" title="线索树"></a>线索树</h2><ol>
<li>n个结点的二叉树有2n个链域，<br>其中真正有用的是n – 1个，其它n + 1个都是空域。<br>让左指针指向前驱，右指针指向后继。</li>
<li>增加了2个标记位，leftThread和rightThread。为0则代表指向子女，为1则代表指向前驱后继。</li>
</ol>
<h2 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h2><ol>
<li>可以构造出一颗二叉搜索树，使得每个节点的左子树的所有节点比自己小，右子树的所有节点比自己大</li>
</ol>
<h3 id="带索引的搜索树（Index-BST）"><a href="#带索引的搜索树（Index-BST）" class="headerlink" title="带索引的搜索树（Index BST）"></a>带索引的搜索树（Index BST）</h3><p>在每个节点左侧添加一个索引，为其左子树中的所有节点数加一（也就是要包括自身）</p>
<h3 id="平衡二叉搜索树（AVL-Tree）"><a href="#平衡二叉搜索树（AVL-Tree）" class="headerlink" title="平衡二叉搜索树（AVL Tree）"></a>平衡二叉搜索树（AVL Tree）</h3><ol>
<li>定义：<ol>
<li>是二叉搜索树</li>
<li>左右子树高度差不能超过一</li>
</ol>
</li>
<li>旋转：详见算法</li>
</ol>
<h3 id="m路搜索树"><a href="#m路搜索树" class="headerlink" title="m路搜索树"></a>m路搜索树</h3><ol>
<li><p>定义：</p>
<ol>
<li><p>树中最多有m路分叉</p>
</li>
<li><p>一个节点最少有一个key，最多有m-1个key</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105164244133.png" alt="image-20241105164244133"></p>
</li>
<li><p>节点中的key是从小到大排好序的</p>
</li>
<li><p>分叉中的所有节点总是小于分叉的右边的key，大于左边的key</p>
</li>
</ol>
</li>
</ol>
<h3 id="平衡m路搜索树（B-Tree"><a href="#平衡m路搜索树（B-Tree" class="headerlink" title="平衡m路搜索树（B-Tree)"></a>平衡m路搜索树（B-Tree)</h3><ol>
<li>定义：<ol>
<li>根节点至少有2个子节点（即至少有1个key）</li>
<li>每个节点中的至少有 [m&#x2F;2]（向上取整）路</li>
<li>外节点全都在同一层，即树同高</li>
</ol>
</li>
<li>性质：<ol>
<li>外节点总数是key值总数加一</li>
</ol>
</li>
</ol>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><ol>
<li>概念：<ol>
<li>增长树：对原二叉树中度为1的结点， 增加一个空树叶 对原二叉树中的树叶， 增加两个空树叶</li>
<li>外通路长度（外路径）E： 根到每个外结点（增长树的叶子） 的路径长度的总和（边数） E&#x3D;3+3+2+3+4+4+3+3&#x3D;25 </li>
<li>内通路长度（内路径）I： 根到每个内结点（非叶子）的路径长度的总和（边 数）。 I&#x3D;2+1+0+3+2+2+1&#x3D;11 </li>
<li>结点的带权路径长度： 一个结点的权值与结点的路径长度的 乘积。</li>
<li>权的外路径长度： 各叶结点的带权路径长度之和。</li>
<li>带权的内路径长度：各非叶结点的带权路径长度之和。</li>
<li>霍夫曼树 1) <ol>
<li>给出m个实数W1，W2，…，Wm （m&gt;&#x3D;2） 作为m个外结 点的权构造一棵增长树， 使得带权外路径长度 </li>
<li>Wi l i最小。 m i&#x3D;1 其中l i 为从根结点出发到具有权为wi的外结点的通路长。</li>
</ol>
</li>
</ol>
</li>
<li>霍夫曼算法</li>
</ol>
<h1 id="第五章-·-散列表（Hash）-需要掌握代码"><a href="#第五章-·-散列表（Hash）-需要掌握代码" class="headerlink" title="第五章 · 散列表（Hash）(需要掌握代码)"></a>第五章 · 散列表（Hash）(需要掌握代码)</h1><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ol>
<li>为了让插入和查找的时间复杂度为O(1)</li>
<li>代价是会有严重空间浪费</li>
<li>“hash值”是会冲突的，我们可以让冲突的数据挂在一个链表上，并且放在hash表的冲突的位置</li>
</ol>
<h2 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h2><ol>
<li>取余法<ol>
<li>H(key) &#x3D; Key % M</li>
<li>其中M是基本区长度的最大质数，这样的冲突概率最小。</li>
</ol>
</li>
<li>平方取中 todo</li>
<li>乘法杂凑函数<ol>
<li>H（Key) &#x3D; M * ((C * Key) % 1)向下取整</li>
<li>M是表的大小，C是任意无理数</li>
<li>原理是表达大小乘以一个0~1之间的数，得到下标</li>
</ol>
</li>
</ol>
<h2 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h2><ul>
<li>同义：算出来地址相同</li>
</ul>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><ol>
<li>发生冲突后往后面放，指导遇到空位置。</li>
<li>如果满了，就不放</li>
<li>缺点：堆积</li>
</ol>
<h3 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h3><ol>
<li>遇到冲突时，处理不一样。线性探测是一个一个往后找，二次探测是用一个平方算出来。<br>$$<br>h(x,i)&#x3D;(h(x)+i^<br>2<br> )modm<br>$$</li>
</ol>
<h3 id="双散列"><a href="#双散列" class="headerlink" title="双散列"></a>双散列</h3><ol>
<li>遇到冲突时，用另外一个完全不同的hash函数计算一个值，再从冲突位置按照这个值往后数。还冲突，再数。<br>$$<br>h(x,i)&#x3D;(h<br>1<br>​<br> (x)+i⋅h<br>2<br>​<br> (x))modm<br>$$</li>
</ol>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>冲突了就用单链表接在后面</p>
<h1 id="第六章-·-堆"><a href="#第六章-·-堆" class="headerlink" title="第六章 · 堆"></a>第六章 · 堆</h1><h2 id="最大（小）优先队列"><a href="#最大（小）优先队列" class="headerlink" title="最大（小）优先队列"></a>最大（小）优先队列</h2><h2 id="最大（小）堆"><a href="#最大（小）堆" class="headerlink" title="最大（小）堆"></a>最大（小）堆</h2><ol>
<li>性质<ol>
<li><strong>完全二叉树</strong>：最大堆必须是一个完全二叉树，即除了最后一层，其他层的节点都要满，最后一层的节点都集中在左侧。</li>
<li><strong>父节点大于或等于子节点</strong>：对于堆中的每一个父节点，其值都大于或等于它的两个子节点的值。换句话说，根节点的值是最大值。</li>
<li><strong>树的性质</strong>：最大堆的树结构是无序的，仅通过父子节点关系来确保堆性质</li>
</ol>
</li>
<li>算法：<ol>
<li><strong>插入（Insert）</strong>：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。</li>
<li><strong>删除最大元素（Extract Max）</strong>：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。</li>
</ol>
</li>
<li>求第K大元素：<ol>
<li><p>不用堆：</p>
<ol>
<li>1A算法：全部排序一遍，找到第K个。O(n^2^)</li>
<li>1B算法：取前K个数据排序，然后把后面的数据和前面K个数据中的最小值比较。如果小于，则跳过；若大于，则删除原来那个，把这个值插入合适位置。O(n*k)</li>
</ol>
</li>
<li><p>用堆</p>
<ol>
<li>6A算法：建堆，执行K次出堆。O(n*log(n))</li>
<li>6B算法：道理一样的，取前K个元素建堆，比较，重构。O(n*log(k))</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第七章-·-并查集"><a href="#第七章-·-并查集" class="headerlink" title="第七章 · 并查集"></a>第七章 · 并查集</h1><ol>
<li>定义：每个集合通过一个代表元素（root）来表示，每个元素都指向它所在集合的代表元素。通过这种方式，可以快速确定两个元素是否属于同一个集合，以及在需要时将两个集合合并成一个集合。</li>
<li>其物理层是森林，更进一步可以是数组。数组内容0或负数表示自己是父节点，非零表示父节点下标</li>
<li>操作：<ol>
<li><strong>Find 操作</strong>：用于查找某个元素所在的集合（即根节点），并在查找的过程中进行路径压缩，即每次查找让路径上的所有节点指向根节点，以减小树的高度，提高查找效率。</li>
<li><strong>Union 操作</strong>：用于合并两个集合，即将两个集合的代表元素连接在一起，通常按照某种规则（如按秩合并）来决定连接的方式，以保持树的平衡。为了不让union后的树形状太糟糕，采用下面的方法：<ol>
<li>在树根上缓存一个树高，把树高小的挂在树高大的上面</li>
</ol>
</li>
</ol>
</li>
<li>实现<ol>
<li>用一个数组来实现，根结点中放负数，而且是代表高度。</li>
</ol>
</li>
</ol>
<h1 id="第八章-·-图"><a href="#第八章-·-图" class="headerlink" title="第八章 · 图"></a>第八章 · 图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>有向图和无向图</p>
</li>
<li><p>完全图</p>
</li>
<li><p>e表示边，v表示节点</p>
</li>
<li><p>TD表示度数，ID表示入读，OD表示出度</p>
</li>
<li><p>$\sum^n_{i&#x3D;1}TD(v_i)&#x3D;2*e$</p>
</li>
<li><p>子图</p>
</li>
<li><p>连通分量：指的是一个图的一个子图，该子图是连通的，并且和图中任何其他子图都不连通。</p>
<ol>
<li>有向图的连通分量可以分为<strong>强连通分量</strong>（strongly connected component）和<strong>弱连通分量</strong>（weakly connected component）。<ul>
<li><strong>强连通分量</strong>：有向图中每个顶点都能到达该分量中的其他顶点。</li>
<li><strong>弱连通分量</strong>：忽略边的方向后，图是连通的。</li>
</ul>
</li>
</ol>
</li>
<li><p>生成树：实际上是极小连通子图</p>
</li>
</ol>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ol>
<li>邻接矩阵（数组）***<ol>
<li>矩阵的行列数都为v</li>
</ol>
</li>
<li>邻接表（链表）***<ol>
<li>对于无向图来说，邻接表节点数量是边的两倍；对有向图来说，是一样多的</li>
<li>每个表头代表起点，其后每个节点代表一个终点</li>
</ol>
</li>
<li>邻接多重表</li>
</ol>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><ol>
<li>定义：<ol>
<li>设G &#x3D;(V，E)是一个连通的无向图(或是强连通有向图) 从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE(G)，显然 G‘&#x3D;(V，TE)是G之子图， G‘被称为G的生成树(spanning tree)，也称为一个连通图.</li>
<li>n个结点的生成树有n-1条边。</li>
<li>生成树的代价(cost)：TE(G)上诸边的代价之和</li>
<li>生成树不唯一</li>
</ol>
</li>
</ol>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ol>
<li><p>概述</p>
<ol>
<li>三种算法： 1)边上权值为非负情况的从一个结点到其它各结点的最短路径 （单源最短路径）（Dijkstra算法） 2)边上权值为任意值的单源最短路径 3)边上权值为(任意值)的所有顶点之间的最短路径</li>
</ol>
</li>
<li><p>Dijkstra算法：</p>
<ol>
<li>起点V0，首先直接连接，不管是否直接连接。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png" alt="img"></a></p>
<ol>
<li>排好序后，V0-V1 10已经是最小的了，不可能再找到更短的路径</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png" alt="img"></a></p>
<ol>
<li>接下来，尝试V0-v2通过V1绕会不会比原来的更短(考虑V1-V2直连)，V0-V4从V1绕会不会比原来更短(考虑V2-V3直连)，如果短则更新，此时V0-V3是三者中最小值，所以选择V0-V3。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png" alt="img"></a></p>
<ol>
<li>尝试绕行V3，计算直连，更新掉，然后重复</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png" alt="img"></a></p>
<ol>
<li>红色是已经选择好的，绿色是绕行选择。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png" alt="img"></a></p>
<ol>
<li>进一步思考，就是只进行一步，不进行多不步。</li>
<li>总体来讲:不可能走更长的路径，然后回来</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png" alt="img"></a></p>
<ol>
<li>数值更新，路径数组对应位置更新</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png" alt="img"></a></p>
</li>
<li><p>贝尔曼·福特改进算法</p>
<ol>
<li>允许有负边，但是不允许有负环</li>
<li>思想是动态规划（迭代？），找到走一步的最短路径，再找两步以内的，一直到n-1步以内的。实际上是看现状加上直连边来看，每一个节点都可能会更新。</li>
</ol>
</li>
<li><p>floyed</p>
<ol>
<li>简单来说就是:每次都会选择一个中介点，然后遍历整个数组，更新相应的需要更新的数组。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png" alt="img"></li>
<li>在更新A时，也更新path矩阵，里面的值是到数第二个节点</li>
</ol>
</li>
</ol>
<h2 id="活动网络"><a href="#活动网络" class="headerlink" title="活动网络"></a>活动网络</h2><ol>
<li>用顶点表示活动的网络（AOV网络）<ol>
<li>AOV网（Activity On Vertex network)<br>用顶点表示活动，用弧表示活动间的优先关系的有向<br>图称为AOV网。<br>直接前驱，直接后继：&lt;i,j&gt;是网中一条弧，则i是j的<br>直接前驱，j是i的直接后继。<br>前驱，后继：从顶点i顶点j有一条有向路径，则称<br>i是j的前驱， j是i的后继。<br>AOV网中，不应该出现有向环</li>
<li>拓扑排序</li>
</ol>
</li>
<li>用边表示活动的网络（AOE网络）<ol>
<li>用边表示活动的网络（AOE网络, Activity On Edge Network）<br>又称为事件顶点网络<br>• 顶点：表示事件（event）<br>事件——状态。表示它的入边代表的活动已完成，它的出边<br>代表的活动可以开始，如下图v0表示整个工程开始<br>，v4表示a4，a5活动已完成a7，a8活动可开始。<br>有向边：表示活动。<br>边上的权——表示完成一项活动需要的时间</li>
<li>关键路径（critical path）<br>1)目的 : 利用事件顶点网络，研究完成整个工程需要多少时间<br>加快那些活动的速度后，可使整个工程提前完成。<br>2)关键路径：具有从开始顶点(源点）完成顶点（汇点）的<br>最长的路径<ol>
<li><p>一些定义</p>
<ol>
<li>对于事件:<ol>
<li>Ve[i]－表示事件Vi的可能最早发生时间。定义为从源点V0-&gt;Vi的最长路径长度, 如Ve[4]&#x3D;7天</li>
<li>Vl[i]－表示事件Vi的允许的最晚发生时间。是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi-&gt;Vn－1的最长路径长度。<strong>是从最后汇点时间长度-两者之间最长路径</strong></li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png" alt="img"></a></p>
<ol>
<li>解释:<ol>
<li>计算到最后汇点的总共最短时间:找到从源点到汇点的最大路径</li>
<li>最早12，因为之前不能做。</li>
<li>最晚12，是因为如果这时候不开始，最后完成不了。</li>
</ol>
</li>
<li>对于活动:<ol>
<li>e[k]－表示活动ak&#x3D;&lt;Vi,Vj&gt;的可能的最早开始时间。 即等于事件Vi的可能最早发生时间。 e[k]&#x3D;Ve[i]</li>
<li>l[k]－表示活动ak&#x3D; &lt;Vi,Vj&gt; 的允许的最迟开始时间 l[k]＝Vl[j]-dur(&lt;i,j&gt;);</li>
<li>l[k]-e[k]－表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack time)</li>
<li>l[k]&#x3D;&#x3D;e[k]－表示活动ak是没有时间余量的<strong>关键活动</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>找关键路径</p>
<ol>
<li>找关键活动的算法：<br>（1）定义几个量<br>对事件而言<br>Ve[i]－表示事件Vi的可能最早发生时间<br>定义为从源点V0 Vi的最长路径长度, 如Ve[4]&#x3D;7天<br>Vl[i]－表示事件Vi的允许的最晚发生时间。<br>是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，<br>事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi  Vn－1的最<br>长路径长度。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第九章-·-排序"><a href="#第九章-·-排序" class="headerlink" title="第九章 · 排序"></a>第九章 · 排序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>稳定性：如果待排序的对象序列中，含有多个关键码值 相等的对象，用某种方法排序后，这些对象的 相对次序不变的，则是稳定的，否则为不稳定 的。</li>
<li>两大类：<ol>
<li>内排序：对内存中的n个对象进行排序。</li>
<li>外排序：内存放不下，还要使用外存的 排序。</li>
</ol>
</li>
<li>排序的算法分析： <ol>
<li>时间开销—比较次数，移动次数 </li>
<li>所需的附加空间</li>
</ol>
</li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ol>
<li>思想：一个一个排</li>
<li>O(n^2^)</li>
<li>稳定的</li>
</ol>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ol>
<li>在直接插入排序的基础上，让比较的过程变成折半查找，而不是线性查找.注意，是在已经排好序的部分进行的二分查找。</li>
<li>O(n*log n)</li>
<li>稳定的</li>
</ol>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol>
<li><p>又称为缩小增量排序</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220142720571.png" alt="image-20241220142720571"></p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shellsort</span><span class="params">(datalist&lt;Type&gt;&amp; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> gap = list.CurrentSize / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShellInsert</span>(list, gap);</span><br><span class="line">        gap = (gap == <span class="number">2</span>) ? <span class="number">1</span> : gap / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellInsert</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> gap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; list.CurrentSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Element&lt;Type&gt; temp = list.Vector[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= gap &amp;&amp; temp.<span class="built_in">getkey</span>() &lt; list.Vector[j - gap].<span class="built_in">getkey</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[j] = list.Vector[j - gap];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        list.Vector[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度大概在n^1.3^左右</p>
</li>
<li><p>不稳定</p>
</li>
</ol>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li><p><strong>注意，我们可以记录是否有交换，如果某一次迭代时没有交换，就可以终止了</strong>。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(datalist&lt;Type&gt;&amp; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pass = <span class="number">1</span>; </span><br><span class="line">    <span class="type">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pass &lt; list.CurrentSize &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="number">0</span>;  <span class="comment">// 重置交换标志</span></span><br><span class="line">        <span class="built_in">BubbleExchange</span>(list, pass, exchange);  <span class="comment">// 执行一轮交换</span></span><br><span class="line">        pass++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleExchange</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> pass, <span class="type">int</span>&amp; exchange)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行一轮交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = list.CurrentSize - <span class="number">1</span>; j &gt;= pass; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.Vector[j - <span class="number">1</span>].<span class="built_in">getkey</span>() &gt; list.Vector[j].<span class="built_in">getkey</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(list.Vector[j - <span class="number">1</span>], list.Vector[j]);  <span class="comment">// 交换元素</span></span><br><span class="line">            exchange = <span class="number">1</span>;  <span class="comment">// 记录发生交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n^2^)</p>
</li>
<li><p>稳定的</p>
</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序 ***"></a>快速排序 ***</h3><ol>
<li><p>方法： 1）在n个对象中，取一个对象（如第一个对象——基 准pivot），按该对象的关键码把所有 该关键码 的对象分划在它的左边。该关键码的对象分划 在它的右边。 2） 对左边和右边（子序列）分别再用快排序。</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> left, <span class="type">const</span> <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivotpos = <span class="built_in">partition</span>(list, left, right);  <span class="comment">// 获取基准元素的位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(list, left, pivotpos - <span class="number">1</span>);  <span class="comment">// 排序左侧子数组</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(list, pivotpos + <span class="number">1</span>, right);  <span class="comment">// 排序右侧子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(datalist&lt;Type&gt;&amp; list, <span class="type">const</span> <span class="type">int</span> low, <span class="type">const</span> <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = high;</span><br><span class="line">    Element&lt;Type&gt; pivot = list.Vector[low];  <span class="comment">// 选择基准元素（这里选择第一个元素）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (list.Vector[j].<span class="built_in">getkey</span>() &gt; pivot.<span class="built_in">getkey</span>() &amp;&amp; i &lt; j) j--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左向右找大于基准值的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[i] = list.Vector[j];  <span class="comment">// 交换</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (list.Vector[i].<span class="built_in">getkey</span>() &lt; pivot.<span class="built_in">getkey</span>() &amp;&amp; i &lt; j) i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            list.Vector[j] = list.Vector[i];  <span class="comment">// 交换</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准值放到正确的位置</span></span><br><span class="line">    list.Vector[i] = pivot;</span><br><span class="line">    <span class="keyword">return</span> i;  <span class="comment">// 返回基准值的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>不稳定</p>
</li>
<li><p>时间平均O(n*log n)</p>
</li>
<li><p>空间：O(log n) ~ O(n)</p>
</li>
<li><p>不稳定</p>
</li>
<li><p>选取枢纽元</p>
<ol>
<li>用第一个元素作pivot是不太好的。</li>
<li>方法1：随机选取pivot, 但随机数的生成一般是昂贵的。 </li>
<li>方法2：三数中值分割法（Median-of-Three partitioning) N个数，最好选第N&#x2F;2个最大数，这是最好的中值，但这是很困难的。 一般选左端、右端和中心位置上的三个元素的中值作为枢纽元。 8, 1, 4, 9, 6, 3, 5, 2, 7, 0 (8, 6, 0) 具体实现时：将 8，6，0 先排序，即 0, 1, 4, 9, 6, 3, 5, 2 , 7, 8, 得到中值pivot为 6 。</li>
</ol>
</li>
<li><p>分割策略：将pivot与最后倒数第二个元素交换，使得pivot离开要被分割的数据段。然后， i 指向第一个元素，j 指向倒数第二个元素。 0, 1, 4, 9, 7, 3, 5, 2, 6, 8 然后进行分</p>
</li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><ol>
<li>思想：首先在n个记录中选出关键码最小（最大）的 记录，然后与第一个记录（最后第n个记录） 交换位置，再在其余的n-1个记录中选关键码 最小（最大）的记录，然后与第二 个记录（ 第n-1个记录）交换位置，直至选择了n－1个 记录。</li>
<li>不稳定</li>
<li>每次寻找都要扫描</li>
</ol>
<h3 id="竞标赛排序"><a href="#竞标赛排序" class="headerlink" title="竞标赛排序"></a>竞标赛排序</h3><ol>
<li>直接选择排序存在重复做比较的情况，锦标赛 排序克服了这一缺点。 </li>
<li>方法： 1. n个对象的关键码两两比较得到 n&#x2F;2 个 比较的优胜 者(关键码小者)保留下来, 再对这 n&#x2F;2 个对象再进行关键 码的两两比较, ……直至选出一个最小的关键码为止。 如果n不是2的K次幂，则让叶结点数补足到满足 2 k</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153506582.png" alt="image-20241220153506582"></li>
<li>树根为当前最小元素。取出后，把对应位置改为无穷</li>
<li>第一次扫描需要建树，但是后面更新只需要比较树高。</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241220153752102.png" alt="image-20241220153752102"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ol>
<li>分治思想，会合并</li>
</ol>
<h1 id="笔记-·-错题集"><a href="#笔记-·-错题集" class="headerlink" title="笔记 · 错题集"></a>笔记 · 错题集</h1><ol>
<li><p>如何求时间复杂度？</p>
<ol>
<li><p>步骤：</p>
<ol>
<li>找关键步骤。明确到底那些地方才算时间。</li>
<li>抓最大规模。如果问题有多个部分，取最慢、最复杂的部分算时间复杂度（其实大O就是这样）。</li>
<li>计算。嵌套向乘，平级相加。</li>
</ol>
</li>
<li><p>注意：</p>
<ul>
<li><p>一定要明确那些地方算时间，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for( i = 1; i &lt; n; i++ )     </span><br><span class="line">	for( j = 0; j &lt; i*i; j++ )</span><br><span class="line">    	if( j % i == 0 )</span><br><span class="line">        	for( k = 0; k &lt; j; k++ )</span><br><span class="line">            	sum++; </span><br></pre></td></tr></table></figure>

<p>不要把所有的循环都算到时间复杂度里，要抓的是执行了多少次sum++。</p>
</li>
<li><p>写成加和的形式，不要写成乘法，否则容易搞混。有一重循环就写一重加和。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>链表实现栈和队列：</p>
<ol>
<li>栈：表头为栈顶</li>
<li>队列：两个指针记录首尾</li>
</ol>
</li>
<li><p><code>Comparable</code> 不是一个类，而是一个<strong>接口</strong>，它用于在 Java 中定义对象的自然顺序。任何实现了 <code>Comparable</code> 接口的类都可以通过该接口提供的 <code>compareTo</code> 方法来进行对象的比较。这个接口是 Java 类库中非常重要的一部分，它允许你定义自定义的排序规则。</p>
</li>
</ol>
<h1 id="笔记-·-算法集"><a href="#笔记-·-算法集" class="headerlink" title="笔记 · 算法集"></a>笔记 · 算法集</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func(int[] a, int size)&#123;</span><br><span class="line">	for(int n = size; n &gt; 1; n--)&#123;</span><br><span class="line">		int j = Max(a, n); //找到数组a中的最大数，返回其索引</span><br><span class="line">		swap(a[j], a&#123;n-1&#125;); //交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二重循环</p>
</li>
<li><p>时间复杂度为：<br>$$<br>(n-1)+(n-2)+…+3+2+1&#x3D;\frac{n*(n-1)}{2} ··· O(n^2)<br>$$</p>
</li>
</ul>
<h3 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func(int[] a, int size)&#123;</span><br><span class="line">	for(int i = 0; i &lt; size-1; i++)&#123;</span><br><span class="line">		if(a[i] &gt; a[i+1])swap(a[i], a[i+1]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line"> 	for(int i = size; i &gt; 1; i--)&#123;</span><br><span class="line"> 		func(a, i);</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二重循环</li>
<li>时间复杂度：</li>
</ul>
<p>$$<br>O(n^2)<br>$$</p>
<h3 id="秩排序（Rank-Sort）"><a href="#秩排序（Rank-Sort）" class="headerlink" title="秩排序（Rank Sort） ***"></a>秩排序（Rank Sort） ***</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排名</span></span><br><span class="line"><span class="built_in">Rank</span>(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span>[] r)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//r数组初始化</span></span><br><span class="line">		r[i] = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &lt;= a[i])</span><br><span class="line">				r&#123;i&#125;++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Rearrange</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span>[] r)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// In-place rearrangement into sorted order</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (r[i] != i) &#123;</span><br><span class="line">				<span class="type">int</span> t = r[i];</span><br><span class="line">				<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">				<span class="built_in">swap</span>(r[i], r[t]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>解释：先给数组里的每个数算排名，然后把数据按照排名放在对应的位置。</li>
<li>时间复杂度：</li>
</ul>
<h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>理解：<ol>
<li>从第二个元素开始，假设第一个元素已排序。</li>
<li>将当前元素与已排序部分的元素逐个比较，从后向前找到合适的位置。</li>
<li>将当前元素插入到适当的位置，移动已排序部分的元素以腾出空间。</li>
<li>重复以上步骤，直到所有元素都已排序。</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InsertionSort( int [ ]a, int n)&#123; </span><br><span class="line">	for(int i=0;i&lt;n;i++) &#123; </span><br><span class="line">		//insert a[i] into a[0:n-1]</span><br><span class="line">		int t=a[i];</span><br><span class="line">			int j;</span><br><span class="line">		for(j=i-1; j&gt;=0&amp;&amp;t&lt;a[j]; j--)</span><br><span class="line">			a[j+1]=a[j];</span><br><span class="line">		a[j+1]=t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：$O(n^2)$</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul>
<li>基数：用什么进制，基数就是几。</li>
<li>理解：<ol>
<li>进桶。有基数个桶（每个桶实际上是单链表），把数字按照最高位放进桶里。</li>
<li>出桶。把每个桶接到前一个桶后面，这样就实现了按照某一位从小到大的排序。</li>
<li>循环，每次比较下一位。</li>
</ol>
</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ol>
<li>有向图G&#x3D;(V,E),V里结点的线性序列（vi1,vi2,…,vin),<br>如果满足: 在G中从结点vi到vj有一条路径，则序列中结点<br>vi必先于结点vj，称这样的线性序列为一拓扑序列。</li>
<li>拓扑序列不是唯一的</li>
<li>算法思想：<br>1）从图中选择一个入度为0的结点输出之。<br>（如果一个图中，同时存在多个入度为0的结点，则随便<br>输出那一个结点）<br>2）从图中删掉此结点及其所有的出边。<br>3）反复执行以上步骤：a）直到所有结点都输出了，则算法结束<br>b）如果图中还有结点，但入度不为0，则说<br>明有环路</li>
</ol>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>字面意思</p>
<ul>
<li>时间复杂度O(n)</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="分治法：求最大子序列和（还有更简的算法）"><a href="#分治法：求最大子序列和（还有更简的算法）" class="headerlink" title="分治法：求最大子序列和（还有更简的算法）"></a>分治法：求最大子序列和（还有更简的算法）</h3><ol>
<li><p>思想：</p>
<ol>
<li>从中间分裂成左右两个数组，分别递归调用求最大序列和</li>
<li>求横跨左右的最大序列和：以中点为边界，分别求向左、右的最大子序列，再把两者相加，得到横跨左右的最大子序列和。</li>
<li>把左最大、右最大、横跨最大三者相比较，保留最大的。</li>
</ol>
</li>
<li><p>时间复杂度：$O(n·log(n))$</p>
<ul>
<li>分：每次递归都是折半的，所以一共会分出log(n)层</li>
<li>治：每次递归都要调用两次，处理左边和右边。所以实际上如果我们把同一层的调用拼在一起，每一层都处理了完整的规模为O(n)的数据。</li>
<li>每层处理的规模为O(n)，有log(n)层，则有时间复杂度$O(n·log(n))$.</li>
</ul>
</li>
</ol>
<h3 id="寻找数组中第K小元素"><a href="#寻找数组中第K小元素" class="headerlink" title="寻找数组中第K小元素"></a>寻找数组中第K小元素</h3><ul>
<li>实际上就是在做选择排序，但是把问题规模限制在K，即做K个元素的排序后就结束</li>
</ul>
<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><ol>
<li><p>用队列实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHui</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printYangHui</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用队列来保存计算过程中的值</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">1</span>); <span class="comment">// 初始化队列</span></span><br><span class="line">        q.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印前置空格以对齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= <span class="number">10</span> - i; k++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在每行计算开始前添加一个辅助的 0</span></span><br><span class="line">            q.add(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于记录前一个出队元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">                q.add(s + t); <span class="comment">// 将新的值入队</span></span><br><span class="line">                s = t; <span class="comment">// 更新 s</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j != i + <span class="number">2</span>) &#123; <span class="comment">// 控制打印范围</span></span><br><span class="line">                    System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 打印前 5 行杨辉三角</span></span><br><span class="line">        printYangHui(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>用可变长的二维数组实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yanghui</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 杨辉三角的行数</span></span><br><span class="line">        <span class="type">int</span>[][] mat = <span class="keyword">new</span> <span class="title class_">int</span>[n][]; <span class="comment">// 申请第一维的存储空间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成杨辉三角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mat[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>]; <span class="comment">// 申请第二维的存储空间，每行长度不同</span></span><br><span class="line">            mat[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 每行的第一个元素为 1</span></span><br><span class="line">            mat[i][i] = <span class="number">1</span>; <span class="comment">// 每行的最后一个元素为 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                mat[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j]; <span class="comment">// 计算中间元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印杨辉三角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mat.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 打印前置空格，用于对齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印每行的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; mat[i].length; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span> + mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rear: 每次指向要出队列的前一个结点</span></span><br><span class="line"><span class="comment">//出队列的人也用链表来表示：</span></span><br><span class="line"><span class="comment">//head: 指向出队列结点链表的开头结点</span></span><br><span class="line"><span class="comment">//p: 指向出队列结点链表的尾结点</span></span><br><span class="line"><span class="comment">//以上rear, head, p都是ListNode的一个对象引用。</span></span><br><span class="line"><span class="number">1.</span> w = m;</span><br><span class="line"><span class="number">2.</span> <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">	<span class="number">1</span>) <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">1</span>; j&lt;=w-<span class="number">1</span>; j++) </span><br><span class="line">		rear = rear.link;</span><br><span class="line">	<span class="number">2</span>) <span class="keyword">if</span> (i = = <span class="number">1</span>)&#123;</span><br><span class="line"> 	head = rear.link ; p = head; &#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line"> 		p.link = rear.link; </span><br><span class="line">		p = rear.link;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="number">3</span>) rear.link = p.link;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">3.</span> P.link = rear;</span><br><span class="line">	rear.link = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="辗转相除法：求最大公因数"><a href="#辗转相除法：求最大公因数" class="headerlink" title="辗转相除法：求最大公因数"></a>辗转相除法：求最大公因数</h3><ol>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static long gcd( long m, long n )&#123; </span><br><span class="line">	while( n != 0 )&#123; </span><br><span class="line">		long rem = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = rem;</span><br><span class="line">	&#125;</span><br><span class="line">	return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>最坏情况是m, n取斐波那契数列的连续两位。</li>
<li>时间复杂度：估计得$O(n·log(n))$</li>
</ol>
</li>
</ol>
<h3 id="一般二叉搜索树"><a href="#一般二叉搜索树" class="headerlink" title="一般二叉搜索树"></a>一般二叉搜索树</h3><ul>
<li>每个节点有一个唯一的key值，左子结点比自己小，右子节点比自己大</li>
</ul>
<h4 id="查找算法（递归）"><a href="#查找算法（递归）" class="headerlink" title="查找算法（递归）"></a>查找算法（递归）</h4><ul>
<li><p>每个节点都有一个key值，当要查找的节点的key值小于当前节点，则只搜索左子树，反之搜索右子树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Find operation for binary search trees</span><br><span class="line">private BinaryNode find( Comparable x, BinaryNode t )&#123; 		if( t = = null )</span><br><span class="line">		return null;</span><br><span class="line">	if( x. compareTo( t.element ) &lt; 0 )</span><br><span class="line">		return find( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		return find( x, t.right );</span><br><span class="line">	else</span><br><span class="line">		return t; //Match</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="插入算法（递归）"><a href="#插入算法（递归）" class="headerlink" title="插入算法（递归）"></a>插入算法（递归）</h4><ul>
<li><p>不能够插入已有的key</p>
</li>
<li><p>当要插入的节点的key值小于当前节点，则只在左子树插入，反之在右子树插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private BinaryNode insert( Comparable x, BinaryNode t )&#123;</span><br><span class="line">	if( t = = null )</span><br><span class="line">		t = new BinaryNode( x, null, null );</span><br><span class="line">	else if( x.compareTo( t.element ) &lt; 0 )</span><br><span class="line">		t.left = insert( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		t.right = insert( x, t.right );</span><br><span class="line">	else</span><br><span class="line">		; //duplicate; do nothing</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法 ***"></a>删除算法 ***</h4><ul>
<li><p>考虑：</p>
<ul>
<li>P是叶节点</li>
<li>P有一棵子树</li>
<li>P有两棵子树</li>
</ul>
</li>
<li><p>前两种情况好理解，第三种情况下删除之后这个位子空出来怎么办呢?</p>
<ul>
<li>找到该节点左子树的最大节点或右子树的最小节点，代替到这个位置。找到的最大或最小节点一定至多有一颗子树。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private BinaryNode remove( Comparable x, BinaryNode t )&#123;</span><br><span class="line">	if( t == null )</span><br><span class="line">		return t;</span><br><span class="line">	if( x.compareTo( t.element ) &lt; 0 )</span><br><span class="line">		t.left = remove( x, t.left );</span><br><span class="line">	else if( x.compareTo( t.element ) &gt; 0 )</span><br><span class="line">		t.right = remove( x, t.right );</span><br><span class="line">	else if( t.left != null &amp;&amp; t.right != null )&#123;	</span><br><span class="line">		t.element = findMin( t.right ).element;</span><br><span class="line">		t.right = remove( t.element , t.right );</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		t = ( t.left != null ) ? t.left : t.right;</span><br><span class="line">	return t; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉搜索树（AVL-Tree）-1"><a href="#平衡二叉搜索树（AVL-Tree）-1" class="headerlink" title="平衡二叉搜索树（AVL Tree）"></a>平衡二叉搜索树（AVL Tree）</h3><h4 id="查找算法-1"><a href="#查找算法-1" class="headerlink" title="查找算法"></a>查找算法</h4><ul>
<li>同一般搜索树</li>
</ul>
<h4 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法 ***"></a>插入算法 ***</h4><ul>
<li>考虑情景：要插入一个比根节点大的节点，但是右子树的高度已经比左子树大一了。<ul>
<li>解决方案：旋转。在这个情境中，左单旋，让右子节点变成根节点，原来的根节点变成左子结点，其余不变。然后向右子树插入。</li>
</ul>
</li>
<li>但是要讨论插入的位置，在外侧还是在内侧</li>
</ul>
<p>![屏幕截图 2024-11-01 152713](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-11-01 152713.png)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241101152900625.png" alt="image-20241101152900625"></p>
<ul>
<li>也可这样讲：插入一个新结点后，需要从插入位置沿通向根 的路径回溯，检查各结点左右子树的高度差， 如果发现某点高度不平衡则停止回溯。 </li>
<li>单旋转：外侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一直线A，C，E </li>
<li>双旋转：内侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一折线A，C，D<ul>
<li>左双旋则先左旋再右旋，右双旋反之</li>
</ul>
</li>
<li>*以上以右外侧，右内侧为例，左外侧，左内侧是对称的。 与前面对称的情况：左外侧，左内侧</li>
<li>时间复杂度：对数关系</li>
</ul>
<h4 id="删除算法-1"><a href="#删除算法-1" class="headerlink" title="删除算法"></a>删除算法</h4><ul>
<li>在一般二叉搜索树的删除算法基础上，引入平衡性检查和旋转</li>
<li>每个节点都有一个自己的树高的数据，用以回溯时检查平衡性</li>
</ul>
<h3 id="m路搜索树-1"><a href="#m路搜索树-1" class="headerlink" title="m路搜索树"></a>m路搜索树</h3><ol>
<li>查找算法<ol>
<li>从左到右排好序的，直接找就好了</li>
</ol>
</li>
<li>插入算法<ol>
<li>先查找，找到了就不用插入</li>
<li>找不到：<ol>
<li>找到了要插入的那个位置，如果key值没满，则插入一个key值；如果满了，就在那个位置的分叉上插入一个节点</li>
</ol>
</li>
</ol>
</li>
<li>删除算法<ol>
<li>没有子树：直接删除</li>
<li>一颗子树：找到对接近自己的key来代替自己</li>
<li>两颗子树：找到左或右子树中最接近自己的Key代替</li>
</ol>
</li>
</ol>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><ol>
<li><p>查找算法：直接找</p>
<ol>
<li>树高：$log_m(n+1)&lt;&#x3D;h&lt;&#x3D;1+log_{m&#x2F;2}(n+1)&#x2F;2$</li>
</ol>
</li>
<li><p>插入算法：</p>
<ol>
<li>总是先在叶节点插入</li>
<li>如果节点满了，就把节点从中间key值分裂，并在父节点中插入。对于根节点，把根节点分裂，提出新的根节点。</li>
</ol>
<p>![image-20241105175508641](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-11-05 175449.png)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241105175530052.png" alt="image-20241105175530052"></p>
</li>
<li><p>删除算法：</p>
<ol>
<li><p>所有删除会转化为叶节点的删除</p>
</li>
<li><p>若下溢，先找兄弟节点借，让旁边的key到父节点，从父节点拉下一个key下来</p>
</li>
<li><p>没得借的，说明两个都是最小数（m&#x2F;2-1），就合并。合并后要从父节点拉一个key下来，注意检查父节点下溢问题，要满足B-Tree要求。</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126202223795.png" alt="image-20241126202223795"></p>
</li>
</ol>
</li>
</ol>
<h3 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h3><ol>
<li>插入：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。</li>
<li>删除最大元素：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。</li>
<li>建堆（初始化）：拿到一颗二叉树，有两种初始化方法。但是，完全二叉树的绝大多数节点都集中在底层附近，所以我们选择<strong>下滤</strong>算法，这样绝大多数节点跑的路径短，少数节点跑的路径长。注意，在数组中，下标为i的节点的父节点下标为i&#x2F;2。<ol>
<li>由底向上（更优）：总共有n个节点。叶节点不用下滤，我们从倒数第二层开始，所以索引从n&#x2F;2开始往下走，对每个节点做下滤。做完之后就完成了。</li>
<li>由顶向下：依次插入节点，然后做上滤（也只能上滤）。</li>
</ol>
</li>
<li>排序算法：以数组为物理层为例<ol>
<li>如何不额外创建数组就实现排序呢？当你从最大堆中取出根节点（最大值）后，剩下的节点要重构，这样数组的最后就会空出一格来，这样你可以把最大值放在最后。做到最后，数组就排序好了。</li>
<li>工作流程：<ol>
<li>先建堆</li>
<li>再排序（取出最大值，放在最后）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ol>
<li><p>深度优先DFS</p>
<ol>
<li><p>思想: 从图中某个顶点V0出发,访问它,然后选择一个 V0 邻接到的未被访问的一个邻接点V1出发深度优先遍 历图,当遇到一个所有邻接于它的结点都被访问过了的 结点U时,回退到前一次刚被访问过的拥有未被访问的 邻接点W,再从W出发深度遍历,……直到连通图中的所 有顶点都被访问过为止.</p>
</li>
<li><pre><code class="language-c++">//利用的是邻接矩阵来表示的图
//C++写的
//主过程:
template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS( ) {
    int *visited=new int[NumVertices];
    for ( int i=0; i&lt;NumVertices; i++)
        visited[i]=0;
        DFS(0,visited);//从顶点0开始深度优先搜索
        delete[] visited;//释放visited的空间
    }
//子过程
template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS(int v, visited[]) {
    cout&lt;&lt;GetValue(v)&lt;&lt;&quot;&quot;;
    visited[v]=1;
    int w = GetFirstNeighbor(v);
    while (w!=-1) {
        if(!visited[w])
            DFS(w,visited);//最坏情况，就是每一次w都没有被访问过
        w = GetNextNeighbor(v,w);
    }
    //无论如何，最坏情况下访问次数，也就只能是图中所有边的个数。
    //也就是对邻接矩阵所有边会被扫一遍
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. 用邻接表表示 O(n+e)</span><br><span class="line"></span><br><span class="line">   4. 用邻接矩阵表示 O(n2)</span><br><span class="line"></span><br><span class="line">2. 广度优先BFS</span><br><span class="line"></span><br><span class="line">   - 广度优先算法是一种先进先出的算法，所以常常用队列来实现</span><br><span class="line"></span><br><span class="line">   1. 思想：从图中某顶点V0出发，在访问了V0之后依次访</span><br><span class="line">      问v0的各个未曾访问过的邻接点，然后分别从这些邻接</span><br><span class="line">      点出发广度优先遍历图，直至图中所有顶点都被访问</span><br><span class="line">      到为止.</span><br><span class="line"></span><br><span class="line">   2. 算法同样需要一个辅助数组visited[] 表示顶点是否被访问过. 还需要一个队列,记正在访问的这一层和上一层的顶点. 算法显然是非递归的.</span><br><span class="line"></span><br><span class="line">   3. ```c++</span><br><span class="line">      template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::BFS(int v) &#123;</span><br><span class="line">          //这个算法使用了队列</span><br><span class="line">          int* visited=new int[NumVertices];</span><br><span class="line">          for (int i=0; i&lt;NumVertices; i++)</span><br><span class="line">              visited[i]=0;</span><br><span class="line">          cout &lt;&lt; GetValue(v) &lt;&lt; &quot;&quot;;</span><br><span class="line">      </span><br><span class="line">          //访问结点</span><br><span class="line">          visited[v]=1;</span><br><span class="line">      </span><br><span class="line">          //使用队列来存储顶点</span><br><span class="line">          queue&lt;int&gt; q;</span><br><span class="line">          q.EnQueue(v);</span><br><span class="line">          while(!q.IsEmpty()) &#123;</span><br><span class="line">              v= q.DeQueue();</span><br><span class="line">              int w= GetFirstNeighbor(v);</span><br><span class="line">              while (w!=-1) &#123;</span><br><span class="line">                  if(!visited[w]) &#123;</span><br><span class="line">                      cout&lt;&lt;GetValue(w)&lt;&lt;&quot;&quot;; </span><br><span class="line">                      visited[w]=1;</span><br><span class="line">                      q.EnQueue(w);</span><br><span class="line">                  &#125;</span><br><span class="line">                  w= GetNextNeighbor(v,w);</span><br><span class="line">                  //访问完成一层的结点</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          delete[] visited;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="贪心算法：最小生成树"><a href="#贪心算法：最小生成树" class="headerlink" title="贪心算法：最小生成树"></a>贪心算法：最小生成树</h4><ol>
<li><p>Prim（贪点）</p>
<ol>
<li>优化<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241206153859993.png" alt="image-20241206153859993"><ol>
<li>优化内容：<ol>
<li>使用两个数组Lowcost[ ]、nearvex[ ]</li>
<li>Lowcost[]:存放生成树顶点集合内顶点到生成树外各顶点的边上的当前最小权值</li>
<li>nearvex[]:记录生成树顶点集合外各顶点，距离集合内那个顶点最近。</li>
</ol>
</li>
<li>步骤：<ol>
<li>在Lowcost[ ]中选择nearvex[i]不等于-1,且lowcost[i] 最小的边用v标记它。，则选中的权值最小的边为(nearvex[v],v), 相应的权值为lowcost[v]。 例如在上面图中第一次选中的v&#x3D;5;则边(0，5)，是选中的权值最小的边，相应的权值为lowcost[5]&#x3D;10。 反复做以下工作</li>
<li>将nearvex[v] 改为-1，表示它已加入生成树顶点集合。将边(nearvex[v],v,lowcost[v])加入生成树的边集合。</li>
<li>修改。取lowcost[i]&#x3D;min{lowcost[i],Edge[v][i]},即用生成树顶点集合外各顶 点i到刚加入该集合的新顶点 v的距离(Edge[v][i])与原来它所到生成树顶点 集合中顶点的最短距离lowcost[i]做比较，取距离近的，作为这些集合外顶 点到生成树顶点集合内顶点的最短距离。</li>
<li>如果生成树顶点集合外的顶点i到刚加入该集合新顶点v的距离比原来它 到生成树顶点集合中顶点的最短距离还要近，则修改nearvex[i]: nearvex[i]&#x3D;v 表示生成树外顶点i到生成树的内顶点v 当前距离最短。</li>
</ol>
</li>
<li>O(n^2^)</li>
</ol>
</li>
</ol>
</li>
<li><p>Kruskal（贪边），小细节：用并查集判断回路</p>
<p>1. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Graph&lt;string,<span class="type">float</span>&gt;::<span class="built_in">Kruskal</span>(MinSpanTree&amp;T) &#123;</span><br><span class="line">    <span class="comment">//结果赋值给T</span></span><br><span class="line">    MSTEdgeNode e;</span><br><span class="line">    MinHeap&lt;MSTEdgeNode&gt;<span class="built_in">H</span>(currentEdges);</span><br><span class="line">    <span class="type">int</span> NumVertices=VerticesList.Last , u , v ;</span><br><span class="line">    <span class="function">Ufsets <span class="title">F</span><span class="params">(NumVertices)</span></span>;<span class="comment">//建立n个单元素的连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;NumVertices;u++)</span><br><span class="line">        <span class="keyword">for</span> (v=u<span class="number">+1</span>;v&lt;NumVertices;v++)</span><br><span class="line">            <span class="keyword">if</span>(Edge[u][v]!=MAXINT) &#123;</span><br><span class="line">                e.tail=u;</span><br><span class="line">                e.head=v;</span><br><span class="line">                e.cost=Edge[u][v];</span><br><span class="line">                H.<span class="built_in">insert</span>(e);</span><br><span class="line">                <span class="comment">//完成堆的初始化，将每一条边插入到优先级队列中去</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;<span class="comment">//生成树边计数</span></span><br><span class="line">    <span class="keyword">while</span>(count&lt;NumVertices) &#123;</span><br><span class="line">        H.<span class="built_in">RemoveMin</span>(e);</span><br><span class="line">        u=F.<span class="built_in">Find</span>(e.tail);<span class="comment">//找到并查集的树根</span></span><br><span class="line">        v=F.<span class="built_in">Find</span>(e.head);<span class="comment">//找到并查集的树根</span></span><br><span class="line">        <span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">            <span class="comment">//并查集做回边检测，在同一个并查集中就是一个回边，不然就不是</span></span><br><span class="line">            F.<span class="built_in">union</span>(u,v);</span><br><span class="line">            T.<span class="built_in">Insert</span>(e);</span><br><span class="line">            count++;<span class="comment">//计数已经查找出来的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最坏的情况时所有的边都被访问一次，比如目标边是最后一条边。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>算法分析：<ol>
<li>建立e条边的最小堆<ol>
<li>检测邻接矩阵O(n2)</li>
<li>每插入一条边，执行一次 fiterup() 算法：log2e 所以，总的建堆时间为O(elog2e)</li>
</ol>
</li>
<li>构造最小生成树时<ol>
<li>e次出堆操作：每一次出堆，执行一次filterdown(), 总时间为O(elog2e)<ul>
<li>没有考虑悬挂问题</li>
</ul>
</li>
<li>2e次find操作：O(elog2n)，树高是log2n<ul>
<li>从头开始生成，两个高为1的树，做union，才有高度为2的树</li>
<li>两个高为2的树，做union，才有高度为3的树</li>
<li>树的高度最坏情况下是log2n，当切仅当第一个二叉树</li>
</ul>
</li>
<li>n-1次union操作：O(n)</li>
<li>所以，总的计算时间为O(elog2e+elog2n+n2+n)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="笔记-·-代码集"><a href="#笔记-·-代码集" class="headerlink" title="笔记 · 代码集"></a>笔记 · 代码集</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li><p>ListNode：代表结点的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;   </span><br><span class="line">    object element;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode( object theElement) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode( object theElement, ListNode n) &#123;</span><br><span class="line">        element = theElement; </span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedListItr：代表游标(指针）位置的类。这里很重要！在Java中已经有一个封装好的类了，不要再自己用指针了。?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListItr</span> &#123;</span><br><span class="line">    LinkedListItr( ListNode  theNode) &#123;</span><br><span class="line">        current = theNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPastEnd</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> current == <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> object <span class="title function_">retrieve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获得当前节点的数据</span></span><br><span class="line">        <span class="keyword">return</span> isPastEnd( ) ? <span class="literal">null</span> : current.element; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">advance</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( ! isPastEnd( ) ) current = current.next; </span><br><span class="line">    &#125;</span><br><span class="line">    ListNode current; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList：代表表本身的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode header;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">( )</span> &#123;<span class="comment">//这里是含有表头节点的单链表，如果不带表头的话，应该是heder = null</span></span><br><span class="line">        header = <span class="keyword">new</span> <span class="title class_">ListNode</span>( <span class="literal">null</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> header.next = = <span class="literal">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeEmpty</span><span class="params">( )</span> &#123;</span><br><span class="line">        header.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向头指针的Itr</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">zeroth</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( header );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指向第一个项的Itr</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">first</span><span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( header.next );</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">find</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> LinkedListItr <span class="title function_">findPrevious</span><span class="params">( object x )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">( object x, LinkedListItr p )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LinkedListItr <span class="title function_">find</span> <span class="params">(object x)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">itr</span> <span class="operator">=</span> header.next;</span><br><span class="line">    <span class="keyword">while</span> ( itr != <span class="literal">null</span> &amp;&amp; !itr.element.equals( x ))</span><br><span class="line">        itr = itr.next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedListItr</span>( itr );</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


</li>
<li><p>移除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">( object x )</span> &#123;</span><br><span class="line">    <span class="type">LinkedListItr</span> <span class="variable">p</span> <span class="operator">=</span> findprevious( x );</span><br><span class="line">    <span class="keyword">if</span>( p.current.next != <span class="literal">null</span> )</span><br><span class="line">        p.current.next = p.current.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ol>
<li><p>约瑟夫问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">w = m;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;= n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=w-<span class="number">1</span>; j++) rear = rear.link;</span><br><span class="line">    <span class="keyword">if</span> (i = = <span class="number">1</span>) &#123; </span><br><span class="line">        head = rear.link ; p = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        p.link = rear.link;</span><br><span class="line">        p = rear.link;</span><br><span class="line">    &#125;</span><br><span class="line">    rear.link = p.link;</span><br><span class="line">    &#125;</span><br><span class="line">    P.link = rear; rear.link = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表</p>
<ol>
<li>静态链表是由数组实现的单链表。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt3/im3-16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt3/im3-16.png" alt="img"></a></p>
<ol>
<li>在系统中，对于系统来说，内存时这样子的被系统管理的。</li>
<li>如果next是0，那么相当于null</li>
</ol>
</li>
</ol>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(object x)</span>&#123;</span><br><span class="line">    topOfStack = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x, topOfStack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">top</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> topOfStack.element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Underflow &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Underflow</span>();</span><br><span class="line">    topOfStack = topOfStack.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">topAndPop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">object</span> <span class="variable">topItem</span> <span class="operator">=</span> topOfstack.element;</span><br><span class="line">    topOfStack = topOfStack.next;</span><br><span class="line">    <span class="keyword">return</span> topItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StackAr</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StackAr</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;   </span><br><span class="line">    theArray = <span class="keyword">new</span> <span class="title class_">object</span> [capacity];</span><br><span class="line">    topOfStack = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(object x)</span> <span class="keyword">throws</span> Overflow &#123;</span><br><span class="line">    <span class="keyword">if</span> (isfull())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Overflow</span>();</span><br><span class="line">    theArray[++topOfStack] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> theArray[ topOfStack ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> <span class="keyword">throws</span> Underflow &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Underflow</span>( );</span><br><span class="line">    theArray[ topOfStack-- ] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">topAndPop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">object</span> <span class="variable">topItem</span> <span class="operator">=</span> top( );</span><br><span class="line">    theArray[ topOfStack-- ] = <span class="literal">null</span>;</span><br><span class="line">    reurn topItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol>
<li>括号匹配</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxlength = <span class="number">100</span>; <span class="comment">// max expression length</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="type">char</span> *expr)</span> </span>&#123;</span><br><span class="line">    <span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(Maxlength)</span></span>;</span><br><span class="line">    <span class="type">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = l; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            s.<span class="built_in">Add</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.<span class="built_in">Delete</span>(j);<span class="comment">//进栈的是括号的位置</span></span><br><span class="line">                cout &lt;&lt; j &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt; endl;&#125;</span><br><span class="line">            <span class="built_in">catch</span> (OutOfBounds)</span><br><span class="line">                &#123;cout &lt;&lt; <span class="string">&quot;No match for right parenthesis&quot;</span> &lt;&lt; <span class="string">&quot;at&quot;</span>&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !s.<span class="built_in">IsEmpty</span> ())&#123;</span><br><span class="line">        s.<span class="built_in">Delete</span>(j);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;No match for left parenthesis at &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> expr[MaxLength];</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;type an expression of length at most&quot;</span> &lt;&lt;MaxLength&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(expr, MaxLength);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the pairs of matching parentheses in&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;are&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printMatcnedPairs</span>(expr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂度O(n)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>表达式求值</p>
<ul>
<li>中缀表达式变成后缀表达式</li>
<li>根据操作的<strong>元数</strong>来决定弹出几个来进行计算</li>
<li>分量是指除了运算符以外的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Infix</span> &#123;</span><br><span class="line">    <span class="comment">// 优先级映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; precedence = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        precedence.put(<span class="string">&quot;+&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;-&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;*&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;/&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        precedence.put(<span class="string">&quot;(&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主方法：计算中缀表达式的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">infix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="comment">// Step 1: 中缀转后缀</span></span><br><span class="line">        List&lt;String&gt; postfix = infixToPostfix(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2: 计算后缀表达式的值</span></span><br><span class="line">        <span class="keyword">return</span> evaluatePostfix(postfix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: 将中缀表达式转为后缀表达式</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">infixToPostfix</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                output.add(token);  <span class="comment">// 如果是数字，直接加入输出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                stack.push(token);  <span class="comment">// 左括号直接入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; !stack.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    output.add(stack.pop());  <span class="comment">// 弹出栈顶操作符直到遇到左括号</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();  <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; precedence.get(stack.peek()) &gt;= precedence.get(token)) &#123;</span><br><span class="line">                    output.add(stack.pop());  <span class="comment">// 弹出栈顶优先级更高的操作符</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(token);  <span class="comment">// 将当前操作符压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后将栈中剩余的操作符添加到输出中</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            output.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Double.parseDouble(token);  <span class="comment">// 尝试转换为数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是操作符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOperator</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> precedence.containsKey(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: 计算后缀表达式的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="title function_">evaluatePostfix</span><span class="params">(List&lt;String&gt; postfix)</span> &#123;</span><br><span class="line">        Stack&lt;Float&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String token : postfix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stack.push(Float.parseFloat(token));  <span class="comment">// 操作数直接压入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOperator(token)) &#123;</span><br><span class="line">                <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> stack.pop();  <span class="comment">// 弹出右操作数</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> stack.pop();  <span class="comment">// 弹出左操作数</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        result = a + b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        result = a - b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        result = a * b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        result = a / b;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stack.push(result);  <span class="comment">// 将运算结果压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后栈中的唯一元素即为结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>中缀转后缀</p>
<ol>
<li><p>基本想法:</p>
<ul>
<li>遇到操作数(运算分量)直接输出。</li>
<li>遇到操作符:当前的操作符一定是不输出的，如果当前运算符低于栈顶预算符优先级低，则输出，一直到当前运算符高于栈顶运算符优先级</li>
</ul>
</li>
<li><p>括号比较麻烦:需要单独处理</p>
<ul>
<li>左半括号需要压栈，也就是只要保证任何一个优先级低就行，也就是我们希望左半括号永远不要输出出来，在遇到右半括号的时候出去左半括号。</li>
</ul>
</li>
<li><p>每一个符号都有两个优先级，加减乘除的两个优先级都是一样的，而括号的优先级不是。</p>
<ul>
<li>经过计算和推断，我们可以得知一个优先级体系是不能满足</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">我们来一步一步地将表达式 3 - 9 + 3 * 4 + 2 - 1 转换成后缀表达式，并且根据这个后缀表达式来求值。</span><br><span class="line"></span><br><span class="line">步骤 1：中缀转后缀</span><br><span class="line">中缀表达式：3 - 9 + 3 * 4 + 2 - 1</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line">操作符栈：[]（空）</span><br><span class="line">输出队列：[]</span><br><span class="line">逐步处理：</span><br><span class="line">处理数字 3：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[]</span><br><span class="line">输出队列：[3]</span><br><span class="line">处理操作符 -：</span><br><span class="line"></span><br><span class="line">是操作符，压入栈。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3]</span><br><span class="line">处理数字 9：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9]</span><br><span class="line">处理操作符 +：</span><br><span class="line"></span><br><span class="line">当前栈顶是 -，其优先级与 + 相同，先将 - 弹出并加入输出队列，再将 + 压入栈。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -]</span><br><span class="line">处理数字 3：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3]</span><br><span class="line">处理操作符 *：</span><br><span class="line"></span><br><span class="line">* 的优先级高于 +，直接压入栈。</span><br><span class="line">操作符栈：[+, *]</span><br><span class="line">输出队列：[3, 9, -, 3]</span><br><span class="line">处理数字 4：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+, *]</span><br><span class="line">输出队列：[3, 9, -, 3, 4]</span><br><span class="line">处理操作符 +：</span><br><span class="line"></span><br><span class="line">* 的优先级高于 +，所以先将 * 弹出并加入输出队列，再将 + 压入栈。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *]</span><br><span class="line">处理数字 2：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[+]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2]</span><br><span class="line">处理操作符 -：</span><br><span class="line"></span><br><span class="line">+ 的优先级与 - 相同，先将 + 弹出并加入输出队列，再将 - 压入栈。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +]</span><br><span class="line">处理数字 1：</span><br><span class="line"></span><br><span class="line">是操作数，直接加入输出队列。</span><br><span class="line">操作符栈：[-]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +, 1]</span><br><span class="line">结束：</span><br><span class="line"></span><br><span class="line">最后将栈中的操作符 - 弹出并加入输出队列。</span><br><span class="line">操作符栈：[]</span><br><span class="line">输出队列：[3, 9, -, 3, 4, *, 2, +, 1, -]</span><br><span class="line">后缀表达式：[3, 9, -, 3, 4, *, 2, +, 1, -]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">LinkedQueue</span> &#123;<span class="comment">//T是任意的类型</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkedQueue</span>()&#123;front=back=<span class="number">0</span>;&#125;</span><br><span class="line">        ~<span class="built_in">LinkedQueue</span>();<span class="comment">//无法调用析构函数，在delete对象的时候可以直接释放</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> ((front)?<span class="literal">false</span>:<span class="literal">true</span>);&#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">First</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">Last</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="function">LinkedQueue&lt;T&gt;&amp;<span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">        <span class="function">LinkedQueue&lt;T&gt;&amp; <span class="title">Delete</span><span class="params">(T&amp; x)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt;*front;</span><br><span class="line">        Node&lt;T&gt;*back;</span><br><span class="line">    &#125;;       </span><br></pre></td></tr></table></figure>

<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ol>
<li><p>杨辉三角</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YANGHUI</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">makeEmpty</span>();</span><br><span class="line">    q.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n;i++) &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">10</span>-i;k++)</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">Enqueue</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">+2</span>;j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">Dequeue</span>();</span><br><span class="line">            q.<span class="built_in">Enqueue</span>(s+t);</span><br><span class="line">            s = t;</span><br><span class="line">            <span class="comment">//0不需要进行打印</span></span><br><span class="line">            <span class="keyword">if</span> (j!=i<span class="number">+2</span>) cout&lt;&lt; s &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环移动？</p>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="左子女右兄弟"><a href="#左子女右兄弟" class="headerlink" title="左子女右兄弟"></a>左子女右兄弟</h3><ul>
<li><p>用于遍历森林</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    TreeNode *firstchild, *nextsibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    TreeNode *root, *c</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 插入算法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">void</span> Tree&lt;T&gt;::<span class="built_in">Insertchild</span>(T value)&#123;</span><br><span class="line">    TreeNode&lt;T&gt;* newnode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;T&gt;(value);</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;firstchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current-&gt;firstchild = newnode;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        TreeNode&lt;T&gt; *p = current-&gt;firstchild;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;nextsibling != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;nextsibling;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;nextsibling = newnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li><p>中序（利用栈，非递归）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现非递归中序遍历</span></span><br><span class="line"><span class="comment">//非递归使用stack实现中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BinaryNode &lt;T&gt;*t)</span></span>&#123;  </span><br><span class="line">    Stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="comment">//无条件进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//一直进行压栈，直到最左下部分</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。</span></span><br><span class="line">            p = s.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            p = p-&gt;Right;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>后序（利用栈，非递归）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="comment">//结点的实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StkNode</span> &#123;</span><br><span class="line">    BinaryNode &lt;T&gt; * ptr;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(BinaryNode &lt;T&gt; * t)</span> </span>&#123;</span><br><span class="line">    Stack &lt;StkNode&lt;T&gt;&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    StkNode&lt;T&gt; Cnode;</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">//优先访问到最左下</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Cnode.ptr = p;</span><br><span class="line">            Cnode.tag = <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最左下结点出栈</span></span><br><span class="line">        Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">        p = Cnode.ptr;</span><br><span class="line">        <span class="keyword">while</span> (Cnode.tag == <span class="number">1</span>)<span class="comment">//从右子树回来 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果已经被访问一次了才进行输出</span></span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">                Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">                p = Cnode.ptr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//访问结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        Cnode.tag = <span class="number">1</span>;<span class="comment">//从左子树遍历完，而右子树还没有动。</span></span><br><span class="line">        s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">        p = p-&gt;Right;<span class="comment">//从左子树回来</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<ul>
<li>另外，非二叉树：<ul>
<li>先根：与原树的左子女右兄弟表示法的先序一致</li>
<li>后根：与原树的左子女右兄弟表示法的中序一致</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现层次访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; q=<span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    q.<span class="built_in">add</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Node temp = q.<span class="built_in">poll</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(temp.value);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=null) q.<span class="built_in">add</span>(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=null) q.<span class="built_in">add</span>(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>森林的遍历</p>
<ol>
<li>将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连</li>
<li><strong>先根次序遍历：</strong> <ol>
<li>访问F的第一棵树的根 </li>
<li>按先根遍历第一棵树的子树森林 </li>
<li>按先根遍历其它树组成的森林</li>
<li>等于二叉树的先序</li>
</ol>
</li>
<li><strong>中根次序遍历：</strong> <ol>
<li>按中根遍历第一棵树的子树森林 </li>
<li>访问F的第一棵树的根 </li>
<li>按中根遍历其它树组成的森林</li>
<li>等于二叉树的中序</li>
</ol>
</li>
</ol>
<ul>
<li><strong>后根次序遍历：</strong> <ol>
<li>按后根遍历第一棵树的子树森林 </li>
<li>按后根遍历其它树组成的森林 </li>
<li>访问F的第一棵树的根</li>
<li>等于二叉树的后序</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="根据前中后序表达式建树"><a href="#根据前中后序表达式建树" class="headerlink" title="根据前中后序表达式建树"></a>根据前中后序表达式建树</h3><ol>
<li><p>根据先序遍历和中序遍历</p>
<ul>
<li><p>先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树</p>
</li>
<li><pre><code class="language-java">// 根据先序遍历和中序遍历构建二叉树
    public static BinTree CreateBT(char[] pres, char[] ins) {
        // 如果先序或中序为空，则返回null
        if (pres.length == 0 || ins.length == 0) {
            return null;
        }

        // 构建根节点，先序遍历的第一个元素是根节点
        BinTree tree = new BinTree();
        tree.element = pres[0];

        // 查找根节点在中序遍历中的位置
        int i = 0;
        while (i &lt; ins.length &amp;&amp; ins[i] != pres[0]) {
            i++;
        }

        // 如果根节点存在
        if (i &lt; ins.length) {
            // 中序遍历中，根节点左侧是左子树的元素，右侧是右子树的元素
            // 递归构建左子树和右子树
            tree.left = CreateBT(Arrays.copyOfRange(pres, 1, i + 1), Arrays.copyOfRange(ins, 0, i));
            tree.right = CreateBT(Arrays.copyOfRange(pres, i + 1, pres.length), Arrays.copyOfRange(ins, i + 1, ins.length));
        }

        return tree;
    }
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 根据中序遍历和后序遍历</span><br><span class="line"></span><br><span class="line">   + 后序遍历树根在尾部，思路一致</span><br><span class="line">3. 根据先序遍历和后序遍历</span><br><span class="line"></span><br><span class="line">   + **单独依赖先序和后序遍历，无法唯一确定一棵二叉树**。如果只给出先序和后序遍历的结果，存在多个可能的二叉树结构。</span><br><span class="line"></span><br><span class="line">### 线索数</span><br><span class="line"></span><br><span class="line">1. 按中序遍历中序线索树</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   //使用是current来记录下来当前节点</span><br><span class="line">   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::First() &#123;</span><br><span class="line">       while (current-&gt;leftThread==0)&#123;</span><br><span class="line">           current = current-&gt;leftchild;</span><br><span class="line">       &#125;</span><br><span class="line">       return current;//找中序遍历的第一个节点</span><br><span class="line">   &#125;</span><br><span class="line">   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::Next() &#123;</span><br><span class="line">       ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;//可能是右子树的根节点，也可能是右链 </span><br><span class="line">       if(current-&gt;rightThread==0)</span><br><span class="line">           while(p-&gt;leftThread==0)&#123;</span><br><span class="line">               //如果有右子树就要搜索到最左下部分</span><br><span class="line">               p=p-&gt;leftchlid;</span><br><span class="line">           &#125;</span><br><span class="line">       current=p;</span><br><span class="line">   &#125;</span><br><span class="line">   template&lt;class Type&gt; void ThreadInorderIterator&lt;Type&gt;:: Inorder() &#123; </span><br><span class="line">       ThreadNode&lt;Type&gt; *p;</span><br><span class="line">       for ( p=Frist(); p!=NULL; p=Next()) </span><br><span class="line">           cout&lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>构造中序线索树</p>
<ul>
<li><p>对已存在的一棵二叉树建立中序线索树</p>
</li>
<li><p>在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">Inthread</span><span class="params">(threadNode&lt;T&gt; * T)</span> &#123;</span><br><span class="line">    stack &lt;threadNode &lt;T&gt;*&gt; s(<span class="number">10</span>)</span><br><span class="line">    ThreadNode &lt;T&gt; *p = T ;</span><br><span class="line">    ThreadNode &lt;T&gt; *pre = NULL;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找到最左下部分的</span></span><br><span class="line">        <span class="keyword">while</span> (p!=NULL) &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p = p -&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始弹出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!s.IsEmpty())&#123;</span><br><span class="line">            p = s.pop;</span><br><span class="line">            <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">                <span class="comment">//添加的代码，在这时候处理pre</span></span><br><span class="line">                <span class="keyword">if</span> (pre -&gt;rightchild == NULL)&#123;</span><br><span class="line">                    pre -&gt;rightchild = p;  </span><br><span class="line">                    pre -&gt;rightthread = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理p</span></span><br><span class="line">                <span class="keyword">if</span>( p -&gt; leftchild == NULL) &#123;</span><br><span class="line">                    p -&gt; leftchild = pre;</span><br><span class="line">                    p -&gt;leftthread = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="comment">//添加的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = p ; <span class="comment">//这里更新了pre</span></span><br><span class="line">            p = p -&gt; rightchild ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//for </span></span><br><span class="line">&#125;<span class="comment">//建议把pre和p存储成全局变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="霍夫曼树-1"><a href="#霍夫曼树-1" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><ol>
<li><p>算法：</p>
<ol>
<li><p>从m个权值中找出两个最小值W1，W2构成</p>
<p>W &#x3D; W1 + W2表示通过该节点的频度</p>
</li>
<li><p>然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解</p>
</li>
</ol>
<ul>
<li>当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15</li>
</ul>
</li>
</ol>
<h3 id="搜索树-1"><a href="#搜索树-1" class="headerlink" title="搜索树"></a>搜索树</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><ol>
<li><p>二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：</p>
<ul>
<li>每一个元素有key值（关键码、主码），key值独一无二不重复</li>
<li>一个树的左子树的关键字小于根中的关键字</li>
<li>一个树的右子树的关键字大于根中的关键字</li>
<li>根的左右子树还是二叉搜索树</li>
</ul>
</li>
<li><p>二叉搜索树可以在很大的数据量下，快速完成增删查改</p>
</li>
<li><p>索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1</p>
</li>
<li><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryNode 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    BinaryNode( Comparable theElement ) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>, <span class="literal">null</span> );<span class="comment">//调用本类中的其他构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;</span><br><span class="line">        element = <span class="type">theElement</span></span><br><span class="line">        <span class="variable">left</span> <span class="operator">=</span> lt;</span><br><span class="line">        right = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某元素</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">find</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">//Match </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找值最小的结点，找最大同理，往右找</span></span><br><span class="line"><span class="comment">//使用递归查找结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">( BinaryNode t )</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> findMin( t.left );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代找最小结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">(BinaryNode t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数值插入固定位置的算法</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">insert</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="comment">//先查找一次，如果找到了就不用进行查找</span></span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>( x, <span class="literal">null</span>, <span class="literal">null</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = insert( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = insert( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> ;<span class="comment">//duplicate; do nothing</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compareTo()方法如果小于返回负数，大于返回正数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果结点本身不在树内，那么不需要删除</span></span><br><span class="line"><span class="comment"> * 如果结点本身在树里面，删除需要分类</span></span><br><span class="line"><span class="comment"> *  1.无子树:删除叶节点</span></span><br><span class="line"><span class="comment"> *  2.一颗子树:直接连接</span></span><br><span class="line"><span class="comment"> *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">remove</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = remove( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = remove( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span> ) &#123;</span><br><span class="line">        t.element = findMin( t.right ).element;<span class="comment">//把右树最小的复制给t</span></span><br><span class="line">        t.right = remove( t.element , t.right );<span class="comment">//递归的删除</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t = ( t.left != <span class="literal">null</span> ) ? t.left : t.right;<span class="comment">//一颗子树的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</p>
<ul>
<li>Best Case：$O(log_2n)$</li>
<li>最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去</li>
</ul>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li><p>插入（进堆，上滤）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: Insert(const T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize= =MaxSize) <span class="keyword">throw</span> NoMem(); </span><br><span class="line">    <span class="type">int</span> i= ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; x&gt;heap[i/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">//0不使用</span></span><br><span class="line">        heap[i]=heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不必每次都进行完全交换</span></span><br><span class="line">        i/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>删除（出堆、下滤）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: DeleteMax(T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize==<span class="number">0</span>) <span class="keyword">throw</span> OutOfBounds(); </span><br><span class="line">    x = heap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0无存储，这个就是root结点</span></span><br><span class="line">    T y=heap[CurrentSize--];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;<span class="comment">//i标向树根</span></span><br><span class="line">    ci=<span class="number">2</span>;<span class="comment">//ci先标到左子树</span></span><br><span class="line">    <span class="keyword">while</span>(ci&lt;=CurrentSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci+<span class="number">1</span>])<span class="comment">//如果ci未越界，并且左子树的值小于右子树的值。</span></span><br><span class="line">            ci++;<span class="comment">//转向右子树</span></span><br><span class="line">        <span class="keyword">if</span>(y&gt;=heap[ci]) <span class="keyword">break</span>;</span><br><span class="line">        heap[i]=heap[ci];</span><br><span class="line">        i=ci;</span><br><span class="line">        ci*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=y;<span class="comment">//y是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>线性时间建堆</p>
<ul>
<li><p>步骤：</p>
<ol>
<li>先将n个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意是对每个子树进行递归处理</span></span><br><span class="line">Template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span> MaxHeap&lt;T&gt;::<span class="built_in">Initialize</span> (T a[],<span class="type">int</span> size,<span class="type">int</span> ArraySize) &#123; </span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap=a;</span><br><span class="line">    CurrentSize=Size;</span><br><span class="line">    MaxSize=ArraySize;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=CurrentSize/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        T y=heap[i];</span><br><span class="line">        <span class="type">int</span> c=<span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c<span class="number">+1</span>])</span><br><span class="line">                c++;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[c/<span class="number">2</span>] = heap[c];</span><br><span class="line">            c*=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到其子节点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap[c/<span class="number">2</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)</p>
</li>
</ul>
</li>
</ol>
<h2 id="图-1"><a href="#图-1" class="headerlink" title="图"></a>图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNumEdges = <span class="number">50</span><span class="comment">// 最大边数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxNumVertices = <span class="number">10</span><span class="comment">//最大顶点数 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> NameType, <span class="keyword">class</span> DistType&gt; <span class="keyword">class</span> Graph&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        SeqList&lt;NameType&gt; <span class="built_in">VerticesList</span>(MaxNumVertices) <span class="comment">//顶点表</span></span><br><span class="line">        DistType Edge [MaxNumVertices] [MaxNumVertices]  <span class="comment">//邻接矩阵，一定是方阵</span></span><br><span class="line">        <span class="type">int</span> CurrentEdges;<span class="comment">//当前边数</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">FindVertex</span> <span class="params">(Seqlist &lt;NameType&gt; &amp;L; <span class="type">const</span>  NameType &amp;Vertex)</span></span></span><br><span class="line"><span class="function">            </span>&#123;<span class="keyword">return</span> L.<span class="built_in">Find</span>(Vertex);&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetVertexPos</span> <span class="params">(<span class="type">const</span> NameTyoe &amp;Vertex)</span></span></span><br><span class="line"><span class="function">            </span>&#123;<span class="keyword">return</span> <span class="built_in">FindVertex</span>(VerticesList);&#125;<span class="comment">// 给出了顶点Vertex在图中的位置</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Graph</span> (<span class="type">const</span> <span class="type">int</span> sz=MaxNumEdges); </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GraphEmpty</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> VerticesList.<span class="built_in">IsEmpty</span>();&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GraphFull</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> VerticesList.<span class="built_in">IsFull</span>() || CurrentEdges= =MaxNumEdges;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">NumberofVertices</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> VerticesList.last;&#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">NumberofEdges</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> CurrentEdges;&#125;</span><br><span class="line">        <span class="function">NameType <span class="title">Getvalue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123;<span class="keyword">return</span>  i&gt;=<span class="number">0</span> &amp;&amp; i&lt;VerticesList.last ? VerticesList.data[i] :  <span class="literal">NULL</span>;&#125; </span><br><span class="line">        <span class="function">DistType <span class="title">Getweight</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetFirstNeighbor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v)</span></span>; </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetNextNeighbor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InsertVertex</span><span class="params">(<span class="type">const</span> NameType &amp; Vertex)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InsertEdge</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2, DistType weight)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">const</span> <span class="type">int</span> v)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(cosnt <span class="type">int</span> v1,<span class="type">const</span> <span class="type">int</span> v2)</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表的声明</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Defaultsize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">NameType</span>，<span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">class</span> <span class="title class_">Graph</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;       <span class="comment">//边的定义 </span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &lt;NameType,DistType&gt;;<span class="comment">//友元函数</span></span><br><span class="line">    <span class="type">int</span> dest;<span class="comment">//边的另一顶点在顶点表中的位置 </span></span><br><span class="line">    DistType cost;<span class="comment">//边上的权</span></span><br><span class="line">    Edge&lt;DistType&gt; *link;<span class="comment">//下一条边的链指针</span></span><br><span class="line">    <span class="built_in">Edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> D,DistType C):<span class="built_in">dest</span>(D),<span class="built_in">cost</span>(C),<span class="built_in">link</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> operate != (<span class="type">const</span> Edge&lt;DistType&gt; &amp;E) <span class="type">const</span> &#123;<span class="keyword">return</span> dest != E.dest; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">DistType</span>&gt; <span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&lt;DistType&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&lt;NameType, DistType&gt;; </span><br><span class="line">    NameType data;<span class="comment">//顶点名字</span></span><br><span class="line">    Edge&lt;DistType&gt; *adj;<span class="comment">//出边表头指针</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> edgesAccepted;</span><br><span class="line">    DisjSet s;</span><br><span class="line">    priorityQueue h;</span><br><span class="line">    Vertex u, v;</span><br><span class="line">    SetType uset, vset;</span><br><span class="line">    Edge e;</span><br><span class="line">    </span><br><span class="line">    h = readGraphIntoHeapArray( );</span><br><span class="line">    h.buildHeap() ;</span><br><span class="line">    s = <span class="keyword">new</span> <span class="title class_">DisjSet</span>( NUM_VERTICES );</span><br><span class="line"></span><br><span class="line">    edgesAccepted = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>( edgesAccepted &lt; NUM_VERTICES – <span class="number">1</span> )&#123;</span><br><span class="line">        e = h.deleteMin() ;<span class="comment">//Edge e = (u, v)</span></span><br><span class="line">        uset = s. find(u);</span><br><span class="line">        vset = s.find(v);</span><br><span class="line">        <span class="keyword">if</span>( uset != vset ) &#123;</span><br><span class="line">            edgesAccepted++;</span><br><span class="line">            s.union( uset, vset );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> graph&lt;string,<span class="type">float</span>&gt;::<span class="built_in">Prim</span>(MinSpanTree&amp;T)&#123;</span><br><span class="line">    <span class="type">int</span> NumVertices=VerticesList.last; </span><br><span class="line">    <span class="type">float</span>*lowcost=<span class="keyword">new</span> <span class="type">float</span>[NumVertices]; </span><br><span class="line">    <span class="type">int</span> * nearvex=<span class="keyword">new</span> <span class="type">int</span>[NumVertices];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt; NumVertices;i++) &#123;</span><br><span class="line">        lowcost[i] = Edge[<span class="number">0</span>][i];<span class="comment">//0到其他所有边的权值</span></span><br><span class="line">        nearvex[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nearvex[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    MSTEdgeNode e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt; NumVertices; i++) &#123;</span><br><span class="line">        <span class="type">float</span> min=MAXINT;</span><br><span class="line">        <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j=<span class="number">1</span>; j&lt; NumVertices; j++)</span><br><span class="line">            <span class="keyword">if</span>(nearvex[j]!=<span class="number">-1</span>&amp;&amp;lowcost[j]&lt;min) &#123;</span><br><span class="line">                v=j;</span><br><span class="line">                min=lowcost[j];</span><br><span class="line">            &#125; <span class="comment">//for j,  选择最小的边</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v) &#123;</span><br><span class="line">            e.tail=nearvex[v];</span><br><span class="line">            e.head=v;</span><br><span class="line">            e.cost=lowcost[v];</span><br><span class="line">            T.<span class="built_in">Insert</span>(e);</span><br><span class="line">            <span class="comment">//添加边进入最小生成树中去</span></span><br><span class="line">            nearvex[v]=<span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt; NumVertices; j++)</span><br><span class="line">                <span class="keyword">if</span>( nearvex[j]!=<span class="number">-1</span> &amp;&amp; Edge[v][j]&lt;lowcost[j] ) &#123;</span><br><span class="line">                    lowcost[j]=Edge[v][j];</span><br><span class="line">                    nearvex[j]=v;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//for i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">int</span> <span class="variable">NumVertices</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//大于所有边的权重的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> Edge[NumVertices][NumVertices]; </span><br><span class="line">        <span class="type">int</span> dist[NumVertices];</span><br><span class="line">        <span class="type">int</span> path[NumVertices];</span><br><span class="line">        <span class="type">int</span> S[NumVertices];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">shortestpath</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Graph::shortestpath(<span class="type">int</span> n,<span class="type">int</span> v) &#123;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="comment">//v为当前节点，dist数组是表示距离的数组</span></span><br><span class="line">        <span class="comment">//遍历n次</span></span><br><span class="line">        dist[i] = Edge[v][i];</span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( i!=v &amp;&amp; dist[i]&lt; MAXNUM )</span><br><span class="line">            path[i]= v;<span class="comment">//如果可达，则用path数组记录下路径</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            path[i]=-<span class="number">1</span>;<span class="comment">//如果不可达，则用path数组记录下不可达(-1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        s[v]=<span class="number">1</span>;</span><br><span class="line">        dist[v]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示访问过当前节点，并且距离为0</span></span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">float</span> min=MAXNUM;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> v;</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  j &lt; n;  j++)</span><br><span class="line">                <span class="keyword">if</span>( !s[j] &amp;&amp; dist[j]&lt;min ) &#123;</span><br><span class="line">                    <span class="comment">//如果结点j还没有访问过，并且dist[j]小于最小值</span></span><br><span class="line">                    u = j;</span><br><span class="line">                    min = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            s[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> w=<span class="number">0</span>; w&lt;n; w++)</span><br><span class="line">                <span class="comment">// 若 dist[u] + Edge[u][w] &lt; dist[w]，则说明通过 u 更新路径更短，更新 dist[w] 和 path[w]。</span></span><br><span class="line">                <span class="keyword">if</span>( !s[w] &amp;&amp; Edge[u][w] &lt; MAXNUM &amp;&amp; dist[u]+Edge[u][w] &lt; dist[w]) &#123;</span><br><span class="line">                    <span class="comment">//dist[u]就是起点到u的距离，下面是关键条件</span></span><br><span class="line">                    dist[w]=dist[u]+Edge[u][w];</span><br><span class="line">                    path[w]=u;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><ol>
<li><p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 迭代版的归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.length;</span><br><span class="line">        <span class="type">int</span>[] tempList = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次将len扩展，逐步合并</span></span><br><span class="line">        <span class="keyword">while</span> (len &lt; n) &#123;</span><br><span class="line">            mergePass(list, tempList, len);</span><br><span class="line">            len *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并函数，合并两个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergePass</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span>[] tempList, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以len为子数组的大小，进行合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + len &lt; n) &#123;</span><br><span class="line">            merge(list, tempList, i, i + len, Math.min(i + <span class="number">2</span> * len - <span class="number">1</span>, n - <span class="number">1</span>));<span class="comment">//这里的数字看一下</span></span><br><span class="line">            i += <span class="number">2</span> * len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理剩余的部分</span></span><br><span class="line">        <span class="keyword">if</span> (i + len &lt; n) &#123;</span><br><span class="line">            merge(list, tempList, i, i + len, n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若后半部分已经是有序的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                tempList[j] = list[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将临时数组的内容复制回原数组</span></span><br><span class="line">        System.arraycopy(tempList, <span class="number">0</span>, list, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序区间的函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span>[] tempList, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>, k = left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个子数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i] &lt;= list[j]) &#123;</span><br><span class="line">                tempList[k++] = list[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tempList[k++] = list[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制剩余的部分</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tempList[k++] = list[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            tempList[k++] = list[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a )</span> &#123;</span><br><span class="line">    Comparable [ ] tmpArray = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    mergeSort( a, tmpArray, <span class="number">0</span>, a.length – <span class="number">1</span> );</span><br><span class="line">&#125;                            </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> left, <span class="type">int</span> right )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; right ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmparray, left, center );</span><br><span class="line">        mergeSort(a, tmpArray, center + <span class="number">1</span>, right );</span><br><span class="line">        merge( a, tmpArray, left, center + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd )</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> rightPos – <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> rightEnd – leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )</span><br><span class="line">        <span class="keyword">if</span>( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= <span class="number">0</span> )</span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ rightPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd )</span><br><span class="line">        tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( rightpos &lt;= rightEnd)</span><br><span class="line">        tmpArray[ tmpPos++] = a[ rightpos++ ];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; i++, rightEnd-- )</span><br><span class="line">        a[ rightEnd ] = tmpArray[ rightEnd ];</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><h2 id="期末重点"><a href="#期末重点" class="headerlink" title="期末重点"></a>期末重点</h2><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="一、数据结构的定义（选择、填空）"><a href="#一、数据结构的定义（选择、填空）" class="headerlink" title="一、数据结构的定义（选择、填空）"></a>一、数据结构的定义（选择、填空）</h3><ul>
<li>数据结构是指某一数据元素的集合与该集合中数据元素之间的关系</li>
<li>Data Structure &#x3D; {D，R}<ul>
<li>D is a data object</li>
<li>R is a limited set of relationship of all the data members in D</li>
</ul>
</li>
</ul>
<h3 id="二、数据结构的逻辑结构与物理结构（理解即可）"><a href="#二、数据结构的逻辑结构与物理结构（理解即可）" class="headerlink" title="二、数据结构的逻辑结构与物理结构（理解即可）"></a>二、数据结构的逻辑结构与物理结构（理解即可）</h3><ul>
<li>逻辑结构——从用户视图看，是面向问题的</li>
<li>物理结构——从具体实现视图看，是面向计算机的</li>
</ul>
<h3 id="三、ADT、OO不考，需要理解"><a href="#三、ADT、OO不考，需要理解" class="headerlink" title="三、ADT、OO不考，需要理解"></a>三、ADT、OO不考，需要理解</h3><ul>
<li><p>ADT：abstract data types抽象数据类型</p>
<ul>
<li>将类型和有关操作封装在一起的数据模型</li>
<li><strong>思想</strong>：将数据类型的使用与它的表示（机内存储）、实现（机内操作的实现）分开。更确切的说，把一个数据类型的表示及在这个类型上的操作<strong>实现</strong>封装到一个程序模块中，用户不必知道它</li>
</ul>
</li>
<li><p>OO：object-oriented面向对象</p>
<ul>
<li>object-oriented＝object＋class＋inherit＋communicate</li>
<li><strong>思想：封装、继承、多态</strong>，使得软件开发团队个成员能够不关心其他成员代码，二只关注接口（这块可以看软工一的板块，主要抓住这三个概念）</li>
</ul>
</li>
</ul>
<h3 id="四、算法概念（选择、填空）定义、五个性质"><a href="#四、算法概念（选择、填空）定义、五个性质" class="headerlink" title="四、算法概念（选择、填空）定义、五个性质"></a>四、算法概念（选择、填空）定义、五个性质</h3><ul>
<li>算法是一个用来解决实际问题的计算机操作序列</li>
<li>五个性质：<ol>
<li><p>明确的输入</p>
</li>
<li><p>明确的输出</p>
</li>
<li><p>确定性（definiteness）有明确的定义，每一个步骤都明确地定义</p>
</li>
<li><p>可行性</p>
</li>
<li><p>有穷性</p>
</li>
</ol>
</li>
</ul>
<h3 id="五、数学部分过一遍即可"><a href="#五、数学部分过一遍即可" class="headerlink" title="五、数学部分过一遍即可"></a>五、数学部分过一遍即可</h3><h3 id="六、递归需要掌握（物理过程、逻辑过程）"><a href="#六、递归需要掌握（物理过程、逻辑过程）" class="headerlink" title="六、递归需要掌握（物理过程、逻辑过程）"></a>六、<strong>递归</strong>需要掌握（<strong>物理过程</strong>、逻辑过程）</h3><ul>
<li>见下算法思想板块</li>
</ul>
<h3 id="七、泛型不考"><a href="#七、泛型不考" class="headerlink" title="七、泛型不考"></a>七、泛型不考</h3><hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="一、空间复杂度、时间复杂度概念"><a href="#一、空间复杂度、时间复杂度概念" class="headerlink" title="一、空间复杂度、时间复杂度概念"></a>一、空间复杂度、时间复杂度概念</h3><ul>
<li>空间复杂度：程序运行到完成所需要的内存量</li>
<li>时间复杂度：程序运行到完成所需要的时间</li>
</ul>
<h3 id="二、最好情况、最差情况、平均情况（等概率）"><a href="#二、最好情况、最差情况、平均情况（等概率）" class="headerlink" title="二、最好情况、最差情况、平均情况（等概率）"></a>二、最好情况、最差情况、平均情况（等概率）</h3><ul>
<li>平均情况：以等概率为前提 各情况求和取平均</li>
<li>平均情况较难确定，一般将分析限制在最好和最坏情况中</li>
</ul>
<h3 id="三、大O表示法（重点）"><a href="#三、大O表示法（重点）" class="headerlink" title="三、大O表示法（重点）"></a>三、<strong>大O表示法</strong>（重点）</h3><ul>
<li>为函数提供一个上界，算法复杂度量级的上界</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230129091917091.png" alt="image-20230129091917091" style="zoom:67%;float:left" /></li>
</ul>
<h3 id="四、二分查找（过程-复杂度）"><a href="#四、二分查找（过程-复杂度）" class="headerlink" title="四、二分查找（过程+复杂度）"></a>四、二分查找（过程+复杂度）</h3><ul>
<li>$O(log_2n)$</li>
</ul>
<h3 id="五、指定复杂度设计算法"><a href="#五、指定复杂度设计算法" class="headerlink" title="五、指定复杂度设计算法"></a>五、指定复杂度设计算法</h3><h3 id="六、辗转相除（过程）"><a href="#六、辗转相除（过程）" class="headerlink" title="六、辗转相除（过程）"></a>六、辗转相除（过程）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">( <span class="type">long</span> m, <span class="type">long</span> n )</span> &#123;   </span><br><span class="line">    <span class="keyword">while</span>( n != <span class="number">0</span> ) &#123;    </span><br><span class="line">        <span class="type">long</span> <span class="variable">rem</span> <span class="operator">=</span> m % n; </span><br><span class="line">        m = n; </span><br><span class="line">        n = rem; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复杂度为O(logN)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章（线性表）-一定有题"><a href="#第三章（线性表）-一定有题" class="headerlink" title="第三章（线性表） 一定有题"></a>第三章（线性表） 一定有题</h2><h3 id="一、ADT的基本操作（比如栈的进栈出栈peek）"><a href="#一、ADT的基本操作（比如栈的进栈出栈peek）" class="headerlink" title="一、ADT的基本操作（比如栈的进栈出栈peek）"></a>一、ADT的基本操作（比如栈的进栈出栈peek）</h3><ul>
<li>创建、查找、删除、插入、输出、得到长度、判断为空……</li>
<li>代码实现基于ADT的物理实现<ol>
<li>数组实现：一整块连续内存，依次排放元素<ul>
<li>在这种情况下，查找操作复杂度为O(1)，但删除与插入操作为O(length)</li>
</ul>
</li>
<li>单链表实现：不要求连续内存，一个节点中存放一个数据，一个指针<ul>
<li>这样的物理实现，是的删除与插入的复杂度大大降低，具体内容在下一版块讨论</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）"><a href="#二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）" class="headerlink" title="二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）"></a>二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）</h3><ul>
<li><p>一个问题：单链表带不带表头，表头节点是没有数据的，其指针指向list的第一个元素</p>
</li>
<li><p>一些操作的实现</p>
<ol>
<li><p>删除操作：<code>Delete(index, x)</code></p>
<ul>
<li><p>删除第一个节点：重新指向新的第一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = first.next;</span><br><span class="line"><span class="comment">// C++中需要delete掉被解引用的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除中间节点：先查询，后删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = first.next; <span class="comment">// 通过不断next，至要删除的节点前</span></span><br><span class="line">before.next = before.next.next;</span><br><span class="line"><span class="comment">// C++中需要delete掉被解引用的对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>插入操作：<code>Insert(index, x)</code></p>
<ul>
<li><p>在线性表开头插入元素：先插入，后移动表头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;f&#x27;</span>, first);</span><br><span class="line">first = newNode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在线性表中间插入元素：先查询，后插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before = first.next; <span class="comment">// 通过不断next，至要删除的节点前</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;f&#x27;</span>,before.next);</span><br><span class="line">before.next = newNode;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>java实现（看一下PPT或者笔记，关注一些方法，尤其是指针操作）DataStructure包中有LinkedListItr类：代表游标位置</p>
</li>
<li><p>双链表与循环链表看一下笔记</p>
</li>
</ul>
<h3 id="三、例题过一遍（懂）"><a href="#三、例题过一遍（懂）" class="headerlink" title="三、例题过一遍（懂）"></a>三、例题过一遍（懂）</h3><ul>
<li>多项式相加</li>
<li>循环链表解约瑟夫问题</li>
<li>最高效查找倒数第k个节点</li>
</ul>
<h3 id="四、栈和队列（小重点）"><a href="#四、栈和队列（小重点）" class="headerlink" title="四、栈和队列（小重点）"></a>四、<strong>栈和队列</strong>（小重点）</h3><ul>
<li><p>栈：LIFO，后进先出</p>
<ul>
<li><p>方法：push、pop</p>
</li>
<li><p>可以用单链表（表头为栈顶）也可以用数组（最后一位做栈顶，记录）进行实现</p>
<ul>
<li>使用数组实现栈的时候，可能存在空间的浪费，如果只有两个栈时，可以使他们从数组的头尾向中间生长</li>
</ul>
</li>
<li><p>无论何种的实现，栈操作的复杂度都是O(1)</p>
</li>
<li><p>例题：<strong>括号匹配、表达式计算、中缀和后缀表达式</strong></p>
<ul>
<li><p>括号匹配（输出匹配的对）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxlength = <span class="number">100</span>; <span class="comment">// max expression length</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMatchedPairs</span><span class="params">(<span class="type">char</span> *expr)</span> </span>&#123;</span><br><span class="line">    <span class="function">Stack&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(Maxlength)</span></span>;</span><br><span class="line">    <span class="type">int</span> j, length = <span class="built_in">strlen</span>(expr);</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = l; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;(&quot;</span>)</span><br><span class="line">            s.<span class="built_in">Add</span>(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (expr[i<span class="number">-1</span>]==<span class="string">&quot;)&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.<span class="built_in">Delete</span>(j);<span class="comment">//进栈的是括号的位置</span></span><br><span class="line">                cout &lt;&lt; j &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt; endl;&#125;</span><br><span class="line">            <span class="built_in">catch</span> (OutOfBounds)</span><br><span class="line">                &#123;cout &lt;&lt; <span class="string">&quot;No match for right parenthesis&quot;</span> &lt;&lt; <span class="string">&quot;at&quot;</span>&lt;&lt; i &lt;&lt; endl;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !s.<span class="built_in">IsEmpty</span> ())&#123;</span><br><span class="line">        s.<span class="built_in">Delete</span>(j);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;No match for left parenthesis at &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> expr[MaxLength];</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;type an expression of length at most&quot;</span> &lt;&lt;MaxLength&lt;&lt;endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(expr, MaxLength);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;the pairs of matching parentheses in&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">puts</span>(expr);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;are&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printMatcnedPairs</span>(expr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂度O(n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>表达式计算看作业代码</p>
</li>
<li><p>后缀转中缀看SpriCoder</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>队列：FIFO，先进先出</p>
<ul>
<li><p>方法：add、delete</p>
</li>
<li><p>实现：</p>
<ul>
<li><p>数组实现：记录首尾</p>
<ul>
<li><p>如果delete不进行左移，一段时间后，数组的前段会存在一段free space，如何更好地利用？</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204184853197.png" alt="image-20230204184853197" style="zoom:70%;float:left" />
</li>
<li><p>如何实现环形数组？</p>
<ol>
<li>当首或尾达到<code>theArray.length-1</code>时，重置为0</li>
<li><code>back = (back + 1) % theArray.length</code> <code>front = (front + 1) % theArray.length</code></li>
</ol>
</li>
</ul>
</li>
<li><p>链表实现：两个指针记录首尾</p>
</li>
</ul>
</li>
<li><p>例题：杨辉三角、循环移动</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第四章（树）"><a href="#第四章（树）" class="headerlink" title="第四章（树）"></a>第四章（树）</h2><h3 id="一、概念（填空选择）"><a href="#一、概念（填空选择）" class="headerlink" title="一、概念（填空选择）"></a>一、概念（填空选择）</h3><ul>
<li><strong>树</strong>：非线性的数据结构，是一个可以为空的节点集，有一个独立节点为root和多棵（可以为0）子树</li>
<li><strong>节点的度数</strong>：有多少个子节点</li>
<li>树的度数：树中子节点的最大度数</li>
<li><strong>leaf叶节点</strong>：度数为0的节点</li>
<li>branch分支节点：度数不为0的节点</li>
<li><strong>level层数</strong>：根节点的层数为0（或规定为1），子节点的层数是其父节点层数+1</li>
<li>树的高度：其节点的最大层数</li>
<li><strong>二叉树</strong>：每个节点度数为2，如果有子树，则子树均为二叉树（称为左右子树）<ul>
<li>n个节点的二叉树有n-1条边（n &gt;&#x3D; 1）</li>
<li>第i层最多有2^i^个节点（根节点层数为0）</li>
<li>高度为h的二叉树，最少有2h+1个节点，最多有2^h+1^-1个节点</li>
<li>叶节点数量为n<del>0</del>，度数为2的节点数量为n<del>2</del>，则n<del>0</del> &#x3D; n<del>2</del> + 1</li>
<li>有n个结点的二叉树的高度最大为n-1，最小为log2(n+1)(向上取整)-1</li>
</ul>
</li>
<li><strong>满二叉树</strong><ul>
<li>把二叉树排满，即如果高度为n，则其节点数为2^n+1^ - 1</li>
</ul>
</li>
<li><strong>完全二叉树</strong><ul>
<li>定义：假设我们为一个高度为h的满二叉树从上到下，从左到右使用1 - 2^h+1^的数字进行编码，删除编号为2^h+1^ - i（1 &lt;&#x3D; i &lt;&#x3D; k）的节点，得到一棵完全二叉树</li>
<li>假设i,0&lt;&#x3D;i&lt;&#x3D;n-1，是一个确定二叉树的一个节点的编号<ul>
<li>如果i&#x3D;0，则是根节点，不然其父结点的编号为 <strong>(i-1)&#x2F;2</strong>(向下取整)</li>
<li>如果2*i+1&gt;&#x3D;n，那么这个元素没有左子树，不然左子树的编号就是这个数字</li>
<li>如果2*i+2&gt;&#x3D;n，那么这个元素没有右子树，不然右子树的编号就是这个数字</li>
</ul>
</li>
</ul>
</li>
<li>完全二叉树和满二叉树是不同的，完全二叉树的最后一层可以不全满，但是必须从左开始顺序无空缺</li>
</ul>
<h3 id="二、表示方式"><a href="#二、表示方式" class="headerlink" title="二、表示方式"></a>二、表示方式</h3><ul>
<li><h4 id="广义表不考"><a href="#广义表不考" class="headerlink" title="广义表不考"></a>广义表不考</h4></li>
<li><h4 id="双亲表示法见并查集"><a href="#双亲表示法见并查集" class="headerlink" title="双亲表示法见并查集"></a>双亲表示法见并查集</h4></li>
<li><h4 id="左子女右兄弟（重点）"><a href="#左子女右兄弟（重点）" class="headerlink" title="左子女右兄弟（重点）"></a><strong>左子女右兄弟</strong>（重点）</h4><ul>
<li><p>用于遍历森林</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230204195723190.png" alt="image-20230204195723190" style="zoom:67%;float:left" />
</li>
<li><pre><code class="language-c++">class TreeNode{
    T data;
    TreeNode *firstchild, *nextsibling;
}
class Tree{
    TreeNode *root, *c
} 
// 插入算法
template&lt;class T&gt;void Tree&lt;T&gt;::Insertchild(T value){
    TreeNode&lt;T&gt;* newnode = new TreeNode&lt;T&gt;(value);
    if(current-&gt;firstchild == NULL){
        current-&gt;firstchild = newnode;
    } else{
        TreeNode&lt;T&gt; *p = current-&gt;firstchild;
        while(p-&gt;nextsibling != NULL){
            p = p-&gt;nextsibling;
        }
        p-&gt;nextsibling = newnode;
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 三、**树的遍历（重点）**</span><br><span class="line"></span><br><span class="line">+ #### 深度优先遍历</span><br><span class="line"></span><br><span class="line">  + ##### 前序VLR</span><br><span class="line"></span><br><span class="line">    ```C++</span><br><span class="line">    //递归实现先序遍历</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    void PreOrder(BinaryNode&lt;T&gt;* t) &#123;</span><br><span class="line">        // preorder traversal of *t.</span><br><span class="line">        if(t)&#123;</span><br><span class="line">            visit(t);</span><br><span class="line">            PreOrder(t-&gt;Left);</span><br><span class="line">            PreOrder(t-&gt;Right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><h5 id="中序LVR"><a href="#中序LVR" class="headerlink" title="中序LVR"></a>中序LVR</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现非递归中序遍历</span></span><br><span class="line"><span class="comment">//非递归使用stack实现中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BinaryNode &lt;T&gt;*t)</span></span>&#123;  </span><br><span class="line">    Stack&lt;BinaryNode&lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="comment">//无条件进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//一直进行压栈，直到最左下部分</span></span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。</span></span><br><span class="line">            p = s.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            p = p-&gt;Right;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="后序LRV"><a href="#后序LRV" class="headerlink" title="后序LRV"></a>后序LRV</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="comment">//结点的实现</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StkNode</span> &#123;</span><br><span class="line">    BinaryNode &lt;T&gt; * ptr;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(BinaryNode &lt;T&gt; * t)</span> </span>&#123;</span><br><span class="line">    Stack &lt;StkNode&lt;T&gt;&gt; <span class="built_in">s</span>(<span class="number">10</span>);</span><br><span class="line">    StkNode&lt;T&gt; Cnode;</span><br><span class="line">    BinaryNode&lt;T&gt;*p = t;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">//优先访问到最左下</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Cnode.ptr = p;</span><br><span class="line">            Cnode.tag = <span class="number">0</span>;</span><br><span class="line">            s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">            p = p-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最左下结点出栈</span></span><br><span class="line">        Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">        p = Cnode.ptr;</span><br><span class="line">        <span class="keyword">while</span> (Cnode.tag == <span class="number">1</span>)<span class="comment">//从右子树回来 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果已经被访问一次了才进行输出</span></span><br><span class="line">            cout &lt;&lt; p-&gt;element;</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">                Cnode = s.<span class="built_in">pop</span>();</span><br><span class="line">                p = Cnode.ptr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//访问结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        Cnode.tag = <span class="number">1</span>;<span class="comment">//从左子树遍历完，而右子树还没有动。</span></span><br><span class="line">        s.<span class="built_in">push</span>(Cnode);</span><br><span class="line">        p = p-&gt;Right;<span class="comment">//从左子树回来</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
</li>
<li><p>另外，非二叉树：</p>
<ul>
<li>先根：与原树的左子女右兄弟表示法的先序一致</li>
<li>后根：与原树的左子女右兄弟表示法的中序一致</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="广度优先遍历（分层访问）"><a href="#广度优先遍历（分层访问）" class="headerlink" title="广度优先遍历（分层访问）"></a>广度优先遍历（分层访问）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于栈实现层次访问</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">levelTravel</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; q=<span class="keyword">new</span> <span class="built_in">LinkedList</span>&lt;Node&gt;();</span><br><span class="line">    q.<span class="built_in">add</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Node temp = q.<span class="built_in">poll</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(temp.value);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=null) q.<span class="built_in">add</span>(temp.left);</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=null) q.<span class="built_in">add</span>(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><ul>
<li>将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连</li>
<li><strong>先根次序遍历：</strong> <ol>
<li>访问F的第一棵树的根 </li>
<li>按先根遍历第一棵树的子树森林 </li>
<li>按先根遍历其它树组成的森林</li>
<li>等于二叉树的先序</li>
</ol>
</li>
<li><strong>中根次序遍历：</strong> <ol>
<li>按中根遍历第一棵树的子树森林 </li>
<li>访问F的第一棵树的根 </li>
<li>按中根遍历其它树组成的森林</li>
<li>等于二叉树的中序</li>
</ol>
</li>
</ul>
<ul>
<li><strong>后根次序遍历：</strong> <ol>
<li>按后根遍历第一棵树的子树森林 </li>
<li>按后根遍历其它树组成的森林 </li>
<li>访问F的第一棵树的根</li>
<li>等于二叉树的后序</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="补、根据前中后序表达式建树"><a href="#补、根据前中后序表达式建树" class="headerlink" title="补、根据前中后序表达式建树"></a>补、根据前中后序表达式建树</h3><ul>
<li><p>根据先序遍历和中序遍历</p>
<ul>
<li><p>先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树</p>
</li>
<li><p>C++实现（java实现看作业4.0）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是一个递归算法</span></span><br><span class="line"><span class="function">BinaryNode&lt;Type&gt;*<span class="type">void</span> <span class="title">CreateBT</span> <span class="params">(String pres, ins)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> inpos;</span><br><span class="line">    BinaryNode &lt;Type&gt;* temp;<span class="comment">//当前二叉树的节点</span></span><br><span class="line">    String prestemp, instemp;</span><br><span class="line">    <span class="keyword">if</span> (pres.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = <span class="keyword">new</span> BinaryNode; </span><br><span class="line">        temp-&gt;element=pres.ch[<span class="number">0</span>];</span><br><span class="line">        inpos=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从中序遍历中找到根节点的位置，这样子根节点左侧的是左子树，右侧的是右子树</span></span><br><span class="line">        <span class="keyword">while</span> (ins.ch[inpos]!=temp-&gt;element) </span><br><span class="line">            inpos++;</span><br><span class="line">        </span><br><span class="line">        prestemp = <span class="built_in">pres</span>(<span class="number">1</span>,inpos);<span class="comment">//小括号是重载的，将先序遍历字符串的1到inpos取出来，赋给中间变量</span></span><br><span class="line">        instemp= <span class="built_in">ins</span>(<span class="number">0</span>,inpos<span class="number">-1</span>);</span><br><span class="line">        temp-&gt;left = <span class="built_in">CreateBT</span>(prestemp, instemp);</span><br><span class="line">        </span><br><span class="line">        prestemp=<span class="built_in">pres</span>(inpos<span class="number">+1</span>, pres.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        instemp=<span class="built_in">ins</span>(inpos<span class="number">+1</span>, pres.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        temp-&gt;right = <span class="built_in">CreateBT</span>(prestemp, instemp);</span><br><span class="line">        <span class="keyword">return</span> temp;<span class="comment">//完成组装返回</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据中序遍历和后序遍历</p>
<ul>
<li>后序遍历树根在尾部，思路一致</li>
</ul>
</li>
<li><p>根据先序遍历和后序遍历</p>
<ul>
<li>先序遍历第二个位置是左子树的根，在后序遍历中，它是左右子树的分界点</li>
</ul>
</li>
</ul>
<h3 id="四、线索化二叉树（常考）"><a href="#四、线索化二叉树（常考）" class="headerlink" title="四、线索化二叉树（常考）"></a>四、线索化二叉树（常考）</h3><ul>
<li><p>目的：为了让二叉树的遍历更快</p>
</li>
<li><p>结构：在树的节点中加入一个指针</p>
<ul>
<li>指针放在哪？——n个节点有2n个链域，期中只有n-1个有用，剩余均为空域。</li>
</ul>
</li>
<li><p>机内存储</p>
<ul>
<li><p>一个节点增加两个标记域</p>
<table>
<thead>
<tr>
<th>leftchild</th>
<th>leftthread</th>
<th>data</th>
<th>rightthread</th>
<th>rightchild</th>
</tr>
</thead>
</table>
<ul>
<li>leftthread与rightthread为bool型，用于表示leftchild与rightchild指向子女还是前驱（后继）</li>
</ul>
</li>
</ul>
</li>
<li><p>几个算法</p>
<ol>
<li><p>按中序遍历中序线索树</p>
<ul>
<li><p>找到中序下的第一个节点（first），不断找后继（next）</p>
<ul>
<li>p指节点没有右子树（p-&gt;rightthread &#x3D;&#x3D; 1），则rightchild就是后继</li>
<li>p指节点有右子树（p-&gt;rightthread &#x3D;&#x3D; 0），则去找右子树的第一个节点</li>
</ul>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用是current来记录下来当前节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::<span class="built_in">First</span>() &#123;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;leftThread==<span class="number">0</span>)&#123;</span><br><span class="line">        current = current-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;<span class="comment">//找中序遍历的第一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::<span class="built_in">Next</span>() &#123;</span><br><span class="line">    ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;<span class="comment">//可能是右子树的根节点，也可能是右链 </span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rightThread==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;leftThread==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果有右子树就要搜索到最左下部分</span></span><br><span class="line">            p=p-&gt;leftchlid;</span><br><span class="line">        &#125;</span><br><span class="line">    current=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> ThreadInorderIterator&lt;Type&gt;:: <span class="built_in">Inorder</span>() &#123; </span><br><span class="line">    ThreadNode&lt;Type&gt; *p;</span><br><span class="line">    <span class="keyword">for</span> ( p=<span class="built_in">Frist</span>(); p!=<span class="literal">NULL</span>; p=<span class="built_in">Next</span>()) </span><br><span class="line">        cout&lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造中序线索树</p>
<ul>
<li><p>对已存在的一棵二叉树建立中序线索树</p>
</li>
<li><p>在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">Inthread</span><span class="params">(threadNode&lt;T&gt; * T)</span> </span>&#123;</span><br><span class="line">    stack &lt;threadNode &lt;T&gt;*&gt; <span class="built_in">s</span>(<span class="number">10</span>)</span><br><span class="line">    ThreadNode &lt;T&gt; *p = T ;</span><br><span class="line">    ThreadNode &lt;T&gt; *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//查找到最左下部分的</span></span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p -&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始弹出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">IsEmpty</span>())&#123;</span><br><span class="line">            p = s.pop;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//添加的代码，在这时候处理pre</span></span><br><span class="line">                <span class="keyword">if</span> (pre -&gt;rightchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    pre -&gt;rightchild = p;  </span><br><span class="line">                    pre -&gt;rightthread = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理p</span></span><br><span class="line">                <span class="keyword">if</span>( p -&gt; leftchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    p -&gt; leftchild = pre;</span><br><span class="line">                    p -&gt;leftthread = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="comment">//添加的代码</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = p ;</span><br><span class="line">            p = p -&gt; rightchild ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//for </span></span><br><span class="line">&#125;<span class="comment">//建议把pre和p存储成全局变量</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）"><a href="#五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）" class="headerlink" title="五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）"></a>五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）</h3><ul>
<li><p>一些概念：</p>
<ul>
<li>增长树：原二叉树中度为1的节点，增加一个空树叶；元二叉树中的树叶，增加两个空树叶</li>
<li>外通路长度（外路径）E：根到每个外节点（增长树的叶）的路径长度的总和</li>
<li>内通路长度（内路径）I：更到每个内节点（增长树的非叶）的路径长度总和</li>
<li>节点的带权路径长度：一个节点的权值与节点的路径长度的乘积</li>
<li>带权的外路径长度：各叶节点的带权路径长度之和</li>
<li>带权的内路径长度：各非叶节点的带权路径长度之和</li>
</ul>
</li>
<li><p>霍夫曼树</p>
<ul>
<li>给出m个实数W1，W2，…，Wm（m&gt;&#x3D;2）作为m个外节点的权构造一颗增长树，是的带权外路径长度最小</li>
</ul>
</li>
<li><p>霍夫曼算法：</p>
<ul>
<li><p>思想：权大的外节点靠近根，权小的远离根</p>
</li>
<li><p>算法：</p>
<ol>
<li><p>从m个权值中找出两个最小值W1，W2构成</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208192950155.png" alt="image-20230208192950155" style="zoom:70%;float:left" />

<p>W &#x3D; W1 + W2表示通过该节点的频度</p>
</li>
<li><p>然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解</p>
</li>
</ol>
<ul>
<li>当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15</li>
</ul>
</li>
</ul>
</li>
<li><p>霍夫曼编码：</p>
<ul>
<li>利用Huffman算法， 把各字符出现的频率作为外部结点的权， 构造具有最小带权外路径长度的增长树，把每个结点的左子女的边标上0， 右子女标上1。 这样从根到每个叶子的路径上的号码连接起来， 就是外结点的字符编码</li>
<li>使得电文总长度最小，并且任意字符的编码不是其他字符的前缀（不相互干扰）</li>
</ul>
</li>
</ul>
<h3 id="六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程"><a href="#六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程" class="headerlink" title="六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程"></a>六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程</h3><h4 id="6-1-二叉搜索树"><a href="#6-1-二叉搜索树" class="headerlink" title="6.1 二叉搜索树"></a>6.1 二叉搜索树</h4><ul>
<li><p>二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：</p>
<ul>
<li>每一个元素有key值（关键码、主码），key值独一无二不重复</li>
<li>一个树的左子树的关键字小于根中的关键字</li>
<li>一个树的右子树的关键字大于根中的关键字</li>
<li>根的左右子树还是二叉搜索树</li>
</ul>
</li>
<li><p>二叉搜索树可以在很大的数据量下，快速完成增删查改</p>
</li>
<li><p>索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1</p>
</li>
<li><p>方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BinaryNode 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryNode</span> &#123;</span><br><span class="line">    BinaryNode( Comparable theElement ) &#123;</span><br><span class="line">        <span class="built_in">this</span>( theElement, <span class="literal">null</span>, <span class="literal">null</span> );<span class="comment">//调用本类中的其他构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;</span><br><span class="line">        element = <span class="type">theElement</span></span><br><span class="line">        <span class="variable">left</span> <span class="operator">=</span> lt;</span><br><span class="line">        right = rt;</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable element;</span><br><span class="line">    BinaryNode left;</span><br><span class="line">    BinaryNode right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某元素</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">find</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> find( x, t.right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;<span class="comment">//Match </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找值最小的结点，找最大同理，往右找</span></span><br><span class="line"><span class="comment">//使用递归查找结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">( BinaryNode t )</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">return</span> findMin( t.left );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代找最小结点</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">findMin</span><span class="params">(BinaryNode t)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            t = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数值插入固定位置的算法</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">insert</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="comment">//先查找一次，如果找到了就不用进行查找</span></span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">BinaryNode</span>( x, <span class="literal">null</span>, <span class="literal">null</span> );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = insert( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = insert( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> ;<span class="comment">//duplicate; do nothing</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compareTo()方法如果小于返回负数，大于返回正数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果结点本身不在树内，那么不需要删除</span></span><br><span class="line"><span class="comment"> * 如果结点本身在树里面，删除需要分类</span></span><br><span class="line"><span class="comment"> *  1.无子树:删除叶节点</span></span><br><span class="line"><span class="comment"> *  2.一颗子树:直接连接</span></span><br><span class="line"><span class="comment"> *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">remove</span><span class="params">( Comparable x, BinaryNode t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">null</span> )</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">if</span>( x.compareTo( t.element ) &lt; <span class="number">0</span> )</span><br><span class="line">        t.left = remove( x, t.left );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( x.compareTo( t.element ) &gt; <span class="number">0</span> )</span><br><span class="line">        t.right = remove( x, t.right );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( t.left != <span class="literal">null</span> &amp;&amp; t.right != <span class="literal">null</span> ) &#123;</span><br><span class="line">        t.element = findMin( t.right ).element;<span class="comment">//把右树最小的复制给t</span></span><br><span class="line">        t.right = remove( t.element , t.right );<span class="comment">//递归的删除</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t = ( t.left != <span class="literal">null</span> ) ? t.left : t.right;<span class="comment">//一颗子树的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</p>
<ul>
<li>Best Case：$O(log_2n)$</li>
<li>最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去</li>
</ul>
</li>
</ul>
<h4 id="6-2-AVL树"><a href="#6-2-AVL树" class="headerlink" title="6.2 AVL树"></a>6.2 AVL树</h4><ul>
<li>自平衡的二叉搜索树</li>
<li>始终保持高度是数据量的对数，目的是为了降低增删改查的复杂度</li>
<li>定义：是一棵二叉搜索树；对于任意一个节点为树根，其左子树与右子树的高度差不能超过1</li>
<li>结构：<ul>
<li>多一个元素，记录树高度，或者平衡因子（两子树高度差）</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208202359104.png" alt="image-20230208202359104" style="zoom:67%;float:left" /></li>
</ul>
</li>
<li>方法（具体看笔记C6-搜索树）：<ul>
<li>查询：与正常二叉搜索树相同</li>
<li>插入：外增高，单旋（左外增则右下旋）；内增高，双旋（左内增则先左下旋后右下旋）<strong>看清楚对谁而言的内外与左右</strong></li>
<li>删除：与二叉搜索树删除相同，再检查平衡因子，进行旋转</li>
</ul>
</li>
<li>算法分析：<ul>
<li><strong>具有n个结点的平衡二叉树（AVL），进行一次插入或删除的时间最坏情况 &lt;&#x3D; O(log<del>2</del> n)</strong></li>
</ul>
</li>
</ul>
<h4 id="6-3-m叉搜索树"><a href="#6-3-m叉搜索树" class="headerlink" title="6.3 m叉搜索树"></a>6.3 m叉搜索树</h4><ul>
<li><p>m叉搜索树可能为空，非空m叉搜索树满足如下属性：</p>
<ul>
<li><p>m路搜索树每个节点里最多有m-1个值和m个索引</p>
</li>
<li><p>每个具有p元素的节点正好有p+1个子节点</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230208204647861.png" alt="image-20230208204647861" style="zoom:100%;float:left" />

<blockquote>
<p>假设任何节点都有p个元素，那么C0 - Cp是他们对应的p+1个子节点</p>
</blockquote>
</li>
<li><p>对于节点（以上为例）</p>
<ul>
<li>在以C0为根的所有子树中的结点的值都小于k1</li>
<li>在以Cp为根的子树中的所有子树的值都大于kp</li>
<li>在以Ci为根的子树中的所有子树的值都在ki与ki+1之间</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么选择m叉搜索树？</p>
<ol>
<li>复杂度（高度）进一步减小</li>
<li>m叉搜索树是可以存入磁盘的，增删改查任意一个数据，只需要访问高度次磁盘</li>
</ol>
</li>
<li><p>操作（具体看笔记C6-搜索树）：</p>
<ul>
<li>插入：未满同级插，已满下级插</li>
<li>删除：删完不空直接删，删完空了下上提</li>
</ul>
</li>
<li><p>行高：</p>
<ul>
<li>一个高为h的m路搜索树最少有h个结点(每一层只有一个结点)，最多有m^h^-1个结点</li>
<li>n个节点的m路搜索树高度在log<del>m</del>(n+1)和n之间</li>
</ul>
</li>
</ul>
<h4 id="6-4-B树"><a href="#6-4-B树" class="headerlink" title="6.4 B树"></a>6.4 B树</h4><ul>
<li><p>平衡的m路搜索树</p>
</li>
<li><p>在m路搜索树的基础上，非空B树有以下扩展属性</p>
<ul>
<li>每个根结点至少有两个子女</li>
<li>所有内节点都至少有m&#x2F;2(向上取整)个子结点</li>
<li>所有的外节点必须都在同一层（所有子树高度一样高）</li>
<li>外部节点的个数等于关键字数+1</li>
</ul>
</li>
<li><p>操作：</p>
<ul>
<li><p>搜索：与m路搜索数相同，与树高有关，一个m节有n个节点的树，高度在log<del>m</del>(n+1)与1+log<del>⌈m&#x2F;2⌉</del>(n+1)&#x2F;2之间</p>
<p><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142357142.png" alt="image-20230209142357142" style="zoom:60%;float:left" /><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209142416129.png" alt="image-20230209142416129" style="zoom:80%;" /></p>
</li>
<li><p>插入：</p>
<ul>
<li>算法思想<ul>
<li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序</li>
<li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol>
<li>从该节点的原有元素和新的元素中选择出中位数</li>
<li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值</li>
<li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）</li>
</ol>
</li>
</ul>
</li>
<li>算法分析：如果操作导致s个节点分裂，那么磁盘查找次数为：h+2s+1<ul>
<li>h为在搜索路径上的读操作；2s为写出两个新节点操作；1为新节点（可能是创建的新根，也可能是最终一个节点被修改）</li>
</ul>
</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li><p>算法思想：</p>
<ol>
<li><p>如果要删除的关键码不在B数中，则直接退出</p>
</li>
<li><p>如果要删除的关键码在外部节点：</p>
<ul>
<li><p>如果删除后节点仍有超过⌈m&#x2F;2⌉个节点，则直接删除</p>
</li>
<li><p>如果不足，则需要向邻居<strong>借关键码</strong>：</p>
<table>
<thead>
<tr>
<th>邻居够借（进行调整）</th>
<th>邻居不够借（与邻居合并，导致上级节点关键码减少，再借或合并）</th>
</tr>
</thead>
<tbody><tr>
<td><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209143950542.png" alt="image-20230209143950542" style="zoom:110%;float:left" /><br />注意：相当于根节点与被借节点的一次旋转</td>
<td><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230209144057066.png" alt="image-20230209144057066" style="zoom:120%;float:left" /><br />删除后“367 379 389 401 419 439”为新节点，但“283 353”出现不足，再求助与邻居</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>如果要删除的关键码在非叶节点：</p>
<ul>
<li>删除这个节点</li>
<li>把这个节点替换成右子树中的最小关键码(或者左子树中的最大关键码)</li>
<li>因为相当于删除了右子树的最小关键码(或者左子树中的最大关键码)，所以重复删除叶结点关键码的操作。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第五章（散列表）"><a href="#第五章（散列表）" class="headerlink" title="第五章（散列表）"></a>第五章（散列表）</h2><h3 id="一、散列函数"><a href="#一、散列函数" class="headerlink" title="一、散列函数"></a>一、散列函数</h3><ul>
<li><p>散列函数是为了将增删改查的复杂度降低至常数，代价是特别浪费空间</p>
</li>
<li><p>负载因子与再散列：</p>
<ul>
<li>为了减少冲突处理的次数，哈希表一般都是稀疏的。我们记整个哈希表容量为$n$，负载因子为$\alpha$，则一旦哈希表内数据量达到$n\alpha$，我们就需要扩充表容量了，这叫再散列</li>
<li>再散列：<ul>
<li>尽量保证表项数&gt;表的70%，也就是意味着如果不满足，就需要进行再散列</li>
<li>取比原表长*2大的指数再散列</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>取余法（大部分情况下）</strong>：</p>
<ul>
<li><code>H(key) = key % M</code>，M取小于基本区长度的<strong>最大质数</strong></li>
</ul>
</li>
<li><p>平方取余法</p>
<ul>
<li><code>H(key) = key * key的中间部分</code></li>
</ul>
</li>
<li><p>乘法杂凑函数</p>
</li>
</ul>
<h3 id="二、冲突处理"><a href="#二、冲突处理" class="headerlink" title="二、冲突处理"></a>二、冲突处理</h3><ul>
<li>碰撞的两个（或多个）关键码称为同义词，即H(k<del>1</del>) &#x3D; H(k<del>2</del>)，k<del>1</del> 不等于 k<del>2</del></li>
<li><strong>开放地址的线性探测法</strong><ul>
<li>方法：如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会按照线性顺序向后成环形查找</li>
<li>带来几个问题：<ol>
<li>散列表越满，查找的复杂度可能越高，需要更多的遍历</li>
<li>堆积问题：指不同的同义词表合为一张了。从而增加了插入，查找的时间</li>
<li>删除问题：不能进行真删除，会截断环型查找，而是通过标记表示数据无效</li>
</ol>
</li>
</ul>
</li>
<li>二次探测很少考<ul>
<li>如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会检查d+1，d+4，d+9，…的位置</li>
</ul>
</li>
<li>双散列（有时考）<ul>
<li>如果k的第一哈希值为d，而这个对应的格子已经被占用则我们继续计算k的第二哈希值，然后检查d+c…</li>
<li>第一个散列函数发生冲突，那么使用第二个散列函数来放置，如果再次冲突则进行相应探测</li>
</ul>
</li>
</ul>
<h3 id="三、分离链接"><a href="#三、分离链接" class="headerlink" title="三、分离链接"></a>三、分离链接</h3><ul>
<li>冲突了拖个链表，查找的时候需要遍历对应链表</li>
</ul>
<h3 id="四、应用环境下发现其应用"><a href="#四、应用环境下发现其应用" class="headerlink" title="四、应用环境下发现其应用"></a>四、应用环境下发现其应用</h3><ul>
<li><p>一般是元素本身可以提取出一个关键码，并且有需求实现快速增删改查的场景下</p>
</li>
<li><p>上段代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++的线性探测法实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;<span class="comment">// 假设每一元素的类型为E，并且有一个类型为k的关键码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>&#123; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HashTable</span>(<span class="type">int</span> divisor = <span class="number">11</span>);</span><br><span class="line">        ~<span class="built_in">HashTable</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span>[]ht;</span><br><span class="line">            <span class="keyword">delete</span> []empty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">const</span> K&amp;k ,E&amp; e)</span><span class="type">const</span></span>; </span><br><span class="line">        <span class="function">HashTable&lt;E,K&gt;&amp;<span class="title">Insert</span><span class="params">(<span class="type">const</span> E&amp;e)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">hSearch</span><span class="params">(<span class="type">const</span> K&amp; k)</span><span class="type">const</span></span>;</span><br><span class="line">        <span class="type">int</span> D;<span class="comment">//hash function divisor</span></span><br><span class="line">        E *ht ; <span class="comment">//hash table array</span></span><br><span class="line">        <span class="type">bool</span> *empty ; <span class="comment">//1D array，为了实现标记删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable的构造方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;<span class="comment">//E和K需要被实例化后，这个类才能被调用。</span></span><br><span class="line">HashTable&lt;E,K&gt;::<span class="built_in">HashTable</span>(<span class="type">int</span> divisor)&#123;</span><br><span class="line">    D = divisor;</span><br><span class="line">    ht = <span class="keyword">new</span> E[D];</span><br><span class="line">    empty= <span class="keyword">new</span> <span class="type">bool</span>[D];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;i++)</span><br><span class="line">        empty[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="type">int</span> HashTable&lt;E,K&gt;::<span class="built_in">hSearch</span>(<span class="type">const</span> K&amp;k)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> i= k % D;<span class="comment">//home bucket</span></span><br><span class="line">    <span class="type">int</span> j= i ; <span class="comment">//start at home bucket</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(empty[j] || ht[j]==k) <span class="keyword">return</span> j;<span class="comment">//fit</span></span><br><span class="line">        j=(j<span class="number">+1</span>)%D; <span class="comment">//next bucket，%D是为了实现环型遍历</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(j!= i);  <span class="comment">//returned to home?是否循环完成一遍</span></span><br><span class="line">    <span class="keyword">return</span> j; <span class="comment">//table full;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数进行引用K&amp;k</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="type">bool</span> HashTable&lt;E,K&gt;::<span class="built_in">Search</span>(<span class="type">const</span> K&amp;k,E&amp;e)<span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//put element that matches k in e.</span></span><br><span class="line">    <span class="comment">//return false if no match.</span></span><br><span class="line">    <span class="type">int</span> b= <span class="built_in">hSearch</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(empty[b]||ht[b].key!=k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=ht[b];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">E</span>,<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line">HashTable&lt;E,K&gt;&amp; HashTable&lt;E,K&gt;::<span class="built_in">Insert</span>(<span class="type">const</span> E&amp; e) &#123;</span><br><span class="line">     K k=e.key;<span class="comment">//extract key</span></span><br><span class="line">     <span class="type">int</span> b=<span class="built_in">hSearch</span>(k);</span><br><span class="line">     <span class="keyword">if</span>(empty[b])&#123;</span><br><span class="line">        empty[b]=<span class="literal">false</span>;</span><br><span class="line">        ht[b]=e;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NoMem</span>();  <span class="comment">//table full</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> java二次探测与分离链接实现去看SpriCoder</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="第六章（优先级队列）"><a href="#第六章（优先级队列）" class="headerlink" title="第六章（优先级队列）"></a>第六章（优先级队列）</h2><ul>
<li>一个优先级队列是0个或者更多元素的集合，每一个元素都有一个优先级或者值</li>
<li>分为最大和最小优先级队列：删除（出列）优先删除优先级最大（小）的元素</li>
</ul>
<h3 id="一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆"><a href="#一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆" class="headerlink" title="一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆"></a>一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆</h3><ul>
<li>最大优先级队列——最大堆，最小优先级队列——最小堆</li>
<li>最大堆是一棵完全二叉树，每一个节点上的值都大于或等于它的子节点</li>
</ul>
<h4 id="1-1-插入（进堆、上滤）"><a href="#1-1-插入（进堆、上滤）" class="headerlink" title="1.1 插入（进堆、上滤）"></a>1.1 插入（进堆、上滤）</h4><ul>
<li><p>算法思想：在树最后插入后，与父节点进行比较，如果比父节点大，则交换，一直到不再大于父节点</p>
</li>
<li><p>复杂度分析：log<del>2</del>(n)</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: <span class="built_in">Insert</span>(<span class="type">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize= =MaxSize) <span class="keyword">throw</span> <span class="built_in">NoMem</span>(); </span><br><span class="line">    <span class="type">int</span> i= ++CurrentSize;</span><br><span class="line">    <span class="keyword">while</span>(i!=<span class="number">1</span> &amp;&amp; x&gt;heap[i/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="comment">//0不使用</span></span><br><span class="line">        heap[i]=heap[i/<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//不必每次都进行完全交换</span></span><br><span class="line">        i/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=x;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-删除（出堆、下滤）"><a href="#1-2-删除（出堆、下滤）" class="headerlink" title="1.2 删除（出堆、下滤）"></a>1.2 删除（出堆、下滤）</h4><ul>
<li><p>算法思想：将根删除，将树最后一个节点换为根，然后进行下滤操作</p>
</li>
<li><p>复杂度分析：log<del>2</del>(n)</p>
</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: <span class="built_in">DeleteMax</span>(T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(CurrentSize==<span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">OutOfBounds</span>(); </span><br><span class="line">    x = heap[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//0无存储，这个就是root结点</span></span><br><span class="line">    T y=heap[CurrentSize--];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;<span class="comment">//i标向树根</span></span><br><span class="line">    ci=<span class="number">2</span>;<span class="comment">//ci先标到左子树</span></span><br><span class="line">    <span class="keyword">while</span>(ci&lt;=CurrentSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci<span class="number">+1</span>])<span class="comment">//如果ci未越界，并且左子树的值小于右子树的值。</span></span><br><span class="line">            ci++;<span class="comment">//转向右子树</span></span><br><span class="line">        <span class="keyword">if</span>(y&gt;=heap[ci]) <span class="keyword">break</span>;</span><br><span class="line">        heap[i]=heap[ci];</span><br><span class="line">        i=ci;</span><br><span class="line">        ci*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i]=y;<span class="comment">//y是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-线性时间建堆"><a href="#1-3-线性时间建堆" class="headerlink" title="1.3 线性时间建堆"></a>1.3 线性时间建堆</h4><ul>
<li><p>步骤：</p>
<ol>
<li>先将n个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性</li>
</ol>
</li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意是对每个子树进行递归处理</span></span><br><span class="line">Template&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span> MaxHeap&lt;T&gt;::<span class="built_in">Initialize</span> (T a[],<span class="type">int</span> size,<span class="type">int</span> ArraySize) &#123; </span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap=a;</span><br><span class="line">    CurrentSize=Size;</span><br><span class="line">    MaxSize=ArraySize;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i=CurrentSize/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        T y=heap[i];</span><br><span class="line">        <span class="type">int</span> c=<span class="number">2</span>*i;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= CurrentSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c<span class="number">+1</span>])</span><br><span class="line">                c++;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=heap[c])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[c/<span class="number">2</span>] = heap[c];</span><br><span class="line">            c*=<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到其子节点位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap[c/<span class="number">2</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析：</p>
<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213163633887.png" alt="image-20230213163633887" style="zoom:100%;float:left" />

<ul>
<li>如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第七章（并查集）"><a href="#第七章（并查集）" class="headerlink" title="第七章（并查集）"></a>第七章（并查集）</h2><h3 id="一、并查集功能（Union、Find）"><a href="#一、并查集功能（Union、Find）" class="headerlink" title="一、并查集功能（Union、Find）"></a>一、并查集功能（Union、Find）</h3><ul>
<li><p>Combine：合并包含元素a和b的两个等价类为一个等价类</p>
<ul>
<li><p>Combine(a, b) ：<code>i = Find(a); j = Find(b); if(i != j) Union(i, j);</code></p>
</li>
<li><p>并查集的实现通过森林（下图是union(1,5)的实现，parent数组存放节点的父节点）</p>
<table>
<thead>
<tr>
<th><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152800463.png" alt="image-20230213152800463"></th>
<th><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213152808426.png" alt="image-20230213152808426"></th>
</tr>
</thead>
</table>
</li>
</ul>
</li>
<li><p>Find：找到包含元素e的等价类</p>
</li>
<li><p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simple tree solution to union-find problem </span></span><br><span class="line"><span class="comment">//使用简单的树结构解决并集的查找问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">1</span>;e&lt;=n;e++) parent[e]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向上找到其根结点</span></span><br><span class="line">    <span class="keyword">while</span>(parent[e]) e=parent[e];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//合并两个结点</span></span><br><span class="line">    parent[j]=i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>性能估计</p>
<ul>
<li>Find——O(n)，n为树高</li>
<li>Union——$\theta$(1)</li>
</ul>
</li>
<li><p>性能提升</p>
<ul>
<li><p>优化Union</p>
<ul>
<li><p>方法一：（权值规则）<strong>节点数少的树挂到节点数多的树下</strong></p>
<ul>
<li><p>如何记录weight？新建一个bool类型数组表示是否为根节点，如果为根，则其父节点字段记录书中节点总数（如何省略标记根的数组？——用负数来表示）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入上两条优化</span></span><br><span class="line"><span class="comment">//Union with the weight rule</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    root=<span class="keyword">new</span> <span class="type">bool</span>[n<span class="number">+1</span>];</span><br><span class="line">    parent=<span class="keyword">new</span> <span class="type">int</span>[n<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e=<span class="number">1</span>;e&lt;=n;e++) &#123;</span><br><span class="line">        parent[e]=<span class="number">1</span>;</span><br><span class="line">        root[e]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!root[e])</span><br><span class="line">        e=parent[e];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[i]&lt;parent[j])</span><br><span class="line">    <span class="comment">//i becomes subtree of j</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent[j]=parent[j]+parent[i];</span><br><span class="line">        root[i]=<span class="literal">false</span>;</span><br><span class="line">        parent[i]=j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[i]=parent[i]+parent[j];</span><br><span class="line">        root[j]=<span class="literal">false</span>;</span><br><span class="line">        parent[j]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法二：（高度规则）<strong>高度低的树挂到高度高的树的下</strong></p>
</li>
</ul>
</li>
<li><p>优化Find</p>
<ul>
<li><p>如果路径上的点父节点非根节点，则将其与根节点相连</p>
</li>
<li><img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20230213161401167.png" alt="image-20230213161401167" style="zoom:80%;float:left" />
</li>
<li><pre><code class="language-c++">int Find(int e) {
    /* C++ */
    int j = e;
    while(!root[j])
        j=parent[j];
    int f = e;
    while(f!=j) {
        int pf = parent[f];
        parent[f] = j;
        f = pf;
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 二、一般和最小生成树算法一起考（kruskal算法）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第八章（图）</span><br><span class="line"></span><br><span class="line">### 一、概念（选择填空）</span><br><span class="line"></span><br><span class="line">+ Graph = (V, E)，顶点集+边集</span><br><span class="line">+ 有向图与无向图，完全与否</span><br><span class="line">+ 度数：连到这个顶点的边的数量，有向图有出度与入度之分，所有顶点度数之和为边的两倍</span><br><span class="line">+ 子图：图 G=(V, E) 和图 G&#x27;=(V&#x27;, E&#x27;) ，如果V&#x27;包含于V，E’包含于E,并且E&#x27;中顶点的边也在G&#x27;中，那么G&#x27;是G的子图</span><br><span class="line">+ 路径：在图 G= (V, E)中，如果边(i~j~，i~j+1~)都在E中，1&lt;= j&lt; k，则顶点序列P=i~1~，i~2~，…,i~k~是i~1~到i~k~的路径</span><br><span class="line">  + 简单路径：路径除了第一个和最后一个顶点没有出现相同的顶点</span><br><span class="line">  + 环：起点和终点相同的简单路径</span><br><span class="line">+ 连通图：无向图中任意两个点是连通的，则为连通图</span><br><span class="line">+ 强连通图：有向图中，每对不同的顶点i, j，包含从i到j和从j到i的有向路径是，则为强联通图</span><br><span class="line">+ 加权图：边被分配权值</span><br><span class="line">+ 生成树：对于连通图来说，是其极小连通子图；n顶点的生成树有n-1条边</span><br><span class="line"></span><br><span class="line">### 二、邻接矩阵、邻接表掌握，邻接多重表不要求</span><br><span class="line"></span><br><span class="line">#### 2.1 邻接矩阵</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130091646130.png&quot; alt=&quot;image-20221130091646130&quot; style=&quot;zoom:60%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ 无向图的邻接矩阵：对称的、对角线为0（无自环）、度数等于对应行的和</span><br><span class="line"></span><br><span class="line">+ 有向图的邻接矩阵：行为起点，列为终点、出度对行求和，入度对列求和</span><br><span class="line"></span><br><span class="line">+ 加权图的邻接矩阵：</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130093426305.png&quot; alt=&quot;image-20221130093426305&quot; style=&quot;zoom:80%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2 邻接表</span><br><span class="line"></span><br><span class="line">+ &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130093948312.png&quot; alt=&quot;image-20221130093948312&quot; style=&quot;zoom:57%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20221130094057188.png&quot; alt=&quot;image-20221130094057188&quot; style=&quot;zoom:60%;float:left&quot; /&gt;</span><br><span class="line"></span><br><span class="line">+ 代码看notes</span><br><span class="line"></span><br><span class="line">### 三、最小生成树（2个）算法掌握，流程复杂度清晰</span><br><span class="line"></span><br><span class="line">### 四、最小路径（3个）算法掌握，流程复杂度清晰</span><br><span class="line"></span><br><span class="line">### 五、活动网络常考（AOV拓扑排序，AOE关键路径）流程复杂度</span><br><span class="line"></span><br><span class="line">+ 上三个看notes</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 排序算法</span><br><span class="line"></span><br><span class="line">+ 流程</span><br><span class="line">+ 看代码（无代码不看代码）</span><br><span class="line">+ 复杂度</span><br><span class="line">+ 性质要求的</span><br><span class="line">+ 折半插入排序不做重点</span><br><span class="line">+ **快排**重点</span><br><span class="line">+ 锦标赛排序考得不多</span><br><span class="line">+ **选择排序**</span><br><span class="line">+ **堆排序**</span><br><span class="line">+ 堆排序注意其是一个固定算法，不额外占用空间</span><br><span class="line">+ **归并排序**</span><br><span class="line"></span><br><span class="line">### 一、PPT**最后的表格**</span><br><span class="line"></span><br><span class="line">| 排序方法        | 比较次数     | 平均比较次数 | 稳定性 | 移动次数     | 辅助存储    |</span><br><span class="line">| --------------- | ------------ | ------------ | ------ | ------------ | ----------- |</span><br><span class="line">| **1、插入排序** |              |              |        |              |             |</span><br><span class="line">| 直接插入排序    | n~n^2^/2     | $O(n^2)$     | 稳定   | 2n~n^2^/2    | $O(1)$      |</span><br><span class="line">| 二分法插入排序  | nlog~2~n     | $O(nlog_2n)$ | 稳定   | 2n~n^2^/2    | $O(1)$      |</span><br><span class="line">| 表插入排序      | n~n^2^/2     | $O(n^2)$     | 稳定   | 0            | $O(n)$      |</span><br><span class="line">| shell排序       |              |              | 不稳定 |              | $O(1)$      |</span><br><span class="line">| **2、选择排序** |              |              |        |              |             |</span><br><span class="line">| 直接选择排序    | n(n-1)/2     | $O(n^2)$     | 不稳定 | 3*(n-1)      | $O(1)$      |</span><br><span class="line">| 堆排序          | $O(nlog_2n)$ | $O(nlog_2n)$ | 不稳定 |              | $O(1)$      |</span><br><span class="line">| **3、交换排序** |              |              |        |              |             |</span><br><span class="line">| 冒泡排序        | n-1          | $O(n^2)$     | 稳定   | 0~3/2*n(n-1) | $O(1)$      |</span><br><span class="line">| 快排            | nlog~2~n     | $O(nlog_2n)$ | 不稳定 | &lt;=nlog~2~n   | $O(log_2n)$ |</span><br><span class="line">| **4、分配排序** |              |              |        |              |             |</span><br><span class="line">| 基数排序        | $O(d*(n+r))$ | $O(d*(n+r))$ | 稳定   | 拉链         | $O(n+r)$    |</span><br><span class="line">| **5、归并排序** |              |              |        |              |             |</span><br><span class="line">| 归并排序        | $O(nlog_2n)$ | $O(nlog_2n)$ | 稳定   |              | $O(n)$      |</span><br><span class="line"></span><br><span class="line">### 二、快排</span><br><span class="line"></span><br><span class="line">+ 方法：在n个对象中，取一个对象（如第一个对象）为基准pivot，按该对象的关键码把所有不大于该关键码的对象划在它的左边，大于该关键码的对象划到它右边；然后对于左右两个子序列再进行快排</span><br><span class="line"></span><br><span class="line">+ 注意这里的划分方法：PPT中采用两个指针，交换基准数与非序数（自己起的名字）来实现，直到两指针都指向基准数</span><br><span class="line"></span><br><span class="line">+ ```c++</span><br><span class="line">  template &lt;class Type&gt; void QuickSort( datalist &lt;Type&gt;&amp; list, const int left,  const int right ) &#123;</span><br><span class="line">      if (left&lt;right) &#123;</span><br><span class="line">          int pivotpos = partition(list, left, right);</span><br><span class="line">          QuickSort(list, left, pivotpos-1);</span><br><span class="line">          QuickSort(list, pivotpos+1, right);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //partition</span><br><span class="line">  template &lt;class Type&gt; int partition(datalist&lt;Type&gt; &amp;list, const int low, const int high) &#123;</span><br><span class="line">      int i=low,j=high;</span><br><span class="line">      Element&lt;Type&gt;pivot=list.Vector[low];</span><br><span class="line">      while (i != j ) &#123;</span><br><span class="line">          while(list.Vector[j].getkey()&gt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">          if (i&lt;j) &#123;</span><br><span class="line">              list.Vector[i]=list.Vector[j];</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          while(list.Vector[i].getkey()&lt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;</span><br><span class="line">              i++;</span><br><span class="line">          &#125;</span><br><span class="line">          if (i&lt;j) &#123;</span><br><span class="line">              list.Vector[j]=list.Vector[i];</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      list.Vector[i]=pivot;</span><br><span class="line">      return i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时间复杂度$O(nlog_2n)$</p>
</li>
<li><p>空间复杂度：非递归算法需要使用栈来存放左部或右部的上下界的下标:$O(log_2n)$ ~ $O(n)$</p>
</li>
<li><p><strong>选择pivot</strong>：<strong>三数中值分割法</strong>（左端、右端和中心三个元素的中值为枢纽元）</p>
<ul>
<li>将枢纽元放在数组的末尾（倒数第二个位置，因为最后的值确定比枢纽元大）</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6262208.html">三数中值分隔法</a></li>
</ul>
</li>
</ul>
<h3 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h3><ul>
<li><p>方法：每次都选出一个最大（小）值，将其放到数组最前</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span> [] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//sort the n number in a[0:n-1].</span></span><br><span class="line">    <span class="comment">//找到大数字放置到后面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> n; size&gt;<span class="number">1</span>; size--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Max(a,size);</span><br><span class="line">        swap(a[j],a[size-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析：</p>
<ul>
<li>比较次数，固定为n(n-1)&#x2F;2</li>
<li>移动次数，固定为3*(n-1)，每次swap有3次操作</li>
<li>$O(n^2)$</li>
</ul>
</li>
</ul>
<h3 id="四、堆排序"><a href="#四、堆排序" class="headerlink" title="四、堆排序"></a>四、堆排序</h3><ul>
<li><p>是固定的算法</p>
</li>
<li><p>方法：一开始先建立最大堆，最后调整为最小堆</p>
<ul>
<li>如何调整：将树根（最大值）与最后一个未定序的节点交换，再对新根做下滤，知道所有节点都定序</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java program</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapsort</span><span class="params">( Comparable []a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">        percDown( a, i, a.length );<span class="comment">// 建最大堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length – <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        swapReferences( a, <span class="number">0</span>, i );</span><br><span class="line">        percDown( a, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftChild</span><span class="params">( <span class="type">int</span> i )</span> &#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">percDown</span><span class="params">( Comparable [ ] a, <span class="type">int</span>  i,  <span class="type">int</span> n )</span> &#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    Comparable tmp;</span><br><span class="line">    <span class="keyword">for</span>( tmp = a[i];leftChild(i) &lt; n ; i = child ) &#123;</span><br><span class="line">        child = leftchild( i );</span><br><span class="line">        <span class="keyword">if</span>( child!=n – <span class="number">1</span>&amp;&amp; a[child].compareTo( a[ child + <span class="number">1</span> ] ) &lt; <span class="number">0</span> )</span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>( tmp . compareTo( a[ child ] &lt; <span class="number">0</span> )</span><br><span class="line">            a[ i ] = a[ child ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度：$O(nlog_2n)$</p>
</li>
</ul>
<h3 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h3><ul>
<li><p>方法：每次去除两个序列中最小的元素输出，当一序列完，则输出另一序列</p>
</li>
<li><p>迭代的归并排序算法</p>
<ul>
<li>n个长为1的对象两两合并，得n&#x2F;2个长为2的文件</li>
<li>n&#x2F;2个长为2的对象两两合并，得n&#x2F;4个长为4的文件</li>
<li>……</li>
<li>2个长为n&#x2F;2的对象两两合并，得1个长为n的文件</li>
</ul>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a )</span> &#123;</span><br><span class="line">    Comparable [ ] tmpArray = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];</span><br><span class="line">    mergeSort( a, tmpArray, <span class="number">0</span>, a.length – <span class="number">1</span> );</span><br><span class="line">&#125;                            </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> left, <span class="type">int</span> right )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; right ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(a, tmparray, left, center );</span><br><span class="line">        mergeSort(a, tmpArray, center + <span class="number">1</span>, right );</span><br><span class="line">        merge( a, tmpArray, left, center + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">( Comparable [ ] a, Comparable [] tmpArray, <span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd )</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftEnd</span> <span class="operator">=</span> rightPos – <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpPos</span> <span class="operator">=</span> leftPos;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numElements</span> <span class="operator">=</span> rightEnd – leftPos + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )</span><br><span class="line">        <span class="keyword">if</span>( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= <span class="number">0</span> )</span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpArray[ tmpPos++ ] = a[ rightPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd )</span><br><span class="line">        tmpArray[ tmpPos++ ] = a[ leftPos++ ];</span><br><span class="line">    <span class="keyword">while</span>( rightpos &lt;= rightEnd)</span><br><span class="line">        tmpArray[ tmpPos++] = a[ rightpos++ ];</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numElements; i++, rightEnd-- )</span><br><span class="line">        a[ rightEnd ] = tmpArray[ rightEnd ];</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析：$O(nlog_2n)$</p>
</li>
<li><p>有序链表的merge算法</p>
<ul>
<li>切断链表：设两个流动指针p,q指向表的结点 一般来讲让p前进一步，q前进二步，最后当q&#x3D; NULL时，这时p 恰好指向前半张表的最后一个结点</li>
</ul>
</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h3><ul>
<li>程序调用自己的编程技巧。函数和函数的调用可以构成一个环，就可以称作一个递归</li>
<li>通过重复将问题分解为同类子问题来解决问题</li>
<li>注意：<ol>
<li>递归就是在过程或函数里面调用自身(自递归)</li>
<li>使用递归，必须有一个明确的递归结束条件，称为递归出口。只有<strong>一个</strong>就行</li>
<li>两个或者多个函数互相递归(互递归)</li>
</ol>
</li>
<li>过程：<ol>
<li>递归：把复杂的问题的求解推到比原问题更简单的问题的求解</li>
<li>回归：获得最简单的情况后，逐步返回，依次得到复杂的解</li>
</ol>
</li>
<li>物理层面：递归栈</li>
</ul>
<h3 id="二、分治"><a href="#二、分治" class="headerlink" title="二、分治"></a>二、分治</h3><ul>
<li>分阶段：把问题分成两个大致相等的子问题，然后递归地对它们求解。</li>
<li>治阶段： 将两个子问题的解合并到一起，可能再做些少量的附加工作，最后得到整个问题的解。</li>
</ul>
<h3 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h3><ul>
<li>逐步求解，只关心眼前</li>
<li>Prim、Kruskal、Dijkstra</li>
</ul>
<h3 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h3><ul>
<li><p>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p>
<p>动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p>
</li>
<li><p>Bellman-Ford</p>
</li>
</ul>
<h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><ol>
<li>最短路径算法</li>
<li>不会考概念默写</li>
</ol>
<h2 id="第一章-1"><a href="#第一章-1" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li>递归会考</li>
<li>汉诺塔？</li>
</ol>
<h2 id="第二章-1"><a href="#第二章-1" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li>大O表示法，theta表示法，omega表示法，分析复杂度</li>
<li>分治？</li>
</ol>
<h2 id="第三章-（线性表，栈，队列）"><a href="#第三章-（线性表，栈，队列）" class="headerlink" title="第三章 （线性表，栈，队列）"></a>第三章 （线性表，栈，队列）</h2><ol>
<li>线性表<ol>
<li>单链表</li>
<li>双向链表不考，循环链表记不清了</li>
<li>约瑟夫不考</li>
<li>所有的排序都要注意</li>
</ol>
</li>
<li>栈<ol>
<li>栈的物理层实现不考</li>
</ol>
</li>
<li>队列</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol>
<li>概念要理解，如满二叉树和完全二叉树的区别</li>
<li>广义表不考</li>
<li>遍历，递归和<strong>非递归</strong></li>
<li>由序列建树</li>
<li>一般树的表示法：<ol>
<li>双亲表示（和并查集什么关系？）</li>
<li>左子女右兄弟</li>
<li>广义表（不考）</li>
</ol>
</li>
<li>线索树</li>
<li>搜索树</li>
<li>霍夫曼树</li>
<li>AVL树</li>
<li>B树</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol>
<li>平方取中法没考，杂乘没考，二次探测没考</li>
<li>线性探测容易考</li>
<li>链地址法（分离链接法）看看</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li>优先级队列就考堆了</li>
<li>证明不考</li>
<li>O（N）复杂度的建堆方法</li>
</ol>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol>
<li>并查集好像没考</li>
</ol>
<h2 id="第八章-（图）"><a href="#第八章-（图）" class="headerlink" title="第八章 （图）"></a>第八章 （图）</h2><ol>
<li>领接矩阵，邻接表要考</li>
<li>领结多重表不考</li>
<li>遍历算法</li>
<li>最小生成树，最短路径</li>
<li>AOE常考<ol>
<li>拓扑排序</li>
<li>算时间</li>
</ol>
</li>
</ol>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol>
<li>折半不考？</li>
<li>希尔不考</li>
<li>竞标赛不考</li>
<li>选择排序，快排，堆排序</li>
<li>归并是重点！！！</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">毛概复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="马克思主义中国化时代化的内涵（3点）"><a href="#马克思主义中国化时代化的内涵（3点）" class="headerlink" title="马克思主义中国化时代化的内涵（3点）***"></a>马克思主义中国化时代化的内涵（3点）***</h2><ol>
<li><p><strong>运用</strong>马克思主义的基本理论来指导我国的革命和建设：运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。</p>
<ol>
<li><strong>例子</strong>：例如，在新民主主义革命时期，马克思主义帮助中国共产党明确了中国社会的主要矛盾和革命任务，而在改革开放过程中，马克思主义为中国特色社会主义道路的选择提供了理论指导，提出了“发展是硬道理”的理念，为中国的快速发展指明了方向。</li>
</ol>
</li>
<li><p>把中国革命和建设中的经验<strong>上升</strong>为理论：总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</p>
<ol>
<li><strong>例子</strong>：如邓小平理论、三个代表重要思想、科学发展观等，都是在总结历史经验的基础上形成的新的理论，这些理论帮助我们把握了社会主义发展的规律，推动了中国特色社会主义事业的发展。</li>
</ol>
</li>
<li><p>把中国<strong>传统文化</strong>与马克思主义结合起来：运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其根植于中华优秀传统文化的土壤之中，具有中国特色、中国风格、中国气派。</p>
<ol>
<li><strong>例子</strong>：例如，习近平新时代中国特色社会主义思想就体现了这一点，特别是在推动中华民族伟大复兴的过程中，提出了“文化自信”，强调中国传统文化在现代社会中的重要作用，提倡从中国传统文化中汲取智慧，在马克思主义理论的指导下构建现代化的社会主义国家。</li>
</ol>
</li>
</ol>
<h2 id="马克思主义中国化的理论成果及其关系"><a href="#马克思主义中国化的理论成果及其关系" class="headerlink" title="马克思主义中国化的理论成果及其关系"></a>马克思主义中国化的理论成果及其关系</h2><ol>
<li>成果：<ol>
<li>毛泽东思想</li>
<li>邓小平理论</li>
<li>“三个代表”重要思想</li>
<li>科学发展观</li>
<li>习近平新时代中国特色社会主义理论</li>
</ol>
</li>
<li>关系：马克思主义中国化时代化的理论成果是<strong>一脉相承</strong>又<strong>与时俱进</strong>的关系。<ol>
<li>一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了<strong>基本遵循</strong>。</li>
<li>另一方面，中国特色社会主义理论体系在新的历史条件下进一步<strong>丰富和发展</strong>了毛泽东思想。</li>
</ol>
</li>
</ol>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="毛泽东思想的主要内容-（6点）"><a href="#毛泽东思想的主要内容-（6点）" class="headerlink" title="毛泽东思想的主要内容 （6点）"></a>毛泽东思想的主要内容 （6点）</h2><ol>
<li><p><strong>新民主主义</strong>革命理论：基本点一是认为中国资产阶级分为大资产阶级和民族资产阶级，二是认为中国革命只能以长期的武装斗争为主要形式。</p>
</li>
<li><p><strong>社会主义</strong>革命和社会主义建设理论：将马克思主义基本原理同中国国情”第二次结合“，是对如何进行社会主义革命和建设的具体指引</p>
</li>
<li><p>革命<strong>军队</strong>建设和军事战略的理论：规定了党对军队的绝对领导的原则。</p>
</li>
<li><p><strong>政</strong>策和策略的理论：指出政策和策略是党的生命，必须根据政治形势、阶级关系和实际情况及其变化制定党的政策。</p>
</li>
<li><p><strong>思想</strong>政治工作和<strong>文化</strong>工作的理论：思想政治工作是一切工作的生命线。要实行政治与经济、技术统一的方针，要发展民族的科学的大众的文化。</p>
</li>
<li><p><strong>党</strong>的建设理论：注重思想建党、理论强党，是我们党的鲜明特色和光荣传统。</p>
</li>
</ol>
<h2 id="毛泽东思想的活的灵魂（3点）"><a href="#毛泽东思想的活的灵魂（3点）" class="headerlink" title="毛泽东思想的活的灵魂（3点）***"></a>毛泽东思想的活的灵魂（3点）***</h2><ol>
<li><p>实事求是：是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。</p>
<ol>
<li>例如，毛泽东在土地改革和农村革命中，依据中国当时的社会结构和农民的实际情况，提出了有针对性的政策，实施了“打土豪分田地”，取得了广泛的支持。</li>
</ol>
</li>
<li><p>群众路线：毛泽东指出：“群众观点是共产党员革命的出发点和归宿。”群众路线是党在实际工作中形成的一套从群众中来、到群众中去的领导方法和工作方法。</p>
<ol>
<li>例如，在抗日战争时期，党通过组织广泛的人民抗战运动，发动了大量的群众力量，取得了战争的胜利。在土地改革时期，毛泽东依靠农民的力量开展了广泛的土地革命，改变了农村的阶级结构。</li>
</ol>
</li>
<li><p>独立自主：是中华民族的优良传统，是中国共产党、中华人民共和国立党立国的重要原则，是我们党从中国实际出发、依靠党和人民力量进行革命、建设、改革的必然结论。</p>
<ol>
<li>毛泽东在中国革命过程中始终坚持独立自主，不依赖外部势力的帮助，特别是在抗日战争期间，中国共产党通过坚持独立自主的道路，不仅赢得了战争的胜利，也奠定了党在国内外的威信。在建国后，毛泽东提出的“自力更生”政策，尤其体现在经济发展和外交战略上。</li>
</ol>
</li>
</ol>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="新民主主义革命的总路线（4点）"><a href="#新民主主义革命的总路线（4点）" class="headerlink" title="新民主主义革命的总路线（4点）"></a>新民主主义革命的总路线（4点）</h2><ol>
<li>内容：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</li>
<li>革命的<strong>对象</strong>：近代中国社会的性质和主要矛盾，决定了中国革命的主要敌人是帝国主义、封建主义和官僚资本主义。（三座大山）</li>
<li>革命的<strong>动力</strong>：包括无产阶级（最基本的动力）、农民阶级（主力军）、城市小资产阶级（可靠同盟者）和民族资产阶级（动力之一）。</li>
<li>革命的<strong>领导力量</strong>：无产阶级的领导权是中国革命的中心问题。新民主主义革命的领导权是在无产阶级手中。</li>
<li>革命的<strong>性质和前途</strong>：<ol>
<li>性质：资产阶级民主主义革命</li>
<li>前途：社会主义</li>
</ol>
</li>
</ol>
<h2 id="新民主主义革命基本纲领"><a href="#新民主主义革命基本纲领" class="headerlink" title="新民主主义革命基本纲领"></a>新民主主义革命基本纲领</h2><ol>
<li>新民主主义的政治纲领：人民民主专政。推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</li>
<li>经济纲领：保护个体手工业，没收官僚资本。没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</li>
<li>文化纲领：反帝反封建，形成科学的民族的大众的文化。新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</li>
</ol>
<h2 id="新民主主义革命的三大法宝"><a href="#新民主主义革命的三大法宝" class="headerlink" title="新民主主义革命的三大法宝"></a>新民主主义革命的三大法宝</h2><ol>
<li>统一战线：一要建立巩固的工农联盟，二要正确对待资产阶级，尤其是民族资产阶级，三要采取区别对待的方针，四要坚持独立自主的原则</li>
<li>武装斗争：革命人民只有武装起来，以武装的革命反对武装的反革命。</li>
<li>党的建设：中国共产党要领导革命取得胜利，必须不断加强党的思想建设、组织建设和作风建设。</li>
</ol>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="社会主义改造的历史经验"><a href="#社会主义改造的历史经验" class="headerlink" title="社会主义改造的历史经验"></a>社会主义改造的历史经验</h2><ol>
<li>坚持社会主义工业化建设和社会主义改造<strong>同时并举</strong>。实践证明，并举的方针对于在深刻的社会变革中保持社会稳定、经济发展具有十分重要的意义。</li>
<li>采取积极引导，<strong>逐步过渡</strong>的方式。实践证明，这种逐步过渡的办法符合农民的特点和生产力状况。</li>
<li>用<strong>和平方法</strong>进行改造。坚持用和平的办法，不仅保证了我国社会主义改造的顺利进行，而且维护了社会稳定，极大地促进了社会主义事业的发展。</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="初步探索的经验教训（6点）"><a href="#初步探索的经验教训（6点）" class="headerlink" title="初步探索的经验教训（6点）"></a>初步探索的经验教训（6点）</h2><ol>
<li><p>第一，必须把马克思主义与中国实际相<strong>结合</strong>，探索符合中国特点的社会主义建设道路。</p>
</li>
<li><p>第二，必须正确认识社会主义社会的主要矛盾和根本<strong>任务</strong>，集中力量发展生产力。</p>
</li>
<li><p>第三，必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，<strong>不能急于求成</strong>。</p>
</li>
<li><p>第四，必须发展社会主义<strong>民主</strong>，健全社会主义<strong>法制</strong></p>
</li>
<li><p>第五，必须坚持党的民主集中制和集体领导制度，加强执政党建设（<strong>党建</strong>）。</p>
</li>
<li><p>第六，必须坚持<strong>对外开放</strong>，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</p>
</li>
</ol>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="社会保障体系的内容和作用"><a href="#社会保障体系的内容和作用" class="headerlink" title="社会保障体系的内容和作用"></a>社会保障体系的内容和作用</h2><ol>
<li>内容（4点）<ol>
<li>社会救济：穷人</li>
<li>社会保险：主要劳动者</li>
<li>社会福利：共享社会…</li>
<li>优抚安置</li>
</ol>
</li>
<li>作用（4点）<ol>
<li>稳定社会：通过社会保障制度的实施，减少社会不安定因素，维护社会稳定和国家长治久安。</li>
<li>保障基本生活需求‌：在年老、疾病、伤残、失业等情况下，提供基本生活保障，确保公民的基本生存与生活需要。</li>
<li>保护劳动力的生产和再生产。在劳动力再生产遇到障碍时给予劳动者及其家属以基本生活、生命的必要保障,以维系劳动力再生产的需要,从而保证社会再生产的正常进行。</li>
<li>宏观调控：如建立社会保障基金</li>
</ol>
</li>
</ol>
<h2 id="国民收入再分配的原因和途径"><a href="#国民收入再分配的原因和途径" class="headerlink" title="国民收入再分配的原因和途径"></a>国民收入再分配的原因和途径</h2><ol>
<li>原因（3点）<ol>
<li>保持非物质生产部门的生存和发展</li>
<li>保证国民经济协调稳定发展：国民收入再分配有助于促进社会生产力既能较高速度地又能平衡协调地发展‌</li>
<li>建立社会后备基金：为了保障劳动者的基本生活，建立社会保障基金，包括应对突发事故和自然灾害的社会后备基金‌</li>
</ol>
</li>
<li>途径（3点）<ol>
<li>国家预算：通过国家年度集中性财政收支计划来实现‌</li>
<li>服务收费：各种非生产性劳务提供服务性劳动，享受这种服务的人们要以自己初次分配或再分配取得的收入支付劳务费用，从而使一部分国民收入向这些非生产性劳务部门转移‌</li>
<li>价格体系：商品价格的高低将直接影响有关当事人的收入分配，通过价格杠杆来实现国民收入的再分配‌</li>
</ol>
</li>
</ol>
<h2 id="国外市场经济模式"><a href="#国外市场经济模式" class="headerlink" title="国外市场经济模式"></a>国外市场经济模式</h2><ol>
<li>美国的，分散的，面向消费者的模式：<ol>
<li>自由的企业制度</li>
<li>完善的法律体系</li>
</ol>
</li>
<li>德国的，社会化的市场经济<ol>
<li>完备的社会保障制度</li>
<li>鼓励自由竞争</li>
</ol>
</li>
<li>法国的，计划化的市场经济<ol>
<li>完备的国民经济计划</li>
<li>高度集中，高度集权</li>
</ol>
</li>
<li>日本的，协调式的市场经济<ol>
<li>独特的企业文化（儒家文化）</li>
<li>官民共管</li>
</ol>
</li>
</ol>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="邓小平理论首要的基本的理论问题（了解）"><a href="#邓小平理论首要的基本的理论问题（了解）" class="headerlink" title="邓小平理论首要的基本的理论问题（了解）"></a>邓小平理论首要的基本的理论问题（了解）</h2><ol>
<li>首要的基本的问题：<ol>
<li>什么是社会主义：社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕</li>
<li>要坚持的原则：一是以社会主义公有制经济为主体，二是共同富裕</li>
</ol>
</li>
<li>精髓：解放思想，实事求是</li>
</ol>
<h2 id="邓小平理论的主要内容（7点）"><a href="#邓小平理论的主要内容（7点）" class="headerlink" title="邓小平理论的主要内容（7点）"></a>邓小平理论的主要内容（7点）</h2><ol>
<li><p>社会主义初级阶段理论和党的基本路线</p>
<ol>
<li>理论：社会主义本身是共产主义的初级阶段，而我们中国有处在社会主义的初级阶段，就是不发达的阶段</li>
<li>党的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自己更生，艰苦创业，为把我国建成富强明主文明的社会主义现代化国家而奋斗</li>
</ol>
</li>
<li><p>社会主义根本任务和发展战略理论</p>
<ol>
<li>社会主义的根本任务是发展生产力</li>
<li>分三步走基本实现现代化的发展战略<ol>
<li>第一步：到1990年，实现国民生产总值比1980年翻一番，解决人民的温饱问题</li>
<li>第二步：到20世纪末，使国民生产总值再增长一倍，人民生活达到小康水平</li>
<li>第三步：到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化。然后在此基础上继续前进。</li>
</ol>
</li>
</ol>
</li>
<li><p>社会主义改革开放和社会主义市场经济理论：</p>
<ol>
<li>改革开放：要发展生产力，经济体制改革是必由之路。改革是从根本上改变束缚生产力发展的经济体制，促进生产力的发展，解决社会主义社会发展动力的问题。<ol>
<li>中国的对内改革先从农村开始，1978年11月，实行“分田到户，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%87%AA%E8%B4%9F%E7%9B%88%E4%BA%8F/1801491?fromModule=lemma_inlink">自负盈亏</a>”的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%B6%E5%BA%AD%E8%81%94%E4%BA%A7%E6%89%BF%E5%8C%85%E8%B4%A3%E4%BB%BB%E5%88%B6/627664?fromModule=lemma_inlink">家庭联产承包责任制</a>（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7%E5%8C%85%E5%B9%B2/6927705?fromModule=lemma_inlink">大包干</a>）。在城市，国营企业的自主经营权得到了明显改善。</li>
</ol>
</li>
<li>市场经济：不再把计划经济和市场经济对立起来，实行计划与市场内在统一的体制，允许市场调节存在和发挥作用</li>
</ol>
</li>
<li><p>“两手抓，两手都要硬”：社会主义精神文明是社会主义社会的重要特征，社会主义发展应实现物质文明与精神文明的共同进步。</p>
</li>
<li><p>“一国两制”与祖国统一：实现祖国的完全统一，是中华民族的根本利益所在。“一国两制”，指在一个中国的前提下，国家的主体坚持社会主义制度，香港、澳门、台湾保持原有的资本主义制度长期不变。</p>
</li>
<li><p>中国特色社会主义外交和国际战略</p>
<ol>
<li>外交：明确维护我国的独立和主权，促进世界的和平与发展，是中国外交政策的基本目标。</li>
<li>国际战略：冷静观察，稳住阵脚，沉着应对</li>
</ol>
</li>
<li><p>党的建设理论：建设中国特色社会主义，关键在于坚持、加强和完善党的领导。没有中国共产党，就没有社会主义的新中国</p>
</li>
</ol>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="三个代表重要思想的核心观点和主要内容"><a href="#三个代表重要思想的核心观点和主要内容" class="headerlink" title="三个代表重要思想的核心观点和主要内容"></a>三个代表重要思想的核心观点和主要内容</h2><ol>
<li>核心观点：<ol>
<li>始终代表中国先进<strong>生产力</strong>的发展要求</li>
<li>始终代表中国先进<strong>文化</strong>的前进方向</li>
<li>始终代表中国最广大<strong>人民</strong>的根本利益</li>
</ol>
</li>
<li>主要内容（6点）：<ol>
<li><strong>发展</strong>是党执政兴国的第一要务</li>
<li>建立社会主义<strong>市场</strong>经济体制</li>
<li>全面建设<strong>小康</strong>社会</li>
<li>建设社会主义<strong>政治</strong>文明</li>
<li>实施“引进来”和“走出去”相结合的对外<strong>开放</strong>战略</li>
<li>推进<strong>党的建设</strong>新的伟大工程</li>
</ol>
</li>
</ol>
<h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="科学发展观的内涵"><a href="#科学发展观的内涵" class="headerlink" title="科学发展观的内涵"></a>科学发展观的内涵</h2><ol>
<li><strong>推动经济社会发展</strong>是科学发展观的<strong>第一要义</strong></li>
<li><strong>以人为本</strong>是科学发展的<strong>核心立场</strong>，发展是为了人民</li>
<li><strong>全面协调可持续</strong>是科学发展观的<strong>基本要义</strong></li>
<li><strong>统筹兼顾</strong>是科学发展观的<strong>根本方法</strong></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">计算机组成结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-12-04T12:00:00+08:00">2024-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:01:19" itemprop="dateModified" datetime="2025-12-03T17:01:19+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="第一章-·-计算机系统概述"><a href="#第一章-·-计算机系统概述" class="headerlink" title="第一章 · 计算机系统概述"></a>第一章 · 计算机系统概述</h2><h3 id="计算机的定义"><a href="#计算机的定义" class="headerlink" title="计算机的定义"></a>计算机的定义</h3><p>通用电子数字计算机</p>
<h3 id="组织与结构"><a href="#组织与结构" class="headerlink" title="组织与结构 ***"></a>组织与结构 ***</h3><ol>
<li><p>组织：对编程人员不可见。（类比：实现乘法是通过硬件单元还是重复加法，我们不得而知）</p>
<ul>
<li>操作单元及其相互连接。</li>
<li>包括控制信号，存储技术等等。</li>
</ul>
</li>
<li><p>结构：对编程人员可见。（类比：有没有乘法指令）</p>
<ul>
<li><p>直接影响程序逻辑执行的属性。</p>
</li>
<li><p>包括指令集，表示数据类型的位数等等。</p>
</li>
</ul>
</li>
</ol>
<h3 id="计算机简史"><a href="#计算机简史" class="headerlink" title="计算机简史"></a>计算机简史</h3><h4 id="发展迭代"><a href="#发展迭代" class="headerlink" title="发展迭代"></a>发展迭代</h4><ul>
<li>第一代：真空管</li>
<li>第二代：晶体管</li>
<li>第三代以及之后：集成电路</li>
</ul>
<h4 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h4><ol>
<li>五部分：<ul>
<li>主存储器</li>
<li>算术逻辑单元 &#x2F; 处理单元</li>
<li>程序控制单元 &#x2F; 控制单元</li>
<li>输入设备</li>
<li>输出设备</li>
</ul>
</li>
<li>存储程序思想：<ol>
<li>指令和数据以同等地位储存到存储器中，并且可以按地址访问</li>
<li>指令和数据以二进制表示</li>
</ol>
</li>
</ol>
<h4 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h4><ul>
<li>单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) &#x2F; 1970年起减慢为每18个月 翻一番 </li>
<li>影响 </li>
<li>由于单个芯片的成本几乎不变，计算机逻辑电路和存储电路的成本显著下降 </li>
<li>这里“成本”是指原料，但制作成本是不断增加的 </li>
<li>更小的尺寸带来更多灵活性和可能性 </li>
<li>更强的计算能力带来更多可能性 </li>
<li>减小了对电能消耗和冷却的要求 </li>
<li>集成电路上的内部连接比焊接更可靠，芯片间的连接更少</li>
</ul>
<h3 id="计算机性能"><a href="#计算机性能" class="headerlink" title="计算机性能 ***"></a>计算机性能 ***</h3><ul>
<li>计算机的关键参数：性能，成本，尺寸，安全性，可靠性，能耗……</li>
<li>性能评价标准<ul>
<li>CPU：速度</li>
<li>存储器：速度，容量</li>
<li>I&#x2F;O：速度，容量</li>
</ul>
</li>
</ul>
<h4 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h4><h5 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h5><ol>
<li><p>时钟频率 &#x2F; 时钟速度（单位：Hz）：计算机在单位时间内（例如1秒钟）执行最基本操 作的次数 </p>
</li>
<li><p>时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间</p>
</li>
</ol>
<ul>
<li><p>时钟滴答（有时也称为“时钟周期”）：CPU 中用于同步执行最基本操作的单个电子脉冲 </p>
</li>
<li><p>因此，周期时间即为两个电子脉冲之间的时间</p>
</li>
</ul>
<p>   注：</p>
<ol>
<li>不是主频越高性能越好，因为可能一个步骤要用几个时钟周期</li>
<li></li>
</ol>
<p>   $$<br>   时钟周期*时钟频率&#x3D;1<br>   $$</p>
<h5 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h5><ul>
<li><p>处理器由时钟驱动，时钟具有固定的频率f，或等价为固定的时钟周期t </p>
</li>
<li><p>如果用$CPI_i$来表示指定类型i所需要的周期数，用 表示在某一给定程序中所执行的i 类 指令的条数，则计算整个CPI如下：<br>$$<br>CPI&#x3D;\frac{\sum_{i&#x3D;1}^{n}(CPI_i*I_i)}{I_c},I_c&#x3D;\sum_{i&#x3D;1}^{n}I_i<br>$$</p>
</li>
<li><p>执行一个给定程序的处理时间表示为：<br>$$<br>T&#x3D;I_c<em>CPI</em>t<br>$$<br>每秒百万条指令（ Million Instructions Per Second ，MIPS）：<br>$$<br>MIPS&#x3D;\frac{I_c}{T<em>10^{6}}&#x3D;\frac{f}{CPI</em>10^6}<br>$$</p>
<p> 每秒百万条浮点操作（Million Floating Point Operations Per Second，MFLOPS)：<br>$$<br>MFLOPS&#x3D;\frac{N_{floating-point op}}{T*10^6}<br>$$</p>
</li>
</ul>
<h5 id="基准程序"><a href="#基准程序" class="headerlink" title="基准程序"></a>基准程序</h5><p>使用一系列基准程序来测量系统的性能 </p>
<ul>
<li>平均结果：</li>
<li>算数平均值（Arithmetic mean） </li>
<li>调和平均值（Harmonic mean）</li>
</ul>
<h4 id="性能设计的基本原则"><a href="#性能设计的基本原则" class="headerlink" title="性能设计的基本原则"></a>性能设计的基本原则</h4><ul>
<li>大概率事件优先原则</li>
<li>Amdahl定律 <ul>
<li>加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性比例 </li>
<li>性能增加的递减规则：如果仅仅对计算机中的一部分做性能改进，改进越多，系统获得 的效果越</li>
</ul>
</li>
</ul>
<h2 id="第二章-·-计算机的顶层视图"><a href="#第二章-·-计算机的顶层视图" class="headerlink" title="第二章 · 计算机的顶层视图"></a>第二章 · 计算机的顶层视图</h2><h3 id="计算机的工作原理"><a href="#计算机的工作原理" class="headerlink" title="计算机的工作原理"></a>计算机的工作原理</h3><ol>
<li>指令和数据存储在单个读写储存器中</li>
<li>主存中的内容按位置访问，不考虑内容类型</li>
<li>CPU以顺序的方式执行指令（除非明确修改）</li>
<li>I&#x2F;O模块与CPU，主存交换计算机系统外部的信息<ul>
<li>注：I&#x2F;O模块不是I&#x2F;O设备</li>
</ul>
</li>
</ol>
<h3 id="计算机体系结构遇到的问题及解决方案"><a href="#计算机体系结构遇到的问题及解决方案" class="headerlink" title="计算机体系结构遇到的问题及解决方案"></a>计算机体系结构遇到的问题及解决方案</h3><ul>
<li>CPU的频率不能无限提高 ➔ 改进CPU芯片结构 </li>
<li>内存墙的存在 ➔ 采用高速缓存（Cache） </li>
<li>CPU等待I&#x2F;O传输数据 ➔ 采用中断机制 </li>
<li>兼顾存储容量、速度和成本 ➔ 层次式存储结构 </li>
<li>I&#x2F;O设备传输速率差异大 ➔ 采用缓冲区和改进I&#x2F;O操作技术 </li>
<li>计算机部件互连复杂 ➔ 采用总线</li>
</ul>
<h2 id="第三章-·-数据的机器级表示"><a href="#第三章-·-数据的机器级表示" class="headerlink" title="第三章 · 数据的机器级表示"></a>第三章 · 数据的机器级表示</h2><h3 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h3><ol>
<li><p>编码：用少量简单的基本符号对复杂多样的信息进行一定规律的组合。实际上是现实世界的无限连续的信号到计算机有限离散的映射。</p>
</li>
<li><p>k位二进制编码可以至多表示2^k个不同的值</p>
<ul>
<li>注：可以小于等于，不能大于。比如我令00和11都表示值0。</li>
</ul>
</li>
<li><p>补码，互补。一个数的补码和他本身加起来得到2^k。或者说，一个数的补码就是2^k减去它。</p>
<ul>
<li>在补码表示中，正数的第一位为0，负数的第一位为1。即使不是符号位，也有这个规律。</li>
</ul>
</li>
</ol>
<h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示 ***"></a>浮点数的表示 ***</h3><ol>
<li><p>规格化表示：要求要表达的浮点小数点左边为1。</p>
</li>
<li><p>32位表示：</p>
<ul>
<li>符号位（s)：1位</li>
<li>指数位（E)：8位</li>
<li>尾数（S)：23位</li>
</ul>
</li>
<li><p>•补码（相对于无符号数） （实际上是强制无符号数变成有符号数）</p>
<ul>
<li>000…000 ~ 011…111：表示的值 不变</li>
<li>100…000 ~ 111…111：表示的值由 2^(k-1)<del>2^k-1变为-2^(k-1)</del>-1</li>
<li>真值为原来的无符号数对应的真值减去2^k（取反加1的由来）</li>
</ul>
</li>
<li><p>规格化数可表示范围：<br>$$<br>-(2-2^{-23})*2^{127}到-2^{-127}之间的负数<br>$$<br>和<br>$$<br>2^{-127}到(2-2^{-23})*2^{127}之间的正数<br>$$</p>
</li>
<li><p>有非规格化的数：</p>
<ul>
<li>解决了下溢的情况</li>
</ul>
</li>
<li><p>浮点数编码表示的性质：</p>
<ul>
<li>总体是不均匀的，局部是均匀的。</li>
<li>对于32位数，它所能表示的数上限一定是确定的。</li>
<li>总体上，绝对值越大的范围内可以表示的数越“稀疏”。1</li>
<li>在同一个数量级上（即指数位相同）的范围里，数的表示是均匀的。</li>
</ul>
</li>
<li><p>多种情况：</p>
<ul>
<li>指数位：00000000<ul>
<li>非规格化数，尾数表示 0.S ，能表示0到2^-126^的数。注意！！！指数位全为零时表示2^1-127&#x3D;-126^。（？</li>
</ul>
</li>
<li>指数位：11111111<ul>
<li>尾数位全零：无穷</li>
<li>尾数位非纯零：NaN</li>
</ul>
</li>
<li>指数位：其他情况<ul>
<li>规格化数</li>
</ul>
</li>
</ul>
</li>
<li><p>舍入：</p>
<ul>
<li>朝正无穷舍入</li>
<li>朝负无穷舍入</li>
<li>朝零舍入</li>
<li>就近舍入</li>
</ul>
</li>
</ol>
<h3 id="二进制编码十进制（BCD）"><a href="#二进制编码十进制（BCD）" class="headerlink" title="二进制编码十进制（BCD）"></a>二进制编码十进制（BCD）</h3><ol>
<li>自然BCD码 (NBCD, 8421 码) <ul>
<li>0 ~ 9: 0000 ~ 1001 </li>
<li>符号: 使用四个最高有效位 </li>
<li>正: 1100 &#x2F; 0 ， 负: 1101 &#x2F; 1 </li>
<li>例子： <ul>
<li>+2039: 1100 0010 0000 0011 1001 &#x2F; 0 0010 0000 0011 1001</li>
<li>-1265: 1101 0001 0010 0110 0101 &#x2F; 1 0001 0010 0110 0101</li>
</ul>
</li>
</ul>
</li>
<li>其他BCD码 • 2421, 5211, 4311, …</li>
</ol>
<h2 id="第四章-·-数据校验"><a href="#第四章-·-数据校验" class="headerlink" title="第四章 · 数据校验"></a>第四章 · 数据校验</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>P1：1,2,4,5,7</p>
<p>P2：1,3,4,6,7</p>
<p>P3：2,3,4,8</p>
<p>P4：5,6,7,8</p>
<h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><h1 id="中央处理器（CPU）"><a href="#中央处理器（CPU）" class="headerlink" title="中央处理器（CPU）"></a>中央处理器（CPU）</h1><h2 id="第五章-·-整数运算"><a href="#第五章-·-整数运算" class="headerlink" title="第五章 · 整数运算"></a>第五章 · 整数运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><h4 id="全加器（FA）"><a href="#全加器（FA）" class="headerlink" title="全加器（FA）"></a>全加器（FA）</h4><ol>
<li>延时：<ol>
<li>逻辑门延时：<ol>
<li>与门延迟：1级门延迟 (1ty)</li>
<li>或门延迟：1级门延迟 (1ty)</li>
<li>异或门延迟：3级门延迟 (3ty)</li>
</ol>
</li>
<li>运算延时：<ol>
<li>$S_i&#x3D;X_i⊕Y_i⊕C_{i-1}$</li>
<li>$C_i&#x3D;X_iC_{i-1}+Y_iC_{i-1}+X_iY_i$</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>缺点：慢</li>
</ul>
<h4 id="全先行进位加法器（CLA）"><a href="#全先行进位加法器（CLA）" class="headerlink" title="全先行进位加法器（CLA）"></a>全先行进位加法器（CLA）</h4><ul>
<li>缺点：复杂</li>
</ul>
<h4 id="部分先行进位加法器"><a href="#部分先行进位加法器" class="headerlink" title="部分先行进位加法器"></a>部分先行进位加法器</h4><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ol>
<li>乘法器原理</li>
</ol>
<p>![屏幕截图 2024-09-26 062919](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-26 062919.png)</p>
<ol start="2">
<li>有符号乘法：<ol>
<li>原理：布斯算法 ***<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241224221732284.png" alt="image-20241224221732284"><ol>
<li>流程：<ul>
<li>记$Y_0&#x3D;0$</li>
<li>根据$Y_i-Y_{i+1}$, 决定是否增加+X，-X，0；</li>
<li>右移部分积</li>
<li>重复第二、三步</li>
</ul>
</li>
<li>注意：<ol>
<li>由于是有符号数的运算，在右移时补位要补的是符号位</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ol>
<li><p>计算机除法原理：不断的削减被除数的绝对值到最小而不变号。</p>
<ul>
<li>注意：在计算机内，余数是和被除数同号的。即，若被除数为负数，余数也为负数。这与数学上不一样。</li>
<li>部分余数：计算过程中的余数</li>
</ul>
</li>
<li><p>无符号除法![屏幕截图 2024-09-26 072639](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-26 072639.png)</p>
<p>![屏幕截图 2024-09-26 072720](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-26 072720.png)</p>
<ol start="3">
<li>有符号<ol>
<li>恢复余数流程：<ol>
<li>![屏幕截图 2024-09-26 073410](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-09-26 073410.png)</li>
</ol>
</li>
<li>不恢复余数流程：<ul>
<li>通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄 存器中 </li>
<li>将余数和商左移，判断是否“够减”<ul>
<li>如果“够”，则做减法（同号）或者加法（异号），并上 商为1 </li>
<li>如果“不够，则上商为0</li>
</ul>
</li>
<li>重复以上步骤 </li>
<li>如果除数和被除数不同号，则将商替换为其相反数 </li>
<li>余数存在余数寄存器中</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>![屏幕截图 2024-10-10 063945](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-10 063945.png)</p>
<ul>
<li>本质就是这次多减了，下次加回去</li>
</ul>
<h2 id="第六章-·-浮点数运算"><a href="#第六章-·-浮点数运算" class="headerlink" title="第六章 · 浮点数运算"></a>第六章 · 浮点数运算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><ol>
<li>流程：![屏幕截图 2024-10-10 065152](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-10 065152.png)<ol>
<li>查零    </li>
<li>对阶：小向大对齐，尾数右移，损失小。同时查零。</li>
<li>相加并调整浮点</li>
<li>处理溢出</li>
<li>舍入：若上溢，设为无穷；若下溢，用非规格化表示</li>
</ol>
</li>
<li>减法：加第二个操作数的补码（一个数的原码和补码之和为2^k^）<ul>
<li>如果最高位有进位，正确 (符号与被减数相同) </li>
<li>否则，计算它的补码作为原码，且符号与被减数相反</li>
</ul>
</li>
</ol>
<h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><p>![屏幕截图 2024-10-11 195205](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-11 195205.png)</p>
<ol>
<li><p>流程</p>
<ol>
<li><p>无论哪个操作数是0，乘积 即为0 </p>
</li>
<li><p>指数运算：从阶值的和中减去一个偏移量<br>$$<br>E_{mul}&#x3D;E_a+E_b-127<br>$$</p>
</li>
</ol>
</li>
<li><p>尾数运算：有效值相乘 （就直接乘就完了）</p>
</li>
<li><p>结果的规格化和舍入处理，规格化可能导致阶值下溢</p>
</li>
</ol>
<h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ol>
<li><p>流程：</p>
<ol>
<li><p>如果除数为0，则报告出错， 或将结果设置为无穷大</p>
</li>
<li><p>如果被除数是0，则结果是0</p>
</li>
<li><p>被除数的阶值减除数的阶值， 加上偏移量<br>$$<br>E_{div}&#x3D;E_a-E_b+127<br>$$</p>
</li>
<li><p>有效值相除</p>
</li>
<li><p>结果规格化和舍入处理</p>
<p>![屏幕截图 2024-10-11 200340](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-11 200340.png)</p>
</li>
</ol>
</li>
<li><p>保护位：24位有效值做运算时，放在ALU左端，右端多出来的几位作保护位。</p>
<ul>
<li>对有效值操作的结果通常保存在更长的寄存器中。当结果转换回浮点格式时，必须要去掉多余的位，有四种方法</li>
</ul>
</li>
</ol>
<h2 id="第七章-·-二进制编码的十进制数运算"><a href="#第七章-·-二进制编码的十进制数运算" class="headerlink" title="第七章 · 二进制编码的十进制数运算"></a>第七章 · 二进制编码的十进制数运算</h2><ol>
<li><p>表示：</p>
<ol>
<li><p>数字<br>• 0 ~ 9：0000 ~ 1001</p>
</li>
<li><p>符号</p>
<p>• 正: 1100 &#x2F; 0<br>• 负: 1101 &#x2F; 1</p>
</li>
</ol>
</li>
</ol>
<h3 id="加法-1"><a href="#加法-1" class="headerlink" title="加法"></a>加法</h3><ol>
<li>补偿：用4位二进制实际上可以看作十六进制，这比十进制能多表示6个数。所以当运算之后某处表示了大于十的数，应该加6帮忙进位。</li>
</ol>
<h2 id="第九章-·-高速缓冲存储器（Cache）"><a href="#第九章-·-高速缓冲存储器（Cache）" class="headerlink" title="第九章 · 高速缓冲存储器（Cache）"></a>第九章 · 高速缓冲存储器（Cache）</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>解决内存墙带来的CPU和主存协作问题</li>
</ul>
<ol>
<li>在使用主存（相对大而慢）之余，添加一块小而快的cache</li>
<li>Cache位于CPU和主存之间，可以集成在CPU内部或作为主板 上的一个模块</li>
<li>Cache中存放了主存中的部分信息的“副本”</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li><p>检查（Check）：当CPU试图访问主存中的某个字时，首先检查 这个字是否在cache中</p>
</li>
<li><p>检查后分两种情况处理：</p>
</li>
<li><p>命中（Hit）：如果在cache中，则把这个字传送给CPU</p>
</li>
<li><p>未命中（Miss）：如果不在cache中, 则将主存中包含这个字固定 大小的块（block）读入cache中，然后再从cache传送该字给CPU</p>
</li>
<li><p>注：</p>
<ol>
<li><p>如何判断命中与否？</p>
<ol>
<li>冯·诺伊曼体系的设计： CPU通过位置对主存中的内容进行寻址，不关心存储在其中的内容</li>
<li>Cache通过标记（tags）来标识其内容在主存中的对应位置</li>
</ol>
</li>
<li><p>如果未命中，为什么不直接把所需要的字从内存传送到CPU?为什么从内存中读入一个块而不只读入一个字?</p>
<ol>
<li>程序访问的局部性原理：处理器频繁访问主存中相同位置或者相邻存储位置的现象</li>
<li>类型：<ol>
<li>时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同位置的信息） </li>
<li>空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据<ul>
<li>顺序局部性：当数据被线性排列和访问时，出现的空间局部性 的一种特殊情况。例如：遍历一维数组中的元素</li>
</ul>
</li>
</ol>
</li>
<li>利用时间局部性：可能多次取同一个数据，所以第一次取的时候会把数据复制到cache中，以便之后取用。</li>
<li>利用空间局部性：可能短时间内取多个相邻数据，所以复制一个块以便之后取用。</li>
</ol>
</li>
<li><p>使用Cache后需要更多的操作，为什么还可以节省时间?</p>
</li>
<li><p>假设p是命中率， $T_c$是cache的访问时间，$T_m$是主存的访问时间，使用cache时的平均访问时间为<br>$$<br>T_A&#x3D;p<em>T_C+(1-p)</em>(T_C+T_M)&#x3D;T_C+(1-p)*T_M<br>$$</p>
<ul>
<li>命中率p越大， $T_C$越小， 效果越好</li>
<li>如果想要 $T_A&lt;T_M$, 必须要求 $p&gt;T_C&#x2F;T_M$</li>
<li>难点：cache的容量远远小于主存的容量</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="设计要素"><a href="#设计要素" class="headerlink" title="设计要素"></a>设计要素</h3><ol>
<li><p>容量：扩大容量可以提高p，但是增加了成本和$T_C$</p>
</li>
<li><p>映射功能：</p>
<ol>
<li><p>直接映射：</p>
<ol>
<li><p>将主存中的每个块映射到一个固定可用的cache行中</p>
</li>
<li><p>假设𝑖是cache行号，𝑗是主存储器的块号，𝐶是cache的行数</p>
</li>
</ol>
<p>   i &#x3D; j mod C</p>
<ol start="3">
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241024151614944.png" alt="image-20241024151614944"></p>
<ul>
<li>前两部分合称为块号</li>
</ul>
</li>
<li><p>流程：</p>
<ol>
<li>对块号进行mod C，得到了块所在的行号。对于二进制而言，mod 4 表示取后两位。</li>
<li>找到行号cache中对应的行，检查块号前的tag和行号前的tag。若相同则表示这一行后面的数据是所求的块。</li>
<li>找到对应的块，再利用块内地址找到数据。</li>
</ol>
</li>
<li><p>优点：简单，快速</p>
</li>
<li><p>缺点：抖动现象：如果一个程序重复访问两个需要映射到 同一行中且来自不同块的字，则这两个块不断地被交换到cache中， cache的命中率将会降低</p>
</li>
<li><p>适合大容量cache</p>
</li>
</ol>
</li>
<li><p>关联映射：</p>
<ol>
<li>一个主存块可以装入cache任意一行</li>
<li>寻找块时要遍历cache所有行</li>
<li>优点：避免抖动现象</li>
<li>缺点：实现起来比较复杂，$T_C$变长</li>
<li>适合小容量cache</li>
</ol>
</li>
<li><p>组关联映射</p>
<ol>
<li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行。组间为直接映射，组内为关联映射。<ol>
<li>假设𝑠是cache组号，𝑗是主存块号，𝑆是组数 𝑠 &#x3D; 𝑗 𝑚𝑜𝑑 𝑆 </li>
<li>K-路组关联映射 𝐾 &#x3D; C &#x2F; S。即：每个组里有几行。</li>
</ol>
</li>
<li>优点：结合了前两种的优点</li>
<li>缺点：结合了前两种的缺点</li>
</ol>
</li>
</ol>
</li>
<li><p>替换算法</p>
<ul>
<li>直接映射没得选，每个块只有一个位置可以放</li>
</ul>
<ol>
<li>最近最少使用算法<ol>
<li>假设：最近使用过的数据块更有可能会被再次使用</li>
<li>策略：替换掉在cache中最长时间未被访问的数据块</li>
</ol>
</li>
<li>先进先出算法</li>
<li>假设：最近由主存载入Cache的数据块更有可能被使用</li>
<li>策略：替换掉在Cache中停留时间最长的块</li>
<li>最不经常使用算法</li>
<li>假设：访问越频繁的数据块越有可能被再次使用</li>
<li>策略：替换掉cache中被访问次数最少的数据块</li>
<li>随机替换算法</li>
<li>假设：每个数据块被再次使用的可能性是相同的</li>
<li>策略：随机替换cache中的数据块</li>
<li>实现：随机替换。随机替换算法在性能上只稍逊于使用其它替换算法</li>
</ol>
</li>
<li><p>写策略</p>
<ol>
<li>写直达：<ol>
<li>所有写操作都同时对cache和主存进行</li>
<li>优点：确保主存中的数据总是和cache中的数据一致，总是最新的</li>
<li>缺点：产生大量的主存访问，减慢写操作</li>
</ol>
</li>
<li>写回法<ol>
<li>先更新cache中的数据，当cache中某个数据块被替换时，如 果它被修改了，才被写回主存。利用一个脏位（dirty bit）或者使用位（use bit）来表示块是 否被修改</li>
<li>优点：减少了访问主存的次数</li>
<li>缺点：部分主存数据可能不是最新的</li>
</ol>
</li>
</ol>
</li>
<li><p>行大小</p>
<ol>
<li>假设从行的大小为一个字开始，随着行大小的逐步增大，则Cache命中率会增加</li>
<li>当行大小变得较大之后，继续增加行大小，则Cache命中率会下降</li>
</ol>
</li>
<li><p>Cache数目：</p>
<ol>
<li>一级VS.多级</li>
<li>统一VS.分立</li>
</ol>
</li>
</ol>
<h2 id="第十三章-·-指令系统"><a href="#第十三章-·-指令系统" class="headerlink" title="第十三章 · 指令系统"></a>第十三章 · 指令系统</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ol>
<li>立即寻址：指令里存放操作数</li>
<li>直接寻址：指令里存放操作数地址（A），把操作数放在内存中</li>
<li>间接寻址：指令里存放的是有效地值（EA）的地址，EA放在内存中，再访问EA得到操作数</li>
<li>寄存器寻址：指令里存放寄存器编号，寄存器里面放操作数</li>
<li>寄存器间接寻址：指令里存放寄存器编号，寄存器放EA</li>
<li>偏移寻址：EA &#x3D; （R）+ A<ol>
<li>相对寻址：R默认为PC。A为偏移量</li>
<li>基址寄存器寻址（寄存器为基）：被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地址的偏移量</li>
<li>变址寻址（寄存器为变）：指令中有一个形式地址，被引用的寄存器含有对于该地址的一个正的偏移量</li>
</ol>
</li>
<li>栈寻址：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li>
</ol>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><ol>
<li>指令格式通过它的各个构成部分来定义指令的位安排</li>
<li>一个指令格式必须包含一个操作码，以及隐式或显式的、零个或<br>多个操作数</li>
<li>指令格式必须显式或隐式地为每个操作数指定其寻址方式</li>
<li>大多数指令集使用不止一种指令格式</li>
</ol>
<h2 id="第十四章-·-指令周期和指令流水线"><a href="#第十四章-·-指令周期和指令流水线" class="headerlink" title="第十四章 · 指令周期和指令流水线"></a>第十四章 · 指令周期和指令流水线</h2><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><ol>
<li>指令的执行可能涉及一个或多个存储器中的操作数，它们每<br>   个都要求一次存储器访问。使用间接寻址，还需要额外的存储器访问</li>
<li>间址周期：把间接地址的读取看成是一个额外的指令子周期</li>
</ol>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="/home/mukongshan/.config/Typora/typora-user-images/image-20241121145038280.png" alt="image-20241121145038280"></p>
<h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><ul>
<li>指令流水线：一条指令的处理过程分成若干个阶段，每个阶段由<br>  相应的功能部件完成</li>
</ul>
<ol>
<li><p>两阶段方法：</p>
<ol>
<li>将指令处理分成两个阶段：取指令和执行指令。在当前指令的执行期间取下一条指令</li>
<li>问题：<ol>
<li>执行时间一般要长于取指时间</li>
<li>主存访问冲突</li>
<li>条件分支指令使得待取的下一条指令的地址是未知的</li>
</ol>
</li>
</ol>
</li>
<li><p>六阶段方法：</p>
<ol>
<li>六个阶段<ol>
<li>取指令（Fetch instruction，FI）：读下一条预期的指令到缓冲器</li>
<li>译码指令（Decode instruction，DI）：确定操作码和操作数指定符</li>
<li>计算操作数（Calculate operands，CO）：计算每个源操作数的有效地址</li>
<li>取操作数（Fetch operands，FO）：从存储器取出每个操作数，寄存器中<br>的操作数不需要取</li>
<li>执行指令（Execute instruction，EI）：完成指定的操作。若有指定的目的<br>操作数位置，则将结果写入此位置</li>
<li>写操作数（Write operand，WO）：将结果存入存储器</li>
</ol>
</li>
<li>注意：<ol>
<li>不是所有指令都包含6个阶段<br>• 例：一条LOAD指令不需要WO阶段</li>
<li>为了简化流水线硬件设计，在假定每条指令都要求这6个阶段的基<br>础上来建立时序</li>
<li>不是所有的阶段都能并行完成<br>• 例：FI、FO和 WO都涉及存储器访问</li>
<li>若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</li>
</ol>
</li>
<li>限制：<ol>
<li>条件转移指令能使若干指令的读取变为无效</li>
</ol>
</li>
</ol>
</li>
<li><p>误解：流水线中的阶段数越多，执行速度越快。$t &#x3D; t_m + d$，d是固定的</p>
</li>
<li><p>对于k阶段流水线执行n条指令所需时间为：$T_{k,n}&#x3D;[k+(n-1)]t$</p>
</li>
<li><p>加速比：<br>$$<br>S_k&#x3D;\frac{T_{1,n}}{T_{k,n}}&#x3D;\frac{nkt}{[k+(n-1)]t}&#x3D;\frac{n}{1+\frac{n-1}{k}}&gt;1<br>$$</p>
</li>
</ol>
<h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><ol>
<li>类型：<ol>
<li>结构冒险（Structure hazard） &#x2F; 硬件资源冲突</li>
<li>数据冒险（Data hazard） &#x2F; 数据依赖性<ol>
<li>解决方案三：旁路(处理不了load)</li>
<li>解决方案四：交换指令顺序</li>
</ol>
</li>
<li>控制冒险（Control hazard）</li>
</ol>
</li>
</ol>
<h2 id="第十五章-·-控制器"><a href="#第十五章-·-控制器" class="headerlink" title="第十五章 · 控制器"></a>第十五章 · 控制器</h2><h3 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h3><ol>
<li><p>定义</p>
<ol>
<li>执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令</li>
<li>每个指令周期又可以看作是由几个更小的子周期组成，包括：取指、间址、执行、中断</li>
<li>每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些 步骤称为微操作</li>
</ol>
</li>
<li><p>分组原则：</p>
<ul>
<li>所谓同组或者同时进行，就是说交换顺序也不会影响结果</li>
</ul>
<ol>
<li>事件的流动顺序必须是恰当的</li>
<li>必须避免冲突</li>
<li>满足上述条件下，所用的时间单位尽可能少</li>
</ol>
</li>
</ol>
<h3 id="指令周期代码（ICC，Instruction-Cycle-Code）"><a href="#指令周期代码（ICC，Instruction-Cycle-Code）" class="headerlink" title="指令周期代码（ICC，Instruction Cycle Code）"></a>指令周期代码（ICC，Instruction Cycle Code）</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126173941791.png" alt="image-20241126173941791"></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126174334927.png" alt="image-20241126174334927"></p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126174432139.png" alt="image-20241126174432139"></p>
<ul>
<li>注：AC是累加器，是ALU的数据源之一</li>
</ul>
<ol>
<li><p>控制CPU的功能需求</p>
<ol>
<li>CPU的基本元素 <ol>
<li>ALU，寄存器组，内部数据通路，控制器，外部数据通路</li>
</ol>
</li>
<li>CPU需要完成的微操作 <ol>
<li>在寄存器之间传送数据</li>
<li>将数据由寄存器传送到外部接口（如系统总线）</li>
<li>将数据由外部接口传送到寄存器</li>
<li>将寄存器作为输入和输出，完成算术和逻辑运算</li>
</ol>
</li>
<li>控制器的两个基本任务<ol>
<li>定序（sequencing）：根据正被执行的程序，控制器使CPU以正确 的顺序通过一系列微操作</li>
<li>执行（execution）：控制器使每个微操作得以完成</li>
</ol>
</li>
</ol>
</li>
<li><p>控制器的输入</p>
<ol>
<li><p>指令寄存器（IR）：当前指令的寻址方式（影响间址周期）和操作码（影响执行）</p>
</li>
<li><p>外部控制信号（包括中断）</p>
<ol>
<li>标志：确定CPU的状态和前一个ALU操作的结果</li>
<li>时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作</li>
<li>来自控制总线的控制信号：向控制器提供控制信号</li>
</ol>
</li>
<li><p>标记</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126174939913.png" alt="image-20241126174939913"></p>
</li>
</ol>
</li>
<li><p>控制器的输出</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241126175746840.png" alt="image-20241126175746840"></p>
</li>
<li><p>控制器的最小特性</p>
<ol>
<li>它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如 正负、溢出等），而不需要知道正被处理的数据或得到的实际结 果具体是什么</li>
<li>它只是以少量的送到CPU内的和送到系统总线上的控制信号来实 现控制</li>
</ol>
</li>
<li><p>控制器的实现</p>
<ol>
<li>硬布线实现（hardwired implementation）：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号， 即控制信号</li>
<li>微程序实现（microprogrammed implementation）：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通 过执行每条微指令来产生控制信号</li>
</ol>
</li>
</ol>
<h3 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h3><ol>
<li><p>基本思路和概念<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241128144729545.png" alt="image-20241128144729545"></p>
</li>
<li><p>构成</p>
<ol>
<li>注意，存入控制缓冲寄存器的微指令就可以认为是直接执行了<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241128144910038.png" alt="image-20241128144910038"></li>
</ol>
</li>
<li><p>工作流程</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241128144547676.png" alt="image-20241128144547676"></p>
</li>
</ol>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="第八章-·-内部存储器"><a href="#第八章-·-内部存储器" class="headerlink" title="第八章 · 内部存储器"></a>第八章 · 内部存储器</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>存储器（Memory）由一定数量的单元构成，每个单元可以被<br>唯一标识，每个单元都有存储一个数值的能力</p>
<ul>
<li>地址：单元的唯一标识符（采用二进制）</li>
<li>地址空间：可唯一标识的单元总数</li>
<li>寻址能力：存储在每个单元中的信息的位数</li>
<li>大多数存储器是字节寻址的，而执行科学计算的计算机通常是64位寻址的</li>
</ul>
<h3 id="半导体存储器-屏幕截图-2024-10-21-172723-C-Users-HUAWEI-Pictures-Screenshots-屏幕截图-2024-10-21-172723-png"><a href="#半导体存储器-屏幕截图-2024-10-21-172723-C-Users-HUAWEI-Pictures-Screenshots-屏幕截图-2024-10-21-172723-png" class="headerlink" title="半导体存储器![屏幕截图 2024-10-21 172723](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-21 172723.png)"></a>半导体存储器![屏幕截图 2024-10-21 172723](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-21 172723.png)</h3><ol>
<li><p>用半导体芯片作主存储器是目前的主流做法</p>
</li>
<li><p>位元（memory cell）</p>
<ol>
<li><p>半导体存储器的基本元件，用于存储1位数据</p>
</li>
<li><p>特性</p>
<ul>
<li><p>呈现两种稳态（或半稳态）：分别表示二进制的0和1</p>
</li>
<li><p>它们能够至少被写入（write）数据一次：用来设置状态</p>
</li>
<li><p>它们能够被读取（read）来获得状态信息</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h4><ol>
<li>特性：<ol>
<li>随机访问：访问地址的时间是相对一致的</li>
<li>可以简单快速的读写</li>
<li>易失的</li>
</ol>
</li>
<li>类型<ol>
<li>动态RAM（DRAM）<ol>
<li>在电容器上用电容充电的方式存储数据，电容器中有无电荷在分别代表二进制的1与0</li>
<li>需要周期地充电刷新以维护数据存储<ul>
<li>原因：电容器有漏电的自然趋势</li>
<li>由一个阈值来确定电荷是被解释为1还是0</li>
</ul>
</li>
</ol>
</li>
<li>静态RAM（SRAM）<ol>
<li>只要有电源，就可以一直维持数据</li>
<li>要有电源，但不用刷新</li>
</ol>
</li>
<li>DRAM和SRAM类型对比<ol>
<li>相同点： 易失的：两者都要求电源持续供电才能保存位值</li>
<li>不同点：<ul>
<li>DRAM比SRAM具有更简单、更小的位元，但要求能支持刷新<br>的电路</li>
<li>DRAM比相应的SRAM集成度更高，价格更低</li>
<li>SRAM通常比DRAM快</li>
<li>DRAM更倾向于满足大容量存储器的需求，SRAM一般用于高<br>  速缓存，DRAM用于主存</li>
</ul>
</li>
</ol>
</li>
<li>SDRAM（要刷新）<ul>
<li>传统DRAM是异步的，DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓 冲将数据输出，处理器只能等待这段延迟，即存取时间 。延时后，DRAM才写入或读取数据</li>
<li>SDRAM与处理器的数据交互同步与外部的时钟信号，并且以处理器&#x2F;存储器总 线的最高速度运行，而不需要插入等待状态。由于SDRAM随系统时钟及时移动数据，CPU知道数据何时准备好，控制器可以完成其它工作</li>
<li>理解：在内存没有准备好数据的时候，CPU先干其他事情</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ol>
<li>特性：<ol>
<li>随机访问</li>
<li>非易失的</li>
</ol>
</li>
<li>类别：<ol>
<li>ROM：只能写一次，用掩膜</li>
<li>可编程ROM（PROM）：也只能写一次，只是这次用电来“编程”，用户写入想要的东西</li>
<li>（紫外线）可擦除PROM（EPROM）：电写入，光擦除</li>
<li>电可擦除PROM（EEPROM）：电写入，电擦除</li>
<li>快闪存储器（Flash Memory）：<ol>
<li>特电可擦除：与EEPROM相同，优于EPROM </li>
<li>擦除时间为几秒：优于EPROM，不如EEPROM </li>
<li>可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM</li>
<li>达到与EPROM相同的密度：优于EEPROM </li>
<li>与EPROM、EEPROM对比 ：价格和功能介于EPROM和EEPROM之间</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="从位元到主存-屏幕截图-2024-10-21-202052-C-Users-HUAWEI-Pictures-Screenshots-屏幕截图-2024-10-21-202052-png"><a href="#从位元到主存-屏幕截图-2024-10-21-202052-C-Users-HUAWEI-Pictures-Screenshots-屏幕截图-2024-10-21-202052-png" class="headerlink" title="从位元到主存![屏幕截图 2024-10-21 202052](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-21 202052.png)"></a>从位元到主存![屏幕截图 2024-10-21 202052](C:\Users\HUAWEI\Pictures\Screenshots\屏幕截图 2024-10-21 202052.png)</h3><ol>
<li><p>寻址单元：由若干相同地址的位元组成</p>
</li>
<li><p>寻址模式：</p>
<ol>
<li>字节（Byte）</li>
<li>字（Word）</li>
</ol>
</li>
<li><p>如何寻址：用地址译码器</p>
<ol>
<li>一个n位译码器有2^n^种输出</li>
</ol>
</li>
<li><p>如何刷新：</p>
<ol>
<li>集中式刷新（Centralized refresh）<br>• 停止读写操作，并刷新每一行<br>• 刷新时无法操作内存</li>
<li>分散式刷新（Decentralized refresh）<br>• 在每个存储周期中，当读写操作完成时进行刷新<br>• 会增加每个存储周期的时间</li>
<li>异步刷新（Asynchronous refresh）<br>• 每一行各自以64ms间隔刷新<br>• 效率高：常用</li>
</ol>
</li>
<li><p>存储阵列：由大量寻址单元组成</p>
<ol>
<li>2048 * 2048 * 4 表示有2048行，2048列，每个单元4位。</li>
<li>地址线可表示2^n^个单元，数据线表示只能n位。<ol>
<li>一个字的每一位都需要数据线。</li>
<li>RAM和ROM采用的都是地址复用技术，地址线是原来的一半。</li>
</ol>
</li>
</ol>
</li>
<li><p>模块组织</p>
<ol>
<li>位扩展：地址线不变，数据线增加<br>• 使用 8 块 4K<em>1 bit 的芯片组成 4K</em>8<br>bit 的存储器</li>
<li>字扩展：地址线增加，数据线不变<br>• 使用 4 个 16K<em>8 bit 的芯片组成<br>64K</em>8 bit 的存储器</li>
<li>字、位同时扩展：地址线增加，数据线<br>增加<br>• 使用 8 个 16K<em>4 bit 的芯片组成<br>64K</em>8 bit 的存储器</li>
</ol>
</li>
<li><p>交叉编址：</p>
<ol>
<li>模块序号 &#x3D; 访存地址 % 存储器交叉模块数。</li>
<li>给定的访存地址在相邻的四次访问中出现在同一个存储模块内，则会发生冲突。</li>
</ol>
</li>
</ol>
<h2 id="第十章-·-外部存储器"><a href="#第十章-·-外部存储器" class="headerlink" title="第十章 · 外部存储器"></a>第十章 · 外部存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>特性：<ol>
<li>用于存储不经常使用的、数据量较大的信息</li>
<li>非易失</li>
</ol>
</li>
<li>类型：<ol>
<li>磁盘存储器（magnetic disk）</li>
<li>光存储器（optical memory）</li>
<li>磁带（magnetic tape）</li>
<li>U盘（USB flash disk），固态硬盘（solid state disk，SSD）</li>
</ol>
</li>
</ol>
<h3 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h3><ol>
<li><p>结构</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241029172144404.png" alt="image-20241029172144404"></li>
<li>由磁头对盘片读写·</li>
</ol>
</li>
<li><p>读写机制</p>
<ol>
<li>在读或写操作期间，磁头静止，而盘片在其下方旋转</li>
<li>磁头的数量<ol>
<li>单磁头：读写公用同一个磁头（软盘、早期硬盘）</li>
<li>双磁头：使用一个单独的磁头进行读取（当代硬盘）</li>
</ol>
</li>
<li>写入机制<ol>
<li>电流脉冲被发送到写入磁头</li>
<li>变化的电流激发出磁场</li>
<li>产生的磁性图案被记录在下面的盘片表面上</li>
<li>反转电流方向，则记录介质上的磁化方向也会反转</li>
</ol>
</li>
<li>读取机制<ol>
<li>读取磁头是由一个部分屏蔽的磁阻（MR）敏感器组成，其电阻 取决于在其下移动的介质的磁化方向</li>
<li>电流通过MR敏感器时，通过电压信号检测其电阻变化</li>
<li>MR敏感器允许更高频率的操作，实现更高的存储密度和更快的 操作速度</li>
</ol>
</li>
</ol>
</li>
<li><p>数据组织</p>
<ol>
<li><p>盘片上的数据组织呈现为一组同心圆环，称为磁道（track）</p>
</li>
<li><p>数据以扇区（sector）的形式传输到磁盘或从传出磁盘</p>
<ul>
<li>默认值为512B</li>
</ul>
</li>
<li><p>相邻磁道之间有间隙（gap），相邻的扇区之间也留有间隙</p>
</li>
<li><p>扇区划分</p>
<ol>
<li>恒定角速度</li>
<li>多带式记录 &#x2F; 多重区域记录<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241029172905548.png" alt="image-20241029172905548"><ol>
<li>提升了存储容量，但是需要更复杂的电路</li>
</ol>
</li>
</ol>
</li>
<li><p>所有盘片上处于相同的相对位置的一组磁道被称为柱面 (cylinder)</p>
</li>
<li><p>格式化：</p>
<ol>
<li>磁道必须有一些起始点和辨别每个扇区起点及终点的方法</li>
<li>格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取 的额外数据</li>
</ol>
</li>
<li><p>I&#x2F;O访问时间</p>
<ol>
<li>寻道时间（seek time）：磁头定位到所需移动到的磁道所花 费的时间<ul>
<li>初始启动时间，跨越若干磁道所用的时间</li>
</ul>
</li>
<li>旋转延迟（rotational delay）：等待响应扇区的起始处到达 磁头所需的时间<ul>
<li>通常是磁道旋转半周所需的时间</li>
</ul>
</li>
<li>传送时间（transfer time）：数据传输所需的 时间</li>
</ol>
<p>$$<br>T&#x3D;\frac{b}{rN}&#x3D;\frac{1}{r}·\frac{b}{N}<br>$$</p>
<p>​    T：传送时间，b：传送的字节数，N：每磁道的字节数，r：旋转速率，单位是 转每秒（rad&#x2F;s).</p>
</li>
<li><p>柱面：写入时是在某一磁道写完一圈之后，不动读写头位置，继续读写另一面。</p>
</li>
</ol>
</li>
<li><p>磁盘调度</p>
<p>效率：SSTF &gt; LOOK &gt; SCAN ~ C-LOOK &gt; C-SCAN &gt; FCFS</p>
<p>公平性反过来</p>
</li>
</ol>
<h2 id="第十一章-·-冗余磁盘阵列（RAID）"><a href="#第十一章-·-冗余磁盘阵列（RAID）" class="headerlink" title="第十一章 · 冗余磁盘阵列（RAID）"></a>第十一章 · 冗余磁盘阵列（RAID）</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li>基本思想<ol>
<li>将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量</li>
<li>将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率</li>
<li>采用数据冗余来进行错误恢复以提高系统可靠性</li>
</ol>
</li>
<li>特性：<ol>
<li>由一组物理磁盘驱动器组成，被视为单个的逻辑驱动器</li>
<li>数据是分布在多个物理磁盘上</li>
<li>冗余磁盘容量用于存储校验信息，保证磁盘万一损坏时能恢复数据</li>
</ol>
</li>
</ol>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241112164441142.png" alt="image-20241112164441142"></p>
<h3 id="七种类型"><a href="#七种类型" class="headerlink" title="七种类型"></a>七种类型</h3><ol>
<li>RAID 0 ***：<ol>
<li>数据以条带的形式在可用的磁盘上分布</li>
<li>不采用冗余来改善性能（不是RAID家族中的真正成员）</li>
<li>用途 <ol>
<li>高数据传输率</li>
<li>高速响应I&#x2F;O请求</li>
</ol>
</li>
<li>如果一个文件横跨四个盘，如果一个盘损坏，就会导致所有文件都不可用。</li>
</ol>
</li>
<li>RAID 1 ***：<ol>
<li>采用简单地备份所有数据的方法来实现冗余</li>
<li>优点<ol>
<li>高速响应I&#x2F;O请求：即便是同一个磁盘上的数据块，也可以由两 组硬盘分别响应</li>
<li>读请求可以由包含请求数据的两个对应磁盘中的某一个提供服 务，可以选择寻道时间较小的那个</li>
<li>写请求需要更新两个对应的条带：可以并行完成，但受限于写 入较慢的磁盘</li>
<li>单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单</li>
</ol>
</li>
<li>缺点： 价格昂贵</li>
</ol>
</li>
<li>RAID 2：<ol>
<li>所有磁盘都参与每个I&#x2F;O请求的执行</li>
<li>纠错：对位于同一条带的各个数据盘上的数据位计算校验码（通常采 用海明码），校验码存储在该条带中多个校验盘的对应位置</li>
</ol>
</li>
<li>RAID 3：<ol>
<li>采用并行存取技术<ol>
<li>各个驱动器的轴同步旋转</li>
<li>采用非常小的数据条带</li>
</ol>
</li>
<li>对所有数据盘上同一位置的数据计算奇偶校验码<ol>
<li>当某一磁盘损坏时，可以用于重构数据。注意，是恢复不是纠错，RAID 3只能解决损坏的问题，但是不能解决出错的问题，换句话说也就是我们不能确定出错的是哪一位。</li>
</ol>
</li>
</ol>
</li>
<li>RAID 4：<ol>
<li>采用相对较大的数据条带</li>
<li>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校 验位存储在奇偶校验盘的对应条带上</li>
</ol>
</li>
<li>RAID 5 ***：<ol>
<li>在所有磁盘上都分布了奇偶校验条带</li>
<li>避免潜在的I&#x2F;O瓶颈问题<ol>
<li>访问时的“<strong>两读两写</strong>”：<ol>
<li>既要读或写用户数据，也要读写校验条带。</li>
<li>一定是先读后写。</li>
<li>最好是两读或两写分别同时进行，最短时间为一次读加一次写，最长时间为两次度加两次写。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>RAID 6：略</li>
</ol>
<h2 id="第十二章-·-虚拟存储器"><a href="#第十二章-·-虚拟存储器" class="headerlink" title="第十二章 · 虚拟存储器"></a>第十二章 · 虚拟存储器</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><ol>
<li>固定分区：会造成浪费</li>
<li>可变长分区：会出现碎片</li>
</ol>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ol>
<li>基本思想<ol>
<li>将内存分为一个个叫做<strong>页框</strong>的固定长度的块，然后将程序分为可以放进块的叫做<strong>页</strong>的部分</li>
<li>程序叫做页，放程序的地点叫做页框<ul>
<li>页放在哪里由OS决定，在我们的程序中写的是逻辑地址，由操作系统的决定物理地址。</li>
<li>页放进去并不是连续的放入，记录页存在的位置</li>
<li>像链表一样，存放不是连续的，必须要<strong>页表</strong>来记录地址</li>
</ul>
</li>
<li>页表<ol>
<li>页表中包含了所有虚拟页的信息，包括虚拟页的存放位置、装<br>入位（valid）、修改位（dirty）、存取权限位等等</li>
<li>保存在主存中</li>
<li>虚拟地址</li>
<li>虚拟页号 + 页内偏移量</li>
</ol>
</li>
<li>逻辑地址:指令中的地址</li>
<li>物理地址:内存中的地址</li>
</ol>
</li>
</ol>
<h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><ul>
<li>从此，CPU不管物理地址了，程序员可以假设独享一块大的连续的内存。</li>
</ul>
<ol>
<li><p>设计：</p>
<ol>
<li>页大小<br>• 4KB, 8KB, …</li>
<li>映射算法<br>• 关联映射</li>
<li>写策略<br>• 写回</li>
<li>类型<br>• 分页式虚拟存储器<br>• 分段式虚拟存储器<br>• 段页式虚拟存储器</li>
</ol>
</li>
<li><p>将虚拟页号转换为物理页号</p>
<p><img src="/home/mukongshan/.config/Typora/typora-user-images/image-20241114144202010.png" alt="image-20241114144202010"></p>
<ul>
<li>null：申请了，但没用</li>
<li>PP0：物理页号</li>
<li>空白：一个指针</li>
</ul>
</li>
</ol>
<h3 id="快表（TLB）"><a href="#快表（TLB）" class="headerlink" title="快表（TLB）"></a>快表（TLB）</h3><ol>
<li>类比cache</li>
<li>页表的使用增加了主存的访问次数。为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中</li>
<li>后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中<br>• 映射：关联映射，组关联映射<br>• 替换：随机替换<br>• 主存中的页表相应地称之为“慢表”</li>
</ol>
<h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h2 id="第十六章-·-总线"><a href="#第十六章-·-总线" class="headerlink" title="第十六章 · 总线"></a>第十六章 · 总线</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li>分类<ol>
<li>芯片内部总线</li>
<li>系统总线：连接CPU、存储器、IO控制器和其他功能设备</li>
<li>通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</li>
</ol>
</li>
<li>复用：<ol>
<li>数据线和地址线可以服用</li>
<li>控制线不能复用</li>
</ol>
</li>
<li>总线结构：<ol>
<li>数据线：在系统组件之间传输数据。数据线的数量决定了一次可以传输的数据的大小</li>
<li>地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向。地址线的数量决定了寻址空间的大小</li>
<li>控制线：控制对数据线和地址线的存取和使用<ol>
<li>时钟（clock）：用于总线同步操作</li>
<li>总线请求（bus request）：表示模块需要获得对总线的控制</li>
<li>总线允许（bus grant）：发出请求的设备已经被允许控制总线</li>
<li>中断请求（interrupt request）：表示某个中断正在悬而未决</li>
<li>中断响应（interrupt ACK）：未决的终端请求被响应 • 存储器读（memory read）：从存储器读数据到总线</li>
<li>存储器写（memory write）：将数据从总线写入存储器</li>
<li>I&#x2F;O读（I&#x2F;O read）：从I&#x2F;O端口读数据到总线</li>
<li>I&#x2F;O写（I&#x2F;O write）：将数据从总线写入I&#x2F;O端口</li>
</ol>
</li>
</ol>
</li>
<li>总线上数据传输的特点<ol>
<li>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</li>
<li>如果同一时刻多个设备同时发送数据，会造成数据之间的混淆</li>
<li>使用总线进行数据传输：如果连在总线上的某个设备希望向另一个设备发送数据，需要：<ol>
<li>获得总线的使用权</li>
<li>通过总线传送数据</li>
</ol>
</li>
<li>如果连在总线上的某个设备希望向另一个组件请求数据，需要：<ol>
<li>获得总线的使用权</li>
<li>通过总线向另一个设备发送请求，等待另一个设备发送数据</li>
</ol>
</li>
<li>当总线在被使用过程中，其它设备不可以抢占</li>
</ol>
</li>
<li>设计要素<ol>
<li>用途：专用总线，复用总线</li>
<li>仲裁：集中式，分布式</li>
<li>时序：同步，异步，半同步，分离事务</li>
<li>总线带宽和数据传输速率</li>
<li>总线层次结构：单总线，双总线，多总线</li>
</ol>
</li>
</ol>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol>
<li>专用总线：始终只负责一项功能，或始终分配给 特定的计算机组件<ol>
<li>优点：高吞吐量，减少总线冲突</li>
<li>缺点：增加了系统的规模和成本</li>
</ol>
</li>
<li>复用（multiplexed）总线：将同一线路用于多种用途<ol>
<li>优点：使用的布线数量少，节省空间和成本</li>
<li>缺点：每个模块需要更复杂的控制电路，且共享可能会降低性能</li>
</ol>
</li>
</ol>
<h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><ol>
<li>总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备</li>
<li>平衡因素<ol>
<li>优先级：优先级高的设备优先被服务</li>
<li>公平性：优先级最低的设备不能一直被延迟</li>
</ol>
</li>
<li>仲裁方案<ol>
<li>分类<ol>
<li>集中式（centralized）：由仲裁器（arbiter）或总线控制器 （bus controller）负责分配总线使用权<ol>
<li>链式查询 &#x2F; 菊花链（daisy chain）</li>
<li>计数器查询（query by a counter）</li>
<li>独立请求（independently request）</li>
</ol>
</li>
<li>分布式（distributed）：每个设备都包含访问控制逻辑，各设 备共同作用分享总线<ol>
<li>自举式（self selection）</li>
<li>冲突检测（collision detection）</li>
</ol>
</li>
</ol>
</li>
<li>链式查询<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205144213747.png" alt="image-20241205144213747"><ol>
<li>优点：<ol>
<li>确定优先级很简单</li>
<li>可以很灵活地添加设备</li>
</ol>
</li>
<li>缺点<ol>
<li>不能保证公平性</li>
<li>对电路故障敏感</li>
<li>限制总线的速度</li>
</ol>
</li>
</ol>
</li>
<li>计数器查询<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205144837921.png" alt="image-20241205144837921"><ol>
<li>优点：<ol>
<li>通过使用不同的初始计数，可以灵活地确定设备优先级</li>
<li>强调优先级：从1开始</li>
<li>强调公平性：从下一个设备的ID开始</li>
<li>对电路故障不敏感</li>
</ol>
</li>
<li>缺点<ol>
<li>需要添加设备ID线</li>
<li>需要解码和比较设备ID信号</li>
<li>限制总线的速度</li>
</ol>
</li>
</ol>
</li>
<li>独立请求<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205150753461.png" alt="image-20241205150753461"><ol>
<li>优点<ol>
<li>快速响应</li>
<li>可编程的优先级</li>
</ol>
</li>
<li>缺点<ol>
<li>复杂的控制逻辑</li>
<li>更多的控制线路</li>
</ol>
</li>
</ol>
</li>
<li>自举式<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205151313019.png" alt="image-20241205151313019"><ul>
<li>需要n条线</li>
</ul>
</li>
<li>冲突检测<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205151842681.png" alt="image-20241205151842681"></li>
</ol>
</li>
</ol>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><ol>
<li>事务：传输一次地址和数据。</li>
<li>同步时序<ol>
<li>优点：容易实现</li>
<li>缺陷：所有设备共享一个时钟，总线长度受到始终偏差的限制</li>
</ol>
</li>
<li>异步时序<ol>
<li>握手策略<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205152813457.png" alt="image-20241205152813457"></li>
<li>异步数据传输<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241205153056387.png" alt="image-20241205153056387"><ul>
<li>实际上是一个七次握手3+1+3</li>
</ul>
</li>
<li>优点：可以灵活地协调速度不同的设备</li>
<li>缺点：接口逻辑复杂，对噪声敏感</li>
</ol>
</li>
<li>半同步时序<ol>
<li>为了减少噪声的影响，在异步计时中使用时钟<ol>
<li>准备和响应信号在时钟上升沿有效</li>
</ol>
</li>
<li>结合同步和异步定时的优点</li>
</ol>
</li>
<li>分离事务<ol>
<li>将一个总线事件分离为两个过程</li>
<li>优点：增加总线利用率</li>
<li>缺点：增加每个总线事件的持续时间和系统复杂度</li>
</ol>
</li>
</ol>
<h3 id="总线带宽和数据传输速率"><a href="#总线带宽和数据传输速率" class="headerlink" title="总线带宽和数据传输速率"></a>总线带宽和数据传输速率</h3><ul>
<li>主要是些计算</li>
</ul>
<ol>
<li>数据块传输：<ol>
<li>为了提高效率，我们采用数据块传输的方法，这样只需要传输一次地址就可以得到多个字的数据。</li>
<li>一次事务四个时间：<ol>
<li>地址传输</li>
<li>数据准备</li>
<li>数据传输</li>
<li>空闲</li>
</ol>
</li>
<li>上一个数据传输时，可以同时准备下一个数据</li>
<li>例题<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241210164747852.png" alt="image-20241210164747852"></li>
</ol>
</li>
</ol>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="第十七章-·-输入-输出"><a href="#第十七章-·-输入-输出" class="headerlink" title="第十七章 · 输入 &#x2F; 输出"></a>第十七章 · 输入 &#x2F; 输出</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ol>
<li>I&#x2F;O模块：本身属于计算机，不是外设。外围设备要与I&#x2F;O模块相连，才能与计算机交互。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241210172923240.png" alt="image-20241210172923240"></li>
<li>外围设备的接口：不同的外设可能有不同的编码，在与I&#x2F;O模块相连时，要用接口把数据格式转换过来，并且要能够接受控制信号。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241210172935289.png" alt="image-20241210172935289"></li>
</ol>
<h3 id="I-O模块结构"><a href="#I-O模块结构" class="headerlink" title="I&#x2F;O模块结构"></a>I&#x2F;O模块结构</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241210173203480.png" alt="image-20241210173203480"></p>
<ol>
<li>注意：控制线是CPU控制I&#x2F;O模块本身的，如果想控制外设，走数据线</li>
<li>外部接口：<ol>
<li>接口类型<ol>
<li>并行接口：多根线连接输入&#x2F;输出模块和外设，同时传送多位数据</li>
<li>串行接口：只有一根线用于传输数据，每次只传输一位数据</li>
</ol>
</li>
<li>由于并行接口要求每次同时传送，当传输速度和总线长度增加时， 总线的时钟频率会受到限制。所以我们用串行接口。</li>
</ol>
</li>
<li>外设至少要有三个内容的交互：数据，状态，控制。数据能交换，状态能出来，控制能进去。</li>
</ol>
<h3 id="I-O操作技术"><a href="#I-O操作技术" class="headerlink" title="I&#x2F;O操作技术"></a>I&#x2F;O操作技术</h3><ol>
<li><p>分类：</p>
<ol>
<li>编程式 I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器 发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</li>
<li>中断驱动式 I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令； 并且当I&#x2F;O模块完成其工作后，才去中断处理器工作</li>
<li>直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与 主存直接交换数据，而不需要处理器的干涉</li>
</ol>
</li>
<li><p>编程式</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241210175332306.png" alt="image-20241210175332306"></p>
<ol>
<li>在编程式I&#x2F;O中，CPU的占用率是100%。即CPU不能够执行其他任务。</li>
<li>这是因为I&#x2F;O不会“敲门”，所以他要不断地检查I&#x2F;O是否就绪</li>
<li>但是不代表CPU一直在工作，只是占用</li>
</ol>
</li>
<li><p>中断驱动<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212141929684.png" alt="image-20241212141929684"></p>
<ol>
<li><p>从I&#x2F;O的视角来看：</p>
<ol>
<li>I&#x2F;O模块接收来自处理器的读命令</li>
<li>I&#x2F;O模块从相关的外设中读入数据</li>
<li>一旦数据进入I&#x2F;O模块的数据寄存器后，该模块通过控制总线给处 理器发送中断信号</li>
<li>I&#x2F;O模块等待直到处理器请求该数据时为止</li>
<li>当处理器有数据请求时，I&#x2F;O模块把数据传送到数据总线上，并准 备另一个I&#x2F;O操作</li>
</ol>
</li>
<li><p>从控制器的视角来看</p>
<ol>
<li>处理器发送一个读命令</li>
<li>处理器离开去做其它的事情，并在每个指令周期结束时检查中断</li>
<li>当来自I&#x2F;O模块的中断出现时，处理器保存当前程序的现场到<strong>栈</strong>中</li>
<li>处理器从I&#x2F;O模块读取数据字并保存到主存中</li>
<li>处理器恢复刚才正在运行的程序的现场，并继续运行原来的程序</li>
</ol>
</li>
</ol>
</li>
<li><p>中断启用<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212142630555.png" alt="image-20241212142630555"></p>
</li>
<li><p>中断优先级</p>
<ol>
<li>响应优先级：“抢得快”</li>
<li>处理优先级：“优先级高”</li>
<li>掩码字 &#x2F; 屏蔽字：“不用管”</li>
<li>主程序没有优先级（或者说优先级最低）</li>
<li>例子<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212144001533.png" alt="image-20241212144001533"><ol>
<li>注意：从哪来回哪去。因为保存恢复是看栈中内容，所以一定会对称。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="直接存储器存取DMA"><a href="#直接存储器存取DMA" class="headerlink" title="直接存储器存取DMA"></a>直接存储器存取DMA</h3><ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212145022256.png" alt="image-20241212145022256"></p>
</li>
<li><p>CPU和DMA访问内存冲突时，CPU让DMA。否则DMA的缓冲可能溢出。</p>
</li>
<li><p>DMA内存访问：</p>
<ol>
<li>CPU停止法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212150719380.png" alt="image-20241212150719380"></li>
<li>周期窃取<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212150740407.png" alt="image-20241212150740407"></li>
<li>交替访问<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241212150952106.png" alt="image-20241212150952106"></li>
</ol>
</li>
</ol>
<h1 id="知识点拾遗"><a href="#知识点拾遗" class="headerlink" title="知识点拾遗"></a>知识点拾遗</h1><ol>
<li><p>计算机性能</p>
<ol>
<li><p>如果用$CPI_i$来表示指定类型i所需要的周期数，用 表示在某一给定程序中所执行的i 类 指令的条数，则计算整个CPI如下：<br>$$<br>CPI&#x3D;\frac{\sum_{i&#x3D;1}^{n}(CPI_i*I_i)}{I_c},I_c&#x3D;\sum_{i&#x3D;1}^{n}I_i<br>$$</p>
</li>
<li><p>执行一个给定程序的处理时间表示为：<br>$$<br>T&#x3D;I_c<em>CPI</em>t<br>$$</p>
</li>
<li><p>每秒百万条指令（ Million Instructions Per Second ，MIPS）：<br>$$<br>MIPS&#x3D;\frac{I_c}{T<em>10^{6}}&#x3D;\frac{f}{CPI</em>10^6}<br>$$</p>
</li>
<li><p>每秒百万条浮点操作（Million Floating Point Operations Per Second，MFLOPS)：<br>   $$<br>   MFLOPS&#x3D;\frac{N_{floating-point op}}{T*10^6}<br>   $$</p>
</li>
<li><p>基准程序</p>
</li>
</ol>
</li>
<li><p>奇校验多一个异或1</p>
</li>
<li><p>海明码校验</p>
</li>
</ol>
<h1 id="错题本"><a href="#错题本" class="headerlink" title="错题本"></a>错题本</h1><ol>
<li>一定与机器字长相同的部件是ALU和通用寄存器。<ul>
<li>机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，它直接影响了CPU内部数据通路的宽度以及运算的精度和速度。</li>
<li>ALU（算术逻辑单元）作为执行算术和逻辑操作的核心部件，其设计通常是基于机器字长的，能够处理与机器字长相同位数的数据，因此ALU的位数一定与机器字长相同。</li>
<li>通用寄存器用于存储临时数据和计算结果，这些寄存器通常与机器字长相匹配，以便能够存储和处理与机器字长相同位数的数据，因此通用寄存器的位数也与机器字长相同。</li>
</ul>
</li>
<li>量级单位：K, M, B, T, G, P, E</li>
<li>CPU区分指令和数据的依据是指令周期的不同阶段</li>
<li>当最高位进位和符号位进位的值不相同时才产生溢出</li>
<li>只有在表述内存时，M表示2^20^，例如Mb就是2^20^bit。在表示速度时，M表示10^6^。所以Mbps是M*bps，而不是Mb&#x2F;s。</li>
</ol>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ol>
<li>加法器：（学会分析）<ol>
<li>逻辑运算延时：与、或、非均为1ty，异或为3ty</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250109212107451.png" alt="image-20250109212107451"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250109212200698.png" alt="image-20250109212200698"><ol>
<li>得到进位后，计算本位和要3ty，计算进位要2ty。</li>
</ol>
</li>
<li>串行进位加法器：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250108223846911.png" alt="image-20250108223846911"><ol>
<li>在FA0运算时，其他的XY也在同时运算。在$C_1$出结果之前，各个位置上的XY已经完成异或</li>
<li>由此，我们得到，<strong>向第n位</strong>进位$C_n &#x3D; (2n+3)ty$，第n位本位和$S_n&#x3D;(2n+6)$。注意，索引从0开始。</li>
<li>从第二位开始，计算出本位和的时间比得到进位的时间多3ty，计算出向下进位的多2ty</li>
</ol>
</li>
<li>先行进位加法器<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250108231327863.png" alt="image-20250108231327863"><ol>
<li>C3 &#x3D; 𝐺3 + 𝑃3𝐺2 + 𝑃3𝑃2𝐺1 + 𝑃3𝑃2𝑃1𝐶0</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ol>
<li><p>搞清楚哪些需要刷新，哪些可以改写</p>
</li>
<li><p>判断可能发生访存冲突的规则如下：给定的访存地址在相邻的四次访问中出现在同一个 存储模块内。</p>
</li>
<li><blockquote>
<p>使用 32 个 64K×1bit 的 DRAM 芯片组成一个 256K×8bit 的存储器。</p>
<p> a) 若采用集中刷新方式，则存储器刷新一遍最少用多少次刷新操作？</p>
<p> 64K×1bit 的 DRAM 由 256×256 的位元阵列组成，即每个芯片有 256 行、256 列的位元 阵列。集中式刷新按行刷新，因此需要用 256 次刷新操作。</p>
<p> b) 若采用异步刷新方式，每单元刷新间隔不超过 2ms，则生成的刷新信号的间隔时间 最长是多少？（保留一位小数，单位为 μs） 2ms&#x2F;256≈7.8μs </p>
<p> c) 若改用 16K×4bit 的 DRAM 芯片构成上述 256K×8bit 的存储器，则以集中式刷新一 遍所有单元需要多少次刷新操作？ 16K×4bit 的 DRAM 芯片由 4 个 128×128 的位元阵列组成，这 4 个存储阵列中行号相同 的那些行将被同时刷新，共有 128 行，因此需要 128 次刷新操作。</p>
</blockquote>
</li>
</ol>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ol>
<li><p>要会分析主存地址的格式，用已知条件推断出地址的某几位是什么功能</p>
<blockquote>
<p>e.g. 一个组关联 Cache 由 64 个行组成，每组 4 行。主存储器包含 4K 个块，每块 128 字，请表示主存 地址的格式。</p>
<blockquote>
<p>解：由每块 128 字得到块内地址长 7 位，64 行每组 4 行得一共 16 组，需要 4 位表示，标记需要 12（4K） -4（组号）&#x3D;8 位</p>
</blockquote>
</blockquote>
<ul>
<li>先分析多少块，再分析块内地址，块，行，再分析tag</li>
<li>一行一块</li>
</ul>
<ol>
<li>直接映射：<ul>
<li>块数 &#x3D; 总数据区大小 &#x2F; 块大小</li>
<li>块内地址：表示块大小</li>
<li>行号 &#x3D; 块数 mod 行数</li>
<li>tag</li>
</ul>
</li>
<li>关联映射<ul>
<li>块内地址：表示块大小</li>
</ul>
</li>
<li>组关联映射：<ul>
<li>块数 &#x3D; 总数据区大小 &#x2F; 块大小</li>
<li>组数 &#x3D; 块数 &#x2F; 每组行数</li>
<li>块内地址 &#x3D; 表示块大小</li>
<li>组号：表示组数</li>
<li>tag</li>
</ul>
</li>
</ol>
</li>
<li><p>题目中说的Cache的行号是数据区的大小。在数据之前还有额外的几位作为tag</p>
</li>
<li><p>1K &#x3D; 2^10^ , 1M &#x3D; 2^20^ </p>
</li>
<li><p>采用指令 Cache 与数据 Cache 分离的主要目的是减少指令流水线资源冲突</p>
</li>
<li><p>Cache 的总容量包括：存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算法控制位）。</p>
</li>
</ol>
<h2 id="外存"><a href="#外存" class="headerlink" title="外存"></a>外存</h2><ol>
<li>平均访问时间 &#x3D; 平均寻道时间 + 平均旋转延迟 + 扇区传送时间</li>
<li>磁盘存储器的最小读写单位为一个扇区，即磁盘按块存取。一个扇面默认为512字节。</li>
<li>磁盘存储数据之前 需要进行格式化，将磁盘分成扇区，并写入信息，因此磁盘的格式化容量比非格式化容量小</li>
<li>磁盘扇区中包含数据、地址和校验等信息</li>
<li>磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成</li>
<li>RAID0 方案是无冗余和无校验的磁盘阵列，而 RAID1～RAID5 方案均是加入了冗余(镜 像）或校验的磁盘阵列。</li>
</ol>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ol>
<li><p>解决问题时也要分析地址结构，区分页内地址和页号，然后查表</p>
</li>
<li><p>关于缺页处理：</p>
<ol>
<li>缺页是在地址转换时 CPU 监测到的一种异常</li>
<li>缺页处理由操作系统提供的缺页处理程序来完成</li>
<li>缺页处理程序根据页故障地址从外存读入所缺失的页</li>
<li>缺页处理完成后回到发生缺页的指令继续执行</li>
</ol>
</li>
<li><p>Cache和TLB的相同点：</p>
<ol>
<li>命中率都与程序局部性有关</li>
<li>缺失后都需要去访问主存</li>
<li>缺失处理都可以由硬件实现</li>
<li>Cache 由 SRAM 组成；TLB 通常由相联存储器组成，也可由 SRAM 组成。DRAM 需要不断刷 新，性能偏低，不适合组成 TLB 和 Cache。静态存储器（SRAM），读写速度快，但成本高， 多用于容量较小的高速缓冲存储器。</li>
</ol>
</li>
<li><p>例题</p>
<blockquote>
<p>假设一个分页虚拟存储系统的虚拟地址为 40 位，物理地址为 36 位，页大小为 16KB，按字节编址。 若页表中的有效位、存储保护位、修改位、使用位共占 4 位，磁盘地址不在页表中。则该存储系统 中每个程序的页表大小为多少（单位：MB）？（说明：1.假设每个程序都能使用全部的虚拟内存； 2.页表项的长度必须为字节的整数倍） </p>
<p>答：256MB</p>
<p>按字节编址，故： 虚拟主存页面个数：2^(40-14)^&#x3D;2^26^ 物理主存页面数：2^(36-14)^&#x3D;2^22^ 页表项的最小长度：22+4&#x3D;26 根据说明 2，取 32 位（4B） 页表大小：2^26^ * 4B&#x3D;256MB</p>
</blockquote>
</li>
<li><p>通过虚拟地址查页，取到的物理页号和页内地址拼起来，就是物理地址了。</p>
</li>
<li><p>看第七次作业第二题，每一步都搞懂</p>
</li>
<li><blockquote>
<p>为什么 Cache 可以采用直写策略，而修改页面内容时总是采用回写策略？</p>
<p>答：因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在 Cache-主存层次，Cache 可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是 采用回写策略。</p>
</blockquote>
</li>
<li><p>计算cache的总容量时，除了数据位，注意每一行都还有一些标志位，如脏位，策略位等等。</p>
<ol>
<li><p>策略：</p>
<ol>
<li>最近最少使用算法（Least Recently Used, LRU）：在2路组时，需要一位标志位</li>
<li>先进先出算法（First In First Out, FIFO）：需要一位标志位</li>
<li>最不经常使用算法（Least Frequently Used, LFU）：需要一个计数器，不是标志位</li>
<li>随机替换算法（Random）：不需要</li>
</ol>
</li>
<li><p>映射：</p>
<ol>
<li>关联映射又称为全相联映射</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><ol>
<li><p>牢记多种寻址方式</p>
</li>
<li><p>括号（）表示取其内容。</p>
</li>
<li><p>汇编语言程序员可见的是程序计数器(PC),即汇编语言程序员通过汇编程序可以对某个寄存器进行访问。 汇编程序员可以通过指定待执行指令的地址来设置 PC 的值，如转移指令、子程序调用指令等。而 IR、 MAR、MDR 是 CPU 的内部工作寄存器，对程序员不可见。</p>
</li>
<li><p>汇编程序员可见的寄存器有基址寄存器(用于实现多道程序设计或者编制浮动程序)和状态&#x2F;标志寄存器、 程序计数器 PC 及通用寄存器组；而 MAR、MDR、IR 是 CPU 的 内部工作寄存器，对汇编程序员不 可见。微指令寄存器属于微程序控制器的组成部分，它是硬 件设计者的任务，对汇编程序员是不可见的。</p>
</li>
<li><p>程序计数器 PC 给出下一条指令字的访存地址（指令在内存中的地址），它取决于存储器的字数，而不是编址的字节数。所以对于32字按字节编址的机器来说，每条指令要4字节，PC应该+4.</p>
</li>
<li><p>例题</p>
<blockquote>
<p>【2017 统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29  条、二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是( )。 A. 24 位 B.26 位 C. 28 位 D.32 位</p>
<p>答：A</p>
<p>三地址指令有 29 条，所以其操作码至少为 5 位。以 5 位进行计算，它剩余 32-29&#x3D;3 种操作码给二地址。 而二地址另外多了 6 位给操作码，因此其数量最大达 3×64&#x3D;192。所以指令字长最少为 23 位，因为计算 机按字节编址，需要是 8 的倍数，所以指令字长至少应该 24 位，选 A。</p>
</blockquote>
</li>
</ol>
<h2 id="指令流水线-1"><a href="#指令流水线-1" class="headerlink" title="指令流水线"></a>指令流水线</h2><ol>
<li><p>字段直接编码法将微命令字段分成若干小字段，互斥性微命令组合在同一字段中，相容性微命令分在不 同字段中，每个字段还要留出一个状态，表示本字段不发出任何微命令。</p>
</li>
<li><p>数据在功能部件之间传送的路径被称为数据通路，包括数据通路上流经的部件，如程序计 数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路由控制部件控制，控制部件 根据每条指令功能的不同生成对数据通路的控制信号。因此，不包括控制部件。</p>
</li>
<li><p>加速比的计算：</p>
<ol>
<li><p>误解：流水线中的阶段数越多，执行速度越快。$t &#x3D; t_m + d$，d是固定的</p>
</li>
<li><p>对于k阶段流水线执行n条指令所需时间为：$T_{k,n}&#x3D;[k+(n-1)]t$</p>
</li>
<li><p>加速比：<br>$$<br>S_k&#x3D;\frac{T_{1,n}}{T_{k,n}}&#x3D;\frac{nkt}{[k+(n-1)]t}&#x3D;\frac{n}{1+\frac{n-1}{k}}&gt;1<br>$$</p>
</li>
</ol>
<h3 id="冒险-1"><a href="#冒险-1" class="headerlink" title="冒险"></a>冒险</h3></li>
</ol>
<h2 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h2><ol>
<li><p>在编写微操作序列时，别忘记括号</p>
<ol>
<li>例如，(MBR)表示取到MBR中的值</li>
<li>例如，（IR(address1)）表示取到IR中一地址的部分的值</li>
</ol>
</li>
<li><p>做减法时，为操作数一减操作数二</p>
</li>
<li><blockquote>
<p>一个指令周期有 4 个主要阶段：取指、间址、执行和中断。硬布线方式实现时，采用一个 2 位的寄 存器来标志当前阶段，但微程序式控制器却不需要类似的标志。请问为什么硬布线式控制器需要这 些标志，而微程序式控制器不需要这些标志？</p>
<p>答：在硬连线式控制器中，当前阶段会作为输入的一部分，用于布尔逻辑式的计算，因此需要采用 2 位 的寄存器来标志当前阶段。 在微程序式控制器中，所有的微指令都存储在控制存储器中，排序逻辑会确定下一条将要执行的微 指令，各个阶段之间通过跳转来实现，因此不需要状态标志。</p>
</blockquote>
</li>
</ol>
<h2 id="总线-1"><a href="#总线-1" class="headerlink" title="总线"></a>总线</h2><ol>
<li><p>在计算数据传输速率时，读出一个字，要考虑把地址传给内存，内存准备，内存把数据送回来的三个过程。</p>
</li>
<li><p>同步总线中的各个步骤的时间要求是时钟周期的整数倍，注意时钟同步！！！</p>
</li>
<li><p>在异步总线中，数据准备是2,3,4步。内存收到地址就立马开始准备，同时发送第2次握手的信息。</p>
</li>
<li><p>USB(通用串行总线)的特点有：①即插即用；②热插拔；③有很强的连接能力，采用菊花链 形式将众多外设连接起来；④有很好的可扩充性，一个 USB 控制器可扩充高达 127 个外 部 USB 设备；⑤高速传输，速率可达 480Mb&#x2F;s。所以 A、B、C 都符合 USB 总线的特点。 对于 D,USB 是串行总线，不能同时传输 2 位数据。</p>
</li>
<li><p>USB 是一种连接外部设备的 I&#x2F;O 总线标准，属于设备总线，是设备和设备控制器之间的接 口。而 PCI、AGP、PCI-E 作为计算机系统的局部总线标准，通常用来连接主存、网卡、视 频卡等。</p>
</li>
<li><p>猝发(突发)传输是在一个总线周期中，可以传输多个存储地址连续的数据，即一次传输一个 地址和一批地址连续的数据，并行传输是在传输中有多个数据位同时在设备之间进行的传 输，串行传输是指数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输的方 式，同步传输是指传输过程由统一的时钟控制。</p>
</li>
<li><p>【2016 统考真题】下列关于总线设计的叙述中，错误的是（A）。 A.并行总线传输比串行总线传输速度快 B.采用信号线复用技术可减少信号线数量 C.采用突发传输方式可提高总线数据传输率 D.采用分离事务通信方式可提高总线利用率</p>
<ol>
<li>初看可能会觉得 A 正确，并行总线传输通常比串行总线传输速率快，但这不是绝对的。在 实际时钟频率较低的情况下，并行总线因为可以同时传输若干比特，速率确实比串行总线快。 但是，随着技术的发展，时钟频率越来越高，并行总线之间的相互干扰越来越严重，当时钟 频率提高到一定程度时，传输的数据已无法恢复。而串行总线因为导线少，线间干扰容易控 制，反而可通过不断提高时钟频率来提高传输速率，A 错误。</li>
<li>总线复用是指一种信号线在不 同的时 间传输不同的信息，它可使用较少的线路传输更多的信息，从而节省空间和成本， 因此 B 正确。</li>
<li>突发(猝发)传输是指在一个总线周期中，可以传输多个存储地址连续的数据， 即一次传输一个地址和一批地址连续的数据，C 正确。</li>
<li>分离事务通信是总线复用的一种，相 比单一的传输线路可以提高总线的利用率，D 正确。</li>
</ol>
</li>
<li><p>各总线通过桥接器相连，后者起流量交换作用。</p>
</li>
<li><p>如果每个时钟周期传送两次数据，则意思是上升沿和下降沿各传送一次数 据</p>
</li>
<li><p>注意，事务间空闲要算到事务时间当中，即使是最后一个事务，也要有空闲时间。</p>
</li>
<li><blockquote>
<p>一个 32 位的微处理器，它有 16 位的外部数据总线，由 40MHz 输入时钟驱动。 </p>
<p>a) 假设一个总线事务需要的最短时间等于 4 个输入时钟周期，那么需要 16 个时钟周 期的总线事务中，这个处理器可能维持的最大数据传输率是多少（单位：Mbps）？</p>
<p>b) 如果将它的外部数据总线扩展为 32 位，那么该总线的最大数据传输率提高到多少 （单位：Mbps）？ </p>
<p>解：</p>
<p>a）一个总线事务过程除了数据传送阶段外，还包括其他阶段，如传送地址和总线 命令、准备数据等，所以，完成一个总线事务所用的所有时钟周期并不都用来传输数据。 由于一个总线事务需要的最短时间为4个时钟周期，这表明在传输最少数据的情况下（占 用1个时钟周期），依然需要3个时钟周期来传送其它信息。 假设一个总线事务占用n个时钟周期，那么最大数据传输率为： 16bit * (n-3)&#x2F;n * 40MHz &#x3D; 640(n-3)&#x2F;n Mbps 例如，当n为16时，最大数据传输率为520Mbps </p>
<p>b）若采用32位总线宽度，则总线带宽可以提高到1280(n-3)&#x2F;n Mbps。这种措施 的效果和加倍外部处理器总线时钟频率的效果相同。 补充：由于处理器是32位的，地址可能为32位。当采用16位数据总线时，需要 2个时钟周期传递地址；而改成32位总线，只需要1个周期传递地址。原来所需要的 3个额外时钟周期可能减少到2个，因此带宽可以提高到1280(n-2)&#x2F;n Mbps，优于加 倍时钟频率。</p>
</blockquote>
</li>
<li><p>带宽是最大<strong>数据</strong>传输率，可以认为是一秒钟最多传多少位。<strong>注意，若地址线和数据线不复用，也只算数据线。</strong></p>
</li>
<li><blockquote>
<p>每次传输 8 个字的数据块，其中 60%的访问是读操作总线事务，40%的访问是写操 作总线事务，总线 2 的数据传输率是多少（单位：Mbps）？</p>
</blockquote>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250102222325105.png" alt="image-20250102222325105"></p>
</li>
</ol>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><ol>
<li><p>.I&#x2F;O 接口中 CPU 可访问的寄存器称为 I&#x2F;O 端口</p>
</li>
<li><blockquote>
<p>【2014 统考真题】下列有关 I&#x2F;O 接口的叙述中，错误的是( D )。</p>
<p> A.状态端口和控制端口可以合用同一个寄存器 </p>
<p>B.I&#x2F;O 接口中 CPU 可访问的寄存器称为 I&#x2F;O 端口 </p>
<p>C.采用独立编址方式时，I&#x2F;O 端口地址和主存地址可能相同 </p>
<p>D.采用统一编址方式时，CPU 不能用访存指令访问 I&#x2F;O 端口</p>
</blockquote>
<ol>
<li>采用统一编址时，CPU 访存和访问 I&#x2F;O 端口用的是一样的指令，所以访存指令可访问 I&#x2F;O 端 口，D 选项错误。其他三个选项均为正确陈述。</li>
</ol>
</li>
<li><p>外部中断是指 CPU 执行指令以外的事件产生的中断，通常指来自 CPU 与内存以外的中断。 </p>
</li>
<li><p>在单级(或单重)中断系统中，不允许中断嵌套。中断处理过程为：① 关中断；② 保存断点； ③ 识别中断源；④ 保存现场；⑤ 中断事件处理；⑥恢复现场；⑦ 开中断；⑧ 中断返回。 其中①～③由硬件完成，④～⑧由中断服务程序完成。</p>
<ol>
<li>所以如果问<strong>中断程序内</strong>的事务，不考虑<strong>关</strong>中断。</li>
<li>响应外部中断的过程中，中断<strong>隐指令</strong>完成的操作，不算在中断服务程序内，也就是硬件部分的操作</li>
</ol>
</li>
<li><p>中断处理方式：在 I&#x2F;O 设备输入每个数据的过程中，由于无须 CPU 干预，因而可使 CPU 与 I&#x2F;O 设备并行工作。仅当输完一个数据时，才需 CPU 花费极短的时间去做一些中断处理。 因此中断申请使用的是 CPU 处理时间，发生的时间是在一条指令执行结束之后，数据在软 件的控制下完成传送。而 DMA 方式与之不同。DMA 方式：数据传输的基本单位是数据块， 即在 CPU 与 I&#x2F;O 设备之间，每次传送至少一个数据块；DMA 方式每次申请的是总线的使 用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开 始和结束时，才需要 CPU 干预，整块数据的传送是在控制器的控制下完成的。</p>
</li>
<li><p>DMA也不是仅适用于快速外部设备，只是低速的不划算</p>
</li>
<li><p>一个多重中断系统的中断可以看做是三大步：保护现场，中断处理，恢复现场。其中，中断处理时为开中断。</p>
</li>
<li><p>每类设备都配置一个设备驱动程序，设备驱动程序向上层用户程序提供一组标准接口，负责 实现对设备发出各种具体操作指令，用户程序不能直接和 DMA 打交道。</p>
</li>
<li><p>DMA 的数据传送 过程分为预处理、数据传送和后处理 3 个阶段。</p>
<ol>
<li>预处理阶段由 CPU 完成必要的准备工作， 数据传送前由 DMA 控制器请求总线使用权；</li>
<li>数据传送由 DMA 控制器直接控制总线完成</li>
<li>传送结束后，DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处 理。</li>
</ol>
</li>
<li><p>周期挪用法就是周期窃取</p>
</li>
<li><p>周期挪用法由 DMA 控制器挪用一个或几个主存周期来访问主存，传送完<strong>一个数据字</strong>后立 即释放总线，是一种单字传送方式，每个字传送完后 CPU 可以访问主存，选项 C 错误。停 止 CPU 访存法则是指在整个数据块的传送过程中，使 CPU 脱离总线，停止访问主存。</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20241216144714447.png" alt="image-20241216144714447"></p>
<ol>
<li>DMA获得和释放总线权限的时间都要算</li>
<li>第一问：五个时间分别是：获取权限，第一个字节的准备时间，后面127字节的准备时间和前127字节的传送时间（同时进行取最大），最后一个字节的传输时间，释放权限</li>
<li>第二问：为什么没有考虑准备时间呢？</li>
</ol>
</li>
<li><p>周期窃取中，如果CPU和DMA没有访存冲突，则在数据传输阶段时，CPU不受影响，不用考虑CPU占用时间。</p>
</li>
<li><p>在传输数据时，可以同时准备数据！！！要比较他们的时间（一般来说是准备时间比较长）</p>
</li>
<li><p>总结：</p>
<ol>
<li>I&#x2F;O访问方式：<ol>
<li>查询：注意CPU占用率总是100%</li>
<li>中断驱动：注意中断服务程序可能包含了数据传输</li>
</ol>
</li>
<li>DMA访存<ol>
<li>CPU停止法</li>
<li>周期挪用</li>
<li>交替分时访问（没考过？）</li>
</ol>
</li>
</ol>
</li>
<li><blockquote>
<p>在包含 DMA 模块的系统中，一般 DMA 存取主存储器的优先级比处理器存取主存储器的优 先级高，为什么？</p>
<p>答： 如果处理器被停止访问主存储器，除处理时间延长外不产生其它问题。但 DMA 可能连接 高速数据传输设备，如果不及时获取主存储器的存取权限来及时写入数据，则可能会因 为缓冲区溢出而造成数据丢失。所以，一般 DMA 存取主存储器的优先级会高于处理器。</p>
</blockquote>
</li>
<li><p>注意描述速度时，1K&#x3D;1000；描述内存大小时，1K&#x3D;1024</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/05/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">数据管理基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-05-04T12:00:00+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:03:24" itemprop="dateModified" datetime="2025-12-03T17:03:24+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol>
<li><p>举出适合用文件系统而不是数据库系统的例子；再举出适合用数据库系统的应用例子。</p>
<ul>
<li>解析：读者可以根据自己所使用的或了解到的实际应用来回答。例如：</li>
</ul>
<ol>
<li>目前，许多手机上的小型应用都把数据存放在手机操作系统的文件中，如照片、短信和微信等数据。一般来说，功能比较简单、比较固定的应用系统适合用文件系统。</li>
<li>目前，几乎所有企业或部门的信息系统都以数据库系统为基础，都使用数据库系统。例如，一个工厂的信息系统会包括多个子系统，如库存管理系统、物资采购系统、作业调度系统、设备管理系统和人事管理系统等；再如学校的学生管理系统、人事管理系统、图书管理系统等都适合用数据库系统。因此，数据库系统已经成为信息系统的基础和核心。</li>
</ol>
</li>
<li><p>试述数据库系统三级模式结构，并说明这种结构的优点是什么？<br>答：</p>
<ol>
<li>数据库系统的三级模式结构由外模式、模式和内模式组成（参考《概论》图1.16)。</li>
<li>外模式，亦称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。</li>
<li>模式，亦称逻辑模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集。</li>
<li>内模式，亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。</li>
<li>为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式／模式映像和模式／内模式映像。正是这两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</li>
</ol>
</li>
</ol>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ol>
<li>定义并理解下列术语，说明它们之间的联系与区别<ol>
<li>(1）域，笛卡儿积，关系，元组，属性<br>答：<ol>
<li>域：域是一组具有相同数据类型的值的集合。</li>
<li>笛卡儿积：给定一组域D,D2,….D，允许其中某些域是有相同的。这组域的笛卡儿积为<br>D,XD,x.xD,&#x3D;|(d,.d2,.d.)ld,eD,,i&#x3D;1.2.….n|</li>
<li>关系：在域D,D2,…,D上笛卡儿积D,xD2x…xD，的子集称为关系，表示为<br>R(D1,D2,….D.)。<br>注意，这里是用较为形式化的方法来定义关系。在第1章中则是用通俗的语言来说明什么是关系，是一种不严格的定义。</li>
<li>元组：关系中的每个元素是关系中的元组。</li>
<li>属性：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute)。</li>
</ol>
</li>
<li>(2）候选码，主码，外码<br>答：<ol>
<li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（candidate key)。</li>
<li>主码：若一个关系有多个候选码，则选定其中一个为主码（primary key)。</li>
<li>外码：设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S 的主码K，相对应，则称F是基本关系R的外部码（foreign key)，简称外码。</li>
</ol>
</li>
<li>(3）关系模式，关系，关系数据库<ol>
<li>关系模式：关系的描述称为关系模式（relation schema)。它可以形式化地表示为<br>R(U,D,DOM,F)<br>其中R为关系名，U为组成该关系的属性名集合，D为属性组U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</li>
<li>关系：见（1)，关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。<br>27&#x2F;292</li>
<li>关系数据库：关系数据库也有型和值之分。关系数据库的型称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ol>
<li><p>数据库的完整性概念与数据库的安全性概念有什么区别和联系？</p>
<blockquote>
<p>答：</p>
<ol>
<li>区别：防范对象的不同。完整性防范的是不正确的、不完整的数据，安全性防范的是恶意用户或非法用户所执行的各种操作。</li>
<li>联系：完整性和安全性都旨在保护数据，确保数据的准确性和可用性。完整性确保数据符合业务规则，而安全性确保数据不被非法篡改或泄露。</li>
</ol>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-05-04T12:00:00+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:03:24" itemprop="dateModified" datetime="2025-12-03T17:03:24+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一讲-·-操作系统概述"><a href="#第一讲-·-操作系统概述" class="headerlink" title="第一讲 · 操作系统概述"></a>第一讲 · 操作系统概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>内核，进程和线程：<ol>
<li>内核：控制多道程序执行的系统超级程序</li>
<li>进程：即内核控制下的多道程序实例(一个独立执行的程序指令流)</li>
<li>线程：是进程的基本执行单位，通常被称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源（如内存、打开的文件等）。</li>
</ol>
</li>
<li>OS是中断驱动的</li>
<li>总览![屏幕截图 2025-02-24 113426](E:\Pictures\Screenshots\屏幕截图 2025-02-24 113426.png)</li>
</ol>
<h1 id="第二章-·-处理器管理文件"><a href="#第二章-·-处理器管理文件" class="headerlink" title="第二章 · 处理器管理文件"></a>第二章 · 处理器管理文件</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="处理器模式"><a href="#处理器模式" class="headerlink" title="处理器模式"></a>处理器模式</h3><ol>
<li>计算机通过设置处理器模式实现特权指令管理</li>
<li>计算器一般设置0、1、2、3等四种运行模式(保护级别)<ul>
<li>0:内核级，操作系统内核，可以执行全部指令，包括中断处理、处理I&#x2F;O操作等命令</li>
<li>1:系统调用级，执行系统调用，获得特定的和受保护的程序服务</li>
<li>2:共享库级，可以多个运行进程共享，允许调用库函数，读取但不修改相关数据。</li>
<li>3:用户程序，只能执行非特权指令，收到的保护最少</li>
</ul>
</li>
<li>0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集</li>
<li>一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式</li>
<li>处理器模式是由处理器模式位决定的。</li>
</ol>
<h3 id="处理器模式切换"><a href="#处理器模式切换" class="headerlink" title="处理器模式切换"></a>处理器模式切换</h3><ol>
<li>$用户态\to内核态$：<strong>中断、异常或系统异常</strong>等事件导致用户程序向OS内核切换。有以下三种：<ol>
<li>程序请求操作系统服务，执行系统调用</li>
<li>程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)</li>
<li>程序运行时发生并响应中断(一般是I&#x2F;O中断)</li>
</ol>
</li>
<li>$内核态\to用户态$：OS内核处理完成后，调用中断返回指令(如Intel的iret)触发</li>
</ol>
<h3 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h3><ol>
<li><p>用户栈：就是平常说的栈</p>
</li>
<li><p>核心栈：</p>
<ol>
<li><p>核心栈也叫系统栈或内核栈，是内存中属于操作系统空间的一块区域，其用途包含以下两种:</p>
<ol>
<li><p>保存中断现场，嵌套中断</p>
</li>
<li><p>保存操作系统程序(函数)间相互调用的参数、返回值、返回点以及程序局部变量。</p>
</li>
</ol>
</li>
<li><p><strong>每个进程</strong>有一个核心栈:可读可写不可执行，大小有限</p>
</li>
<li><p>硬件栈指针只有一个</p>
</li>
</ol>
</li>
</ol>
<h3 id="中断系统处理流程"><a href="#中断系统处理流程" class="headerlink" title="中断系统处理流程"></a>中断系统处理流程</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/12.png" alt="img"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li>概念：<strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。<ol>
<li>具有一定独立功能的程序：进程是相对独立的</li>
<li>关于某个数据集合：对于不同数据集合的操作不是同一个进程。</li>
<li>一次运行活动：有生命周期</li>
</ol>
</li>
<li><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>:这只限于单线程单进程的情况下</li>
<li>属性：<ol>
<li><strong>动态性</strong>:进程是程序在数据结合上的一次执行过程，是动态概念</li>
<li><strong>共享性</strong>:同一程序同时运行于不同数据集合上时都是不同的进程，即不同的进程可以运行相同的程序。</li>
<li><strong>独立性</strong>:每个进程是操作系统中的一个独立实体。有自己的虚存空间、程序计数器和内部状态.</li>
<li><strong>制约性</strong>:进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度予以协调。</li>
<li><strong>并发性</strong>:多个进程的执行在时间上可以重叠。</li>
</ol>
</li>
<li>组成：一个进程包括五个实体部分，分别是：<ol>
<li>(OS管理运行程序的)数据结构P</li>
<li>(运行程序的)内存代码C</li>
<li>(运行程序的)内存数据D</li>
<li>(运行程序的)通用寄存器信息R</li>
<li>(OS控制程序执行的)程序状态字信息PSW</li>
</ol>
</li>
</ol>
<h3 id="转态和转换"><a href="#转态和转换" class="headerlink" title="转态和转换"></a>转态和转换</h3><ol>
<li><p>进程三态模型<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/7.png" alt="img"></p>
<ol>
<li>只要操作系统支持多道程序设计，就必须要设计进程转换模型来管理，必须实现<strong>三个进程状态和四个跳转关系</strong></li>
<li>进程状态转换一定有<strong>内核</strong>的参与。</li>
<li>四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：<ol>
<li>没有就绪态到等待态:到等待态需要内核参与。</li>
<li>没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。</li>
</ol>
</li>
</ol>
</li>
<li><p>挂起</p>
<ol>
<li><p>概念</p>
<ol>
<li>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况。，现为<strong>性能低</strong>和<strong>死锁</strong>两种情况。</li>
<li>解决办法：剥夺某些进程的<strong>内存及其他资源</strong>，调入OS管理的<strong>对换区</strong>（对换区在磁盘上，是外存），不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是<strong>进程挂起</strong></li>
<li>挂起态与等待态有着本质区别<ol>
<li>进程挂起:<strong>没有任何资源</strong></li>
<li>进程等待:<strong>占有已申请到的资源处于等待</strong></li>
</ol>
</li>
<li>结束挂起状态的命令只能由<strong>操作系统和父进程</strong>发出。</li>
</ol>
</li>
<li><p>挂起的选择和恢复<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/8.png" alt="img"></p>
<ol>
<li>挂起的选择：<ol>
<li>一般选择<strong>等待态</strong>进程进入<strong>挂起等待态</strong></li>
<li>也可选择<strong>就绪态</strong>进程进入<strong>挂起就绪态</strong></li>
<li><strong>运行态</strong>进程还可以挂起自己</li>
</ol>
</li>
<li>挂起的恢复<ol>
<li>等待事件结束后，<strong>挂起等待态</strong>进入<strong>挂起就绪态</strong></li>
<li>一般选择<strong>挂起就绪态</strong>进程予以恢复</li>
<li>操作系统极其空闲才会选择调入<strong>挂起等待态</strong>的进程</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="描述和组成"><a href="#描述和组成" class="headerlink" title="描述和组成"></a>描述和组成</h3><h4 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h4><ol>
<li><strong>某一时刻进程的内容及其执行状态集合</strong>：<ol>
<li>进程控制块: 每个进程捆绑一个，保存进程的标识信息、现场信息和控制信息。进程创建时创建进程控制块，进程撤销时回收进程控制块，与进程一一对应，<strong>是进程存在的唯一标识</strong>。</li>
<li>进程程序块: 进程执行的程序空间，规定进程一次运行所应完成的功能。</li>
<li>进程数据块: 进程处理的数据空间，是进程的私有地址空间，包括各类私有数据、处理函数的用户栈和可修改的程序</li>
<li>进程核心栈: 每个进程捆绑一个，进程在<strong>内核模式</strong>下运行时使用的堆栈，中断或系统过程使用，保存函数调用的参数、局部变量和返回地址等。</li>
</ol>
</li>
<li>进程运行时如果遇到要执行操作系统内核函数，此时则保存应用程序的全部现场信息及其用户栈，使其不被内核程序破坏。而内核函数运行时使用进程的核心栈来放置工作信息。</li>
<li>进程映像是<strong>内存级</strong>的物理实体，又称为进程的内存映像</li>
<li>进程的内存映像示意图<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/14.png" alt="img"></li>
</ol>
<h4 id="进程控制块-描述符（Process-Control-Block，PCB）"><a href="#进程控制块-描述符（Process-Control-Block，PCB）" class="headerlink" title="进程控制块&#x2F;描述符（Process Control Block，PCB）"></a>进程控制块&#x2F;描述符（Process Control Block，PCB）</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/13.png" alt="img"></p>
<ol>
<li>进程控制块PCB是OS用于记录和刻画<strong>进程状态及环境信息</strong>的数据结构，是进程存在的唯一标识，是操作系统掌握进程的唯一资料结构和进程调度的主要依据</li>
<li>包括标识信息、现场信息和控制信息。</li>
</ol>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><ol>
<li>进程的执行需要环境支持，进程上下文刻画了进程的执行情况.</li>
</ol>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><ol>
<li>进程队列分类<ol>
<li>运行队列：通常只有一个进程</li>
<li>等待(阻塞)队列:也是有机会被调入，他等待的资源或事件完成后，调入就绪队列。</li>
<li>就绪队列:从就绪队列中挑选进程调入运行，按照优先级或FCFS的原则排队</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/9.png" alt="img"></p>
<ol start="2">
<li>进程队列组织方式<ol>
<li>链接方式：采用单向链接或双向链接。</li>
<li>索引方式：利用索引表记录不同状态进程的PCB地址或在PCB表中的编号</li>
<li>核心是完成入队和出队操作</li>
<li>进程与资源调度围绕进程队列展开</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/32.png" alt="img"></p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol>
<li><p>原语</p>
<ol>
<li><strong>原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性</strong>(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)。原语的执行可以通过<strong>关中断实现</strong></li>
<li>进程控制使用的原语被称为<strong>进程控制原语</strong>，另一类常用原语是<strong>进程通信原语</strong></li>
</ol>
</li>
<li><p>进程切换和模式切换</p>
<ol>
<li><h3 id="进程切换与模式切换-状态转换"><a href="#进程切换与模式切换-状态转换" class="headerlink" title="进程切换与模式切换(状态转换)"></a>进程切换与模式切换(状态转换)</h3><ol>
<li>一些中断&#x2F;异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：<ol>
<li>(中断&#x2F;异常触发)正向模式切换压入PSW&#x2F;PC</li>
<li>保存被中断进程的现场信息</li>
<li>处理中断&#x2F;异常</li>
<li>恢复被中断进程的现场信息</li>
<li>(中断返回指令触发)逆向模式转换弹出PSW&#x2F;PC</li>
</ol>
</li>
<li>比如计时中断，中断处理完成后直接恢复</li>
<li>模式切换是进程仍在自己的上下文进行处理，仅仅是处理器状态发生了变化，内核仍然被中断进程的上下文中进行处理。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/80.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>把进程的两项功能分离开来</p>
<ol>
<li>独立分配资源(进程概念上)，进程作为系统资源分配和保护的<strong>独立单位</strong>，不需要频繁地切换</li>
<li>被调度分派执行(线程概念上)，线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换</li>
</ol>
</li>
<li><p>多线程结构<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/15.png" alt="img"></p>
</li>
<li><p>概念</p>
<ol>
<li>线程是进程能够并发执行的实体，是进程的组成单位，也是处理器调度和分派的基本单位。</li>
<li>进程是一条执行路径，有独立的程序计数器，未运行时保护线程上下文。</li>
<li>同一个进程中的所有线程共享进程获得的主存空间和资源。</li>
</ol>
</li>
<li><p>多线程策略<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/21.png" alt="img"></p>
</li>
</ol>
<h3 id="内核级线程（-KLT-Kernel-Level-Threads）"><a href="#内核级线程（-KLT-Kernel-Level-Threads）" class="headerlink" title="内核级线程（ KLT, Kernel-Level Threads）"></a>内核级线程（ KLT, Kernel-Level Threads）</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/16.png" alt="img"></p>
<ol>
<li>特点<ol>
<li>优点：<ol>
<li>在多处理器上内核可以同时调度统一进程的多个线程运行。</li>
<li>进程中的某一线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行，也可以运行其他进程。</li>
<li>由于内核比较小，内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率。</li>
</ol>
</li>
<li>缺陷：<ol>
<li>应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大。</li>
<li>线程调度开销大，线程通信开销小。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="用户级线程（ULT-User-Level-Threads）"><a href="#用户级线程（ULT-User-Level-Threads）" class="headerlink" title="用户级线程（ULT, User-Level Threads）"></a>用户级线程（ULT, User-Level Threads）</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/17.png" alt="img"></p>
<ol>
<li>特点<ol>
<li>优点：<ol>
<li>节省开销和内核资源:所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能<strong>节省模式切换开销和内核的宝贵资源</strong>。</li>
<li>允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法。</li>
<li>可移植性好:能运行在任何OS上，内核在支持ULT方面不需要做任何工作。</li>
<li>ULT可以解决逻辑并行性问题。</li>
</ol>
</li>
<li>缺点：<ol>
<li>不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行。</li>
<li>一个ULT的阻塞，将引起整个进程的阻塞:不能完成切换线程，因为内核感知不到进程中的线程的存在。</li>
</ol>
</li>
<li>ULT可以解决逻辑并行性问题。</li>
</ol>
</li>
</ol>
<h3 id="混合式策略"><a href="#混合式策略" class="headerlink" title="混合式策略"></a>混合式策略</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/19.png" alt="img"></p>
<ol>
<li>特点：<ol>
<li>合并了用户级线程&#x2F;内核级线程设施</li>
<li>线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行</li>
<li>一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上</li>
<li>程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果</li>
<li>该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点</li>
</ol>
</li>
<li>线程混合式策略下的线程状态<ol>
<li>KLT的三态模型，由系统调度负责</li>
<li>ULT的三态模型，由用户调度负责</li>
<li>活跃态的ULT代表绑定KLT的三态</li>
<li>活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT</li>
</ol>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/20.png" alt="img"></p>
<ul>
<li>为什么是活跃态绑定KLT的三态？<ul>
<li><strong>因为ULT 依赖于 KLT 执行，而 KLT 受操作系统的调度机制控制。用户级线程（ULT）需要绑定到内核级线程（KLT）上才能真正执行</strong></li>
<li>只有ULT为活跃态<strong>且</strong>KLT为运行态，ULT才处于运行态。</li>
</ul>
</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="处理器调度层次"><a href="#处理器调度层次" class="headerlink" title="处理器调度层次"></a>处理器调度层次</h3><ol>
<li>高级调度：又称长程调度、作业调度，决定能否加入到执行的进程池中，管理从创建进程到调度运行再到结束阶段后的善后部分的全过程。</li>
<li>中级调度，又称平衡调度、中程调度，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作。</li>
<li>低级调度：又称短程调度、进程调度&#x2F;线程调度，根据某种原则决定就绪队列中哪个进程&#x2F;线程获得处理器，并将处理器让出给它使用。</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/22.png" alt="img"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec2/23.png" alt="img"></p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>考虑因素</p>
<ol>
<li><p>资源利用率：使得CPU或其他资源的使用率尽可能高且能够并行工作<br>$$<br>CPU利用率&#x3D;\frac{CPU有效工作时间}{CPU总运行时间}<br>$$</p>
</li>
<li><p>吞吐量：单位事假内CPU处理作业的个数，服务器的TPS，例如12306或淘宝</p>
</li>
<li><p>公平性：确保每个用户每个进程获得合理的CPU份额或其他资源份额</p>
</li>
<li><p>响应时间：</p>
<ol>
<li>使交互式用户的响应时间尽可能小，或尽快处理实时任务</li>
<li>细分包含输入的程序命令传送到CPU时间、CPU处理请求命令的时间、处理所形成的响应回送到终端显示器的时间。</li>
</ol>
</li>
<li><p><strong>周转时间</strong>：从提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短。</p>
</li>
</ol>
</li>
<li><p>调度模式</p>
<ol>
<li>抢占式(剥夺式)调度：当前正在运行的进程可能被操作系统中断，并转移到就绪态。处理器剥夺原则：<ol>
<li>高优先级进程&#x2F;线程可剥夺低优先级进程&#x2F;线程。</li>
<li>运行进程&#x2F;线程时间片用完后被剥夺。</li>
</ol>
</li>
<li>非抢占式(非剥夺式)调度：一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I&#x2F;O或请求某些操作系统服务而阻塞自己。</li>
<li>与非抢占式调度相比，抢占式调度可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间</li>
</ol>
</li>
</ol>
<h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><ul>
<li>非抢占式</li>
<li>弊端太大，性能会非常差，不被现在的操作系统使用</li>
</ul>
<h4 id="最短进程优先（SPN）"><a href="#最短进程优先（SPN）" class="headerlink" title="最短进程优先（SPN）"></a>最短进程优先（SPN）</h4><ul>
<li>非抢占式</li>
<li>缺点：<ul>
<li>需要预知作业所需的CPU运行时间</li>
<li>忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。</li>
<li>分时、实时处理仍然不理想。</li>
</ul>
</li>
</ul>
<h4 id="最短剩余时间优先（SRTF）"><a href="#最短剩余时间优先（SRTF）" class="headerlink" title="最短剩余时间优先（SRTF）"></a>最短剩余时间优先（SRTF）</h4><ul>
<li>抢占式</li>
</ul>
<h4 id="最高响应比优先（HRRN）"><a href="#最高响应比优先（HRRN）" class="headerlink" title="最高响应比优先（HRRN）"></a>最高响应比优先（HRRN）</h4><ul>
<li>非抢占式</li>
</ul>
<ol>
<li><p>每当需要调度时，计算出所有的响应比，选择最高的。</p>
</li>
<li><p>$$<br>响应比&#x3D;\frac{等待时间+期待服务时间}{期待服务时间}&#x3D;1+\frac{等待时间}{期待服务时间}<br>$$</p>
</li>
</ol>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><ol>
<li>调度器总是选择优先级较高的进程，提供多个就绪队列(一组就绪队列)，代表各个级别的优先级。</li>
<li>低优先级的进程可能很难被执行到？一个进程的优先级应该随着它的时间或执行的历史而变化。</li>
<li>如果就绪队列中出现优先级高的进程&#x2F;线程，系统可以预先规定策略为非剥夺式和剥夺式策略。</li>
<li>优先级的确定<ol>
<li>用户给出优先级</li>
<li>系统综合考虑各因素，包括打开文件数、资源申请情况等等</li>
</ol>
</li>
<li>优先级确定方式<ol>
<li>静态：生命周期内不改变，容易造成饥饿问题。</li>
<li>动态：生命周期内可能会发生改变，正在运行的进程逐渐降低优先级，正在等待的进程逐渐提高优先级。</li>
</ol>
</li>
</ol>
<h4 id="时间片轮转调度-（RR）"><a href="#时间片轮转调度-（RR）" class="headerlink" title="时间片轮转调度***（RR）"></a>时间片轮转调度***（RR）</h4><ol>
<li>本质也是<strong>先来先服务</strong>，但是要按照时间片来进行调度。</li>
<li>根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片，基于时钟做抢占式调度。</li>
<li>时间片中断：以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列队尾，然后基于FCFS策略选择下一个就绪进程运行</li>
<li>时间片的确定：选择长短合适的时间片，一般为10ms到200ms<ol>
<li>过长则退化为先来先服务算法</li>
<li>过短则调度开销显著增大</li>
</ol>
</li>
<li>时间片分为单时间片、多时间片和动态时间片三种</li>
<li>使用时间片轮转调度算法，在给一个进程分配处理器的时候，不需要知道进程需要多长时间</li>
<li>很多的调度都会结合时间片轮转调度算法来实现</li>
<li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318204105076.png" alt="image-20250318204105076"></li>
</ol>
<h4 id="多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度"><a href="#多级反馈调度-Multi-level-Feedback-Queue，MLFQ-，又称分级调度" class="headerlink" title="多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度"></a>多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度</h4><ol>
<li>基本思想<ol>
<li>建立多个不同优先级的就绪进程队列</li>
<li>多个就绪进程队列之间按照优先数调度</li>
<li>高优先级的就绪进程, 分配的时间片短</li>
<li>单个就绪进程队列中的进程的优先数和时间片相同,按照先来先服务算法调度</li>
</ol>
</li>
<li>如果没做完会惩罚降级，做题目要至少画一下前几个RQ。如果进程掉出去的同时，有新的进程进入，那么新的进程优先进入就绪队列</li>
<li>对以计算为主的长进程不友好，就绪队列越深获得调度的机会越小</li>
<li>不同的进程可以设置不同的时间片长度：q&#x3D;2^i^(可选)，i是第几次处理的意思</li>
<li>多级队列更能够发现先到达的，时间片比较短的处理完。</li>
<li>除了极少数的硬实时操作系统使用抢占式调度算法，绝大多数操作系统有效地组合时间片调度算法和优先数调度算法，采用分级调度算法的策略加以实现</li>
<li>如果没有竞争不掉下去，时刻1(根据考试具体情况决定)</li>
</ol>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><ol>
<li>基本思想：为进程发放针对<strong>系统各种资源</strong>(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源</li>
</ol>
<h1 id="第三章-·-存储管理"><a href="#第三章-·-存储管理" class="headerlink" title="第三章 · 存储管理"></a>第三章 · 存储管理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>逻辑地址<ol>
<li>逻辑地址：又称相对地址，即用户编程所使用的地址空间</li>
<li>逻辑地址从零开始编号，有两种形式：<ol>
<li>一维逻辑地址(地址)</li>
<li>二维逻辑地址(段号:段内地址)</li>
</ol>
</li>
</ol>
</li>
<li>物理地址<ol>
<li>又称绝对地址，从处理器角度看到的物理内存单元。</li>
<li>处理器执行指令时按照物理地址进行</li>
</ol>
</li>
</ol>
<h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="单连续分区存储管理"><a href="#单连续分区存储管理" class="headerlink" title="单连续分区存储管理"></a>单连续分区存储管理</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ol>
<li>每个进程占用一个物理上完全连续的存储空间(区域)</li>
<li>单连续分区存储管理细分:<ol>
<li>单用户连续存储管理</li>
<li>固定分区存储管理</li>
<li>可变分区存储管理</li>
</ol>
</li>
<li>分区方式不能实现虚拟存储。</li>
<li>内部碎片和外部碎片<ol>
<li>内部碎片：比如在固定分区中，某一块被使用的分区中还有空闲</li>
<li>外部碎片：比如在固定分区中，有空闲的小分区</li>
</ol>
</li>
</ol>
<h4 id="单用户连续分区"><a href="#单用户连续分区" class="headerlink" title="单用户连续分区"></a>单用户连续分区</h4><ol>
<li><p>适用于单用户单任务操作系统，如DOS</p>
</li>
<li><p>主存区域(内存空间)划分为系统区与用户区</p>
<ol>
<li>系统区用于存放操作系统内核程序和数据结构等</li>
<li>用户区用于存放应用程序和数据</li>
</ol>
</li>
<li><p>设置一个<strong>栅栏寄存器</strong>界分两个区域，硬件用它在执行时进行存储保护</p>
</li>
<li><p>一般采用<strong>静态重定位</strong>进行地址转换</p>
</li>
<li><p>硬件实现代价低</p>
</li>
<li><p>单用户连续分区存储管理示意</p>
<ol>
<li>静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址全部转换成绝对地址</li>
<li>界限地址:放置软件访问到操作系统的部分<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102402017.png" alt="image-20250324102402017"></li>
</ol>
</li>
</ol>
<h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><ol>
<li><p>又称静态分区模式</p>
</li>
<li><p>基本思想：</p>
<ol>
<li>内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们都可以并发执行。</li>
<li>可用静态&#x2F;动态重定位、硬件实现代价低、被早期OS采用<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324102526444.png" alt="image-20250324102526444"></li>
</ol>
</li>
<li><p>主存分配</p>
<ol>
<li>主存分配表：包含内容：起始地址、长度、占用标志</li>
<li>内存分配方法很简单，其任务有何时吧内存空间划分成分区：由系统管理员和操作系统初始化模块协同完成。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/8.png" alt="img"></a></p>
<ol>
<li>作业进入分区的排队策略：<ol>
<li>每个分区有自己的作业等待队列，作业等待能装下自身的最小分区。</li>
<li>所有等待处理作业排成等待队列，每当有空闲，找到队列中能进入的最大的一个。</li>
</ol>
</li>
</ol>
</li>
<li><p>地址转换：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103121851.png" alt="image-20250324103121851"></p>
</li>
<li><p>缺点：</p>
<ol>
<li>由于预先规定了分区的大小，使得大作业无法装入，而不得不采用覆盖技术，带来负担。</li>
<li>内存空间利用率不高，作业很少填满分区：固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存<strong>内零头</strong>，有浪费，内存内零头是因为在分区内部有零头。</li>
<li>如果作业在运行中要求动态扩展内存空间是困难的。</li>
<li>分区数目是操作系统初启动时确定的，会限制多道运行程序的道数。</li>
</ol>
</li>
</ol>
<h4 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h4><ol>
<li>概述<ol>
<li>可变分区存储管理又称动态分区模式，按照作业大小划分分区，但划分的时间、大小和位置都是动态的。</li>
<li>创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间<ol>
<li>若有，则按需要量分割一个分区</li>
<li>若无，则令该进程等待主存资源</li>
</ol>
</li>
<li>由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的</li>
</ol>
</li>
<li>示例<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103508697.png" alt="image-20250324103508697"></li>
<li>主存分配表<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103659047.png" alt="image-20250324103659047"><ol>
<li>管理的数据结构：已分配区表与未分配区表，采用链表实现</li>
<li>找一个最大的空闲的位置进行分配</li>
</ol>
</li>
<li>内存回收<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324103801245.png" alt="image-20250324103801245"><ol>
<li>可变分区方式的内存回收会导致内存空间的转换</li>
<li>作业X撤离后有且仅有如上4种情况</li>
</ol>
</li>
<li>地址转换<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324104131474.png" alt="image-20250324104131474"><ol>
<li>硬件实现机制与动态重定位</li>
<li>进程的程序和数据的地址由硬件完成<ol>
<li>基址寄存器：分配进程的起始地址</li>
<li>限长寄存器：进程占用的连续存储空间的长度</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h3><h4 id="最先适应"><a href="#最先适应" class="headerlink" title="最先适应"></a>最先适应</h4><p>优先使用低地址空闲分区</p>
<h4 id="最佳适应"><a href="#最佳适应" class="headerlink" title="最佳适应"></a>最佳适应</h4><p>优先使用更小的空闲分区</p>
<h4 id="最坏适应"><a href="#最坏适应" class="headerlink" title="最坏适应"></a>最坏适应</h4><p>优先使用更大的空闲分区</p>
<h4 id="临近适应（循环首次适应法）"><a href="#临近适应（循环首次适应法）" class="headerlink" title="临近适应（循环首次适应法）"></a>临近适应（循环首次适应法）</h4><p>每次都从上次查找结束的位置开始查找空闲分区链</p>
<h3 id="分区方式的内存零头"><a href="#分区方式的内存零头" class="headerlink" title="分区方式的内存零头"></a>分区方式的内存零头</h3><ol>
<li>固定分区方式会产生<strong>内存内零头</strong></li>
<li>可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为<strong>内存外零头</strong>，内存外零头是指分区内部是没有零头的，而是在外面的零头。</li>
<li><strong>最优适配算法最容易产生外零头</strong></li>
<li>任何适配算法都<strong>不能避免</strong>产生外零头</li>
</ol>
<h3 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h3><ol>
<li><p>移动技术（程序浮动）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324105052339.png" alt="image-20250324105052339"></p>
<ol>
<li>碎片：内存中的小空闲区，移动分区来解决内存外零头问题。</li>
<li>需要动态重定位支撑:静态重定位无法解决内存外零头</li>
<li>问题：移动技术有极大的系统开销。</li>
</ol>
</li>
<li><p>对换技术：</p>
<ol>
<li>如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为<strong>对换</strong>。</li>
<li>被对换出去的进程的状态会调整为就绪态，并且通知存储管理程序，一旦内存可用，立即将该进程对换回内存。</li>
<li>对换技术关键点<ol>
<li>被对换进程：通常系统选择时间片耗尽或优先级较低的进程对换出去。</li>
<li>对换的进程信息：将数据区和堆栈通过文件系统转换为特殊文件保存。</li>
<li>被对换的时机：<ol>
<li>批处理系统中：进程需要扩充内存空间但不能被满足时</li>
<li>分时系统：<ol>
<li>时间片结束时</li>
<li>执行I&#x2F;O操作时</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>覆盖技术</p>
<ol>
<li><p>移动和对换技术解决因多个程序存在而导致内存区不足问题。</p>
</li>
<li><p>但是如果程序长度超过物理内存的总和，或者超出固定分区大小，则会出现内存永久性短缺，大程序无法运行，解决方案是覆盖技术。</p>
</li>
<li><p><strong>程序分段：</strong> 将一个大程序划分为多个独立的部分（通常是功能模块），这些部分通常称为”覆盖块”（Overlay Blocks）。</p>
<p><strong>内存交换：</strong> 在程序执行过程中，操作系统将某些覆盖块从磁盘加载到内存中运行，当这些块不再需要时，操作系统可以将它们从内存中卸载，释放空间给其他块。</p>
</li>
</ol>
</li>
</ol>
<h2 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ol>
<li>高级语言采用模块化程序设计方法。应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每一段都从0开始编制，各有各自名字和长度且实现不同功能。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/27.png" alt="img"></a></p>
<ol start="2">
<li>编译后段间地址是不连续的，段内地址是连续的。</li>
</ol>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ol>
<li>分段存储器的逻辑地址由两部分组成:段号+段内偏移</li>
<li>页式存储管理中页的划分对程序员不可见。</li>
<li>段式存储管理中段的划分对程序员可见。</li>
</ol>
<h2 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>基本原理</p>
<ol>
<li><p>页面：金层逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始编号。比如出版一本书，出版受到页大小影响，最后由若干页组成，一般大小为4KB</p>
</li>
<li><p>页框：又称页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区都是一个页框(物理块)，块号从0开始。</p>
</li>
<li><p>逻辑地址：分页存储器的逻辑地址由页号 + 页面偏移组成(地址总线32位)</p>
<ol>
<li>页号：32-12 &#x3D; 20位，则包含页220220位</li>
<li>页面偏移：页面大小为4KB，则需要12位</li>
</ol>
</li>
<li><p>内存页框表：该表长度取决于内存划分的物理块数，表项中给出物理块使用情况，0为空闲，1为占用，有的系统还会添加保护位、脏位等等。</p>
</li>
<li><p>页表：将页装入到内存中，</p>
<p>页未必连续</p>
<p>，我们需要为每一个页面设立一个重定向寄存器，这个寄存器的集合就是页表。</p>
<ol>
<li>数学角度：页面号→页框号页面号→页框号</li>
<li>系统设置页表基址寄存器，存放当前运行进程的页表起始地址。</li>
<li>物理地址&#x3D;页框号∗块长+页内偏移物理地址&#x3D;页框号∗块长+页内偏移，实际转换时，我们将页内偏移作为低地址，根据页号从页表中查找到页框号并作为高地址即可。</li>
<li>页表不存储<strong>页号</strong>，只存储页框号和相应标志位</li>
</ol>
</li>
<li><p>页式存储产生的碎片是内部碎片</p>
<ol>
<li>可以类比固定分区</li>
<li>比如19KB的程序，加载到页大小为4KB中，会产生1KB的内存内零头。</li>
</ol>
</li>
</ol>
</li>
<li><p>地址：</p>
<ol>
<li>页式存储管理的逻辑地址由两部分组成，<strong>页号和单元号(页内偏移)</strong>，逻辑地址形式：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/16.png" alt="img"></a></p>
<ol>
<li>页式存储管理的物理地址也有两部分组成：<strong>页架号(页框号)和单元号(页内偏移)</strong>，物理地址形式：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/17.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/17.png" alt="img"></a></p>
</li>
<li><p>多道程序环境下的进程表</p>
<ol>
<li>进程表中登记了每个进程的页表</li>
<li>进程占有处理器运行时，其<strong>页表起始地址和长度</strong>送入<strong>页表控制寄存器</strong><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/20.png" alt="img"></li>
</ol>
</li>
<li><p>多道程序环境下的地址转换</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/21.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/21.png" alt="img"></a></p>
<ol>
<li>页表控制寄存器存储了当前的页表的地址和长度</li>
<li>页表控制寄存器和进程表是有关联的，所有进程在进程表中都有一项，当这个进程占据CPU时，这个进程就占据页表控制寄存器。</li>
<li>不使用快表:首先从逻辑地址中，提取出页号，比较页号是否出现越界中断，如果没有越界，则根据页表向下偏移到对应的块号，提取出页表信息和页框号，页框号结合单元号，得到物理地址</li>
<li>快表:不是从页表中查找，而是优先从快表中查询块号。</li>
</ol>
</li>
</ol>
<h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="最佳算法OPT（Belady算法）"><a href="#最佳算法OPT（Belady算法）" class="headerlink" title="最佳算法OPT（Belady算法）"></a>最佳算法OPT（Belady算法）</h4><ol>
<li>算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择<strong>距现在最长时间后再访问</strong>的页。</li>
<li>该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)</li>
<li>OPT只可以<strong>模拟</strong>，不可以实现，因为永远无法预知之后的事情。</li>
<li>这种算法可以用作衡量其他各种算法的标准。</li>
<li>图示。（这个图应该斜着看，左下的栈和右上的数字搭配，更新后得到右下的栈）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104230843.png" alt="image-20250331104230843"></li>
</ol>
<h4 id="FIFO先进先出"><a href="#FIFO先进先出" class="headerlink" title="FIFO先进先出"></a>FIFO先进先出<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104328678.png" alt="image-20250331104328678"></h4><ol>
<li><strong>FIFO算法的Belady异常</strong>：更多的页框导致了更高的缺页率，页框为3和4的时候。注意，Belady异常和Beladey算法没关系。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331105353886.png" alt="image-20250331105353886"></li>
</ol>
<h4 id="LRU，最近最少用"><a href="#LRU，最近最少用" class="headerlink" title="LRU，最近最少用"></a>LRU，最近最少用<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104351141.png" alt="image-20250331104351141"></h4><h4 id="LFU，最不常用"><a href="#LFU，最不常用" class="headerlink" title="LFU，最不常用"></a>LFU，最不常用</h4><h4 id="CLOCK算法"><a href="#CLOCK算法" class="headerlink" title="CLOCK算法"></a>CLOCK算法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250331104416252.png" alt="image-20250331104416252"></h4><ol>
<li>CLOCK就是SCR结合FIFO形成循环，使用页引用标志位。</li>
<li>流程<ol>
<li>页面调入主存时，其引用标志位置为1</li>
<li>访问主存页面时，其引用标志位置为1</li>
<li>淘汰页面时，从指针当前指向的页面开始扫描循环队列<ol>
<li>把所遇到的引用标志位是1的页面的引用标志位清0并跳过</li>
<li>把所遇到的引用标志位是0的页面淘汰，<strong>指针推进一步</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="局部最佳页面替换算法-MIN-（一般不考）"><a href="#局部最佳页面替换算法-MIN-（一般不考）" class="headerlink" title="局部最佳页面替换算法(MIN)（一般不考）"></a>局部最佳页面替换算法(MIN)（一般不考）</h4><ol>
<li>实现思想：进程在时刻t访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框.</li>
<li>不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中</li>
<li>t为一个系统常量，间隔(t, t+τ)称作滑动窗口 。例子中τ&#x3D;3，双闭区间</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/51.png" alt="img"></p>
<h4 id="工作集模型和工作集置换算法-WS"><a href="#工作集模型和工作集置换算法-WS" class="headerlink" title="工作集模型和工作集置换算法(WS)"></a>工作集模型和工作集置换算法(WS)</h4><ol>
<li>进程工作集指”在某一段时间间隔内进程运行所需访问的页面集合”</li>
<li>实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，<strong>不向前查看页面引用串，而是基于程序局部性原理向后看</strong></li>
<li>任何给定时刻，<strong>进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计</strong></li>
<li>双闭区间</li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/55.png" alt="img"></li>
</ol>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><ul>
<li>页表是面向进程的，每个进程都要有页表，标记为页号</li>
<li>反置页表是面向内存的，标记为页框号</li>
</ul>
<ol>
<li>为每个进程创建完整的页表开销很大</li>
<li>既然页表也是数据，我们就为页表再创建一个页表，每一页称为页表页，新页表叫页目录表</li>
<li>做法：把整个页表分割成许多小页表，每个称为页表页，它的大小与页框长度相同，于是每个页表页含有若干页表表项。<ol>
<li>页表项从0开始编号，允许放到不连续的页框中，为了找到页表页，建立地质索引，称为<strong>页目录表</strong>。</li>
<li>系统为每一个进程建立一张页目录表，他的每一个表项指出一个页表页，而页表页的每个表项给出页面和页框的对应关系。</li>
</ol>
</li>
<li>逻辑地址结构有三部分组成：页目录、页表页和位移</li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/83.png" alt="img"></li>
<li>页目录项是页表页的索引，而页表页项是进程程序的页面索引。</li>
</ol>
<h3 id="反置页表-IPT"><a href="#反置页表-IPT" class="headerlink" title="反置页表(IPT)"></a>反置页表(IPT)</h3><ol>
<li><p>正向页表(名单)、反置页表(现场坐的是谁)</p>
<ol>
<li>正向页表:以<strong>页号</strong>为索引(隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表</li>
<li>反置页表:以<strong>页框号</strong>为索引(隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号</li>
</ol>
</li>
<li><p>基本设计思想：</p>
<ol>
<li><strong>针对内存中的每个页架建立一个页表</strong>，按照块号(页架号)排序</li>
<li>表项包含：正在访问该页框的进程标识、页号及特征位，和<strong>哈希链指针</strong>等</li>
<li>用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换</li>
</ol>
</li>
<li><p>反置页表的页表项</p>
<ol>
<li>页号：虚拟地址页号</li>
<li>进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)</li>
<li>标志位：有效、引用、修改、保护和锁定等标志信息</li>
<li>链指针：<strong>哈希链</strong>，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。</li>
</ol>
</li>
<li><p>反置页表的逻辑地址</p>
<ol>
<li>进程标识符：使用该页的进程。</li>
<li>页号：虚拟地址页号部分，页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。</li>
<li>页内位移</li>
</ol>
</li>
<li><p>地址转换<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/76.png" alt="img"></p>
<ol>
<li>反置页表地址转换过程如下:<ol>
<li>需要访问内存地址时，地址转换机制用进程标识符与页号作为输入，由哈希函数先映射到哈希表，哈希表项存放的是指向IPT表项的指针<ol>
<li>此指针可能就是指向匹配的IPT表项</li>
<li>如果不是则遍历哈希链直至找到进程标识符与页号均匹配的IPT表项：因为多个页号通过哈希函数可能得到了相同的哈希值，所以我们选择使用哈希链。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/77.png" alt="img"></li>
</ol>
</li>
<li>而此表项的**序号(索引)**就是页框号，通过拼接页内位移便可生成物理地址。</li>
<li>若在反置页表中未能找到匹配的IPT页表项，说明此页不在内存，触发缺页异常，请求操作系统通过页表调入：发生缺页中断时需要多访问一次磁盘，速度会比较慢。</li>
</ol>
</li>
<li>页框号是根据公式换算出来的：$x_i&#x3D;x_0+4*i$，其中$x_i$ 表示第 <em>i</em> 个表项的物理地址，$x_0$ 表示反置页表的起始物理地址，4 表示每个表项的大小（以字节为单位）</li>
</ol>
</li>
</ol>
<h2 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h2><ol>
<li><p>基本原理</p>
<ol>
<li>一言以蔽之：先分段，再分页</li>
<li>逻辑地址由段号s、段内页号p和页内偏移d组成<ol>
<li>对用户，虚拟地址由段号s和段内位移d’组成</li>
<li>系统内部将d’分解为p和d，d’ &#x3D; p * 块长 + d</li>
</ol>
</li>
<li>请求段页式虚拟存储管理的数据结构比较复杂，包含作业表、段表和页表三部分。<ol>
<li>作业表：进入系统的作业和作业段表的起始地址</li>
<li>段表：是否在内存、段页表起始地址</li>
<li>页表：是否在内存、对应内存块号</li>
</ol>
</li>
</ol>
</li>
<li><p>地址转换</p>
<ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/33.png" alt="img"></li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec3/88.png" alt="img"></li>
</ol>
</li>
</ol>
<h1 id="第四章-·-设备管理"><a href="#第四章-·-设备管理" class="headerlink" title="第四章 · 设备管理"></a>第四章 · 设备管理</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><ol>
<li>知道三种控制方式：轮询，中断，DMA（直接存储器访问）</li>
<li>IO通道<ol>
<li>描述：<ol>
<li>设备控制器包含自身专用的<strong>处理器和通道程序</strong>，自成体系，使得<strong>CPU与通道高度并行</strong>，实现通道和CPU并行操作，通道之间并行操作，设备之间并行操作。</li>
</ol>
</li>
<li>工作流程（就是中断那一套）<ol>
<li>CPU在执行主程序时遇到I&#x2F;O任务，启动指定通道(通过通道程序地址字CAW)上选址的设备。</li>
<li>启动成功，通道开始控制设备进行操作，此时CPU继续执行其他任务，直到I&#x2F;O操作完成。</li>
<li>通道发出I&#x2F;O操作结束中断，处理器相应并停止当前工作，转向处理I&#x2F;O操作结束事件。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IO软件的实现"><a href="#IO软件的实现" class="headerlink" title="IO软件的实现"></a>IO软件的实现</h2><h3 id="IO软件的层次结构"><a href="#IO软件的层次结构" class="headerlink" title="IO软件的层次结构"></a>IO软件的层次结构</h3><ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png" alt="img"></li>
</ol>
<h3 id="IO中断程序"><a href="#IO中断程序" class="headerlink" title="IO中断程序"></a>IO中断程序</h3><ol>
<li>I&#x2F;O中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系</li>
<li>进程请求I&#x2F;O操作时，通常被挂起，直到数据传输结束后并产生I&#x2F;O中断时，操作系统接管CPU后转向中断处理程序</li>
<li>当设备向CPU提出中断请求时，CPU响应请求并转入中断处理程序</li>
<li>I&#x2F;O中断处理程序的功能<ol>
<li>检查设备状态寄存器内容，判断<strong>产生中断的原因</strong>，根据I&#x2F;O操作的完成情况进行相应的处理</li>
<li>如果数据传输有错，向<strong>上层软件</strong>报告设备的<strong>出错信息</strong>，实施<strong>重新执行</strong></li>
<li>如果正常结束，唤醒等待传输的进程，使其转换为<strong>就绪态</strong></li>
<li>如果有等待传输的I&#x2F;O命令，通知相关软件启动下一个I&#x2F;O请求</li>
</ol>
</li>
</ol>
<h3 id="IO驱动程序"><a href="#IO驱动程序" class="headerlink" title="IO驱动程序"></a>IO驱动程序</h3><ol>
<li>概念：<ol>
<li>I&#x2F;O设备驱动程序是操作系统与I&#x2F;O设备之间的接口软件。它是一组软件代码，用于控制和管理I&#x2F;O设备的运行。驱动程序为操作系统提供了一种与硬件设备进行通信的方式，使得操作系统能够通过标准的接口来操作各种不同的硬件设备。</li>
</ol>
</li>
<li>任务<ol>
<li>把用户提交的<strong>逻辑I&#x2F;O请求</strong>转化为<strong>物理I&#x2F;O操作</strong>的启动和执行，如设备名转换为端口等</li>
<li>监督设备是否正确执行，管理<strong>数据缓冲区</strong>，进行必要的纠错处理</li>
</ol>
</li>
<li>功能<ol>
<li><strong>设备初始化</strong>:在系统<strong>初次启动或设备传输数据</strong>时，预置设备和控制器以及通道状态</li>
<li>执行设备驱动例程<ol>
<li>负责启动设备，进行数据传输</li>
<li>对于具有通道方式，还负责生成<strong>通道指令和通道程序</strong>，启动通道工作</li>
</ol>
</li>
<li><strong>调用和执行中断处理程序</strong>:负责处理设备和控制器及通道所发出的各种中断</li>
</ol>
</li>
</ol>
<h3 id="独立于设备的IO软件"><a href="#独立于设备的IO软件" class="headerlink" title="独立于设备的IO软件"></a>独立于设备的IO软件</h3><ol>
<li>基本功能：执行适用于所有设备的常用I&#x2F;O功能，并向<strong>用户层软件</strong>提供一致性接口</li>
<li>设备命名：通过路径名寻址设备</li>
<li>设备保护：检查用户是否有权访问所申请设备</li>
<li>资源分配方式<ol>
<li>静态分配：进程运行前申请。实现简单，能够防止死锁，但会降低设备利用率</li>
<li>动态分配：进程随用随申请。考虑互锁管理，需要结合信号量与PV操作</li>
</ol>
</li>
<li>缓冲技术：<ol>
<li>通过缓冲消除填满速率和清空速率的影响<ol>
<li>网络上数据需要分析检查才知道去哪里。</li>
<li>有些设备有严格时间约束，比如数字音频设备。</li>
</ol>
</li>
<li>块设备和字符设备都需要缓冲技术<ol>
<li>块设备：磁盘读写以块为单位，应用程序以任意大小单元处理设备，如果应用程序读写长度和位置不是完整扇区，则需要使用缓冲区来缓冲。</li>
<li>字符设备：字符设备提供数据速度快于或慢于应用程序消耗数据的速度。</li>
</ol>
</li>
<li>缓冲设计大量复制操作，对I&#x2F;O性能有较大开销</li>
</ol>
</li>
</ol>
<h3 id="用户空间的IO软件"><a href="#用户空间的IO软件" class="headerlink" title="用户空间的IO软件"></a>用户空间的IO软件</h3><ol>
<li>库函数<ol>
<li>一小部分I&#x2F;O软件<strong>不在</strong>操作系统中，是与<strong>应用程序链接在一起的库函数</strong>，甚至完全由运行于<strong>用户态</strong>的程序组成</li>
<li><strong>系统调用通常由库函数封装后供用户使用</strong>，封装函数只是将系统调用所用的参数放在合适位置，然后执行<strong>访管指令</strong>来陷入内核，再由内核函数实现真正的I&#x2F;O操作</li>
</ol>
</li>
<li>SPOOLing软件<ol>
<li>在<strong>内核外运行</strong>的<strong>系统</strong>I&#x2F;O软件，采用<strong>预输入、缓输出和井管理</strong>技术，是多道程序设计系统中处理<strong>独占型设备</strong>的一种方法，通过创建守护进程和特殊目录解决<strong>独占型设备</strong>的<strong>空占</strong>问题</li>
</ol>
</li>
</ol>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><ol>
<li><p>概述</p>
<ol>
<li>缓冲区:在<strong>内存</strong>中开辟的存储区，专门用于临时存放I&#x2F;O操作的数据</li>
<li>目的：<ol>
<li>解决<strong>CPU与设备之间速度不匹配</strong>的矛盾，协调逻辑记录大小和物理记录大小不一致的问题</li>
<li>减少I&#x2F;O操作对CPU的中断次数</li>
<li>放宽对CPU中断响应时间的要求</li>
<li>提高CPU和设备的并行性</li>
</ol>
</li>
</ol>
</li>
<li><p>单缓冲</p>
<ol>
<li>每当应用程序发出I&#x2F;O操作时，操作系统在主存(内存)的系统区中开设一个缓冲区</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/14.png" alt="img"></a></p>
<ol>
<li><p>如果希望输入的数据被加工后再输出，则需要双缓冲。</p>
</li>
<li><p>工作机制：</p>
<ol>
<li>输入：将数据读至缓冲区，系统将缓冲区数据送至用户区，应用程序对数据进行处理；如此往复，系统读入后续的数据</li>
<li>输出：把数据从用户区复制到缓冲区，再将数据输出后，应用程序继续请求输出</li>
</ol>
</li>
<li><p>双缓冲</p>
<ol>
<li>操作系统在主存的系统区中开设两个缓冲区</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/15.png" alt="img"></a></p>
<ol start="2">
<li><p>工作机制</p>
<ol>
<li>输入：<ol>
<li>设备首先将数据输入缓冲区1，系统再从缓冲区1把数据传到用户区，供应用程序处理，同时从设备数据传送到缓冲区2</li>
<li>当缓冲区1为空，则再次从设备读出数据到缓冲区1，将缓冲区2的数据传送到用户区，供应用程序处理，同时从设备数据传送到缓冲区1</li>
<li>仅当两个缓冲区全为空，并且进程还要提取数据时等待。</li>
</ol>
</li>
<li>输出：<ol>
<li>第一张卡片读入缓冲区1，在打印缓冲区1中数据的同时，又把第二张卡片读入缓冲区2。</li>
<li>缓冲区1打印完毕时，缓冲区2也刚好输入完毕，让读卡机和打印机交换缓冲区。这样，I&#x2F;O设备就能够处于并行工作状态。</li>
</ol>
</li>
</ol>
</li>
<li><p>多缓冲</p>
</li>
</ol>
<ul>
<li>多缓冲的缓冲区是系统的<strong>公共资源</strong>，可供进程共享并由系统<strong>统一分配和管理</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/16.png" alt="img"></p>
<h2 id="驱动调度技术"><a href="#驱动调度技术" class="headerlink" title="驱动调度技术"></a>驱动调度技术</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ol>
<li>组成<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/17.png" alt="img"></li>
<li>术语<ol>
<li>盘面号也被叫做<strong>磁头号</strong></li>
<li>磁道号也被叫做<strong>柱面号</strong></li>
<li>区别:”0面0道1扇区”中的”面”是指磁头，不是柱面<ol>
<li><strong>面和道都是0开始</strong></li>
<li><strong>扇区是从1开始</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="调度-1"><a href="#调度-1" class="headerlink" title="调度"></a>调度</h3><ol>
<li>调度耗时：磁盘完成数据读写所需要的时间:是<strong>寻道时间、旋转延迟、传送时间</strong>的总和</li>
<li>调度策略包括<strong>旋转调度</strong>和<strong>移臂调度</strong></li>
</ol>
<h4 id="移臂调度"><a href="#移臂调度" class="headerlink" title="移臂调度"></a>移臂调度</h4><ul>
<li>目的：使移动臂的移动时间最短，从而减少寻道总时间</li>
</ul>
<h5 id="先来先服务算法-FCFS"><a href="#先来先服务算法-FCFS" class="headerlink" title="先来先服务算法 FCFS"></a>先来先服务算法 FCFS</h5><ol>
<li>移臂距离大，性能不好，移动臂是<strong>随机移动</strong>，寻道性能较差</li>
<li>按顺序处理请求，对所有进程公平</li>
</ol>
<h5 id="最短查找时间优先-最小短距离法-SSTF"><a href="#最短查找时间优先-最小短距离法-SSTF" class="headerlink" title="最短查找时间优先(最小短距离法) SSTF"></a>最短查找时间优先(最小短距离法) SSTF</h5><ol>
<li>先执行<strong>查找时间最短</strong>的请求，具有较好的寻道性能，<strong>存在”饥饿”现象</strong>：距离比较远的被满足</li>
<li>选择使磁头臂从当前位置开始移动最少的磁盘I&#x2F;O请求，因此SSTF策略总是选择导致<strong>最小寻道时间</strong>的请求，总是选择最小寻道时间并不能保证平均寻道时间最小，但是，它的性能比FCFS更好</li>
</ol>
<h5 id="扫描算法-SCAN算法"><a href="#扫描算法-SCAN算法" class="headerlink" title="扫描算法 SCAN算法"></a>扫描算法 SCAN算法</h5><ol>
<li>移动臂每次向一个方向移动，遇到最近的I&#x2F;O请求便进行处理，到达<strong>最后一个</strong>柱面后再向相反方向移动</li>
<li>对最近扫描所跨越区域的请求响应较慢</li>
<li>和电梯调度算法的不同：碰壁才会折返</li>
</ol>
<h5 id="循环扫描算法-C-SCAN算法"><a href="#循环扫描算法-C-SCAN算法" class="headerlink" title="循环扫描算法 C-SCAN算法"></a>循环扫描算法 C-SCAN算法</h5><ol>
<li>单向移动的扫描算法</li>
</ol>
<h5 id="分布扫描算法-N-step-SCAN"><a href="#分布扫描算法-N-step-SCAN" class="headerlink" title="分布扫描算法 N-step-SCAN"></a>分布扫描算法 N-step-SCAN</h5><ol>
<li><p>进程</p>
<p>重复请求同一磁道会垄断整个设备造成磁头臂的粘性，采用分步扫描可避免这类问题</p>
<ol>
<li><strong>把磁盘I&#x2F;O请求队列分成长度为N的子队列，按照FIFO处理每一个子队列，每个子队列内部使用扫描算法</strong></li>
<li>在处理一个队列时，新请求必须添加到<strong>其他</strong>某个队列中</li>
<li>处理完一个子队列后再服务下一个队列</li>
</ol>
</li>
<li><p>如果在扫描的最后剩下的请求数小于N，则它们全部将在下一次扫描时处理</p>
<ol>
<li>当N→∞时，N-step-SCAN的性能接近SCAN</li>
<li>当N&#x3D;1时，实际上是FIFO</li>
</ol>
</li>
</ol>
<h5 id="电梯调度-LOOK-算法"><a href="#电梯调度-LOOK-算法" class="headerlink" title="电梯调度(LOOK 算法)"></a>电梯调度(LOOK 算法)</h5><ol>
<li>无请求时移动臂停止不动，有请求时按电梯规律移动</li>
<li>每次选择沿移动臂的移动方向最近的柱面</li>
<li>如果当前移动方向上没有但相反方向有请求时，改变移动方向</li>
</ol>
<h4 id="旋转调度"><a href="#旋转调度" class="headerlink" title="旋转调度"></a>旋转调度</h4><ul>
<li>目的：使得旋转延迟的总时间最少<ol>
<li>循环排序：通过优化I&#x2F;O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求 </li>
<li>旋转位置测定硬件和多磁头同时读写 技术有利于提高旋转调度的效率</li>
<li>优化分布如下</li>
</ol>
</li>
</ul>
<h4 id="优化分布"><a href="#优化分布" class="headerlink" title="优化分布"></a>优化分布</h4><ul>
<li>通过信息在存储空间的排列方式来减少旋转延迟</li>
<li>交替排序：由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，如交叉因子为n:1表示相邻编号间会间隔n-1个扇区</li>
<li>把相邻扇区集中成簇读写</li>
<li>按柱面集中存储数据（另一种集簇方式），可以减少数据读写时的移臂操作</li>
</ul>
<h2 id="磁盘循环冗余阵列"><a href="#磁盘循环冗余阵列" class="headerlink" title="磁盘循环冗余阵列"></a>磁盘循环冗余阵列</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421102810232.png" alt="image-20250421102810232"></p>
<h2 id="SPOOLing（外部设备联机并行操作）系统"><a href="#SPOOLing（外部设备联机并行操作）系统" class="headerlink" title="SPOOLing（外部设备联机并行操作）系统"></a>SPOOLing（外部设备联机并行操作）系统</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><ul>
<li>实质：<strong>让独享型设备变为共享设备</strong></li>
</ul>
<ol>
<li>相关概念：<ol>
<li>独占性设备：指在一段时间内只能被一个进程独占使用的设备</li>
<li>输入井，输出井：类似于缓冲区。但是缓冲区在内存，输入输出井在磁盘</li>
<li>虚拟设备：使用一类物理设备模拟另一类物理设备的技术，<strong>让独享型设备变为共享设备</strong><ol>
<li>示例<ol>
<li>内存卡模拟磁盘</li>
<li>块设备模拟字符设备</li>
<li>输入输出重定向</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>作用：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421104404005.png" alt="image-20250421104404005"></li>
</ol>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li>软件组成：<ol>
<li>预输入程序**：**预先把数据从输入设备传送到磁盘输入井</li>
<li>缓输出程序：把数据从磁盘输出井传送到输出设备</li>
<li>井管理程序：控制作进程和井之间的数据交换（事实上是I&#x2F;O重定向）<ol>
<li>目标：预输入，缓输出</li>
</ol>
</li>
</ol>
</li>
<li>数据结构：<ol>
<li>系统有一张作业表来登记进入系统的所有作业的JCB，包括作业名、作业状态等信息。</li>
<li>预输入表用来登记作业的各个输入文件的情况。</li>
<li>缓输出表用来登记作业的各个输出文件的情况。</li>
</ol>
</li>
</ol>
<h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><ul>
<li>是指从<strong>后备状态</strong>作业中选择进入运行状态</li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105520096.png" alt="image-20250421105520096"></p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421105553539.png" alt="image-20250421105553539"></p>
<h1 id="第五章-·-文件管理"><a href="#第五章-·-文件管理" class="headerlink" title="第五章 · 文件管理"></a>第五章 · 文件管理</h1><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/1.png" alt="img"></p>
<h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol>
<li>卷和块<ol>
<li>卷：卷是存储介质的物理单位，对应于一盘磁带、 一块软盘、一个光盘片、一个硬盘分区</li>
<li>块是存储介质上连续信息所组成的一个区域， 也叫做物理记录<ol>
<li>块是主存储器和辅助存储器进行信息交换的 物理单位，每次总是交换一块或整数块信息</li>
</ol>
</li>
</ol>
</li>
<li>顺序存取存储设备：<ol>
<li>顺序存取设备是严格依赖信息的物理位置次 序进行定位和读写的存储设备</li>
<li>磁带机是最常用的一种顺序存取存储设备， 它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档。现在也有在用</li>
</ol>
</li>
<li>直接存取存储设备<ol>
<li>磁盘是一种直接存取存储设备，又叫 随机存取存储设备</li>
</ol>
</li>
</ol>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ol>
<li>流式文件<ol>
<li>流式文件指文件内的数据不再组成记 录，只是由一串依次的字节组成的信 息流序列 </li>
<li>这种文件常常按长度来读取所需信息， 也可以用插入的特殊字符作为分界</li>
</ol>
</li>
<li>记录式文件<ol>
<li>记录式文件是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件<ol>
<li>逻辑记录是文件中按<strong>信息</strong>在<strong>逻辑</strong>上的<strong>独立含义</strong>所划分的信息单位</li>
<li>每个职工的工资信息是一个<strong>逻辑记录</strong>；</li>
<li>整个单位职工的工资信息便组成了该单位工资信息的<strong>记录式文件</strong></li>
</ol>
</li>
<li>逻辑记录是文件内<strong>独立的最小信息单位</strong>，记录位置代替字节位置。</li>
<li>记录是文件常用的记录组织和使用方法<ol>
<li>记录式顺序文件：文件的记录顺序生成并被顺序访问。</li>
<li>记录式索引文件：文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引文件便指向相应记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="成组与分解"><a href="#成组与分解" class="headerlink" title="成组与分解"></a>成组与分解</h3><ul>
<li>记录式文件才有成组与分解</li>
</ul>
<ol>
<li>基本概念<ol>
<li>一些定义：<ol>
<li>逻辑记录：是按信息在逻辑上的<strong>独立含义</strong>由用户所划分的<strong>单位</strong>。</li>
<li>块：是系统划分的存储介质上连续信息所组成的区域。<ol>
<li>一条逻辑记录被存放到文件存储器的存储介质上时可能占用一个或多块，或者一个物理块包含多条逻辑记录。</li>
<li>扇区也叫做物理块，或者物理记录</li>
</ol>
</li>
<li>组：若干逻辑记录的组合。</li>
<li>块因子：每块中逻辑记录的个数。比如物理块800K，卡片80K，此时的块因子数就是10。</li>
<li>对于流式文件，一个物理记录可以存放很多个连续字节。</li>
</ol>
</li>
<li>记录的成组操作在输出<strong>缓冲区</strong>内进行， 凑满一块后才将缓冲区内的信息写到 存储介质上</li>
<li>当存储介质上的一个物理记录读进输入<strong>缓冲区</strong>后，把逻辑记录从块中分离 出来的操作叫记录的分解操作<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421115348634.png" alt="image-20250421115348634"></li>
</ol>
</li>
<li>特点：<ol>
<li>优点：记录成组与分解不仅<strong>节省存储空间</strong>，还能<strong>减少输入输出操作次数</strong>，提高系统效率</li>
<li>记录成组与分解处理带来的新特征：<ol>
<li><strong>提前读</strong>：用户读请求，导致包含该逻辑记录的<strong>物理块</strong>读入输入缓冲区；这一操作可能读入了多个逻辑记录，可以更快的访问附近的记录。</li>
<li><strong>推迟写</strong>：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出。</li>
</ol>
</li>
<li>副作用(推迟写操作)：因为优先写到输出缓冲区，等到缓冲区满，才会写到磁盘，可能会造成<strong>数据不一致</strong>(写到缓冲区，但是因为<strong>停电</strong>等原因没有办法同步到磁盘)</li>
</ol>
</li>
</ol>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ol>
<li><p>文件分类：</p>
<ol>
<li>顺序文件</li>
<li>连接文件，又称串联文件</li>
<li>直接文件，又称散列文件</li>
<li>索引文件</li>
</ol>
</li>
<li><p>FCB：文件控制块</p>
<ol>
<li>在Linux系统中，FCB中的管理信息单独组成一个数据结构，称为inode</li>
</ol>
</li>
<li><p>目录项（Directory Entry）：</p>
<p>目录项是目录文件中的一个条目，用于存储文件或子目录的名称和对应的 inode 号。目录本身也是一个文件，它包含多个目录项。每个目录项包含以下信息：</p>
<ul>
<li>文件或子目录的名称</li>
<li>对应的 inode 号</li>
</ul>
</li>
<li></li>
</ol>
<h3 id="目录项，inode和数据块的关系"><a href="#目录项，inode和数据块的关系" class="headerlink" title="目录项，inode和数据块的关系"></a>目录项，inode和数据块的关系</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428113341689.png" alt="image-20250428113341689"></p>
<ol>
<li>物理结构：<ol>
<li>引导块</li>
<li>超级块：<ol>
<li>存放<strong>文件系统结构和管理信息</strong>，如记录inode表所占盘块数</li>
<li>可见<strong>超级块</strong>既有<strong>盘位示图</strong>的功能，又记录<strong>整个文件卷的控制数据</strong>。</li>
</ol>
</li>
<li>磁盘inode：<ol>
<li>有K块，K待定</li>
<li>每个文件都有<strong>各种属性</strong>，它们被记录在称为索引节点inode的结构中</li>
<li>所有inode都有<strong>相同大小</strong>，且inode表是inode结构的列表，文件系统中的每个文件在该表中都有一个inode。</li>
</ol>
</li>
<li>数据区</li>
<li>索引文件详细<ol>
<li>访问方式：<ol>
<li>索引文件在文件存储器上分两个区：<strong>索引区和数据区</strong></li>
<li>访问索引文件需两步操作<ol>
<li>第一步查找索引表</li>
<li>第二步获得记录物理地址</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>目录项与 inode 的关系<ol>
<li>目录项指向 inode：目录项中的 inode 号是关键。通过目录项中的 inode 号，文件系统可以找到对应的 inode。</li>
<li>inode 与文件名分离：inode 本身不存储文件名，文件名存储在目录项中。这种分离使得硬链接成为可能，多个目录项可以指向同一个 inode。</li>
</ol>
</li>
<li>inode 与数据块的关系<ol>
<li>inode 指向数据块：inode 中的块号字段存储了文件内容所在的磁盘块号。通过这些块号，文件系统可以找到文件的实际存储位置。</li>
<li>数据块存储文件内容：数据块中存储了文件的实际内容。</li>
</ol>
</li>
</ol>
<h3 id="索引的组织（重要）"><a href="#索引的组织（重要）" class="headerlink" title="索引的组织（重要）"></a>索引的组织（重要）</h3><ul>
<li>注意，这里索引文件的组织是指一个文件内部的数据的组织方式，而不是多个文件之间的组织<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/26.png" alt="img"></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/5.png" alt="img"></p>
<ol>
<li>一级索引：存放的是物理地址</li>
<li>两级索引：若干索引本身也是一种记录。</li>
<li>多级索引：以三级索引为例，一个地址指引12831283个地址，但是全部使用三级索引也不行，性能会比较差，所以我们往往选择使用混编的方式。</li>
<li>动态扩容：放不下就扩容</li>
<li>inode规定了15个索引项，每项4KB<ol>
<li>直接索引：前12项存放文件信息的磁盘块号</li>
<li>一次间接索引：第13项指向一个物理块</li>
<li>二次间接索引：第14项指向一个物理块</li>
<li>三次间接索引：第15项指向一个物理块</li>
<li>ext2中，每个物理块存放1KB，所以下面右图最多存放12KB+256KB+2562KB+2563KB<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/17.png" alt="img"></li>
</ol>
</li>
</ol>
<h2 id="文件系统功能及实现"><a href="#文件系统功能及实现" class="headerlink" title="文件系统功能及实现"></a>文件系统功能及实现</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li>一级目录结构：顾名思义</li>
<li>二级目录结构：<ol>
<li>第一级为主文件目录，它用于管理所有用户文件目录</li>
<li>第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250428112651146.png" alt="image-20250428112651146"></li>
</ol>
</li>
<li>树形目录结构<ol>
<li>是一种层次目录结构</li>
<li>一个硬盘分区可以组织成一颗子树<ol>
<li>每棵子树可以对应于一个逻辑盘符（Win）</li>
<li>也可以把众多子树嫁接成一颗大树（UNIX）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><ol>
<li><p>文件的定位</p>
</li>
<li><p>目录项的查找</p>
</li>
<li><p>活动文件表</p>
<ol>
<li>文件系统向应用程序提供了一组系统调用，包括建立、打开、关闭、撤销、读&#x2F;写和控制，通过这些系统调用，用户能够获得文件系统的各种服务。</li>
<li>系统会为每一个用户进程建立一张打开文件表<ol>
<li>用户使用文件之前先通过<strong>打开</strong>操作，将文件FCB拷贝到指定内存位置</li>
<li>当不在使用时，通过<strong>关闭</strong>操作切断和文件的联系，释放文件的FCB。</li>
</ol>
</li>
<li>接下来以Linux系统为例，介绍其文件系统调用的种类、功能和实现。内核将磁盘作为主要文件存储器，磁盘按扇区编号，扇区序列分成三个部分。</li>
<li>文件系统内部结构如下图所示：不是三级坐标，是经过转化后的结构</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png" alt="img"></a></p>
</li>
</ol>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>见spricoder</li>
</ul>
<h3 id="文件空间管理"><a href="#文件空间管理" class="headerlink" title="文件空间管理"></a>文件空间管理</h3><ol>
<li>位示图<ol>
<li>磁盘空间通常使用<strong>固定大小</strong>的块，<strong>可方便地用位示图管理，用若干字节构成一张位示图</strong>，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。</li>
</ol>
</li>
<li>空闲块的管理：成组连接法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/27.png" alt="img"><ol>
<li>第一行指出有多少个空闲块</li>
<li>第二行指向下一级</li>
<li>从第三行起指向空闲块</li>
</ol>
</li>
<li>管理的算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/9.png" alt="img"></li>
</ol>
<h3 id="文件的共享"><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h3><ul>
<li>文件共享指不同进程共同使用同一个文件，文件共享为不同进程完成共同任务所需。</li>
<li>节省大量外存空间，减少因文件复制而增加的I&#x2F;O操作次数。</li>
</ul>
<ol>
<li><p>静态共享</p>
<ol>
<li><p>允许一个文件同时属于多个目录，但是实际上文件仅有一处物理存储。</p>
</li>
<li><p>文件链接：从多个目录可到达文件的链接。</p>
</li>
<li><p>无论进程是否运行，文件链接关系都存在，所以称为静态共享。</p>
</li>
<li><p>链接的文件的存在形式：</p>
<ol>
<li>同一父目录下的不同文件名出现</li>
<li>不同父目录下的相同或不同文件名出现</li>
</ol>
</li>
<li><p>链接实际上是共享已存在文件的索引节点inode，完成链接的系统调用：</p>
<p>link(“&#x2F;home&#x2F;fei1&#x2F;myfile.c” <strong>,</strong> ”&#x2F;home&#x2F;fei2&#x2F;myfile.c”)；硬链接</p>
</li>
</ol>
</li>
<li><p>动态链接：</p>
<ol>
<li><p>使用同一位移指针的文件共享：先打开文件，再fork()<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/23.png" alt="img"></p>
<ol>
<li>同一用户父、子进程协同完成任务，使用同一读&#x2F;写位移，同步地对文件进行操作。</li>
<li>该位移指针宜放在相应文件的活动inode中。当用系统调用fork()建立子进程时，父进程的PCB结构被复制到子进程的PCB结构中，使两个进程的打开文件表指向同一活动的索引节点，达到共享同一位移指针的目的。</li>
</ol>
</li>
<li><p>使用不同位移指针的文件共享：先fork()，再打开文件<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/24.png" alt="img"></p>
<ol>
<li>多用户进程共享文件，每个希望独立地读、写文件，这时不能只设置一个读写位移指针，须为每个用户进程分别设置一个<strong>读、写位移指针</strong>。</li>
<li>位移指针应放在每个进程<strong>用户打开文件表</strong>的表目中。</li>
<li>这样，当一个进程读、写文件，并修改位移指针时，另一个进程的位移指针不会随之改变，从而，使两个进程能独立地访问同一文件，会新建系统打开文件表(包含f_offset)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第六章-·-并发程序设计"><a href="#第六章-·-并发程序设计" class="headerlink" title="第六章 · 并发程序设计"></a>第六章 · 并发程序设计</h1><h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><ol>
<li>顺序程序设计<ol>
<li>特点：<ol>
<li>程序执行的<strong>顺序性</strong>：程序指令执行是严格按序的，每个操作必须在下一个操作开始前结束。</li>
<li>计算环境的<strong>封闭性</strong>：程序运行时如同独占受操作系统保护的资源，资源状态只能由程序本身决定和改变，不受外界因素改变。</li>
<li>计算结果的<strong>确定性</strong>：程序执行结果与执行速度和执行时段无关</li>
<li>计算过程的<strong>可再见性</strong>：程序对相同数据集的执行轨迹是确定的</li>
</ol>
</li>
</ol>
</li>
<li>并发程序设计：<ol>
<li>无关与交往：<ol>
<li><strong>无关</strong>的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关<ol>
<li><strong>Bernstein条件</strong>：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512103948727.png" alt="image-20250512103948727"></li>
<li>这样的无关性使得进程之间互不影响</li>
</ol>
</li>
</ol>
</li>
<li><strong>交往</strong>的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果</li>
</ol>
</li>
<li>两个视角：<ol>
<li>宏观上，并发性反应了一个时间段内有几个程序都处于运行但运行尚未结束的状态。</li>
<li>微观上，任一时刻都只有一个程序在运行。</li>
</ol>
</li>
<li>特点：<ol>
<li>不再满足顺序程序设计的四个特点</li>
<li><strong>并行性</strong>：多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行，提高了计算效率</li>
<li><strong>共享性</strong>：多个进程共享软件资源</li>
<li><strong>交往性</strong>：多个进程并发执行时存在制约，增加了程序设计的难度</li>
</ol>
</li>
<li>与时间有关的错误<ol>
<li>结果不唯一</li>
<li>永久等待</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="竞争（互斥）与协作（同步）"><a href="#竞争（互斥）与协作（同步）" class="headerlink" title="竞争（互斥）与协作（同步）"></a>竞争（互斥）与协作（同步）</h3><ul>
<li>$竞争\to互斥\to等待$</li>
<li>$协作\to同步\to等待$</li>
</ul>
<ol>
<li>竞争：<ol>
<li>：并发进程之间因相互争夺<strong>独占性资源</strong>而产生的竞争制约关系</li>
<li>竞争带来的问题：<ol>
<li><strong>死锁(Deadlock)问题</strong>: 一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。</li>
<li><strong>饥饿(Starvation)问题</strong>: 一个进程由于其他进程总是优先于它而被无限期拖延，可以使用FCFS来解决饥饿问题</li>
</ol>
</li>
<li>操作系统需要保证诸进程能<strong>互斥</strong>地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li>
<li></li>
</ol>
</li>
<li>协作：<ol>
<li>概念：某些进程为完成同一任务需要<strong>分工协作</strong>，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上<strong>协调</strong>各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应<strong>阻塞自己</strong>，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行</li>
<li>进程互斥关系是一种特殊的<strong>进程同步</strong>关系，即<strong>逐次使用互斥</strong>共享资源，是对进程使用资源次序上的一种协调</li>
</ol>
</li>
</ol>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ol>
<li>临界区：是指包含对共享资源进行访问的代码段。</li>
<li>临界区管理的三个要求(Dijkstra, 1965)<ol>
<li><strong>一次至多一个</strong>进程能够进入临界区内执行：在某些特殊情况下可能会突破</li>
<li>如果已有进程在临界区，其他试图进入的进程应<strong>等待</strong></li>
<li>进入临界区内的进程应在<strong>有限时间</strong>内退出，以便让等待进程中的一个进入</li>
</ol>
</li>
<li>进程互斥的软件实现方法：<ol>
<li><p>单标志法</p>
</li>
<li><p>双标志先检查法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112253396.png" alt="image-20250512112253396"></p>
<ol>
<li>可能两个都进</li>
</ol>
</li>
<li><p>双标志后检查法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112306550.png" alt="image-20250512112306550"></p>
<ol>
<li>可能两个都不进</li>
</ol>
</li>
<li><p>Peterson算法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512112343027.png" alt="image-20250512112343027"></p>
<ul>
<li><p>原理：结合了双标志法和一个额外的“进入”标志<code>turn</code>。每个进程在进入临界区前，先设置自己的标志为<code>true</code>，然后检查对方的标志和<code>turn</code>标志。如果对方标志为<code>true</code>且<code>turn</code>指向对方，则等待。</p>
</li>
<li><p>优点：完全避免了死锁和忙等问题，且满足互斥条件。</p>
</li>
<li><p>缺点：实现较为复杂，且仅适用于两个进程的情况。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250512113527360.png" alt="image-20250512113527360"></p>
<ol>
<li><p>信号量：</p>
<ol>
<li>是一个数据结构，由两部分组成：<ol>
<li>信号量的值：为正数是代表空闲资源数量，为负数代表等待进程数量</li>
<li>信号量队列指针：指向等待队列</li>
</ol>
</li>
</ol>
</li>
<li><p>PV操作：</p>
<ol>
<li><p>P(s)：</p>
<ol>
<li>将信号量s减去1，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态</li>
<li>负数的绝对值就是等待的进程的个数</li>
</ol>
</li>
<li><p>V(s)：将信号量s加1，若结果不大于0，则释放(唤醒)一个等待信号量s的进程，使其转换为就绪态</p>
</li>
<li><p><strong>原语</strong>：CPU处于内核态，在关中断环境下执行的一段<strong>指令序列</strong></p>
</li>
<li><p>强调：对于信号量，只允许使用P和V原语操作访问信号量，不能直接对信号量的整型值做读写操作，也不能直接对信号量的队列做任何其他操作</p>
</li>
<li><p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数据结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">semaphore</span> &#123;</span><br><span class="line">   <span class="type">int</span> value;           <span class="comment">/*信号量值，正值表示资源可复用次数，0值表示无资源且无进程等待，负数的绝对*/</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">pcb</span>* list;    <span class="comment">/*信号量队列指针，等待队列*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// P操作原语</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(semahore s)</span> </span>&#123;</span><br><span class="line">   s.value--;           <span class="comment">/* 信号量值减1 */</span></span><br><span class="line">   <span class="keyword">if</span>(s.value &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">sleep</span>(s.list);</span><br><span class="line">   <span class="comment">/* 若信号量值小于0,执行P操作的进程调用sleep(s.list)阻塞自己，被置成等待信号量s状态并移人s信号量队列,转向进程调度程序*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V操作原语</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span> <span class="params">( semaphore s)</span> </span>&#123;</span><br><span class="line">   s.value++;           <span class="comment">/* 信号量值加 1*/</span></span><br><span class="line">   <span class="keyword">if</span>(s.value &lt;=<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">wakeup</span>(s.list) ;</span><br><span class="line">   <span class="comment">/*若信号量值小于等于0,则调用wakeup(s. list) 从信号量s队列中释放一-个等待信号量s的进程并转换成就绪态,进程则继续执行*/</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PV操作解决进程互斥问题框架</span></span><br><span class="line">semaphore s;</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line">cobegin</span><br><span class="line">   process Pi &#123;</span><br><span class="line">      ……</span><br><span class="line">      <span class="built_in">P</span>(s);</span><br><span class="line">      临界区;</span><br><span class="line">      <span class="built_in">V</span>(s);</span><br><span class="line">      ……</span><br><span class="line">   &#125;</span><br><span class="line">coend;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>信号量与状态：</p>
<ol>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/41.png" alt="img"></li>
<li><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/42.png" alt="img"></li>
</ol>
</li>
</ol>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><ol>
<li><p>问题：</p>
<ol>
<li>五个哲学家，五把叉子，必须拿到左右两把叉子才能吃上饭。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519105828495.png" alt="image-20250519105828495"></li>
<li>即使使用了PV操作，还是可能死锁。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519110524795.png" alt="image-20250519110524795"></li>
</ol>
</li>
<li><p>解决方案</p>
<ol>
<li><p>霍尔方案：控制人数，至多有四个人可以拿叉子<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519111008420.png" alt="image-20250519111008420"></p>
<ol>
<li>这里声明了两个信号量。fork表示叉子，每个叉子值为1，表示互斥关系。room表示可以同时拿叉子的人数。</li>
<li>每次都是先控制人数，然后再去叉子，这样就不会死锁</li>
</ol>
</li>
<li><p>编号方案：奇数号先取左手边的叉子，偶数号先取右手边的叉子</p>
</li>
</ol>
</li>
</ol>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ol>
<li>问题描述：<ol>
<li>互斥访问：缓冲区同一时间只能被一个生产者或消费者访问。</li>
<li>同步：生产者不能在缓冲区满时继续生产，消费者不能在缓冲区空时尝试消费。</li>
</ol>
</li>
<li>解决方案：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113033843.png" alt="image-20250519113033843"><ol>
<li>设计两个信号量sput和sget，分别表示可以生产的量和可以消耗的量。</li>
<li>注意，每段代码的P操作和V操作不是同一个信号量</li>
<li>设计两个信号量S1,S2，若有多个消费者和生产者，他们要互斥的访问缓冲区.</li>
</ol>
</li>
</ol>
<h3 id="苹果-桔子问题"><a href="#苹果-桔子问题" class="headerlink" title="苹果-桔子问题"></a>苹果-桔子问题</h3><ol>
<li><p>问题描述：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113706958.png" alt="image-20250519113706958"></p>
</li>
<li><p>解决方案：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519113726494.png" alt="image-20250519113726494"></p>
</li>
</ol>
<h3 id="前驱关系"><a href="#前驱关系" class="headerlink" title="前驱关系"></a>前驱关系</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115725366.png" alt="image-20250519115725366"></p>
<h3 id="读写问题"><a href="#读写问题" class="headerlink" title="读写问题"></a>读写问题</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115455054.png" alt="image-20250519115455054"></p>
<h3 id="睡眠的理发师"><a href="#睡眠的理发师" class="headerlink" title="睡眠的理发师"></a>睡眠的理发师</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250519115517425.png" alt="image-20250519115517425"></p>
<ul>
<li>这里的mutex是必要的。访问共享的变量时，需要互斥！</li>
</ul>
<h3 id="农夫猎人问题"><a href="#农夫猎人问题" class="headerlink" title="农夫猎人问题"></a>农夫猎人问题</h3><ul>
<li>和苹果-桔子问题本质上是一样的</li>
</ul>
<h3 id="银行服务问题"><a href="#银行服务问题" class="headerlink" title="银行服务问题"></a>银行服务问题</h3><ul>
<li>这个例子对理解PV操作有帮助</li>
<li>信号量就像是一个通讯方式（实际上就是IPC对象），PV就是等待信号和发送信号</li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522104654836.png" alt="image-20250522104654836"></p>
<h3 id="缓冲区问题"><a href="#缓冲区问题" class="headerlink" title="缓冲区问题"></a>缓冲区问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/60.png" alt="img"></p>
<h3 id="售票问题"><a href="#售票问题" class="headerlink" title="售票问题"></a>售票问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/61.png" alt="img"></p>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/62.png" alt="img"></p>
<h3 id="独木桥问题"><a href="#独木桥问题" class="headerlink" title="独木桥问题 ***"></a>独木桥问题 ***</h3><ol>
<li><p>问题一：东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。请用信号量和PV操作写出过独木桥问题的同步算法。<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/63.png" alt="img"></p>
<ol>
<li><strong>确保同一时间只有一个方向的行人过桥</strong>：<ul>
<li>通过 <code>wait</code> 信号量，确保同一时间只有一个方向的行人可以过桥。如果一个方向的行人已经占用桥，另一个方向的行人必须等待。</li>
</ul>
</li>
</ol>
</li>
<li><p>问题二：在独木桥问题1中，限制桥面上最多可以有k辆汽车通过。试用信号量和P，V操作写出过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/64.png" alt="img"></p>
</li>
<li><p>问题三：在独木桥问题1中，以3辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。试用信号量和P，V操作写出汽车过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/65.png" alt="img"></p>
</li>
<li><p>问题四：在独木桥问题1中，要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。试用信号量和P，V操作写出过独木桥问题的同步算法<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/66.png" alt="img"></p>
</li>
</ol>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>概念：它是一种封装了共享数据和操作这些数据的过程（或函数）的模块。</p>
</li>
<li><p><strong>功能</strong>：管程不仅提供互斥功能，还提供条件变量（condition variables）用于线程或进程之间的同步。它通常包含：</p>
<ul>
<li><strong>共享数据</strong>：封装的共享数据，只能通过管程提供的过程访问。</li>
<li><strong>过程（或函数）</strong>：操作共享数据的过程。</li>
<li><strong>互斥锁</strong>：内部的互斥锁，确保一次只有一个线程或进程可以执行管程中的操作。</li>
<li><strong>条件变量</strong>：用于线程或进程之间的同步，提供 <code>wait</code> 和 <code>signal</code>（或 <code>broadcast</code>）操作。</li>
</ul>
</li>
<li><p><strong>为什么要引入管程</strong>？</p>
<ul>
<li><p>把分散在各进程中的临界区集中起来进行管理 </p>
</li>
<li><p>防止进程有意或无意的违法同步操作 </p>
</li>
<li><p>便于用高级语言来书写程序</p>
</li>
</ul>
</li>
<li><p>管程和互斥锁有什么区别？</p>
<ol>
<li>互斥锁：是一种低级同步原语，用于确保一次只有一个线程或进程可以访问共享资源。</li>
<li>管程：是一种高级同步机制，封装了共享数据和操作这些数据的过程（或函数），并提供了一种安全的方式来访问和修改共享数据。</li>
</ol>
</li>
<li><p>形式：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250522114935161.png" alt="image-20250522114935161"></p>
</li>
<li><p>条件变量</p>
<ol>
<li>当资源不足导致进程阻塞时，同时开放冠层，让挡在管程外的一个进程进入管程。</li>
<li>条件变量：是出现在管程内的一种数据结构，且只有在管程中才能被访问，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它，用于阻塞进程的信号量。<ol>
<li>wait()：当一个管程过程发现无法继续时(如发现没有可用资源时)，它在某些条件变量上执行wait，这个动作引起调用进程阻塞，直到另一个进程在该条件变量上执行signal()</li>
<li>signal()<ol>
<li>如果存在其他进程由于对条件变量执行wait()而被阻塞，便释放之</li>
<li>如果没有进程在等待，那么信号不被保存，并不是立即退出管程等待队列，而是进入next信号量，以保证多个进程都可以正常退出。</li>
</ol>
</li>
<li>条件变量仅仅维护阻塞队列的作用，如果没有等待时发生signal()操作，相当于空操作。</li>
</ol>
</li>
<li>使用signal释放等待进程时，可能出现两个进程同时停留在管程内。解决方法：<ol>
<li><strong>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件</strong></li>
<li>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</li>
</ol>
</li>
<li>霍尔(Hoare, 1974)采用第一种办法</li>
<li>汉森(Hansen)选择两者的折衷，规定管程中的过程所执行的signal操作是过程体的最后一个操作</li>
</ol>
</li>
</ol>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li><p>Hoare管程的enter()和leave()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enter</span><span class="params">(InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">P</span>(IM.mutex);         <span class="comment">//判有否发出过signal的进程?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leave</span><span class="params">(InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (IM.next_count&gt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">V</span>(IM.next);       <span class="comment">//有就释放一个发出过signal的进程</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">V</span>(IM.mutex);      <span class="comment">//否则开放管程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hoare管程的wait()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_sem: semaphore;       <span class="comment">// 与资源相关的信号量</span></span><br><span class="line">x_count: integer;       <span class="comment">// 在x_sem上等待的进程数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore &amp;x_sem,<span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">      x_count,InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   x_count++;           <span class="comment">//等资源进程个数加1，x_count初始化为0</span></span><br><span class="line">   <span class="keyword">if</span> (IM.next_count&gt;<span class="number">0</span>) <span class="comment">//判断是否有发出过signal的进程</span></span><br><span class="line">      <span class="built_in">V</span>(IM.next);       <span class="comment">//有就释放一个</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">V</span>(IM.mutex);      <span class="comment">//否则开放管程</span></span><br><span class="line">   <span class="built_in">P</span>(x_sem);            <span class="comment">//等资源进程阻塞自己，x_sem初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hoare管程的signal()操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore &amp;x_sem,<span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">      &amp;x_count,InterfaceModule &amp;IM)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x_count&gt;<span class="number">0</span>) &#123;      <span class="comment">//判断是否有等待资源的进程</span></span><br><span class="line">      IM.next_count++;  <span class="comment">//发出signal进程个数加1</span></span><br><span class="line">      <span class="built_in">V</span>(x_sem);         <span class="comment">//释放一个等资源的进程</span></span><br><span class="line">      <span class="built_in">P</span>(IM.next);       <span class="comment">//发出signal进程阻塞自己**</span></span><br><span class="line">      x_count--;        <span class="comment">//发出signal进程个数减1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 霍尔管程执行signal的进程等待，直到被释放进程退出管程或等待另一个条件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115334937.png" alt="image-20250526115334937"></p>
<h4 id="读者写者"><a href="#读者写者" class="headerlink" title="读者写者"></a>读者写者</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115358852.png" alt="image-20250526115358852"></p>
<h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115425074.png" alt="image-20250526115425074"></p>
<h4 id="苹果桔子"><a href="#苹果桔子" class="headerlink" title="苹果桔子"></a>苹果桔子</h4><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526115444182.png" alt="image-20250526115444182"></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol>
<li>必要条件：<ol>
<li><strong>互斥条件</strong>: 进程应互斥使用资源，任一时刻一个资源仅为一个进程独占</li>
<li><strong>占有和等待条件</strong>: 一个进程请求资源得不到满足而等待时，不释放已占有的资源</li>
<li><strong>不剥夺条件</strong>: 任一进程不能从另一进程那里抢夺资源</li>
<li><strong>循环等待条件</strong>: 存在一个循环等待链，每一个进程分别等待它前一个进程所持有的资源<ul>
<li>前三个是死锁存在的必要条件，但不是充分条件，第四个条件是前三个条件同时存在时所产生的结果。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h3><ol>
<li>死锁的避免<ol>
<li>当不能防止死锁的产生时，如果能掌握并发进程中与每个进程有关的<strong>资源申请情况</strong>，仍然可以避免死锁的发生</li>
<li>只需在为申请者分配资源前先测试系统状态，若把资源分配给申请者会产生死锁的话，则拒绝分配，否则接收申请，为它分配资源</li>
</ol>
</li>
</ol>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>总结：牢记两个关键点：<ul>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171023399.png" alt="image-20250526171023399"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526171043589.png" alt="image-20250526171043589"></li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>算法背景和目的</strong></p>
<p>银行家算法是一种预防死锁的资源分配算法，其灵感来源于银行家的贷款原则。在计算机系统中，操作系统就像银行家，管理着有限的资源（如内存、磁盘空间等）。进程就像要求贷款的客户，需要向操作系统申请资源。银行家算法的目标是确保系统在分配资源的过程中不会出现死锁情况，即避免多个进程因相互等待资源而无法继续执行。</p>
</li>
<li><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>银行家算法使用以下数据结构来管理资源和进程：</p>
<ol>
<li><strong>资源总数向量（Resource）</strong>：<ul>
<li>表示系统中每类资源的总数。</li>
<li>例如，Resource &#x3D; (R1, R2, …, Rm)，其中R1表示第一类资源的总数，R2表示第二类资源的总数，依此类推。</li>
</ul>
</li>
<li><strong>可用资源向量（Available）</strong>：<ul>
<li>表示系统中每类资源当前可用的数量。</li>
<li>例如，Available &#x3D; (V1, V2, …, Vm)，其中V1表示第一类资源当前可用的数量，V2表示第二类资源当前可用的数量。</li>
</ul>
</li>
<li><strong>最大需求矩阵（Claim）</strong>：<ul>
<li>Claim[i, j]表示进程Pi对Rj类资源的最大需求量。</li>
<li>例如，Claim[1, 2] &#x3D; 3表示进程P1对第二类资源的最大需求量是3个。</li>
</ul>
</li>
<li><strong>分配矩阵（Allocation）</strong>：<ul>
<li>Allocation[i, j]表示进程Pi已经分配到的Rj类资源数量。</li>
<li>初始值为0，随着进程申请资源而更新。</li>
</ul>
</li>
<li><strong>需求矩阵（Need）</strong>：<ul>
<li>Need[i, j]表示进程Pi还需要的Rj类资源数量。</li>
<li>计算公式为：Need[i, j] &#x3D; Claim[i, j] - Allocation[i, j]。</li>
</ul>
</li>
<li><strong>请求矩阵（Request）</strong>：<ul>
<li>Request[i, j]表示进程Pi当前申请的Rj类资源数量。</li>
</ul>
</li>
</ol>
<h3 id="3-算法原理"><a href="#3-算法原理" class="headerlink" title="3. 算法原理"></a>3. 算法原理</h3><p>银行家算法通过以下步骤确保系统不会进入死锁状态：</p>
<h4 id="3-1-进程启动时的检查"><a href="#3-1-进程启动时的检查" class="headerlink" title="3.1 进程启动时的检查"></a>3.1 进程启动时的检查</h4><ul>
<li><p>当系统要启动一个新进程时，需要检查是否满足以下不等式：</p>
<p><em>R**i</em>≥Claim[(<em>n</em>+1),<em>i</em>]+<em>k</em>&#x3D;1∑<em>n</em>Claim[<em>k</em>,<em>i</em>]</p>
<p>其中，Ri表示第i类资源的总数，Claim[(n+1),i]表示新进程对第i类资源的最大需求量，Claim[k,i]表示已存在的进程对第i类资源的最大需求量。</p>
</li>
<li><p>如果不满足上述条件，系统拒绝启动该进程，以防止资源不足导致死锁。</p>
</li>
</ul>
<h4 id="3-2-资源分配过程"><a href="#3-2-资源分配过程" class="headerlink" title="3.2 资源分配过程"></a>3.2 资源分配过程</h4><ol>
<li><strong>试探性分配</strong>：<ul>
<li>当系统收到进程的资源请求后，先进行试探性分配。即假设系统满足了进程的请求，更新资源分配情况。</li>
</ul>
</li>
<li><strong>安全性检查</strong>：<ul>
<li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较。</li>
<li>在进程集合中找到剩余资源能满足最大需求量的进程。这样可以保证这个进程运行完毕并归还全部资源。</li>
</ul>
</li>
<li><strong>资源回收</strong>：<ul>
<li>把这个进程从集合中去掉，系统的剩余资源会增加。</li>
<li>然后反复执行上述步骤，逐步减少进程集合中的进程数量。</li>
</ul>
</li>
</ol>
<h4 id="3-3-安全性判断"><a href="#3-3-安全性判断" class="headerlink" title="3.3 安全性判断"></a>3.3 安全性判断</h4><ul>
<li>如果最后进程集合为空，说明本次申请可行，系统处于安全状态，可以实施本次分配。</li>
<li>如果进程集合不为空，说明有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。</li>
</ul>
<h3 id="4-系统安全性定义"><a href="#4-系统安全性定义" class="headerlink" title="4. 系统安全性定义"></a>4. 系统安全性定义</h3><p>在时刻T0，系统是安全的，当且仅当存在一个进程序列P1，…，Pn，对进程Pk满足公式：</p>
<p>Need[<em>k</em>,<em>i</em>]≤Available[<em>i</em>]+<em>j</em>&#x3D;1∑<em>k</em>−1Allocation[<em>j</em>,<em>i</em>]</p>
<p>这个公式的意思是，对于每个进程Pk，它还需要的资源数量（Need[k,i]）不能超过当前可用资源数量（Available[i]）加上前面已经分配资源的进程（j &#x3D; 1到k - 1）所分配的资源数量总和。这说明系统能够按照这个序列依次满足进程的最大资源需求，从而保证系统不会出现死锁。</p>
<h3 id="5-示例说明"><a href="#5-示例说明" class="headerlink" title="5. 示例说明"></a>5. 示例说明</h3><p>假设系统有三个进程P, Q, R，系统只有一类资源共10个，目前分配情况如下：</p>
<p>表格</p>
<p>复制</p>
<table>
<thead>
<tr>
<th align="left">进程</th>
<th align="left">最大需求（Claim）</th>
<th align="left">已分配（Allocation）</th>
<th align="left">需求（Need）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">P</td>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">Q</td>
<td align="left">4</td>
<td align="left">1</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">3</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
</tbody></table>
<p>当前可用资源（Available）为：5</p>
<ol>
<li><strong>安全性检查</strong>：<ul>
<li>检查是否存在一个安全序列。假设序列是P, Q, R。</li>
<li>对于P：Need[P] &#x3D; 3，Available + Allocation[Q] + Allocation[R] &#x3D; 5 + 1 + 2 &#x3D; 8，满足Need[P] ≤ 8。</li>
<li>P运行完毕后，释放资源2，Available &#x3D; 7。</li>
<li>对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 7 + 2 &#x3D; 9，满足Need[Q] ≤ 9。</li>
<li>Q运行完毕后，释放资源1，Available &#x3D; 8。</li>
<li>对于R：Need[R] &#x3D; 1，Available &#x3D; 8，满足Need[R] ≤ 8。</li>
<li>R运行完毕后，释放资源2，Available &#x3D; 10。</li>
<li>进程集合为空，系统处于安全状态。</li>
</ul>
</li>
<li><strong>资源请求</strong>：<ul>
<li>假设进程P请求2个资源。</li>
<li>试探性分配后，Available &#x3D; 3，Allocation[P] &#x3D; 4，Need[P] &#x3D; 1。</li>
<li>检查安全性：新的序列可能是Q, R, P。<ul>
<li>对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 3 + 2 &#x3D; 5，满足Need[Q] ≤ 5。</li>
<li>Q运行完毕后，释放资源1，Available &#x3D; 4。</li>
<li>对于R：Need[R] &#x3D; 1，Available &#x3D; 4，满足Need[R] ≤ 4。</li>
<li>R运行完毕后，释放资源2，Available &#x3D; 6。</li>
<li>对于P：Need[P] &#x3D; 1，Available &#x3D; 6，满足Need[P] ≤ 6。</li>
<li>P运行完毕后，释放资源4，Available &#x3D; 10。</li>
<li>进程集合为空，系统处于安全状态。</li>
</ul>
</li>
<li>因此，可以真正分配资源给P。</li>
</ul>
</li>
</ol>
<p>通过上述步骤，银行家算法能够有效地预防死锁的发生，确保系统资源的安全分配。</p>
</li>
</ol>
<h3 id="10-8-5-银行家算法的程序及实现"><a href="#10-8-5-银行家算法的程序及实现" class="headerlink" title="10.8.5. 银行家算法的程序及实现"></a>10.8.5. 银行家算法的程序及实现</h3><p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/112.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/112.png" alt="img"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">state</span> &#123;<span class="comment">//全局数据结构</span></span><br><span class="line">   <span class="type">int</span> resource[m];</span><br><span class="line">   <span class="type">int</span> available[m];</span><br><span class="line">   <span class="type">int</span> claim[n][m];</span><br><span class="line">   <span class="type">int</span> allocation[n][m];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resource_allocation</span><span class="params">( )</span> </span>&#123; <span class="comment">//资源分配算法</span></span><br><span class="line">   <span class="keyword">if</span>(allocation[i,*]+request[*]&gt;claim[i,*])</span><br><span class="line">      &#123;error&#125;; <span class="comment">//申请量超过最大需求值</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(request[*]&gt;available[*])</span><br><span class="line">         &#123;suspend process.&#125;;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//尝试分配，define newstate by:</span></span><br><span class="line">         allocation[i,*]=allocation[i,*]+request[*];</span><br><span class="line">         available[*]=available[*]-request[*];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">safe</span>(newstate))</span><br><span class="line">      &#123;carry out allocation&#125;;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      &#123;restore original state&#125;;</span><br><span class="line">      &#123;suspend process&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">safe</span><span class="params">(state s)</span> </span>&#123; <span class="comment">//安全性测试算法</span></span><br><span class="line">   <span class="type">int</span> currentavail[m];</span><br><span class="line">   set &lt;process&gt; rest;</span><br><span class="line">   currentavail[*]=available[*];</span><br><span class="line">   rest=&#123;all process&#125;;</span><br><span class="line">   possible=<span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">while</span>(possible)&#123; <span class="comment">//rest中找一个Pk，满足以下条件</span></span><br><span class="line">      claim[k,*]-allocation[k,*]&lt;=currentavail[*]</span><br><span class="line">      <span class="keyword">if</span>(found)&#123;</span><br><span class="line">         currentavail[*]=currentavail[*]+allocation[k,*];</span><br><span class="line">         rest=rest–&#123;Pk&#125;;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         possible=<span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(rest=null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure>

<h3 id="10-8-6-银行家算法例子"><a href="#10-8-6-银行家算法例子" class="headerlink" title="10.8.6. 银行家算法例子"></a>10.8.6. 银行家算法例子</h3><h4 id="10-8-6-1-银行家算法例1"><a href="#10-8-6-1-银行家算法例1" class="headerlink" title="10.8.6.1. 银行家算法例1"></a>10.8.6.1. 银行家算法例1</h4><table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/25.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/25.png" alt="img"></a></th>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/26.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>P或者R再申请资源时，不能分配，因为现在只剩下2个资源，不能满足它们的最大需求</p>
<h4 id="10-8-6-2-实例说明系统所处的安全或不安全状态-1"><a href="#10-8-6-2-实例说明系统所处的安全或不安全状态-1" class="headerlink" title="10.8.6.2. 实例说明系统所处的安全或不安全状态(1)"></a>10.8.6.2. 实例说明系统所处的安全或不安全状态(1)</h4><ol>
<li>如果系统中共有五个进程和A、B、C三类资源</li>
<li>A类资源共有10个,B类资源共有5个,C类资源共有7个</li>
<li>在时刻T0T0,系统目前资源分配情况如下：</li>
</ol>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/86.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/86.png" alt="img"></a></th>
<th><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/87.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/87.png" alt="img"></a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>可以断言目前系统处于安全状态，因为序列{P1,P3,P4,P2,P0}{P1,P3,P4,P2,P0}能满足安全性条件</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/88.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/88.png" alt="img"></a></p>
<ol>
<li><p>假设</p>
<p>P1P1</p>
<p>又请求1个A类资源和2个c类资源，得到新的状态如下图所示：</p>
<ol>
<li>Request1(1,0,2)≤Need(1,2,2)Request1(1,0,2)≤Need(1,2,2)</li>
<li>Request1(1,0,2)≤Available(3,3,2)Request1(1,0,2)≤Available(3,3,2)</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/89.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/89.png" alt="img"></a></p>
<ol>
<li>判定新状态是否安全?可执行安全性测试算法，找到一个进程序列{P1,P3,P4,P0,P2}{P1,P3,P4,P0,P2}能满足安全性条件，所以可正式把资源分配给进程P1；</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/90.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/90.png" alt="img"></a></p>
<ol>
<li><p>假设</p>
<p>P4P4</p>
<p>发起资源请求，按照银行家算法检查，资源不足不予以分配</p>
<ol>
<li>Request4(3,3,0)≤Need(4,3,1)Request4(3,3,0)≤Need(4,3,1)</li>
<li>Request4(3,3,0)&gt;Available(2,3,0)Request4(3,3,0)&gt;Available(2,3,0)</li>
</ol>
</li>
<li><p>假设</p>
<p>P0P0</p>
<p>发起资源请求，按照银行加算法检查，得到中间结果如下</p>
<ol>
<li>Request0(0,2,0)≤Need(7,3,1)Request0(0,2,0)≤Need(7,3,1)</li>
<li>Request0(0,2,0)≤Available(2,3,0)Request0(0,2,0)≤Available(2,3,0)</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/91.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/91.png" alt="img"></a></p>
<h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ol>
<li><p>解决死锁问题的另一条途径是<strong>死锁检测方法</strong></p>
</li>
<li><p>这种方法对资源的分配不加限制，但系统定时运行一个”<strong>死锁检测</strong>“程序，判断系统内是否已出现死锁，若检测到死锁则设法加以解除</p>
</li>
<li><p>检测的一种方法：可设置两张表格来记录进程使用资源的情况</p>
<ol>
<li>等待资源表记录每个被<strong>阻塞进程等待</strong>的资源</li>
<li>占用资源表记录每个进程<strong>占有</strong>的资源</li>
</ol>
</li>
<li><p>进程申请资源时，先查该资源</p>
<p>是否为其它进程所占用</p>
<ol>
<li>若资源空闲，则把该资源分配给申请者且登入占用资源表</li>
<li>否则，则登入进程等待资源表</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/27.png" alt="img"></a></p>
<ol>
<li>死锁检测程序定时检测这两张表，若有进程Pi等待资源rk，且rk被进程Pj占用，则说PiPi和PjPj具有”等待占用关系”，记为W(Pi,Pj)</li>
<li>死锁检测程序反复检测这两张表，可以列出所有的”<strong>等待占用</strong>关系”</li>
<li>如果出现循环等待占用时，显然，系统中存在一组循环等待资源的进程：Pi，Pj，Pk，…，Pm，Pn也就是说出现了死锁</li>
</ol>
<h4 id="资源分配图与死锁定理"><a href="#资源分配图与死锁定理" class="headerlink" title="资源分配图与死锁定理"></a>资源分配图与死锁定理</h4><ol>
<li>资源分配图的图例<ol>
<li>每个资源用一个<strong>方框</strong>表示</li>
<li>方框中的<strong>黑圆点</strong>表示此资源类中的各个资源</li>
<li>每个进程用一个<strong>圆圈</strong>表示</li>
<li><strong>有向边</strong>表示进程申请资源和资源被分配情况</li>
</ol>
</li>
<li>约定Pi→Rj为请求边，表示进程Pi申请资源类Rj中的一个资源得不到满足而处于等待Rj类资源的状态，该有向边从进程开始指到方框的边缘，表示进程Pi申请Rj类中的一个资源。</li>
<li>Rj→Pi为分配边，表示Rj类中的一个资源已被进程Pi占用，由于已把一个具体的资源分给了进程Pi，故该有向边从方框内的某个黑圆点出发指向进程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/92.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/92.png" alt="img"></a></p>
<ol>
<li><p>图3.6中存在环路，经过分析是存在死锁的</p>
</li>
<li><p>图3.7中存在环路，但是经过分析是不存在死锁的，因为R1和R2资源都不只一个，P2和P4进程归还后是可以避免的。</p>
</li>
<li><p>简化：</p>
<ol>
<li><p><strong>简化步骤</strong>：</p>
<ol>
<li><strong>寻找可完成的进程</strong>：找到一个进程 <em>P**i</em>，它请求的资源都能得到满足。即 <em>P**i</em> 所需的资源要么是未分配的，要么是已分配给其他进程但这些进程可以释放这些资源。</li>
<li><strong>释放资源</strong>：假设 <em>P**i</em> 获得了所需资源并运行完成，它会释放所有分配给它的资源。这相当于从图中移除所有与 <em>P**i</em> 相关的申请边和分配边。</li>
<li><strong>重复步骤</strong>：重复上述步骤，寻找下一个可完成的进程，直到所有边都被消去。</li>
</ol>
<p>如果最终所有边都被消去，资源分配图是可完全简化的，系统不存在死锁。</p>
</li>
</ol>
</li>
</ol>
<h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是<strong>不可完全简化</strong>的。该充分条件称为死锁定理</p>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/113.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/113.png" alt="img"></a></p>
<h4 id="死锁检测的数据结构"><a href="#死锁检测的数据结构" class="headerlink" title="死锁检测的数据结构"></a>死锁检测的数据结构</h4><ol>
<li>把两张表格中记录的进程使用和等待资源的情况用一个矩阵A来表示</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/28.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec6/28.png" alt="img"></a></p>
<h4 id="死锁检测程序可用Warshall的传递闭包算法"><a href="#死锁检测程序可用Warshall的传递闭包算法" class="headerlink" title="死锁检测程序可用Warshall的传递闭包算法"></a>死锁检测程序可用Warshall的传递闭包算法</h4><ol>
<li>检测是否有死锁发生，即对矩阵A构造传递闭包A∗[bij]</li>
<li>A∗[bij]中的每个bij是对A[bij]执行如下算法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for k:=1 to n do</span><br><span class="line">   for i:=1 to n do </span><br><span class="line">      for j:=1 to do</span><br><span class="line">         bij:= bij 并 (bik 并 bkj)</span><br><span class="line">         </span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>在计算完传递闭包矩阵 <em>W</em>∗ 后，检查对角线上的元素 <em>W</em>∗[<em>i</em>][<em>i</em>]：</p>
<ul>
<li>如果存在某个 <em>i</em> 使得 <em>W</em>∗[<em>i</em>][<em>i</em>]&#x3D;1，则表示存在从节点 <em>i</em> 到自身的路径，即存在循环等待，系统可能处于死锁状态。</li>
</ul>
<h3 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h3><ol>
<li>死锁被检测到后可以通过各种方法来解除系统死锁以恢复到可运行状态，方法有资源剥夺法、进程回退法、进程撤销法和系统重启法。<ol>
<li>资源剥夺法：剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。可仿照撤销陷于死锁的进程那样来选择剥夺资源的进程。</li>
<li>进程回退法：根据系统保存的检查点让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检査点、回退及重启机制。</li>
<li>进程撤销法：<ol>
<li>撤销陷于死锁的<strong>所有进程</strong>，解除死锁，继续运行。</li>
<li>逐个撤销<strong>陷于死锁</strong>的进程，回收其资源并<strong>重新分派</strong>，直至死锁解除。但是究竟先撤销哪个死锁进程呢？可选择符合下面条件之一的进程先撤销： PU消耗时间最少者、产生的输出量最少者、预计剩余执行时间最长者、分得的资源数量最少者或优先级最低者。</li>
</ol>
</li>
<li>系统重启法：结束所有进程的执行并<strong>重新启动</strong>操作系统。这种方法很简单，但先前的工作全部作废，损失很大。</li>
</ol>
</li>
<li>检测死锁是否出现和发现死锁后实现恢复的代价大于防止和避免死锁花费的代价，但是这样的代价是值得的，因为死锁不是经常出现的。<ol>
<li>检测策略的代价依赖于<strong>死锁出现的频率</strong></li>
<li>恢复的代价是指处理器<strong>时间的损失</strong>。</li>
</ol>
</li>
</ol>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="第一章-·-导论"><a href="#第一章-·-导论" class="headerlink" title="第一章 · 导论"></a>第一章 · 导论</h2><ol>
<li><blockquote>
<p>____C____操作系统允许在一台主机上同时联接多台终端，多个用户可以通过各自的终端同时交互使用计算机。</p>
<p>A. 网络    B. 分布式    C. 分时    D. 实时</p>
</blockquote>
</li>
<li><p>分时操作系统、实时操作系统的特点和应用领域</p>
<ol>
<li><p>分时操作系统（Time-Sharing Operating System）</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>多用户交互</strong>：允许多个用户同时通过终端与计算机交互。</li>
<li>时间片轮转：采用时间片轮转（Round Robin）调度算法，将CPU时间分配给多个用户，每个用户感觉像是独占计算机。</li>
<li>快速响应：系统对用户输入的响应时间较短，通常在几秒内。</li>
<li>资源共享：系统中的资源（如CPU、内存、I&#x2F;O设备）被多个用户共享。</li>
</ul>
</li>
<li>应用领域：<ul>
<li>多用户环境：如大学计算机实验室、企业办公环境等。</li>
<li>交互式应用：如文本编辑、电子邮件、在线数据库查询等。</li>
<li>云计算服务：云平台提供多用户访问和资源共享，类似于分时系统。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>实时操作系统（Real-Time Operating System, RTOS）</li>
</ol>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>严格的时间约束</strong>：系统必须在严格的时间限制内完成任务，否则可能导致严重后果。</li>
<li>高可靠性：系统必须高度可靠，能够处理突发的事件和任务。</li>
<li>优先级调度：采用优先级调度算法，确保高优先级任务优先执行。</li>
<li>快速响应：系统对事件的响应时间非常短，通常在毫秒甚至微秒级别。</li>
</ul>
</li>
<li>应用领域：<ul>
<li><strong>嵌入式系统</strong>：如汽车电子控制系统、工业自动化设备、医疗设备等。</li>
<li><strong>航空航天</strong>：如飞行控制系统、卫星通信系统等。</li>
<li>军事应用：如雷达系统、导弹制导系统等。</li>
<li><strong>金融服务</strong>：如高频交易系统，需要快速处理交易请求。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>配置了操作系统的机器是一台比原来的物理机器功能更强的计算机，这样的计算机只是一台逻辑上的计算机，称为____虚拟____计算机。</p>
</li>
<li><blockquote>
<p>实时操作系统必须在__ A __内处理来自外部的事件。</p>
<ul>
<li>A.规定时间；</li>
<li>B.调度时间；</li>
<li>C.响应时间；</li>
<li>D.周转时间；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>特权指令是指____A____。</p>
<ul>
<li>A.其执行可能有损系统的安全性；</li>
<li>B.机器指令；</li>
<li>C.控制指令；</li>
<li>D.系统管理员可用的指令；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍____Celeron____不是一个操作系统环境。</p>
</blockquote>
</li>
</ol>
<p>‎</p>
<h2 id="第二章-·-处理器管理"><a href="#第二章-·-处理器管理" class="headerlink" title="第二章 · 处理器管理"></a>第二章 · 处理器管理</h2><ol>
<li><p>静态共享进程时间图像如下，注意B处理完IO之后马上就可以执行C的IO。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250427191806703.png" alt="image-20250427191806703"></p>
</li>
<li><p>在做进程调度大题时，列出详细的表格，不会错：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250603203011372.png" alt="image-20250603203011372"></p>
<ol>
<li><strong>注意可能会需要平分CPU时间！！！</strong></li>
</ol>
</li>
<li><blockquote>
<p>试写出进程映像包括哪些组成部分(不必详述每个组成部分的具体内容)。(2 分)</p>
<p>答: 程序块、数据块、核心栈、进程控制块(PCB)</p>
</blockquote>
</li>
<li><p>七状态图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250608180546438.png" alt="image-20250608180546438"></p>
</li>
<li><p>时间片轮转调度（RR）：</p>
<ol>
<li>不考虑优先级的，就是先来先服务，服务完了到最后排队。</li>
<li>如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。</li>
</ol>
</li>
<li><p>多级反馈调度：</p>
<ol>
<li>在时间片调度（RR）的基础上，引入了优先级。刚进入队列时优先级最高，被抢占一次就降一级。</li>
<li>设置的q就是指时间片长度</li>
<li>而前面笔记中的 q&#x3D;2^i^ 是指我们希望动态调整时间片长度</li>
</ol>
</li>
<li><p>注意看题目中同时最多支持几道程序。</p>
</li>
<li><blockquote>
<p>实模式下 16 位 CPU 使用段偏移方式的寻址能力为_______B___。</p>
<p>A. 64kb B. 1M C. 16M D. 4G</p>
</blockquote>
<ul>
<li>记住实模式的寻址能力就是20位也可以</li>
</ul>
</li>
<li><p>段偏移：</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602171744758.png" alt="image-20250602171744758"></p>
</li>
<li><p>通过段地址和偏移地址相加的方式来寻址</p>
</li>
<li><p>为了表示更大范围的地址，我们对段地址左移四位再和偏移地址相加。</p>
</li>
<li><p>此时我们可以认为我们有了20位的寻址能力，即1M</p>
</li>
</ol>
</li>
<li><blockquote>
<p>下面哪条指令不是从实模式进入保护模式需要的指令______C____。</p>
<p>A. lgdt [GdtPtr] B. out 92h, al C. jmp $ D. mov cr0, eax</p>
</blockquote>
<ul>
<li>jmp $。 其中$是指前地址。这句指令会形成死循环</li>
</ul>
</li>
<li><p>实模式和保护模式：</p>
</li>
<li><p>实模式：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172431181.png" alt="image-20250602172431181"></li>
</ol>
</li>
<li><p>保护模式</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602172450157.png" alt="image-20250602172450157"></li>
</ol>
</li>
<li><p>模式切换：</p>
<ol>
<li><p>实模式切换到保护模式：</p>
<ol>
<li><p>一般步骤：</p>
<ol>
<li><p><strong>构造 GDT（全局描述符表）</strong><br> 并使用 <code>lgdt [GdtPtr]</code> 加载 GDT。</p>
</li>
<li><p><strong>设置 PE 位（Protection Enable）</strong><br> 把 <code>CR0</code> 的第 0 位（PE 位）设置为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0  </span><br><span class="line">or eax, 1  </span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>立即跳转（Far Jump）刷新流水线和 CS 段寄存器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp selector:offset</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><blockquote>
<p>Solaris 的多线程的实现方式为___B___</p>
<p>A.纯内核级线程 </p>
<p>B.混合式 </p>
<p>C.纯用户级多线程 </p>
<p>D.单线程结构进程</p>
</blockquote>
</li>
<li><blockquote>
<p>引入多道程序设计技术的前ᨀ条件之一是系统具有___C__。</p>
<p>A. 多个 CPU </p>
<p>B.多个终端 </p>
<p>C. 中断功能 </p>
<p>D.分时功能</p>
</blockquote>
</li>
<li><blockquote>
<p>操作系统里没有下面哪种述符表______D___。</p>
<p>A. GDT B. LDT C. IDT D. KDT</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602173324647.png" alt="image-20250602173324647"></p>
</blockquote>
</li>
<li><blockquote>
<p>C 语言里面调用汇编的函数方法为______A___。 </p>
<p>A. C 代码中使用 extern 声明，汇编中使用 global 导出 </p>
<p>B. C 代码中使用 global 声明，汇编中使用 extern 导出 </p>
<p>C. C 代码中使用 extern 声明，汇编中使用 extern 导出 </p>
<p>D. C 代码中使用 global 声明，汇编中使用 global 导出</p>
</blockquote>
</li>
<li><p>进程包含的实体部分：OS 管理程序的<strong>数据结构</strong>和程序状态字（对应进程控制块），运⾏程序的<strong>内存代码</strong>、内存数据（对应程序块和数据块）、<strong>通⽤寄存器信息</strong>（对应核心栈）</p>
</li>
<li><p>进程映像：进程控制块、进程程序块、进程数据块、核⼼栈</p>
</li>
<li><p>对进程的管理和控制通过<strong>原语</strong></p>
</li>
<li><p>系统调用的实现流程，画图！</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250604173033445.png" alt="image-20250604173033445"></li>
</ol>
</li>
<li><p>线程的调度</p>
</li>
<li><blockquote>
<p>当计算机提供了管态（内核态）和目态（用户态）时，____A____必须在管态下运行</p>
<p>A. 输入输出指令</p>
<p>B. 从内存中取数</p>
<p>C. 运算指令</p>
<p>D. 把运算结果存回内存</p>
<ul>
<li>输入输出涉及到IO设备，要用内核指令调用</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>关于内核级线程，以下描述不正确的是_­­­­­­__­­­­­­_B_­­­­­­__­­­­­­。</p>
<p>‎</p>
<ul>
<li>A.内核可以将处理器调度直接分配给某个内核级线程；</li>
<li>B.控制权从一个线程传送到另一个线程时不需要用户态-内核态-用户态的模式切换；</li>
<li>C.可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势；</li>
<li>D.建立和维护线程的数据结构及保存每个线程的入口；</li>
<li><strong>内核级线程的定义</strong><ul>
<li>内核级线程是操作系统内核能够感知的线程。内核为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息。</li>
</ul>
</li>
<li><strong>选项A的正确性</strong><ul>
<li>内核可以将处理器调度直接分配给某个内核级线程。因为内核级线程是内核能够感知和管理的实体，内核可以直接对它们进行调度，将处理器分配给某个线程运行。</li>
</ul>
</li>
<li><strong>选项B的错误性</strong><ul>
<li>控制权从一个线程传送到另一个线程时，通常需要进行用户态-内核态-用户态的模式切换。这是因为线程切换涉及到内核对线程上下文的切换，而上下文切换需要内核的参与。具体过程如下：<ul>
<li>当一个线程运行时，它可能处于用户态。</li>
<li>当需要切换到另一个线程时，当前线程需要将控制权交回内核，这涉及到从用户态切换到内核态。</li>
<li>内核保存当前线程的上下文，加载下一个线程的上下文，然后将控制权交给下一个线程，这又涉及到从内核态切换回用户态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选项C的正确性</strong><ul>
<li>可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势。内核级线程是内核能够感知的线程，内核可以将它们分派到不同的处理器上运行，从而实现多处理器并行工作。</li>
</ul>
</li>
<li><strong>选项D的正确性</strong><ul>
<li>建立和维护线程的数据结构及保存每个线程的入口是内核级线程的特性。内核需要为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息，这些信息构成了线程的数据结构。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍__B__优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。</p>
<p>‎</p>
<ul>
<li>A.短作业；</li>
<li>B.静态；</li>
<li>C.先来先服务；</li>
<li>D.动态；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>下面对进程的描述中，错误的是__B__。</p>
<p>‍</p>
<ul>
<li>A.进程执行需要处理机；</li>
<li>B.进程是指令的集合；</li>
<li>C.进程是有生命周期的；</li>
<li>D.进程是动态的概念；<ul>
<li>进程是操作系统中一个独立运行的基本单位，它包含了程序运行时所需的全部信息和资源。它不仅仅是一组指令，还包括以下几个重要组成部分</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>下面所述步骤中，__ C __不是创建进程所必需的。</p>
<p>‏</p>
<ul>
<li>A.为进程分配内存；</li>
<li>B.建立一个进程控制块；</li>
<li>C.由调度程序为进程分配CPU；</li>
<li>D.将进程控制块链入就绪队列；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>所谓“可重入”程序是指___C___。</p>
<ul>
<li>A.在执行过程中其代码自身会发生变化的程序；</li>
<li>B.不能够被多个程序同时调用的程序；</li>
<li>C.能够被多个进程共享的程序；</li>
<li>D.无限循环程序；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‍在下述关于父进程和子进程的叙述中，正确的是__C___。</p>
<ul>
<li>A.父进程创建了子进程，因此父进程执行完了，子进程才能运行；</li>
<li>B.撤销子进程时，应该同时撤销父进程；</li>
<li>C.父进程和子进程可以并发执行；</li>
<li>D.撤销父进程时，应该同时撤销子进程；<ul>
<li>父进程创建子进程后，父进程和子进程可以独立运行。操作系统会根据调度策略来决定哪个进程运行，而不是依赖于父进程是否完成。父进程和子进程可以并发执行，互不干扰。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>一个可共享的程序在执行过程中是不能被修改的，这样的程序代码应该是­<strong>C</strong>_。</p>
<ul>
<li>A.可再现代码；</li>
<li>B.可执行代码；</li>
<li>C.可重入代码；</li>
<li>D.封闭的代码；</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="第三章-·-存储管理-1"><a href="#第三章-·-存储管理-1" class="headerlink" title="第三章 · 存储管理"></a>第三章 · 存储管理</h2><ol>
<li><p>页式存储地址转换</p>
<ol>
<li>在做题时，中间过程可以先用十进制表示，不用完全展开为二进制，提高做题速度。</li>
</ol>
</li>
<li><p>clock算法：</p>
<ol>
<li><p>如果在页表中找到了某一页，设置完引用位之后不用推进指针。</p>
</li>
<li><p>那个‘*’叫引用位</p>
</li>
<li><p>淘汰需要推进指针，找到了页不用</p>
</li>
</ol>
</li>
<li><p>MIN算法和WS算法一次只会引入一个页</p>
</li>
<li><p>页式存储会导致内部碎片，包括段页式，分页式等。而分段式不会</p>
</li>
<li><p>程序装入与链接：</p>
<ol>
<li><strong>装入</strong>是指将程序从外存（如磁盘）加载到内存的过程。</li>
<li><strong>链接</strong>是指将多个目标模块（如程序模块、库模块等）组合成一个可执行程序的过程。链接可以分为静态链接和动态链接。</li>
</ol>
</li>
<li><p>静态重定位：</p>
<ol>
<li>是一种地址转换的方法，比如把逻辑地址变为物理地址。</li>
<li>一般在进程装入的时候发生</li>
</ol>
</li>
<li><p>能够装入内存任何位置的代码程序必须是__<strong>可动态链接的</strong>__。</p>
</li>
<li><p>在分页式虚存中，分页由__<strong>操作系统</strong>___实现。</p>
</li>
<li><p>缺⻚中断后重新执⾏被中断的指令</p>
</li>
<li><p>分段式不会产生内部碎片，分页式不会产生外部碎片。</p>
</li>
<li><p>在请求分页存储管理中，当访问的页面不在内存时，便产生缺页中断，缺页中断是属于_<em>C</em>_。😥</p>
</li>
</ol>
<blockquote>
<p>A. 访管中断</p>
<p>B. 外中断；</p>
<p><strong>C. I&#x2F;O中断；</strong></p>
<p>D. 程序中断；</p>
</blockquote>
<ol start="11">
<li><p>虚存的可行性基础是____。😥</p>
<blockquote>
<p><strong>A. 程序执行的局部性；</strong></p>
<p>B. 程序执行的顺序性；</p>
<p>C. 程序执行的离散性；</p>
<p>D. 程序执行的并发性；</p>
</blockquote>
</li>
<li><p>把逻辑地址转变为内存的物理地址的过程称作__<strong>重定位或地址映射</strong>__。</p>
</li>
<li><p>页面替换算法_____有可能会产生Belady异常现象。</p>
<blockquote>
<p><strong>A. FIFO；</strong></p>
<p>B. OPT；</p>
<p>C. Clock；</p>
<p>D. LRU；</p>
</blockquote>
</li>
<li><p><strong>Belady异常</strong>是指在分页式虚拟存储器管理中，当使用某些页面置换算法（如FIFO）时，增加分配给进程的页面帧数反而导致页面错误（缺页）次数增加的异常现象。就是可能马上就要访问的页面被淘汰了。</p>
</li>
<li><blockquote>
<p>FAT12 文件系统里，FAT 表的数量和每张 FAT 表占用的扇区数量为______A___。</p>
<p>A. 2, 9 B. 2, 10 C. 3, 9 D. 3, 10</p>
<ul>
<li>没印象，硬记吧</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>静态重定位的时机是__D__。</p>
<ul>
<li>A.程序运行时；</li>
<li>B.程序链接时；</li>
<li>C.程序编译时；</li>
<li>D.程序装入时；</li>
<li>重定位可以理解为地址映射，也就是把逻辑地址转换为物理地址。当程序装入内存的时候就要做转换了</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>通常所说的”存储保护”的基本含义是__防止程序间相互越界访问__。</p>
<p>‏</p>
</blockquote>
</li>
<li><blockquote>
<p>LRU置换算法所基于的思想是__A__。</p>
<ul>
<li>A.在最近的过去很久未使用的在最近的将来也不会使用；</li>
<li>B在最近的过去用得少的在最近的将来也用得少；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>作业在执行中发生了缺页中断，经操作系统处理后，应该让其执行____A___指令。</p>
<ul>
<li>A.被中断的；</li>
<li>B.被中断的前一条；</li>
<li>C.被中断的后一条；</li>
<li>D.启动时的第一条；</li>
<li>被中断的指令还没做完，要重新做一遍。比如说有两条指令A和B，A执行的过程中发现了缺页中断，那么处理完以后执行指令A</li>
</ul>
</blockquote>
</li>
<li><p>段式存储是<strong>不定长不连续的</strong></p>
</li>
</ol>
<h2 id="第四章-·-设备管理-1"><a href="#第四章-·-设备管理-1" class="headerlink" title="第四章 · 设备管理"></a>第四章 · 设备管理</h2><ol>
<li><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec4/13.png" alt="img"></p>
</li>
<li><p>死锁：</p>
<ol>
<li>就是循环等待</li>
<li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。。</li>
</ol>
</li>
<li><p>通道：通道是一种专门用于处理I&#x2F;O操作的硬件设备，它可以通过通道程序和通道指令独立于CPU运行，控制I&#x2F;O设备与内存之间的数据传输</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110727554.png" alt="image-20250421110727554"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421110741521.png" alt="image-20250421110741521"></p>
<blockquote>
<p>注意，J1退出的时间是11:50，是其所需要的时间的两倍。因为用的时间片调度算法，有两个进程。</p>
</blockquote>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250421111351369.png" alt="image-20250421111351369"></p>
</li>
<li><p>过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为__<strong>虚拟设备</strong>__。😥</p>
</li>
<li><p>通道又称I&#x2F;O处理机，它用于实现__<strong>内存与外设</strong>__之间的信息传输。</p>
</li>
<li><p>大多数低速设备都属于____设备。</p>
<blockquote>
<p>A. 虚拟；</p>
<p>B. SPOOLing；</p>
<p>C. 共享；</p>
<p><strong>D. 独享；</strong></p>
</blockquote>
</li>
<li><p>在操作系统中，用户程序申请使用I&#x2F;O设备时，通常采用____。😥😇</p>
<blockquote>
<p>A. 独占设备名；</p>
<p>B. 虚拟设备名；</p>
<p>C. 物理设备名；</p>
<p><strong>D. 逻辑设备名；</strong></p>
<ul>
<li>注：逻辑设备名：逻辑设备名是用户程序在请求I&#x2F;O操作时使用的设备名称，它是用户程序与实际物理设备之间的一个抽象层。</li>
</ul>
</blockquote>
</li>
<li><p>使用SPOOLing系统的目的是为了提高______的使用效率。</p>
<blockquote>
<p>A. CPU；</p>
<p><strong>B. I&#x2F;O设备；</strong></p>
<p>C. 操作系统；</p>
<p>D. 内存；</p>
</blockquote>
</li>
<li><p>工作集模型和工作集置换算法(WS)！！</p>
</li>
<li><p>SPOOLing的实质是<strong>让独享型设备变为共享设备</strong></p>
</li>
<li><blockquote>
<p>在操作系统中，__D__指的是一种硬件机制。</p>
<p>‌</p>
<ul>
<li>A.内存覆盖技术；</li>
<li>B.SPOOLing技术；</li>
<li>C.缓冲池；</li>
<li>D.通道技术；</li>
<li>硬记，ABC是软件机制，D是硬件机制</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>‏__C__算法是设备分配常用的一种算法。</p>
<p>‍</p>
<ul>
<li>A.首次适应；</li>
<li>B.短作业优先；</li>
<li>C.先来先服务；</li>
<li>D.最佳适应；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>采用假脱机技术，将磁盘的一部分作为公共缓冲区以代替打印机，用户对打印机的操作实际上是对磁盘的存储操作，用以代替打印机的部分是__C__。</p>
<ul>
<li>A.独占设备；</li>
<li>B.一般物理设备；</li>
<li>C.虚拟设备；</li>
<li>D.共享设备；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>使用SPOOLing系统的目的是为了提高___D___的使用效率。</p>
<p>‎</p>
<p>得分&#x2F;总分</p>
<ul>
<li>A.操作系统；</li>
<li>B.CPU；</li>
<li>C.内存；</li>
<li><strong>D.I&#x2F;O设备；</strong></li>
</ul>
</blockquote>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250610173842189.png" alt="image-20250610173842189"></p>
</li>
</ol>
<h2 id="第五章-·-文件管理-1"><a href="#第五章-·-文件管理-1" class="headerlink" title="第五章 · 文件管理"></a>第五章 · 文件管理</h2><ol>
<li><p>逻辑结构的文件：</p>
<ol start="2">
<li>流式文件</li>
<li>记录式文件</li>
</ol>
</li>
<li><p>物理结构的文件：</p>
<ol>
<li>顺序文件</li>
<li>直接文件（散列文件）</li>
<li>连接文件（串联文件）</li>
<li>索引文件</li>
</ol>
</li>
<li><p>文件系统的主要目的是____。</p>
<blockquote>
<p>A. 提高外存的读写速度；</p>
<p>B. 用于存储系统文件；</p>
<p>C. 实现虚拟存储；</p>
<p><strong>D. 实现对文件的按名存取；</strong></p>
</blockquote>
</li>
<li><p>文件系统采用多级目录结构后，对于不同用户的文件，其文件名____。</p>
<blockquote>
<p>A. 受系统约束；</p>
<p>B. 应该不同；</p>
<p><strong>C. 可以相同也可以不同；</strong></p>
<p>D. 应该相同；</p>
</blockquote>
</li>
<li><p>为了解决不同用户文件的“命名冲突”问题，通常在文件系统中采用____。</p>
<blockquote>
<p>A. 索引；</p>
<p><strong>B. 多级目录；</strong></p>
<p>C. 路径；</p>
<p>D. 约定的方法；</p>
</blockquote>
</li>
<li><p>文件系统的主要目的是__<strong>实现对文件的按名存取</strong>__。</p>
</li>
<li><p>文件目录的主要作用是____<strong>按名存取</strong>____。</p>
</li>
<li><p>在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中，______具有直接读写文件任意一个记录的能力，又提高了文件存储空间的利用率。</p>
<blockquote>
<p>A. 链接结构；</p>
<p><strong>B. 索引结构；</strong></p>
<p>C. Hash结构；</p>
<p>D. 顺序结构；</p>
<ul>
<li>注：</li>
<li>散列文件：不适合直接读写文件的任意记录</li>
<li>链接文件：不支持直接访问文件的任意记录</li>
<li>顺序文件：不支持高效的随机访问</li>
</ul>
</blockquote>
</li>
<li><p>存放在磁盘上的文件__<strong>既可随机访问，又可顺序访问</strong>__。😥</p>
</li>
<li><p>Unix文件系统中，打开文件的系统调用open返回值是____<strong>文件描述符（字）</strong>____。</p>
</li>
<li><p>文件的动态共享！！！</p>
</li>
<li><p>打开文件的系统调用open接收的参数是<strong>文件名</strong>，返回值是<strong>文件描述符</strong></p>
</li>
<li><blockquote>
<p>文件系统用__B__组织文件。</p>
<ul>
<li>A.堆栈；</li>
<li><strong>B.目录；</strong></li>
<li>C.指针；</li>
<li>D.路径；</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>在inode中的i_count是什么含义？</p>
<p><strong>A.不同进程在同一系统下共享的文件数</strong></p>
<p>B.不同进程在不同系统下共享的文件数</p>
<p>C.相同进程在同一系统下共享的文件数</p>
<p>D.不同进程在不同系统下共享的文件数</p>
<ul>
<li><code>i_count</code> 是 Linux&#x2F;UNIX 内核中 内存中的 inode（也称为 in-core inode） 的一个字段，用于记录： <strong>有多少个进程正在使用这个 inode</strong>（即该文件当前被打开了多少次）.它通常作为 引用计数（reference count），防止 inode 被释放（如释放内存）时仍有进程在使用它。</li>
</ul>
</blockquote>
</li>
<li><p>文件系统磁盘结构：<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/16.png" alt="img"></p>
<ol>
<li>用户打开文件表：进程的PCB结构中保留一个files_struct，称为用户打开文件表或文件描述符表<ol>
<li>表项的序号为文件描述符fd</li>
<li>该登记项内<strong>登记系统打开文件表的一个入口指针fp</strong></li>
<li>通过此系统打开文件表项<strong>连接到打开文件的活动inode</strong>。</li>
</ol>
</li>
<li>系统打开文件表：是为解决多用户进程共享文件、父子进程共享文件而设置的系统数据结构file_struct<ol>
<li>一个文件可能被多个进程同时打开或打开多次，导致位移量不同。</li>
<li>每次打开就是一个file，多次打开就是多个file。</li>
<li>一个inode可以连接0个或多个file，多个file对应一个inode。</li>
<li>内核内存区开辟最多存放256项的系统打开表区。</li>
</ol>
</li>
<li><strong>主存活动inode表</strong>：为解决频繁访问磁盘索引节点inode表的效率问题，系统开辟的主存区，正在使用的文件的inode被调入主活动索引节点inode中，以加快文件访问速度。</li>
</ol>
</li>
<li><p>目录项：包含inode号和文件名<img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-OS/img/lec5/11.png" alt="img"></p>
</li>
<li><p>文件操作：</p>
<ol>
<li><p>创建文件（create）过程：</p>
<ol>
<li>例如create(“path”, 0775)<ol>
<li>为新文件newfile分配磁盘inode和活动inode，并把inode编号与文件分量名newfile组成新目录项，记到目录中，这个过程中执行目录检索程序。</li>
<li>在新文件所对应的活动inode中置初值，如置存取权限i_mode&#x3D;0775，连接计数i_nlink&#x3D;1等。</li>
<li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，为后者置初值，包括特征位为写，读写位移f_offset清0。</li>
<li>把各表项及文件对应的活动inode用指针连接起来</li>
<li>把文件描述字fd返回给调用者。</li>
</ol>
</li>
</ol>
</li>
<li><p>删除过程：</p>
<ol>
<li>删除把指定文件从所在的<strong>目录文件</strong>中除去。</li>
<li>如果没有连接用户(i_link为1)，还要<strong>把文件占用的存储空间释放</strong>。删除系统调用形式为：<code>unlink(filenamep)</code>。</li>
<li>在执行删除时，必须要求用户对该文件具有”<strong>写</strong>“操作权。</li>
</ol>
</li>
<li><p>打开过程：</p>
<ol>
<li>文件使用前需要打开，以建立进程与文件之间的联系，而文件描述符唯一标识了这种连接，其任务是<strong>把文件的磁盘inode复制到内存活动inode</strong>中去，同时建立一个独立的读写文件数据结构，即系统打开文件表的一个表项。</li>
<li>打开过程：<ol>
<li>检索目录<ol>
<li>如果没有则会出错</li>
<li>检索到指定文件后，把它的磁盘inode复制到活动inode表中。</li>
<li>如果inode号<strong>已经</strong>在活动表项中则直接执行下一步。</li>
</ol>
</li>
<li>根据参数mode核对权限(与创建时的mode)<ol>
<li>如果非法，则这次打开失败。</li>
<li>当”打开”合法时，为文件分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>，并为后者赋初值。通过指针建立这些表项与活动inode间的联系。把文件描述字，即用户打开文件表中相应文件表项的序号返回给调用者。</li>
</ol>
</li>
</ol>
</li>
<li>输入是含路径的文件名 →→ 依据层次式目录结构解释与检索 →→ 匹配文件名并读取目录项 →→ 提取inode号 →→ 按号定位，在inode区读取inode数据结构(主存活动inode)</li>
<li>系统实现上必须有inode号，但是对文件名而言是透明的。</li>
</ol>
</li>
<li><p>关闭过程：</p>
<ol>
<li>关闭文件时需要释放掉inode来保证空间。</li>
<li>关闭过程<ol>
<li>根据fd找到用户打开文件表项，再找到系统打开文件表项。释放<strong>用户打开文件表项</strong>。</li>
<li>把对应<strong>系统打开文件表项</strong>中的f_count减1，如果非0，说明还有进程共享这一表项，不用释放直接返回；否则释放表项。</li>
<li>把活动索引节点中的i_count减1（前提是系统打开文件表项被释放），若不为0，表明还有用户进程正在使用该文件，不用释放而直接返回，否则在<strong>把该活动索引节点中的内容复制回文件卷上的相应索引节点中</strong>后，<strong>释放</strong>该活动索引节点。</li>
</ol>
</li>
<li>f_count和i_count分别反映进程动态地共享一个文件的两种方式<ol>
<li>f_count反映<strong>不同进程</strong>通过<strong>同一个</strong>系统打开文件表项共享一个文件的情况；</li>
<li>i_count反映<strong>不同进程</strong>通过<strong>不同</strong>系统打开文件表项共享一个文件的情况。</li>
</ol>
</li>
<li>通过两种方式，进程之间既可用相同的位移指针f_offset，也可用不同位移指针f_offset共享同一个文件。</li>
</ol>
</li>
</ol>
</li>
<li><p>虚拟文件系统（VFS，Virtual File System）是现代操作系统中用于管理文件系统的一个抽象层。VFS通常分为三个层次：实现层、虚拟层和应用层。</p>
</li>
<li></li>
</ol>
<h2 id="第六章-·-并发程序设计-1"><a href="#第六章-·-并发程序设计-1" class="headerlink" title="第六章 · 并发程序设计"></a>第六章 · 并发程序设计</h2><ol>
<li><p>注意，写管程或者PV操作的时候，如果说到“有两个进程”，就要有两个process，例如：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250526153852861.png" alt="image-20250526153852861"></p>
</li>
<li><blockquote>
<p>在操作系统中，临界区指___D____ </p>
<p>。</p>
<p>A．一个缓冲区 </p>
<p>B.一个数据区 </p>
<p>C.同步机构 </p>
<p>D.一段程序</p>
</blockquote>
</li>
<li><p><strong>死锁的检测和解除</strong></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2024/05/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">编译原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-04 12:00:00" itemprop="dateCreated datePublished" datetime="2024-05-04T12:00:00+08:00">2024-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:03:24" itemprop="dateModified" datetime="2025-12-03T17:03:24+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/course/" itemprop="url" rel="index"><span itemprop="name">课业</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Ch1-·-综述"><a href="#Ch1-·-综述" class="headerlink" title="Ch1 · 综述"></a>Ch1 · 综述</h1><ol>
<li><p>编译路线<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250302135338910.png" alt="image-20250302135338910"></p>
<ul>
<li><p>源代码 (Source Code)</p>
<p>→ 词法分析 (Lexical Analysis) → 生成标记 (Tokens）<br>→ 语法分析 (Syntax Analysis) → 生成抽象语法树 (AST)<br>→ 中间表示生成 (Intermediate Rep. Generation) → 生成中间表示 (IR)<br>→ 目标代码生成 (Target Code Generation) → 生成机器代码 (Machine Code)</p>
</li>
</ul>
<ol>
<li>词法分析（Lexical Analysis)<ol>
<li>正则语言(Regular Language)</li>
<li>有穷自动机(Finite Automata)</li>
</ol>
</li>
<li>语法分析 (Syntax Analysis)：<ol>
<li>上下文无关语言 (Context-Free Language)</li>
<li>下推自动机 (Push-Down Automata)</li>
</ol>
</li>
<li>更复杂的语言（例如递归语言等）：<ol>
<li>递归语言 (Recursive Language)</li>
<li>图灵自动机 (Turing Automata)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Ch3-1-·-有穷自动机"><a href="#Ch3-1-·-有穷自动机" class="headerlink" title="Ch3-1 · 有穷自动机"></a>Ch3-1 · 有穷自动机</h1><h2 id="确定有穷自动机（Deterministic-Finite-Automata"><a href="#确定有穷自动机（Deterministic-Finite-Automata" class="headerlink" title="确定有穷自动机（Deterministic Finite Automata"></a>确定有穷自动机（Deterministic Finite Automata</h2><p>，DFA）</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>是一个五元组<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250302140829022.png" alt="image-20250302140829022"></p>
<ol>
<li>有限的状态集Q</li>
<li>有限的输入Σ</li>
<li>转换函数𝛿</li>
<li>初始状态q</li>
<li>终止状态集F</li>
</ol>
</li>
<li><p>总能输出”accept”或”reject”</p>
</li>
<li><p>有两个“基本集合”：最终状态和非最终状态</p>
</li>
</ol>
<h3 id="Minimization"><a href="#Minimization" class="headerlink" title="Minimization"></a>Minimization</h3><ol>
<li>首先，把状态区分为最终状态和非最终状态两个集合</li>
<li>然后细分集合，把“去向”不同状态的分开</li>
</ol>
<h3 id="Bi-Simulation"><a href="#Bi-Simulation" class="headerlink" title="Bi-Simulation"></a>Bi-Simulation</h3><ul>
<li>用于判断两个状态机是否等价</li>
</ul>
<ol>
<li>用一个pair把两者的起始状态表示出来</li>
<li>写出它们分别经过a, b后的pair</li>
<li>若这些pair没有出现在state pairs中，则加入进去，重复上述操作</li>
<li>如果两个状态机同时进入最终状态，则等价</li>
</ol>
<h2 id="不确定有穷自动机（Non-deterministic-Finite-Automata，NFA）"><a href="#不确定有穷自动机（Non-deterministic-Finite-Automata，NFA）" class="headerlink" title="不确定有穷自动机（Non-deterministic Finite Automata，NFA）"></a>不确定有穷自动机（Non-deterministic Finite Automata，NFA）</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>判断：</p>
<ol>
<li>“路径”是不确定的，可能有多条路</li>
<li>含有空字符边</li>
</ol>
</li>
<li><p>如果一个走不通，就试其他路径</p>
</li>
<li><p>只要有一条路通了，就认为这个自动机接受这个字符串</p>
</li>
</ol>
<h3 id="𝜖-Closure"><a href="#𝜖-Closure" class="headerlink" title="𝜖-Closure"></a>𝜖-Closure</h3><ul>
<li>如果从状态集合 S 出发，可以经过零个或多个ε转换到达其他状态，那么这些状态都属于𝜖-Closure(S)。</li>
</ul>
<h3 id="δ"><a href="#δ" class="headerlink" title="$δ^*$"></a>$δ^*$</h3><ul>
<li>δ∗(q,w)&#x3D;{q′∣q′∈δ(q,a) for some a∈Σ or w&#x3D;ϵ}</li>
<li>用于描述在给定状态下，经过一整个输入字符串的处理后，自动机可能到达的状态集合。</li>
</ul>
<h2 id="DFA和NFA的关联"><a href="#DFA和NFA的关联" class="headerlink" title="DFA和NFA的关联"></a>DFA和NFA的关联</h2><ol>
<li><p>NFA&lt;&#x3D;&gt;DFA，二者可以相互转化</p>
<ol>
<li><p>DFA是特殊的NFA，只不过没有空串，且只有一条出边</p>
</li>
<li><p>NFA可以通过子集构造法变为DFA</p>
</li>
</ol>
</li>
<li><p>若一个集合中含有final state，则整个集合构成的状态是final state</p>
</li>
<li><p>子集构造法：</p>
<ol>
<li>核心思想：让构造的DFA的每个状态对应NFA的一个状态集合</li>
<li>如果NFA中有n个状态，则DFA中最多可以有2^n^个状态。因为DFA中的状态是NFA状态集合的子集。</li>
</ol>
</li>
<li><p>L(a)表示a的自动机</p>
</li>
</ol>
<h1 id="Ch3-2-·-词汇分析（Lexical-Analysis"><a href="#Ch3-2-·-词汇分析（Lexical-Analysis" class="headerlink" title="Ch3-2 · 词汇分析（Lexical Analysis)"></a>Ch3-2 · 词汇分析（Lexical Analysis)</h1><h2 id="正则语言-Regular-Language"><a href="#正则语言-Regular-Language" class="headerlink" title="正则语言(Regular Language)"></a>正则语言(Regular Language)</h2><h4 id="从正则到NFA"><a href="#从正则到NFA" class="headerlink" title="从正则到NFA"></a>从正则到NFA</h4><ol>
<li><p>$L_1 U L_2$</p>
</li>
<li><p>$L_1L_2$</p>
</li>
<li><p>$L_1^R$</p>
</li>
<li><p>$L$</p>
</li>
<li><p>$L_1$取反</p>
</li>
<li><p>交集</p>
</li>
<li><p>正则的性质</p>
</li>
</ol>
<h4 id="从DFA到正则"><a href="#从DFA到正则" class="headerlink" title="从DFA到正则"></a>从DFA到正则</h4><ul>
<li>变量消除法：把各个状态都表示出来，再把终止状态表达式中的其他状态消去。</li>
</ul>
<h2 id="Pumping-Lemma"><a href="#Pumping-Lemma" class="headerlink" title="Pumping Lemma"></a>Pumping Lemma</h2><ul>
<li>Pumping Lemma 证明不是正则语言：如果你能够找到一个语言 LL的字符串 w，并证明<strong>无论如何分解都无法满足</strong> Pumping Lemma 中的条件，那么就可以证明该语言不是正则的。</li>
</ul>
<ol>
<li>内容：</li>
<li>理解：若|w| &gt; n（n是自动机的状态数），则一定有“回头路”。$w_i&#x3D;xy^iz$且|xy|&lt;n, |y|&gt;1.<ol>
<li>若存在k使得$xy^kz$不属于L，则L不是正则</li>
<li>上面这条可以证明$a^nb^n$不是正则语言</li>
</ol>
</li>
</ol>
<h1 id="Ch4-1-·-上下文无关语言"><a href="#Ch4-1-·-上下文无关语言" class="headerlink" title="Ch4-1 · 上下文无关语言"></a>Ch4-1 · 上下文无关语言</h1><h2 id="上下文无关文法（Context-Free-Grammar，CFG）"><a href="#上下文无关文法（Context-Free-Grammar，CFG）" class="headerlink" title="上下文无关文法（Context-Free Grammar，CFG）"></a>上下文无关文法（Context-Free Grammar，CFG）</h2><ol>
<li>定义<ol>
<li>上下文无关文法（Context-Free Grammar，CFG）是一种用于描述计算机语言和自然语言语法的形式文法。它由四元组 G&#x3D;(V,Σ,P,S)G &#x3D; (V, \Sigma, P, S)G&#x3D;(V,Σ,P,S) 组成，其中：<ol>
<li><strong>终结符集合 Σ</strong>：一组基础符号，不能再被替换（如字母、数字、标点等）。</li>
<li><strong>非终结符集合 V</strong>：一组可以继续展开的符号（如语法成分：句子、名词短语等）。</li>
<li><strong>规则集合 P</strong>：一组产生式规则，每条规则的形式为 A→α，其中 A 是非终结符，α 是终结符和&#x2F;或非终结符的序列。</li>
<li><strong>起始符号 S</strong>：语法生成的起点，通常是一个非终结符。</li>
</ol>
</li>
</ol>
</li>
<li>推导<ol>
<li>最左推导和最右推导：就是优先把最左边或者最右边的符号展开</li>
</ol>
</li>
<li>歧义性：<ol>
<li>如果一个表达式可以构造出两棵语法树，则是有歧义的</li>
<li>例子：w &#x3D; a + a * a.这是有歧义的<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250304104127271.png" alt="image-20250304104127271"></li>
</ol>
</li>
</ol>
<h2 id="下推自动机-Push-Down-Automata-PDA"><a href="#下推自动机-Push-Down-Automata-PDA" class="headerlink" title="下推自动机(Push-Down Automata, PDA)"></a>下推自动机(Push-Down Automata, PDA)</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li>上下文无关文法&#x3D;PDA&#x3D;NDA + Stack（z0）</li>
<li>就是NDA加挂一个栈</li>
<li>定义（是七元组，GPT说错了）：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250304111925097.png" alt="image-20250304111925097"></li>
<li>例子：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250304112616625.png" alt="image-20250304112616625"></li>
<li></li>
<li>简洁表达（三元组）：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250304112853465.png" alt="image-20250304112853465"></li>
<li>注意，有两种情况接受字符串：<ol>
<li>终止状态</li>
<li>空栈</li>
</ol>
</li>
</ol>
<h2 id="CFG等价于PDA"><a href="#CFG等价于PDA" class="headerlink" title="CFG等价于PDA"></a>CFG等价于PDA</h2><h3 id="从CFG到PDA"><a href="#从CFG到PDA" class="headerlink" title="从CFG到PDA"></a>从CFG到PDA</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250307102558284.png" alt="image-20250307102558284"></p>
<ol>
<li>总是只有一个状态q</li>
<li>若栈中为非终止符，则展开（如图前两行）</li>
<li>如果读入终止符，则从栈中弹出</li>
</ol>
<h3 id="从PDA到CFG"><a href="#从PDA到CFG" class="headerlink" title="从PDA到CFG"></a>从PDA到CFG</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250307103850553.png" alt="image-20250307103850553"></p>
<ul>
<li>注：<ol>
<li>$V_{pXq}$是一个中间字符，意思是从p到q状态，从栈中弹出了X。</li>
</ol>
</li>
</ul>
<ol>
<li>从初始状态到另一个状态，消耗了$S$，得到中间字符$V_{pSq}$</li>
<li>从p到q，读入了a，弹出了X（PDA的读入和CFG的展开是一回事）</li>
<li>读到了非终结符，展开，压入对应的中间字符</li>
</ol>
<h2 id="NPDA和DPDA"><a href="#NPDA和DPDA" class="headerlink" title="NPDA和DPDA"></a>NPDA和DPDA</h2><ul>
<li>NPDA有歧义，DPDA没有</li>
<li>两者不等价</li>
</ul>
<h2 id="上下文无关语言（CFL）"><a href="#上下文无关语言（CFL）" class="headerlink" title="上下文无关语言（CFL）"></a>上下文无关语言（CFL）</h2><ol>
<li><p>给定两个CFL：$L_1,L_2$</p>
<ol>
<li><p>仍然是CFL的</p>
<ol>
<li>并，$L_1UL_2$</li>
<li>连接，$L_1L_2$</li>
<li>星号，$L_1^*$</li>
<li>倒置，$L_1^R$</li>
</ol>
</li>
<li><p>不一定是CFL的</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250307111851680.png" alt="image-20250307111851680"></li>
</ol>
</li>
</ol>
</li>
<li><p>CFL与RL</p>
<ol>
<li>两者相交为也CFL</li>
</ol>
</li>
</ol>
<h2 id="Pumping-Lemma-for-CFL"><a href="#Pumping-Lemma-for-CFL" class="headerlink" title="Pumping Lemma for CFL"></a>Pumping Lemma for CFL</h2><h3 id="Chomsky-Normal-Form（CNF）"><a href="#Chomsky-Normal-Form（CNF）" class="headerlink" title="Chomsky Normal Form（CNF）"></a>Chomsky Normal Form（CNF）</h3><ol>
<li><p>Chomsky Normal Form (CNF, 乔姆斯基范式) 是上下文无关文法（Context-Free Grammar, CFG）的一种标准形式。若一个上下文无关文法符合 CNF，则它的所有产生规则必须满足以下两种形式之一：</p>
<ol>
<li><strong>二元规则（Binary Rules）</strong>：<br> 形如 <code>A → BC</code>，其中 <code>A, B, C</code> 均为非终结符（<code>B</code> 和 <code>C</code> 不能是起始符 <code>S</code>）。</li>
<li><strong>终结规则（Terminal Rules）</strong>：<br> 形如 <code>A → a</code>，其中 <code>A</code> 为非终结符，<code>a</code> 为终结符。</li>
</ol>
<p>此外，还允许一个特殊的起始符规则：</p>
<ul>
<li><code>S → ε</code>（仅当 <code>S</code> 不出现在其他产生式的右侧时），表示空串。</li>
</ul>
</li>
</ol>
<h3 id="Puming-Lemma"><a href="#Puming-Lemma" class="headerlink" title="Puming Lemma"></a>Puming Lemma</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250307114000658.png" alt="image-20250307114000658"></p>
<ol>
<li>是RL的Puming Lemma的升级版，要分解为五部分</li>
<li>要重复的是2,4两部分，两者不能都为空</li>
</ol>
<h1 id="Ch4-2-·-语法分析-Syntax-Analysis"><a href="#Ch4-2-·-语法分析-Syntax-Analysis" class="headerlink" title="Ch4-2 · 语法分析(Syntax Analysis)"></a>Ch4-2 · 语法分析(Syntax Analysis)</h1><h2 id="自上而下的语法分析（Top-down-parsing）"><a href="#自上而下的语法分析（Top-down-parsing）" class="headerlink" title="自上而下的语法分析（Top-down parsing）"></a>自上而下的语法分析（Top-down parsing）</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Top-down parsing 是一种解析技术，用于分析输入字符串的语法结构。它从语法的起始符号（根节点）开始，逐步向下扩展，直到生成与输入字符串匹配的解析树</li>
<li>特点：<ol>
<li><strong>解析树的构建方向</strong>：从根节点（起始符号）开始，逐步向下构建解析树。</li>
<li><strong>推导方式</strong>：使用左推导（leftmost derivation），即每次替换最左边的非终结符。</li>
<li><strong>解析过程</strong>：解析器尝试应用语法规则，逐步匹配输入字符串。如果匹配失败，可能需要回溯（backtracking）。</li>
</ol>
</li>
<li>主要类型<ol>
<li><strong>递归下降解析（Recursive Descent Parsing）</strong>：<ul>
<li>通过递归函数实现解析，每个非终结符对应一个函数。</li>
<li>可能需要回溯，尤其是在语法存在左递归或多个可选规则时。</li>
</ul>
</li>
<li><strong>预测解析（Predictive Parsing）</strong>：<ul>
<li>一种特殊的递归下降解析，通过向前看（lookahead）符号预测应用的规则。</li>
<li>不需要回溯，效率更高，但对语法的要求更严格。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="LL（1）文法"><a href="#LL（1）文法" class="headerlink" title="LL（1）文法"></a>LL（1）文法</h3><ol>
<li><p>定义</p>
<p>LL(1) 是一种 自上而下的预测分析文法，其中：</p>
<ul>
<li><strong>第一个 L</strong>：表示 Left-to-right（从左到右解析）</li>
<li><strong>第二个 L</strong>：表示 Leftmost derivation（最左推导）</li>
<li><strong>(1)</strong>：表示 每次只查看一个输入符号 来决定如何推导</li>
</ul>
</li>
<li><p>特点：</p>
<ol>
<li>不是二义性的 (Not ambiguous)：每个输入字符串最多有一个语法分析树。</li>
<li>没有左递归 (Not left-recursive)：文法不能包含直接或间接左递归，否则预测分析无法工作。</li>
<li>可以使用一个符号的前瞻 (1-token lookahead) 进行预测。</li>
</ol>
</li>
<li><p>LL(1) 文法的条件</p>
<p>文法是 LL(1) 当且仅当 所有产生式$A→α∣βA \to \alpha | \beta A→α∣β$ 满足：</p>
<ol>
<li><p>α 和 β 不能以相同的终结符开头（避免选择冲突）。</p>
<ul>
<li><p>解决方法：左因子提取 (left factoring)</p>
</li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A → ab | ac</span><br></pre></td></tr></table></figure>

<p>不是 LL(1)，因为 ab 和 ac都以 a开头，可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A → a B</span><br><span class="line">B → b | c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>至多一个选项可以推导空串 (ε)，否则 Follow 集合会冲突。</p>
<ul>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A → α | β</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>FIRST(α)</code> 和 <code>FIRST(β)</code> 有交集，则不是 LL(1)</li>
<li>如果 <code>ε ∈ FIRST(α)</code> 并且 <code>ε ∈ FIRST(β)</code>，则 <code>FOLLOW(A)</code> 可能冲突。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果某个选项能推出空串（ε），另一个选项不能以 FOLLOW(A) 里的终结符开头，否则解析器无法确定如何解析。</p>
<ul>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A → α | ε</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>FOLLOW(A)</code> 包含 <code>b</code>，且 <code>FIRST(α)</code> 也包含 <code>b</code>，则不是 LL(1)。因为当输入 <code>b</code> 时，解析器无法确定使用 <code>A → α</code> 还是 <code>A → ε</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="右下角的示例文法"><a href="#右下角的示例文法" class="headerlink" title="右下角的示例文法"></a><strong>右下角的示例文法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E  →  T E&#x27;</span><br><span class="line">E&#x27; →  + T E&#x27; | ε</span><br><span class="line">T  →  F T&#x27;</span><br><span class="line">T&#x27; →  * F T&#x27; | ε</span><br><span class="line">F  →  ( E ) | id</span><br></pre></td></tr></table></figure>

<p><strong>验证是否 LL(1)：</strong></p>
<ol>
<li>没有左递归</li>
<li><code>E&#39; → + T E&#39; | ε</code>，由于 <code>+</code> 不在 <code>FOLLOW(E&#39;)</code> 中，因此符合条件</li>
<li><code>T&#39; → * F T&#39; | ε</code>，由于 <code>*</code> 不在 <code>FOLLOW(T&#39;)</code> 中，因此符合条件</li>
<li>没有 FIRST 集合冲突</li>
</ol>
<p>✅ <strong>符合 LL(1) 文法规则！</strong></p>
</li>
</ol>
<h2 id="递归下降解析（Recursive-Descent-Parsing）"><a href="#递归下降解析（Recursive-Descent-Parsing）" class="headerlink" title="递归下降解析（Recursive Descent Parsing）"></a>递归下降解析（Recursive Descent Parsing）</h2><ol>
<li><p>思想：通过递归函数实现解析，每个非终结符对应一个函数。</p>
</li>
<li><p>问题和解决：</p>
<ol>
<li><p>需要回溯。当一种情况不被接受，还要回过头去尝试。</p>
<ol>
<li>例子：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250311102259084.png" alt="image-20250311102259084"><ol>
<li>显然cAb应该被接受。但是在函数A()中，提前把b消了，导致结果为False。此时应回溯</li>
</ol>
</li>
<li>解决：<ol>
<li>我们定义两个函数：<ol>
<li>First(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身</li>
<li>Follow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
<li><p>左递归循环。</p>
<ol>
<li><p>问题描述：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250312115949062.png" alt="image-20250312115949062"></p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250312120001244.png" alt="image-20250312120001244"></li>
<li>会发现没有读入任何字符，在A()中无限循环</li>
</ol>
</li>
<li><p>解决：套公式<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250311103010549.png" alt="image-20250311103010549"></p>
<ul>
<li>有“循环项”和“非循环项”，先表示全部的非循环项，在用A’表示所有循环项。</li>
</ul>
<ol>
<li>消除直接左递归<ol>
<li>就是要得到展开式不以相同字符开头。</li>
<li>$A{\to}Ab|c$变为$A{\to}cB,B{\to}bB|𝜖$</li>
<li>以这样的形式就可以至少读入一个字符，避免无限循环</li>
</ol>
</li>
<li>消除间接左递归<ol>
<li>带入，然后消除直接左递归</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Ch6-1-·-中间表示（Intermediate-Representation，IR）"><a href="#Ch6-1-·-中间表示（Intermediate-Representation，IR）" class="headerlink" title="Ch6-1 · 中间表示（Intermediate Representation，IR）"></a>Ch6-1 · 中间表示（Intermediate Representation，IR）</h1><h2 id="三地址码"><a href="#三地址码" class="headerlink" title="三地址码"></a>三地址码</h2><ol>
<li><p>形式：</p>
<ol>
<li>右侧最多只有一个运算符</li>
<li>每条语句最多只有三个地址（变量）</li>
</ol>
</li>
<li><p>四元式（Quadruples）：四元式（Quadruples）是一种中间代码，用于表示三地址代码。</p>
<ol>
<li>形式：(op, arg1, arg2, result)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318190033673.png" alt="image-20250318190033673"></li>
</ol>
</li>
<li><p>三元式（Triples）：</p>
<ol>
<li>形式：<ol>
<li>(op, arg1, arg2)<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318190330720.png" alt="image-20250318190330720"></li>
<li>优化：Triples with Syntax DAG（有向无环图）。避免重复运算。<ol>
<li>在<strong>表达式计算</strong>或<strong>代码优化</strong>时，<strong>相同的子表达式</strong>可能会重复出现。<strong>DAG 通过共享公共子表达式</strong>，减少重复计算，提高效率。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318190933404.png" alt="image-20250318190933404"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><ol>
<li><p>语法制导定义SDD</p>
<ol>
<li>SDD由两部分组成<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318113548445.png" alt="image-20250318113548445"><ol>
<li>上下文无关文法（CFG）</li>
<li>属性和语义规则</li>
</ol>
</li>
<li><strong>CFG 只能描述语法，而 Ruler 规则使 CFL 具备了语义处理能力</strong>。<ol>
<li>CFG表述了一颗语法树在某一步如何展开，对应的Ruler告诉你在某一步应该计算什么</li>
</ol>
</li>
<li>Generation of Syntax DAG：消除重复计算</li>
</ol>
</li>
<li><p>语法制导翻译（Syntax-Directed Translation，SDT）</p>
<ol>
<li>变量声明<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250321102857707.png" alt="image-20250321102857707"></li>
</ol>
<ul>
<li>record是一个终结符，后面跟一个声明的列表，用大括号包围<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250321103016549.png" alt="image-20250321103016549"></li>
<li>有offest指针<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250321103147179.png" alt="image-20250321103147179"></li>
<li>record嵌套怎么办？用栈记录<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250321103407418.png" alt="image-20250321103407418"></li>
</ol>
</li>
</ul>
<ol start="2">
<li>一般语句：<ol>
<li>符号说明：<ol>
<li>“||”表示拼接</li>
<li>E.addr：计算结果的地址，通常是一个临时变量或标识符</li>
<li>E.code：计算该表达式的中间代码</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250321104736738.png" alt="image-20250321104736738"></li>
</ol>
</li>
<li>流控制：<ol>
<li>符号说明：<ol>
<li>S.next：S的下一条语句</li>
<li>B.true &#x2F; B.false：是标签，表示B这个布尔表达式的值为true &#x2F; false时，要跳转的标签</li>
</ol>
</li>
</ol>
</li>
<li>布尔语句</li>
</ol>
</li>
</ol>
<h1 id="Ch6-2-·-翻译为SSA形式"><a href="#Ch6-2-·-翻译为SSA形式" class="headerlink" title="Ch6-2 · 翻译为SSA形式"></a>Ch6-2 · 翻译为SSA形式</h1><h2 id="静态单赋值（Static-Single-Assignment，SSA）"><a href="#静态单赋值（Static-Single-Assignment，SSA）" class="headerlink" title="静态单赋值（Static Single Assignment，SSA）"></a>静态单赋值（Static Single Assignment，SSA）</h2><ol>
<li><p>特点：</p>
<ol>
<li><p>每个变量只能定义（赋值）一次</p>
</li>
<li><p>用φ函数，根据流从多条路径中合并定义（赋值）</p>
<ol>
<li><p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (cond) &#123;</span><br><span class="line">    x1 = 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    x2 = 2;</span><br><span class="line">&#125;</span><br><span class="line">x3 = φ(x1, x2)   // 选择 x1 或 x2 作为 x3</span><br><span class="line">y1 = x3 + 3;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>Gated SSA：</p>
<ol>
<li><p><strong>使用“门”变量（Gate Variables）来控制 <code>φ</code>（phi）函数的赋值</strong>，避免不必要的计算和存储开销。加一个条件</p>
</li>
<li><p>在上例中，<code>φ(x1, x2)</code> 在控制流合并点 <strong>无条件执行</strong>，即使 <code>cond</code> 为 <code>true</code>，<code>x2</code> 也会被计算（在 <code>else</code> 分支不执行的情况下）。</p>
</li>
<li><p>使用GSSA，<code>φ_g(cond, x1, x2)</code> 只有在 <code>cond</code> <strong>确定后才执行对应的赋值</strong>，不会无条件执行所有分支的赋值。</p>
</li>
<li><p><strong>𝛍（mu）函数</strong> 处理 <strong>循环入口（Loop Entry）</strong> 的变量初始化。之后遇到，让X2直接继承X4的值。</p>
<p><strong>𝛈（eta）函数</strong> 处理 <strong>循环体（Loop Body）</strong> 内部变量的更新。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250324190913322.png" alt="image-20250324190913322"></p>
</li>
</ol>
</li>
</ol>
<h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><ol>
<li>Function<ol>
<li>每个变量都用“%n”标记，这就保证了SSA的要求</li>
</ol>
</li>
<li>GEP（指令，GetElementPtr，获取元素指针）</li>
</ol>
<h2 id="翻译为-SSA"><a href="#翻译为-SSA" class="headerlink" title="翻译为 SSA"></a>翻译为 SSA</h2><ol>
<li>基本块<ol>
<li>基本块的第一条指令一定是leader：<ol>
<li>函数的第一条指令是leader</li>
<li>跳转目标地址的指令是leader</li>
<li>跳转指令后紧跟的指令是leadeer</li>
</ol>
</li>
<li>一些基本块相关的名词<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250325103218021.png" alt="image-20250325103218021"></li>
<li>自然循环<ol>
<li>定义：<ol>
<li>只有一个header，称作支配</li>
<li>最大的SCC（强联通分量）</li>
</ol>
</li>
</ol>
</li>
<li>支配：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250325103734981.png" alt="image-20250325103734981"><ol>
<li>A支配B：从入口开始进入B的所有路径一定经过A</li>
<li>A后支配B：从B开始到出口的所有路径一定经过A</li>
<li>A严格支配B：A支配B但是A不等于B。所有基本块都支配自己，但它们不会严格支配自己</li>
<li>A立即支配B：A严格支配B，且不存在A严格支配C的同时C严格支配B</li>
</ol>
</li>
</ol>
</li>
<li>控制依赖<ol>
<li>如果A节点的结果决定了会不会经过B，则B控制依赖于A。</li>
<li>注意可以自己控制依赖自己</li>
</ol>
</li>
<li>依赖前沿<ol>
<li>就是B所支配的块的后继，且该后继不被B支配。</li>
<li>出入口节点的支配前沿一定是空集</li>
<li>迭代的支配前沿：计算出支配前沿，再把结果加入Bset，然后循环，直到不动点。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250325111907799.png" alt="image-20250325111907799"></li>
</ol>
</li>
</ol>
</li>
<li>IDF vs. SSA<ol>
<li>某个块中的变量可能传播到其支配前沿，所以要在支配前沿需要插入φ。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250325112933226.png" alt="image-20250325112933226"></li>
</ol>
</li>
</ol>
<h1 id="Ch8-1-·-Target-Code-Generation"><a href="#Ch8-1-·-Target-Code-Generation" class="headerlink" title="Ch8-1 · Target Code Generation"></a>Ch8-1 · Target Code Generation</h1><h2 id="块内优化"><a href="#块内优化" class="headerlink" title="块内优化"></a>块内优化</h2><h3 id="基于树的指令选择"><a href="#基于树的指令选择" class="headerlink" title="基于树的指令选择"></a>基于树的指令选择</h3><ol>
<li>例子：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250401114121645.png" alt="image-20250401114121645"></li>
</ol>
<h2 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250401115551979.png" alt="image-20250401115551979"></p>
<h1 id="Ch8-2-·-Translation-out-of-SSA"><a href="#Ch8-2-·-Translation-out-of-SSA" class="headerlink" title="Ch8-2 · Translation out of SSA"></a>Ch8-2 · Translation out of SSA</h1><h2 id="消除φ"><a href="#消除φ" class="headerlink" title="消除φ"></a>消除φ</h2><ol>
<li>两大问题：<ol>
<li>The Lost Copy Problem</li>
<li>The Swap Problem</li>
</ol>
</li>
<li>统一的解决方法（不考）<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250408105428665.png" alt="image-20250408105428665"></li>
</ol>
</li>
</ol>
<h1 id="Ch8-3-·-寄存器分配"><a href="#Ch8-3-·-寄存器分配" class="headerlink" title="Ch8-3 · 寄存器分配"></a>Ch8-3 · 寄存器分配</h1><ul>
<li>一般考局部而不是全局</li>
</ul>
<h2 id="局部分配（Local-Register-Allocation）"><a href="#局部分配（Local-Register-Allocation）" class="headerlink" title="局部分配（Local Register Allocation）"></a>局部分配（Local Register Allocation）</h2><ol>
<li>要求<ol>
<li>生成的代码只能用到不多于k个寄存器</li>
<li>最少地使用loads, stores</li>
<li>足够高效O(N), O(N logN)</li>
</ol>
</li>
<li>术语<ol>
<li>live：在后面还会被调用，即在最后一次调用之前</li>
<li>spilling：溢出，把值从寄存器存入内存</li>
</ol>
</li>
<li>方法：<ol>
<li>检查最大同时使用的寄存器数量n<ol>
<li>若k&gt;&#x3D;n，则容易处理</li>
<li>若k&lt;n，则要spilling。把暂时不用的数据存到内存中，要用的时候再调出来。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="全局分配（Global-Register-Allocation）"><a href="#全局分配（Global-Register-Allocation）" class="headerlink" title="全局分配（Global Register Allocation）"></a>全局分配（Global Register Allocation）</h2><ol>
<li><p>思想：图着色算法</p>
<ol>
<li>先画出干扰图<ol>
<li>会同时生存的寄存器之间加一条边</li>
</ol>
</li>
<li>计算着色最少需要的颜色n<ol>
<li>若k&gt;&#x3D;n，即能够用k种颜色着色，则容易处理</li>
<li>如果k&lt;n则spilling</li>
</ol>
</li>
</ol>
</li>
<li><p>Chaitin’s Algorithm（一个图着色算法）</p>
<ul>
<li>易知，若节点的度小于k，则容易用k色着色</li>
</ul>
<ol>
<li>所以，我们先把度小于k的节点压栈，最后着色</li>
<li>如果没有，则选择一个度最小的节点放入列表。</li>
<li>若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。</li>
<li>迭代第1、2、3条</li>
</ol>
</li>
<li><p>Chaitin-Briggs Algorithm（前一个算法等等改进）</p>
<ul>
<li>思想是不急着spilling，减少spill code</li>
<li>即使没有满足要求的节点，我们也尝试把一个节点压栈。</li>
<li>不一定成功</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250408114747094.png" alt="image-20250408114747094"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250408114804851.png" alt="image-20250408114804851"></li>
</ul>
</li>
</ol>
<h1 id="Ch10-·-指令流水线"><a href="#Ch10-·-指令流水线" class="headerlink" title="Ch10 · 指令流水线"></a>Ch10 · 指令流水线</h1><p>去看PPT上的示例</p>
<ol>
<li>我们能否通过调整寄存器分配和指令顺序，从而生成出更快的代码呢？</li>
</ol>
<h2 id="指令调度的约束（Scheduling-Constraints）"><a href="#指令调度的约束（Scheduling-Constraints）" class="headerlink" title="指令调度的约束（Scheduling Constraints）"></a>指令调度的约束（Scheduling Constraints）</h2><ol>
<li>依赖关系<ol>
<li>真依赖关系（Read-After-Write Dependence）：无论如何调度，都不能打乱指令的顺序<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415103337166.png" alt="image-20250415103337166"></li>
<li>假依赖关系：看似不能打乱顺序，但可以通过重命名寄存器解决1.<ol>
<li><strong>Antidependence</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415103419020.png" alt="image-20250415103419020"><ol>
<li>左图不能交换两条指令的顺序，否则MUL拿到了R2就不对了。</li>
<li>但事实上可以像右图那样解决</li>
</ol>
</li>
<li><strong>Output dependence（<strong>Write-After-Write</strong>）</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415103714763.png" alt="image-20250415103714763"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="基本块调度"><a href="#基本块调度" class="headerlink" title="基本块调度"></a>基本块调度</h2><ol>
<li>依赖图：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415104155080.png" alt="image-20250415104155080"><ol>
<li>节点(Node): Instructions</li>
<li>边（Edge): True Dependence (Read-After-Write Dependence)</li>
<li>深度(Depth)：从某一块到结束所需要的时钟周期</li>
</ol>
</li>
<li>List Scheduling（列表调度）<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415104426587.png" alt="image-20250415104426587"></li>
</ol>
</li>
</ol>
<h2 id="全局代码调度"><a href="#全局代码调度" class="headerlink" title="全局代码调度"></a>全局代码调度</h2><ol>
<li><p>Extended Basic Block（EBB）</p>
<ol>
<li><p>定义：</p>
<ol>
<li>扩展基本块只有一个入口点</li>
<li>除了第一个基本块可以有多个前驱基本块外，其他基本块都只有一个前驱基本块，且这个前驱基本块必须在扩展基本块内。</li>
</ol>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415105431266.png" alt="image-20250415105431266"></p>
</li>
<li><p>可以把每条EBB path当做一个基本块来指令调度</p>
<ol>
<li>但是可能破坏程序的语义。比如说g需要c，但是我们把c移动到了B2，导致B3语义变化</li>
<li>我们要添加一些指令来保证语义</li>
</ol>
</li>
<li><p>Downward Code Motion（下移）</p>
<ol>
<li>src 不支配 dst<ol>
<li>我们需要把dst块复制一下，保证其他路径的语义<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415105822251.png" alt="image-20250415105822251"></li>
</ol>
</li>
<li>dst 不后支配 src<ol>
<li>要把下移的指令也复制到其他块</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415105922568.png" alt="image-20250415105922568"></li>
</ol>
</li>
<li>src支配dst 且 dst后支配src<ol>
<li>直接下移即可，因为没有其他路径<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415110022464.png" alt="image-20250415110022464"></li>
</ol>
</li>
</ol>
</li>
<li><p>Upward Code Motion（上移）</p>
<ol>
<li><p>dst 不后支配 src：每条路径都要复制一条才行<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250418102830059.png" alt="image-20250418102830059"></p>
</li>
<li><p>src 不支配 dst：</p>
<ol>
<li><p>对于其他路径，其”父节点“多出来一条指令。我们需要做逆操作<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250418103029116.png" alt="image-20250418103029116"></p>
</li>
<li><p>但是可能会有干扰，比如说你添加undo指令之后，其他父节点又多出来一句。解决方式是复制基本块：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250418103508101.png" alt="image-20250418103508101"></p>
<p> 变为<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250418103518725.png" alt="image-20250418103518725"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Ch9-1-·-数据流分析（Data-Flow-Analysis）"><a href="#Ch9-1-·-数据流分析（Data-Flow-Analysis）" class="headerlink" title="Ch9-1 · 数据流分析（Data Flow Analysis）"></a>Ch9-1 · 数据流分析（Data Flow Analysis）</h1><h2 id="数据流方程"><a href="#数据流方程" class="headerlink" title="数据流方程"></a>数据流方程</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506102505983.png" alt="image-20250506102505983"></p>
<ol>
<li>代码优化：<ol>
<li>Local common subexpression</li>
<li>Global common subexpression</li>
<li>Copy propagation</li>
<li>Strength reduction</li>
<li>Induction-variable elimination</li>
</ol>
</li>
<li>相关概念：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422105041017.png" alt="image-20250422105041017"></li>
<li>分析算法：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422104858892.png" alt="image-20250422104858892"><ol>
<li>前两行是初始化</li>
<li>后面的操作可以自定义。下面有几种不同的定义。<ol>
<li>要求：是单调的。这样才能让OUT[B]最终确定下来。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422115748201.png" alt="image-20250422115748201"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422115801249.png" alt="image-20250422115801249"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="三大经典DFA"><a href="#三大经典DFA" class="headerlink" title="三大经典DFA"></a>三大经典DFA</h2><ol>
<li>Reaching Definitions（到达定义分析）<ol>
<li>函数定义<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422105552642.png" alt="image-20250422105552642"><ol>
<li>定义传递函数$f_B$为基本块B输入的定义减去覆盖（kill）的定义加上生成的定义。</li>
<li>定义合并函数&#x2F;\为并集</li>
</ol>
</li>
<li>分析的例子见PPT</li>
</ol>
</li>
<li>Available Expressions（可用表达式分析）<ol>
<li>什么是avaliable的？<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422112630916.png" alt="image-20250422112630916"><ol>
<li><strong>后面的4*i可以用前面的代替，也就是中间没有重新定义</strong></li>
</ol>
</li>
<li>函数定义<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422112839015.png" alt="image-20250422112839015"><ol>
<li>定义传递函数$f_B$为基本块B输入的定义减去覆盖（kill）的定义加上生成的定义。</li>
<li>定义合并函数&#x2F;\为交集</li>
</ol>
</li>
<li>Live Variable Analysis（活跃变量分析）<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422113330019.png" alt="image-20250422113330019"></li>
<li>这是一个从后向前的分析，因为是根据某一个块的表达式来分析前一个块的信息。</li>
</ol>
</li>
<li>What’s the Best Order of Blocks<ol>
<li>深度优先。在这里，深度优先搜索是一个逆向的后序搜索。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250422114728765.png" alt="image-20250422114728765"></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="局部冗余（Partial-Redundancy）"><a href="#局部冗余（Partial-Redundancy）" class="headerlink" title="局部冗余（Partial Redundancy）"></a>局部冗余（Partial Redundancy）</h2><ol>
<li>冗余的来源</li>
</ol>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506104548798.png" alt="image-20250506104548798"></p>
<ol start="2">
<li>无法完全消除冗余</li>
<li>我们希望<strong>尽可能</strong>的不要重复计算，多次变一次</li>
<li>分析步骤见PPT</li>
</ol>
<h2 id="懒惰代码运动问题（The-Lazy-Code-Motion-Problem）"><a href="#懒惰代码运动问题（The-Lazy-Code-Motion-Problem）" class="headerlink" title="懒惰代码运动问题（The Lazy Code Motion Problem）"></a>懒惰代码运动问题（The Lazy Code Motion Problem）</h2><ul>
<li><p>是什么（3点）</p>
<ul>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250513103332875.png" alt="image-20250513103332875"></p>
</li>
<li><h3 id="消除所有可以消除的表达式冗余计算"><a href="#消除所有可以消除的表达式冗余计算" class="headerlink" title="消除所有可以消除的表达式冗余计算"></a>消除所有可以消除的表达式冗余计算</h3></li>
<li><h3 id="优化后的程序不会执行原程序中不存在的计算"><a href="#优化后的程序不会执行原程序中不存在的计算" class="headerlink" title="优化后的程序不会执行原程序中不存在的计算"></a>优化后的程序不会执行原程序中不存在的计算</h3></li>
<li><h3 id="尽可能晚地计算表达式"><a href="#尽可能晚地计算表达式" class="headerlink" title="尽可能晚地计算表达式"></a>尽可能晚地计算表达式</h3></li>
</ul>
</li>
<li><p>怎么办（4点）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506105354032.png" alt="image-20250506105354032"></p>
</li>
</ul>
<ol>
<li><p>第一步：找到预期表达式</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506105808269.png" alt="image-20250506105808269"></li>
<li>预期表达式是指从此到结束一定会计算的表达式（像后支配）</li>
<li>从后往前，如果从程序点 <em>p</em> 出发的所有路径最终都会计算表达式 <em>e</em>，那么称 <em>e</em> 在 <em>p</em> 处是预期的</li>
</ol>
</li>
<li><p>第二步：可用表达式</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506110127990.png" alt="image-20250506110127990"></li>
<li>从前往后，如果表达式 <em>e</em> 在到达程序点 <em>p</em> 的所有路径上都是预期的，并且在到达 <em>p</em> 之前没有被覆盖，那么称 <em>e</em> 在 <em>p</em> 处是可用的。</li>
</ol>
</li>
<li><p>第三步：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506110152514.png" alt="image-20250506110152514"></li>
<li>从前往后，如果到达程序点 <em>p</em> 的所有路径都看到了表达式 <em>e</em> 的最早放置位置，但尚未使用它，那么称 <em>e</em> 在 <em>p</em> 处是可推迟的。</li>
</ol>
</li>
<li><p>第四步：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506110215171.png" alt="image-20250506110215171"></li>
<li>从后往前，如果表达式 <em>e</em> 在程序点 <em>p</em> 之后的某个路径上被使用，那么称 <em>e</em> 在 <em>p</em> 处是已使用的</li>
</ol>
</li>
</ol>
<h2 id="常数传播（Constant-Propagation）"><a href="#常数传播（Constant-Propagation）" class="headerlink" title="常数传播（Constant Propagation）"></a>常数传播（Constant Propagation）</h2><ol>
<li><p>概述：</p>
<ol>
<li><p>常数传播的基本概念</p>
<p>在常数传播中，每个变量 <em>v</em> 被赋予一个状态，表示它在程序的某个点上的值。这些状态通常有以下几种：</p>
<ol>
<li><strong>UNDEF</strong>：表示变量的值是未定义的。</li>
<li><strong>Constant</strong>：表示变量的值是一个具体的常数。</li>
<li><strong>NAC</strong>（Not a Constant）：表示变量的值不是常数，即变量的值在运行时可能会变化。</li>
</ol>
<p>这些状态可以用一个函数 <em>m</em>(<em>v</em>) 来表示，其中 <em>m</em>(<em>v</em>) 的值可以是 UNDEF、Constant 或 NAC</p>
</li>
<li><p>m(v)的合并：</p>
<ol>
<li><strong>Merge Function: m(x)</strong> <strong>∧</strong> <strong>m(x’)</strong><ol>
<li>UNDEF ∧ Constant &#x3D; Constant，把UNDEF看做任意值</li>
<li>NAC ∧ Constant &#x3D; NAC</li>
<li>Constant ∧ Constant &#x3D; Constant，相同的constant合并后还是const</li>
<li>Constant ∧ Constant’ &#x3D; NAC，不同的const合并后就不对了。</li>
</ol>
</li>
</ol>
</li>
<li><p>单调性：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250513105230264.png" alt="image-20250513105230264"></li>
</ol>
</li>
</ol>
</li>
<li><p>两大特征：</p>
<ol>
<li>可能的数据流值集合是无界的（It has a unbounded set of possible data-flow values）：在常数传播中，一个变量在程序的不同路径上可能有不同的值。这些值的集合可能是无界的，即没有上限或下限。</li>
<li>它不是分配的（It is not distributives）：f(a ∧ b) ≠ f(a) ∧ f(b).先合并再传播，和先传递再合并，不一样</li>
</ol>
</li>
</ol>
<h1 id="Ch9-2-·-符号执行（Symbolic-Execution）"><a href="#Ch9-2-·-符号执行（Symbolic-Execution）" class="headerlink" title="Ch9-2 · 符号执行（Symbolic Execution）"></a>Ch9-2 · 符号执行（Symbolic Execution）</h1><ol>
<li><p>限制Limitations</p>
<ol>
<li><p>• <strong>Scalability</strong></p>
<p>• (1) Path Explosion</p>
<p>• (2) External Calls</p>
<p>• (3) Constraint Solving</p>
</li>
</ol>
</li>
</ol>
<h2 id="命题逻辑（PL）"><a href="#命题逻辑（PL）" class="headerlink" title="命题逻辑（PL）"></a>命题逻辑（PL）</h2><ol>
<li>语法（syntax）：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516102321293.png" alt="image-20250516102321293"></li>
<li>solution<ol>
<li>可满足性(satisfiability)和有效性(validity)：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516102636633.png" alt="image-20250516102636633"></li>
</ol>
</li>
</ol>
</li>
<li>范式<ol>
<li>Negation Normal Form (NNF)<ol>
<li>不允许出现$¬F$：例如：¬(a ∧ b) 写为 ¬a ∨ ¬b</li>
<li>不允许出现$F⇒G$：例如：a ⇒ b 写为 ¬a ∨ b</li>
</ol>
</li>
<li>析取范式，Disjunctive Normal Form (DNF)<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516103721661.png" alt="image-20250516103721661"></li>
</ol>
</li>
<li>合取范式，Conjunctive Normal Form (CNF)<ol>
<li>类似于DNF，只不过析取合取换位了</li>
</ol>
</li>
</ol>
</li>
<li>可满足性等价（Equisatisfiability）<ol>
<li>两个公式 <em>ϕ</em> 和 <em>ψ</em> 是<strong>可满足性等价</strong>的，如果满足以下条件： <em>ϕ</em> 是可满足的⇔<em>ψ</em> 是可满足的</li>
</ol>
</li>
</ol>
<h3 id="Tseitin-Transformation"><a href="#Tseitin-Transformation" class="headerlink" title="Tseitin Transformation"></a>Tseitin Transformation</h3><ol>
<li><strong>Tseitin 变换</strong>是一种将任意命题逻辑公式转换为合取范式（CNF）的方法，同时保持可满足性等价。![屏幕截图 2025-05-16 105137](E:\Pictures\Screenshots\屏幕截图 2025-05-16 105137.png)</li>
<li>![屏幕截图 2025-05-16 105146](E:\Pictures\Screenshots\屏幕截图 2025-05-16 105146.png)</li>
<li>把逻辑树写出来，根据逻辑树写出合取式，再改写以满足规范</li>
</ol>
<h3 id="SAT-problem"><a href="#SAT-problem" class="headerlink" title="SAT problem"></a>SAT problem</h3><ul>
<li>如何判断一个式子是否可满足呢？真值表法太慢！</li>
</ul>
<ol>
<li>DPLL<ol>
<li><strong>DPLL算法</strong>是一种用于解决布尔可满足性问题（SAT问题）的回溯搜索算法。</li>
<li>算法：<ol>
<li>选择一个未赋值的变量，为其分配一个真值（通常是True或False）。</li>
<li>简化公式，递归地调用DPLL算法。</li>
<li>如果递归调用返回不可满足，则回溯，为该变量分配另一个真值。</li>
</ol>
</li>
<li>小结论：<ol>
<li>$(a_1 ∨ a_2 ∨ ¬c) ∧ (b_1 ∨ b_2 ∨ c)$可以立即简化为$a_1 ∨ a_2 ∨ b_1 ∨ b_2$（无论c的取值）</li>
</ol>
</li>
</ol>
</li>
<li>CDCL<ol>
<li><strong>冲突驱动的子句学习（CDCL）</strong> 是一种先进的布尔可满足性问题（SAT）求解算法</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516112439776.png" alt="image-20250516112439776"></li>
<li>遇到需要讨论的地方，就假设。例如，假设x1&#x3D;0，那么x4&#x3D;1.</li>
<li>遇到冲突，例如x9&#x3D;1 &amp;&amp; x9 &#x3D; 0，就分析导致冲突的条件。由图可知，是x3,x7,x8导致的。这就说明x3&#x3D;1,x7&#x3D;1,x8&#x3D;0不能够同时满足</li>
<li>把¬x3 ∨ ¬x7 ∨ x8加入原式</li>
</ol>
</li>
</ol>
<h2 id="一阶逻辑（FOL）"><a href="#一阶逻辑（FOL）" class="headerlink" title="一阶逻辑（FOL）"></a>一阶逻辑（FOL）</h2><h3 id="可满足性模理论（Satisfiability-Modulo-Theories，-SMT）"><a href="#可满足性模理论（Satisfiability-Modulo-Theories，-SMT）" class="headerlink" title="可满足性模理论（Satisfiability Modulo Theories， SMT）"></a>可满足性模理论（Satisfiability Modulo Theories， SMT）</h3><ol>
<li>SMT求解器用于确定这些逻辑公式在给定理论下的可满足性。</li>
<li>步骤：<ol>
<li><strong>Step 1</strong>: Word-Level Preprocessing<ol>
<li>简化公式</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516115056197.png" alt="image-20250516115056197"></li>
</ol>
</li>
<li><strong>Step 2</strong>: Bit-Blasting (From FOL to PL)<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250516115042183.png" alt="image-20250516115042183"></li>
</ol>
</li>
<li><strong>Step 3</strong>: DPLL&#x2F;CDCL</li>
</ol>
</li>
</ol>
<h1 id="Ch12-1-·-Inter-procedural-Data-Flow-Analysis"><a href="#Ch12-1-·-Inter-procedural-Data-Flow-Analysis" class="headerlink" title="Ch12-1 · Inter-procedural Data Flow Analysis"></a>Ch12-1 · Inter-procedural Data Flow Analysis</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ol>
<li><strong>交叉过程数据流分析</strong>是一种程序分析技术，用于分析程序中数据在不同过程（函数、方法）之间的流动。与仅分析单个过程的**内过程（intra-procedural）**数据流分析不同，交叉过程分析考虑了过程之间的调用关系，能够更全面地理解程序的行为和数据依赖关系</li>
</ol>
<h2 id="调用图和调用链"><a href="#调用图和调用链" class="headerlink" title="调用图和调用链"></a>调用图和调用链</h2><ol>
<li><strong>调用图</strong>是一个有向图，表示程序中各个函数之间的调用关系。每个节点代表一个函数，每条有向边表示一个函数调用了另一个函数。</li>
<li><strong>调用链</strong>是从程序的入口点到某个特定函数的调用路径。调用链可以看作是调用图中的一条路径，表示函数调用的顺序。</li>
</ol>
<h2 id="上下文敏感的数据流分析（Context-Sensitive-Data-Flow-Analysis）"><a href="#上下文敏感的数据流分析（Context-Sensitive-Data-Flow-Analysis）" class="headerlink" title="上下文敏感的数据流分析（Context-Sensitive Data Flow Analysis）"></a>上下文敏感的数据流分析（Context-Sensitive Data Flow Analysis）</h2><ol>
<li><p>基于克隆的交叉过程数据流分析（Clone-based Interprocedural DFA）<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520102803449.png" alt="image-20250520102803449"></p>
<ol>
<li><strong>克隆过程</strong>：<ul>
<li>对于每个过程，根据其调用上下文创建多个副本。每个副本对应一个特定的调用路径。</li>
<li>例如，如果一个过程被两个不同的调用者调用，那么该过程会被克隆为两个副本，每个副本对应一个调用者。</li>
</ul>
</li>
</ol>
</li>
<li><p>基于摘要的交叉过程数据流分析（Summary-based Inter-procedural DFA）</p>
<ol>
<li><h3 id="自顶向下（Top-Down-TD）分析"><a href="#自顶向下（Top-Down-TD）分析" class="headerlink" title="自顶向下（Top-Down, TD）分析"></a>自顶向下（Top-Down, TD）分析</h3><p>自顶向下的分析方法从调用者（caller）开始，逐步分析被调用者（callee）。这种方法更具体地考虑了调用上下文，能够更精确地捕捉数据依赖关系。</p>
</li>
<li><h3 id="自底向上（Bottom-Up-BU）分析"><a href="#自底向上（Bottom-Up-BU）分析" class="headerlink" title="自底向上（Bottom-Up, BU）分析"></a>自底向上（Bottom-Up, BU）分析</h3><p>自底向上的分析方法从被调用者（callee）开始，逐步分析调用者（caller）。这种方法需要假设所有可能的调用上下文，但更容易并行化。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520103309407.png" alt="image-20250520103309407"></p>
</li>
</ol>
</li>
</ol>
<h3 id="DFA-as-Graph-Reachability"><a href="#DFA-as-Graph-Reachability" class="headerlink" title="DFA as Graph Reachability"></a>DFA as Graph Reachability</h3><ol>
<li>图可达性问题<ol>
<li>图可达性问题是图论中的一个基本问题，用于判断从一个节点到另一个节点是否存在路径。在数据流分析中，图可达性问题可以用来确定数据在程序中的流动路径。</li>
<li><strong>节点</strong>：表示程序中的基本块（Basic Blocks），即一段没有分支的代码序列。</li>
<li><strong>边</strong>：表示控制流的转移，即从一个基本块到另一个基本块的跳转。</li>
</ol>
</li>
<li>如何判断节点可达呢？两种方法：<ol>
<li>计算传递闭包</li>
<li>深度优先搜索</li>
</ol>
</li>
</ol>
<h3 id="IFDS问题"><a href="#IFDS问题" class="headerlink" title="IFDS问题"></a>IFDS问题</h3><ol>
<li><strong>I</strong>nterprocedural <strong>F</strong>inite <strong>D</strong>istributive Subset Problem：<strong>IFDS问题</strong>是一类用于交叉过程数据流分析的框架，它将数据流分析问题转化为图可达性问题，从而提供了一种高效的解决方案。IFDS框架适用于具有有限域上的分配流函数的问题，能够精确地处理全程序分析</li>
<li>特点：<ol>
<li><strong>过程间（Interprocedural）</strong>：考虑整个程序，包括过程调用和返回。</li>
<li><strong>有限（Finite）</strong>：数据流事实的定义域是有限的。</li>
<li><strong>分配性（Distributive）</strong>：流函数具有分配性，即对于任意两个数据流事实 <em>x</em> 和 <em>y</em>，有 <em>F</em>(<em>x</em>∪<em>y</em>)&#x3D;<em>F</em>(<em>x</em>)∪<em>F</em>(<em>y</em>)。</li>
</ol>
</li>
<li>传递闭包方法：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520105953438.png" alt="image-20250520105953438"><ol>
<li>能从0到达的地方代表着UNDEF</li>
</ol>
</li>
<li>一个错误的例子：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520111846295.png" alt="image-20250520111846295"><ol>
<li>有一条路径可以从0到y，但是y显然不是UNDEF（因为z&#x3D;read（）让z变为DEF，进而y&#x3D;get（z）也是DEF）。</li>
<li>原因是这条路径不是上下文敏感的。蓝色的是x&#x3D;get(z)的call，绿色的却是y&#x3D;get(z)的ret。</li>
<li>解决方法：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520112733340.png" alt="image-20250520112733340"></li>
</ol>
</li>
</ol>
</li>
<li>深度优先方法：</li>
<li>两种方法的比较：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520113018740.png" alt="image-20250520113018740"></li>
</ol>
<h3 id="Indexing-Conventional-Reachability"><a href="#Indexing-Conventional-Reachability" class="headerlink" title="Indexing Conventional Reachability"></a>Indexing Conventional Reachability</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520114748097.png" alt="image-20250520114748097"></p>
<ol>
<li><p>标签的定义</p>
<p>标签通常是一个包含两个值的数组 <code>[low, high]</code>，其中：</p>
<ul>
<li><strong><code>low</code></strong>：表示子图中的最小值。</li>
<li><strong><code>high</code></strong>：表示节点的后序遍历值（post-order value）。</li>
</ul>
</li>
<li><p>标签的性质</p>
<ol>
<li><strong><code>A → B ⇒ LabelB ⊆ LabelA</code></strong>：<ul>
<li>如果存在一条从节点 <em>A</em> 到节点 <em>B</em> 的路径，则节点 <em>B</em> 的标签必须是节点 <em>A</em> 标签的子集。</li>
<li>这是因为在路径上，节点 <em>B</em> 的 <code>low</code> 值必须大于或等于节点 <em>A</em> 的 <code>low</code> 值，而 <code>high</code> 值必须小于或等于节点 <em>A</em> 的 <code>high</code> 值。</li>
</ul>
</li>
<li><strong><code>LabelB ⊈ LabelA ⇒ A ↛ B</code></strong>：<ul>
<li>如果节点 <em>B</em> 的标签不是节点 <em>A</em> 标签的子集，则不存在从节点 <em>A</em> 到节点 <em>B</em> 的路径。</li>
<li>这是因为如果 <em>B</em> 的 <code>low</code> 值小于 <em>A</em> 的 <code>low</code> 值，或者 <em>B</em> 的 <code>high</code> 值大于 <em>A</em> 的 <code>high</code> 值，那么 <em>B</em> 一定不在 <em>A</em> 的子图中。</li>
</ul>
</li>
</ol>
</li>
<li></li>
<li></li>
</ol>
<h2 id="上下文敏感的数据依赖分析（CS-DDA）"><a href="#上下文敏感的数据依赖分析（CS-DDA）" class="headerlink" title="上下文敏感的数据依赖分析（CS-DDA）"></a>上下文敏感的数据依赖分析（CS-DDA）</h2><ol>
<li>概述<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527103256566.png" alt="image-20250527103256566"></li>
<li>同级依赖指的是相同函数中的变量依赖，不同级则是不同函数的变量</li>
<li>依赖就是“左手依赖右手”。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527103451399.png" alt="image-20250527103451399"></li>
<li>不同级依赖分析时要注意比配。不能让h()的调用匹配到了给g()的返回值</li>
</ol>
</li>
</ol>
<h3 id="同级数据依赖分析"><a href="#同级数据依赖分析" class="headerlink" title="同级数据依赖分析"></a>同级数据依赖分析</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527104131158.png" alt="image-20250527104131158"></p>
<ol>
<li><p>和“summary edge”异曲同工</p>
</li>
<li><p>关键步骤：</p>
<ol>
<li>计算TC（传递闭包）</li>
<li>更新TC</li>
</ol>
</li>
<li><p><strong>Key Observation</strong>: The graph of each function is sparse, i.e., has a low treewidth (&lt; 10)</p>
</li>
<li><p><strong>Key Result:</strong> Answer any same-level data dependence query in O(1) after a O(n + k*log n) preprocessing</p>
</li>
<li><p>如何降低计算TC的复杂度呢</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527104659476.png" alt="image-20250527104659476"></p>
</li>
<li><p>引入树分解：</p>
<ol>
<li><p>定义：</p>
<ol>
<li><h3 id="定义-树分解"><a href="#定义-树分解" class="headerlink" title="定义 [树分解]"></a>定义 [树分解]</h3><p>给定一个图 <em>G</em>&#x3D;(<em>V</em>,<em>E</em>)，图 <em>G</em> 的<strong>树分解</strong> Tree(<em>G</em>)&#x3D;(<em>V**T</em>,<em>E**T</em>) 是一个树，其中每个节点称为一个<strong>袋子</strong>（bag），每个袋子是一个顶点子集 <em>B**i</em>⊆<em>V</em>。树分解需要满足以下条件：</p>
<ol>
<li><p><strong>顶点覆盖</strong>：</p>
<ul>
<li>图中的每个顶点 <em>v</em>∈<em>V</em> 必须至少出现在一个袋子 <em>B**i</em> 中。形式化地表示为：对于每个 <em>v</em>∈<em>V</em>，存在一个袋子 <em>B**i</em>，使得 <em>v</em>∈<em>B**i</em>。</li>
</ul>
</li>
<li><p><strong>边覆盖</strong>：</p>
<ul>
<li>图中的每条边 (<em>u</em>,<em>v</em>)∈<em>E</em> 必须有一个袋子 <em>B**i</em> 包含 <em>u</em> 和 <em>v</em>。形式化地表示为：对于每条边 (<em>u</em>,<em>v</em>)∈<em>E</em>，存在一个袋子 <em>B**i</em>，使得 <em>u</em>∈<em>B**i</em> 且 <em>v</em>∈<em>B**i</em>。</li>
</ul>
</li>
<li><p><strong>连通性</strong>：</p>
<ul>
<li>对于图中的任意一个顶点 <em>v</em>∈<em>V</em>，包含 <em>v</em> 的所有袋子在树中必须形成一个连通的子树。换句话说，如果 <em>v</em> 出现在多个袋子中，这些袋子在树中必须通过边相连。</li>
</ul>
</li>
<li><h3 id="树宽"><a href="#树宽" class="headerlink" title="树宽"></a>树宽</h3><ul>
<li><p><strong>定义</strong>：图 <em>G</em> 的<strong>树宽</strong>是其所有树分解中，袋子大小的最大值减1。形式化地表示为：</p>
<p>tw(<em>G</em>)&#x3D;Tree(<em>G</em>)min(<em>B**i</em>∈Tree(<em>G</em>)max∣<em>B**i</em>∣−1)</p>
</li>
<li><p><strong>意义</strong>：树宽越小，图的结构越接近树，许多图算法在树宽较小的图上可以更高效地运行。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>理解：</p>
<ol>
<li>在同一个Bag内的节点代表能够互相到达</li>
</ol>
</li>
</ol>
</li>
<li><p>计算TC</p>
<ol>
<li>想要知道两个节点能不能互相到达，就让两个Bag从下向上爬树。如果到达了同一个Bag，就说明他们能互相到达</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="不同级数据依赖分析"><a href="#不同级数据依赖分析" class="headerlink" title="不同级数据依赖分析"></a>不同级数据依赖分析</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527112708159.png" alt="image-20250527112708159"></p>
<h1 id="Ch12-2-·-指针别名分析"><a href="#Ch12-2-·-指针别名分析" class="headerlink" title="Ch12-2 · 指针别名分析"></a>Ch12-2 · 指针别名分析</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ol>
<li>别名：two expressions that denote the same memory location</li>
</ol>
<h2 id="May-Must-Pointer-Alias-Analysis"><a href="#May-Must-Pointer-Alias-Analysis" class="headerlink" title="May&#x2F;Must Pointer Alias Analysis"></a>May&#x2F;Must Pointer Alias Analysis</h2><ol>
<li><p>定义：</p>
<ol>
<li><p><strong>May Alias（可能别名）</strong></p>
</li>
<li><p>定义：如果两个指针可能指向同一个内存位置，则称它们之间存在 May Alias 关系。</p>
</li>
<li><p><strong>Must Alias（必须别名）</strong></p>
</li>
<li><p>定义：如果两个指针一定指向同一个内存位置，则称它们之间存在 Must Alias 关系。</p>
</li>
<li><h3 id="Soundness（可靠性）"><a href="#Soundness（可靠性）" class="headerlink" title="Soundness（可靠性）"></a><strong>Soundness（可靠性）</strong></h3><p><strong>定义</strong>：一个分析方法是 <strong>sound</strong> 的，如果它能够保证所有可能的运行时行为都被考虑在内，即不会漏掉任何可能的情况。换句话说，sound 分析方法不会产生假阴性（false negatives）。</p>
</li>
<li><h3 id="Completeness（完整性）"><a href="#Completeness（完整性）" class="headerlink" title="Completeness（完整性）"></a><strong>Completeness（完整性）</strong></h3><p><strong>定义</strong>：一个分析方法是 <strong>complete</strong> 的，如果它能够精确地描述所有可能的运行时行为，即不会引入任何假阳性（false positives）。换句话说，complete 分析方法能够完全准确地描述指针之间的关系。</p>
</li>
<li><h3 id="Over-approximation（过近似）（上近似）"><a href="#Over-approximation（过近似）（上近似）" class="headerlink" title="Over-approximation（过近似）（上近似）"></a><strong>Over-approximation（过近似）（上近似）</strong></h3><p><strong>定义</strong>：Over-approximation 是一种保守的分析方法，它会引入一些假阳性（false positives），以确保不会漏掉任何可能的情况。换句话说，over-approximation 会高估指针之间的别名关系。</p>
</li>
<li><h3 id="Under-approximation（欠近似）（下近似）"><a href="#Under-approximation（欠近似）（下近似）" class="headerlink" title="Under-approximation（欠近似）（下近似）"></a><strong>Under-approximation（欠近似）（下近似）</strong></h3><p><strong>定义</strong>：Under-approximation 是一种精确的分析方法，它会漏掉一些可能的情况（false negatives），以确保不会引入任何假阳性。换句话说，under-approximation 会低估指针之间的别名关系。</p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527114858805.png" alt="image-20250527114858805"></p>
</li>
</ol>
</li>
</ol>
<h2 id="Andersen’s-Algorithm"><a href="#Andersen’s-Algorithm" class="headerlink" title="Andersen’s Algorithm"></a>Andersen’s Algorithm</h2><ul>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530102322022.png" alt="image-20250530102322022"></li>
</ul>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530103232544.png" alt="image-20250530103232544"></p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol>
<li><p>如何证明表达式是正则的？把自动机画出来。正则的定义就是能被自动机表示</p>
</li>
<li><p>如何证明表达式不是正则的？Pumping Lemma。</p>
</li>
<li><p>泵引理可以证明不是RL，但是不能证明是RL。当存在至少一种情况不会改变文法结构时，泵引理失效。</p>
</li>
<li><p>确定有限自动机的五元组要搞清楚</p>
</li>
<li><p>字符串能否被NFA接受</p>
</li>
<li><p>正则到NFA转换为DFA</p>
<ol>
<li>正则变为NFA，关注几个基本方法</li>
<li>NFA到DFA：子集构造法<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250529210604379.png" alt="image-20250529210604379"><ol>
<li>先得到初始状态集，即只需要𝜖就能到达</li>
<li>然后经过一次字符运算，得到新的集合</li>
<li>把新的集合拿出来继续迭代<ul>
<li>有点像workLIst算法，算到不动点</li>
</ul>
</li>
<li>带终结状态的集合作为DFA的终结状态</li>
<li>最后可能需要最小化</li>
</ol>
</li>
</ol>
</li>
<li><p>DFA最小化：</p>
<ol>
<li>把终结态和非终结态分为两个集合</li>
<li>最每个集合中的每个状态进行传递，把结果落在相同集合的状态放一起，不同的则分开来成为新的集合</li>
<li>迭代</li>
<li>等价则只保留一个</li>
</ol>
</li>
</ol>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol>
<li>所有正则语言都是上下文无关语言</li>
<li>对于一个题，可以先写出正则语言</li>
<li>如何表示$a^nb^m,n!&#x3D;m$<ol>
<li>$S-&gt;aSb|X|Y,X-&gt;aX|𝜖,Y-&gt;bY|𝜖$</li>
<li>就是ab先相同，最后多出来几个a或者几个b</li>
</ol>
</li>
<li>PDA：$a^ib^jc^k,i&#x3D;j,or,j&#x3D;k$</li>
<li>$a^nb^n$是CFL，但不是RL</li>
<li>$a^nb^nc^n$不是CFL</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601210954519.png" alt="image-20250601210954519"></li>
</ol>
<h3 id="RL和CFL"><a href="#RL和CFL" class="headerlink" title="RL和CFL"></a>RL和CFL</h3><ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250307112214690.png" alt="image-20250307112214690"></p>
<blockquote>
<ol>
<li>假设L是CFL，</li>
<li>令L交$a^*b^<em>c^</em>$，后者为RL，则整体为CFL</li>
<li>交下来结果是$a^nb^nc^n$，不是CFL</li>
<li>矛盾，假设不成立</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="Puming-Lemma-for-CFL"><a href="#Puming-Lemma-for-CFL" class="headerlink" title="Puming Lemma for CFL"></a>Puming Lemma for CFL</h3><ol>
<li>{$a^nb^{n^2}$}</li>
</ol>
<h3 id="Top-down-parsing自上而下分析"><a href="#Top-down-parsing自上而下分析" class="headerlink" title="Top-down parsing自上而下分析"></a>Top-down parsing自上而下分析</h3><ol>
<li><p>$$<br>A\to{Ba}\newline<br>B\to{dab}\newline<br>B\to{Cb}\newline<br>C\to{cB}\newline<br>C\to{Ac}\newline<br>$$</p>
<ol>
<li><p>消除左递归：带入消除。但是$B\to{cBd}$这样的消不掉，保留。</p>
</li>
<li><table>
<thead>
<tr>
<th align="left">符号</th>
<th align="center">First</th>
<th align="right">Follow</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="center">a</td>
<td align="right">&#x2F;</td>
</tr>
<tr>
<td align="left">b</td>
<td align="center">b</td>
<td align="right">&#x2F;</td>
</tr>
<tr>
<td align="left">c</td>
<td align="center">c</td>
<td align="right">&#x2F;</td>
</tr>
<tr>
<td align="left">d</td>
<td align="center">d</td>
<td align="right">&#x2F;</td>
</tr>
<tr>
<td align="left">A</td>
<td align="center">c, d</td>
<td align="right">$, d</td>
</tr>
<tr>
<td align="left">B</td>
<td align="center">c, d</td>
<td align="right">c, d</td>
</tr>
<tr>
<td align="left">C</td>
<td align="center">c, d</td>
<td align="right">c</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>LL(1)文法：</p>
<ol>
<li>特点：<ol>
<li>无左递归</li>
<li>无二义性</li>
<li>最左推导</li>
</ol>
</li>
<li>判断方法：First 和 Follow 集合<ol>
<li>为了判断一个文法是否是 LL(1) 文法，需要计算每个非终结符的 <strong>First 集合</strong> 和 <strong>Follow 集合</strong>：<ol>
<li>First(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身<ol>
<li>First(A)要么是终结符，要么是𝜖</li>
</ol>
</li>
<li>Follow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。<ol>
<li>理解：<ol>
<li>Follow(A)要么是终结符，要么是$。</li>
<li>S是开头，$是结尾</li>
<li>不能有𝜖</li>
</ol>
</li>
<li>计算：<ol>
<li>Follow(S) &#x3D; {$}</li>
<li>若$A\to{BD}$，则把First(D) \ {𝜖}加入Follow(B)</li>
<li>若$A\to{aB}$，注意，此时A的follow一定是B的follow，换言之Follow(A)是Follow(B)的子集。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>求出来了FIrst和Follow，如何判断文法是不是LL(1)文法呢？<ol>
<li>观察，无左递归</li>
<li>无二义性：对于每个非终结符 <em>A</em> 的产生式 <em>A</em>→<em>α</em> 和 <em>A</em>→<em>β</em>，检查 First(<em>α</em>) 和 First(<em>β</em>) 是否有交集。例<ol>
<li>对于 <em>A</em>→<em>a</em> 和 <em>A</em>→<em>ϵ</em>，First(<em>a</em>)&#x3D;{<em>a</em>} 和 First(<em>ϵ</em>)&#x3D;{<em>ϵ</em>} 互斥。</li>
<li>如不互斥，则不是LL(1)文法</li>
</ol>
</li>
<li>First 集和 Follow 集的互斥性<ol>
<li>如果 <em>α</em> 可以推导出空串 <em>ϵ</em>，则检查 First(<em>β</em>) 和 Follow(<em>A</em>) 是否有交集。</li>
<li>对于 <em>A</em>→<em>ϵ</em>，First(<em>ϵ</em>)&#x3D;{<em>ϵ</em>} 和 Follow(<em>A</em>)&#x3D;{<em>b</em>,$} 互斥</li>
<li>如果有交集，则文法不是 LL(1) 文法。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>预测分析表：预测分析表是实现 LL(1) 语法分析的关键工具。它通过 First 集和 Follow 集的计算，帮助分析器在解析输入字符串时选择合适的产生式进行推导。</p>
<ol>
<li><p>预测分析表的结构</p>
<p>预测分析表是一个二维表，其结构如下：</p>
<ul>
<li><strong>行</strong>：对应文法中的非终结符。</li>
<li><strong>列</strong>：对应输入符号（包括终结符和输入结束符 $）。</li>
<li><strong>表项</strong>：每个表项存储一个产生式或特殊标记（如错误标记或空产生式 <em>ϵ</em>）。</li>
</ul>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601211756710.png" alt="image-20250601211756710"></p>
</li>
</ol>
</li>
</ol>
<h3 id="Bottom-Up-Parsing自下而上分析"><a href="#Bottom-Up-Parsing自下而上分析" class="headerlink" title="Bottom-Up Parsing自下而上分析"></a>Bottom-Up Parsing自下而上分析</h3><ol>
<li>位移规约解析<ol>
<li>位移规约解析是一种自底向上的语法分析方法，广泛应用于编译器设计中。它通过将输入符号逐步推入栈中，并根据文法规则进行规约，最终生成语法树。位移规约解析的核心在于两个基本操作：<strong>位移（Shift）</strong> 和 <strong>规约（Reduce）</strong>。</li>
<li>基本概念<ol>
<li><strong>位移（Shift）</strong><ol>
<li>操作：将输入符号从输入缓冲区移动到分析栈的栈顶。</li>
<li>目的：将输入符号逐步推入栈中，为后续的规约操作做准备。</li>
</ol>
</li>
<li><strong>规约（Reduce）</strong><ol>
<li>操作：根据文法规则，将栈顶的若干符号替换为规则的左侧非终结符。</li>
<li>目的：逐步构建语法树，将输入符号归约为更高层次的语法结构。</li>
</ol>
</li>
<li><strong>句柄</strong>：具体来说，句柄是当前栈顶符号序列中<strong>最左边</strong>的一个子序列，该子序列可以匹配某个产生式的右侧。</li>
</ol>
</li>
<li>位移规约解析的步骤<ol>
<li>初始化：<ul>
<li>创建一个分析栈，初始时栈中只有一个特殊的起始符号（如 <code>$</code>）。</li>
<li>创建一个输入缓冲区，包含输入符号和输入结束符（如 <code>$</code>）。</li>
</ul>
</li>
<li>分析过程：<ul>
<li>重复以下步骤，直到分析栈和输入缓冲区都为空：<ol>
<li>位移操作：<ul>
<li>如果当前<strong>输入</strong>符号是一个终结符，并且根据当前状态和输入符号，应该进行位移操作，则将输入符号推入分析栈，并移动输入指针到下一个符号。</li>
</ul>
</li>
<li>规约操作：<ul>
<li>如果<strong>分析栈</strong>的栈顶符号可以匹配某个产生式的右侧，则根据该产生式进行规约操作。将产生式右侧的符号从栈顶弹出，并将产生式左侧的非终结符推入栈中。</li>
</ul>
</li>
<li>接受状态：<ul>
<li>如果分析栈中只剩下起始符号和输入结束符，且输入缓冲区为空，则解析成功。</li>
</ul>
</li>
<li>错误处理：<ul>
<li>如果无法进行位移或规约操作，则报告语法错误。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601213025655.png" alt="image-20250601213025655"></li>
</ol>
</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol>
<li><p>SDT语法制导翻译，和SDD很像：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530161958331.png" alt="image-20250530161958331"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530164309828.png" alt="image-20250530164309828"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530164235753.png" alt="image-20250530164235753"></li>
</ol>
</li>
<li><p>SDD：语法制导的定义</p>
<ol>
<li>SDD三要素：文法，属性，规则</li>
<li>S属性定义：父节点的值有子节点计算出来。</li>
<li>L属性定义：产生式中某个节点的值只能由其左侧的值求出。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602145848506.png" alt="image-20250602145848506"></li>
<li>属性：<ol>
<li>综合属性.syn：<ol>
<li>用的是自身的产生式所关联的语义规则来定义</li>
<li>即通过N的子节点或本身的属性值来定义</li>
</ol>
</li>
<li>继承属性.inh：<ol>
<li>用的是父节点所关联的语义规则来定义</li>
<li>即通过N的父节点、本身或兄弟节点的属性值来定义</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530110305304.png" alt="image-20250530110305304"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601213830036.png" alt="image-20250601213830036"></p>
<ol>
<li>左图是传统的左递归，右图是右递归（消除左递归的结果）</li>
<li>左图是自底向上计算，右图是从顶往下计算</li>
<li>右图.inh是指继承属性，即从父节点或兄弟节点获得的值。.syn是综合属性，即向父节点传送的值</li>
</ol>
</li>
<li><p>公式：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250311103010549.png" alt="image-20250311103010549"></p>
</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li><p>DAG：有向无环图</p>
<ol>
<li>从下往上画，箭头指向父节点</li>
<li>符号写在节点下面</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250530171736424.png" alt="image-20250530171736424"></li>
<li>被减数或者被除数放在左边</li>
<li>在<strong>表达式计算</strong>或<strong>代码优化</strong>时，<strong>相同的子表达式</strong>可能会重复出现。<strong>DAG 通过共享公共子表达式</strong>，减少重复计算，提高效率。</li>
</ol>
</li>
</ol>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><ol>
<li><p>栈内部有哪些必要部分？</p>
<ol>
<li>局部变量</li>
<li>返回值，参数</li>
<li>返回地址</li>
<li>data to recover(?)</li>
</ol>
</li>
<li><p>函数调用时，栈中发生了什么（即函数调用的步骤）：</p>
<ol>
<li><h3 id="调用前"><a href="#调用前" class="headerlink" title=". 调用前"></a>. 调用前</h3><ul>
<li><strong>调用者的状态保存</strong>：在调用函数之前，调用者（即调用当前函数的代码）的执行状态需要被保存。这通常包括：<ul>
<li><strong>寄存器保存</strong>：某些寄存器（如通用寄存器、状态寄存器等）的值会被保存到栈中。这些寄存器可能包含调用者的局部变量、状态信息等。</li>
<li><strong>返回地址保存</strong>：调用者的下一条指令地址（即函数调用完成后需要返回到的位置）会被保存到栈中。这个地址通常被称为返回地址。</li>
<li><strong>参数准备</strong>：调用者会将函数调用所需的参数准备好，并按照一定的顺序（通常是从右到左）压入栈中。这些参数将被传递给被调用的函数。</li>
</ul>
</li>
</ul>
<h3 id="2-调用时"><a href="#2-调用时" class="headerlink" title="2. 调用时"></a>2. 调用时</h3><ul>
<li><strong>栈帧创建</strong>：当函数被调用时，系统会为被调用的函数创建一个新的栈帧（Stack Frame）。栈帧是栈中的一个区域，用于存储函数调用期间所需的所有信息。<ul>
<li><strong>局部变量分配</strong>：被调用函数的局部变量会在栈帧中分配空间。这些局部变量只在函数调用期间有效，函数调用结束后，这些空间会被释放。</li>
<li><strong>寄存器保存与恢复</strong>：某些寄存器的值可能会被保存到栈帧中，以便在函数调用期间使用这些寄存器。函数调用结束后，这些寄存器的值会被恢复。</li>
<li><strong>函数执行</strong>：被调用的函数开始执行，它会使用栈帧中的局部变量和参数进行计算。在函数执行过程中，可能会进行更多的函数调用，从而在栈中创建更多的栈帧。</li>
</ul>
</li>
</ul>
<h3 id="3-调用后"><a href="#3-调用后" class="headerlink" title="3. 调用后"></a>3. 调用后</h3><ul>
<li><strong>返回值处理</strong>：函数执行完成后，会将返回值（如果有）存储在某个约定的位置（通常是某个寄存器或栈中的某个位置）。</li>
<li><strong>栈帧销毁</strong>：被调用函数的栈帧会被销毁。这包括释放局部变量占用的空间，恢复之前保存的寄存器值等。</li>
<li><strong>返回地址恢复</strong>：从栈中恢复之前保存的返回地址，程序控制权会跳转到这个地址，继续执行调用者的代码。</li>
<li><strong>调用者状态恢复</strong>：调用者的寄存器值等状态信息被恢复，调用者的代码继续执行。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>调用前</strong>：保存调用者的状态，准备参数。<ul>
<li>例如：sw ra, 4(sp)把调用者的返回地址线保存到栈上。</li>
</ul>
</li>
<li><strong>调用时</strong>：创建栈帧，分配局部变量空间，执行函数。<ul>
<li>例如：addi sp, sp, -4</li>
</ul>
</li>
<li><strong>调用后</strong>：销毁栈帧，恢复调用者状态，继续执行调用者的代码。<ul>
<li>例如：恢复返回地址lw ra 0(sp)，销毁栈帧：addi sp, sp, 4</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="三地址码-1"><a href="#三地址码-1" class="headerlink" title="三地址码"></a>三地址码</h3><ol>
<li><p>可能出一个快排的题目</p>
</li>
<li><p><strong>三地址语句不是三地址码！！！</strong></p>
<ol>
<li>三地址语句如x &#x3D; t + s</li>
<li>三地址码如LD R1, x</li>
</ol>
</li>
<li><p>注意翻译的时候，运算结果要先用临时变量保存，然后才可以赋值</p>
</li>
<li><p>中间码写法：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250318112510132.png" alt="image-20250318112510132"></p>
</li>
<li><p>四元式序列格式：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531153012392.png" alt="image-20250531153012392"></p>
</li>
<li><p>三元式序列格式：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531153024914.png" alt="image-20250531153024914"></p>
<ol>
<li>注意，像a &#x3D; b + c这种语句，结果是用编号表示，即#0这种，不用写a</li>
<li>但是像a &#x3D; d这种语句，要把a写出来。# 1: (&#x3D;, d, a)</li>
</ol>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601215759188.png" alt="image-20250601215759188"></p>
</li>
<li><p>间接三元式序列写法：两张表：三元式表和间接码表<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531154758707.png" alt="image-20250531154758707"></p>
<ol>
<li>三元式表：和前面的三元式表几乎一样，但是不要出现重复的语句</li>
<li>间接码表：根据三元式表的编号选择性的引用。</li>
</ol>
</li>
<li><p>对于跳转的操作符：goto, ifTrue</p>
</li>
<li><p>对于数组的操作符：</p>
</li>
<li><p>[ ]：( [ ], b, t1, t2 )     &#x2F;&#x2F; t2 &#x3D; b[ j ]</p>
</li>
<li><p>[ ]&#x3D;：( [ ]&#x3D;, a, t4, t3 )    &#x2F;&#x2F; a[ t4 ] &#x3D; t3</p>
</li>
</ol>
<h3 id="静态单赋值（有题不会）"><a href="#静态单赋值（有题不会）" class="headerlink" title="静态单赋值（有题不会）"></a>静态单赋值（有题不会）</h3><ul>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531165713429.png" alt="image-20250531165713429"></li>
</ul>
<ol>
<li><p>一般来说while的头尾会有φ函数</p>
</li>
<li><p>熟悉短路回填算法（Short-Circuit Backpatching）</p>
</li>
<li><p><strong>语句翻译（不会）</strong>：</p>
<ol>
<li>例题：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531162952427.png" alt="image-20250531162952427"><ol>
<li>先构造语法分析树：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602133052384.png" alt="image-20250602133052384"></li>
<li>注意翻译要求，要求用这里的翻译方案，所以还是要乘width</li>
<li>把每一步展开，在需要临时变量的地方做好标记</li>
<li>每一个gen都代表一条三地址码语句，但是不用写在分析树上</li>
<li>每一条规则都代表分析树上的一个信息</li>
</ol>
</li>
<li>例题：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250531170153835.png" alt="image-20250531170153835"><ol>
<li>真值列表和假值列表怎么写？</li>
<li>这两个表中装的是 goto 语句目标地址</li>
</ol>
</li>
</ol>
</li>
<li></li>
</ol>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol>
<li><p><strong>三地址语句不是三地址码！！！</strong></p>
</li>
<li><p>riscv常见的操作符：</p>
<ol>
<li>beq, bne, blt, bgt</li>
<li>JAL rd, offset   # 跳转到 PC + offset，并将返回地址存入 rd（一般为 ra</li>
<li>JALR rd, offset(rs1)</li>
<li>lw t0, 4(sp) 或 lw t0, x</li>
<li>sw t0, 4(sp) 或 sw t0, x</li>
</ol>
</li>
<li><p>图着色算法：</p>
<ol>
<li><p>思想：图着色算法</p>
<ol>
<li>先画出干扰图<ol>
<li>会同时生存的寄存器之间加一条边</li>
</ol>
</li>
<li>计算着色最少需要的颜色n<ol>
<li>若k&gt;&#x3D;n，即能够用k种颜色着色，则容易处理</li>
<li>如果k&lt;n则spilling</li>
</ol>
</li>
</ol>
</li>
<li><p>Chaitin’s Algorithm（一个图着色算法）</p>
<ul>
<li>易知，若节点的度小于k，则容易用k色着色</li>
</ul>
<ol>
<li>所以，我们先把度小于k的节点压栈，最后着色</li>
<li>如果没有，则选择一个度最小的节点放入列表。</li>
<li>若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。</li>
<li>迭代第1、2、3条</li>
</ol>
</li>
<li><p>Chaitin-Briggs Algorithm（前一个算法等等改进）</p>
<ul>
<li>思想是不急着spilling，减少spill code</li>
<li>即使没有满足要求的节点，我们也尝试把一个节点压栈。</li>
<li>不一定成功</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250408114747094.png" alt="image-20250408114747094"></li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250408114804851.png" alt="image-20250408114804851"></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol>
<li><img src="E:\Pictures\Screenshots\A4C440C08DF9249AEC705CA307F288F2.jpg" alt="A4C440C08DF9249AEC705CA307F288F2"></li>
<li>如题：<ol>
<li>y &#x3D; *q<ol>
<li>LD R1 q</li>
<li>LD R2 *R1</li>
<li>ST y R2</li>
</ol>
</li>
<li>q &#x3D; q + 4<ol>
<li>LD R1 q</li>
<li>ADD R1 R1 #4</li>
<li>ST q R1</li>
</ol>
</li>
<li>*p &#x3D; y<ol>
<li>LD R1 y</li>
<li>LD R2 p </li>
<li>ST *R2 R1</li>
</ol>
</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602150004004.png" alt="image-20250602150004004"></li>
</ol>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ol>
<li><p>为什么要寄存器分配？</p>
<ol>
<li>在避免**溢出（spill）**的情况下，<strong>减少</strong>物理寄存器使用。</li>
</ol>
</li>
<li><p>什么是寄存器生命周期？</p>
<ol>
<li>从第一次使用，到最后一次使用之前</li>
</ol>
</li>
<li><p>![b99444ab4b23b65a81f1e3906549f76b](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\b99444ab4b23b65a81f1e3906549f76b.jpg)</p>
<blockquote>
<ol>
<li>第4条已经解答</li>
<li>2个。注意，不要简单的从左往右写，这样的话就要从头到尾保存a-1的值，没用。</li>
<li>略</li>
</ol>
</blockquote>
<ol start="6">
<li>![50304d832c5dcecacb25ff2c46c45764](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\50304d832c5dcecacb25ff2c46c45764.jpg)</li>
</ol>
<blockquote>
<ol>
<li>false。</li>
</ol>
</blockquote>
<ol start="7">
<li><p>![27eb905b5102524f832632dd4a80b887](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\27eb905b5102524f832632dd4a80b887.jpg)</p>
</li>
<li><p>![f16c9d6b485184730df0a5cc65dbe63c](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\f16c9d6b485184730df0a5cc65dbe63c.jpg)</p>
</li>
<li><p>![a8247b709ef323d292ac02e78aec1289](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\a8247b709ef323d292ac02e78aec1289.jpg)</p>
<blockquote>
<ol>
<li>画出生命周期图，看重叠部分，就是无溢出所需要的寄存器。然后画依赖图，只要同时存在就连边。</li>
</ol>
</blockquote>
</li>
<li><p>![7c4f7ce31b032857b2dd3f88abe841f4](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\7c4f7ce31b032857b2dd3f88abe841f4.jpg)</p>
<blockquote>
<ul>
<li>不用考虑控制流的问题，直接看行号。</li>
<li>注意生命周期是到最后一次使用的前一行</li>
</ul>
</blockquote>
</li>
<li><p>![f4142ea4341eeaf67c4317ef4b43721e](E:\Documents\Tencent Files\2087179041\nt_qq\nt_data\Pic\2025-04\Ori\f4142ea4341eeaf67c4317ef4b43721e.jpg)</p>
<blockquote>
<ol>
<li>要先画依赖图</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="支配"><a href="#支配" class="headerlink" title="支配 ***"></a>支配 ***</h3><ol>
<li><p>支配：</p>
<ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250325103734981.png" alt="image-20250325103734981"></p>
<ol>
<li>A支配B：从入口开始进入B的所有路径一定经过A</li>
<li>A后支配B：从B开始到出口的所有路径一定经过A</li>
<li>A严格支配B：A支配B但是A不等于B。所有基本块都支配自己，但它们不会严格支配自己</li>
<li>A立即支配B：A严格支配B，且不存在A严格支配C的同时C严格支配B</li>
</ol>
</li>
<li><p>支配树：支配树是一个有向树，其中每个节点的父节点是它的立即支配节点。支配树的根是控制流图的入口节点。</p>
<ol>
<li><p>图中边的类型（基于支配树的 DFS）</p>
<p>假设我们从控制流图（CFG）入口出发进行 <strong>深度优先遍历（DFS）</strong>，那么访问过程中，图的边可以被分类如下：</p>
<h3 id="1-树边（Tree-edge）"><a href="#1-树边（Tree-edge）" class="headerlink" title="1. 树边（Tree edge）"></a>1. <strong>树边（Tree edge）</strong></h3><ul>
<li>DFS 过程中沿着尚未访问的子节点走的边。</li>
<li>组成 DFS 树的主干结构。</li>
<li>就是存在于支配树中的边</li>
</ul>
<h3 id="2-前进边（Forward-edge）"><a href="#2-前进边（Forward-edge）" class="headerlink" title="2. 前进边（Forward edge）"></a>2. <strong>前进边（Forward edge）</strong></h3><ul>
<li>指向已访问过的“后代”节点（在 DFS 树中向下跳过中间层级）。</li>
</ul>
<h3 id="3-后退边（Back-edge）"><a href="#3-后退边（Back-edge）" class="headerlink" title="3. 后退边（Back edge）"></a>3. <strong>后退边（Back edge）</strong></h3><ul>
<li>指向已访问过的“祖先”节点（常表示<strong>循环结构</strong>，例如回跳到循环头）。</li>
</ul>
<h3 id="4-交叉边（Cross-edge）"><a href="#4-交叉边（Cross-edge）" class="headerlink" title="4. 交叉边（Cross edge）"></a>4. <strong>交叉边（Cross edge）</strong></h3><ul>
<li>指向非祖先也非后代的<strong>其他分支的节点</strong>。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>如何判断一个流图是<strong>可规约</strong>的？<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602152334869.png" alt="image-20250602152334869"></p>
<ol>
<li>一个控制流图是可规约的，当且仅当：<ul>
<li><strong>所有的后退边（Back Edges）</strong> <code>X → Y</code> 满足：<ul>
<li><code>Y</code> 是 <code>X</code> 的**支配者（dominator）&#96;，即所有的后退边都是回边</li>
</ul>
</li>
<li>**其余的边（非后退边）*<em>构成的图是*<em>无环的</em></em></li>
</ul>
</li>
</ol>
</li>
<li><p>计算流图的深度：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602152632442.png" alt="image-20250602152632442"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602152728775.png" alt="image-20250602152728775"></p>
</li>
<li><p><strong>自然循环</strong>：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602152823700.png" alt="image-20250602152823700"></p>
<ol>
<li>只有一个入口header，且header要能支配循环中所有的节点</li>
<li>最大的强联通分量（强联通分量：任意两个节点都可以到达）</li>
<li>一个图可以有多个自然循环。可以通过抓回边来找</li>
</ol>
</li>
<li><p>若a dom c且b dom c，证明a, b之间有支配关系</p>
<blockquote>
<p>考虑支配数，a到c有边，b到c有边，求证ab之间有边</p>
</blockquote>
</li>
<li><p>在CFG（控制流图）中有$a\to{b}$，证明idon(b) dom a。</p>
<blockquote>
<p>考虑反证法</p>
</blockquote>
</li>
<li><p>画支配树可以倒过来想，从最后开始找支配节点。因为节点可以有很多子节点，但是只有唯一的父节点。</p>
</li>
<li><p>找支配前沿时，配合支配树更快</p>
</li>
</ol>
<h2 id="ch9-1"><a href="#ch9-1" class="headerlink" title="ch9-1"></a>ch9-1</h2><ol>
<li>流控制当中，要会worklist算法</li>
<li>数据流方程</li>
<li>能举例，什么是“可分配的控制流分析”。先分配再传递和先传递再分配结果相同，就是可分配。f(a v b) &#x3D; f(a) v f(b).</li>
<li>会证明worklist算法的收敛性（可终止）：单调有界。<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250506103954853.png" alt="image-20250506103954853"></li>
</ol>
</li>
<li>一句话解释什么是数据流分析</li>
<li>The Lazy Code Motion Problem是什么（3点），怎么办（4点）</li>
</ol>
<h3 id="三大经典DFA-1"><a href="#三大经典DFA-1" class="headerlink" title="三大经典DFA ***"></a>三大经典DFA ***</h3><ol>
<li>reaching definition<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162651074.png" alt="image-20250601162651074"></li>
</ol>
</li>
<li>Available Expressions<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162721099.png" alt="image-20250601162721099"></li>
<li>gen中这些表达式都在本块中<strong>被明确计算</strong>，并且在到达前、计算后，<strong>没有变量被重新赋值影响它们</strong>。换言之，凡是包含重新定义的表达式都是kill</li>
<li>注意这里的表达式都是‘&#x3D;’右边的式子</li>
</ol>
</li>
<li>Live Variable Analysis<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162709850.png" alt="image-20250601162709850"></li>
</ol>
</li>
</ol>
<h2 id="ch9-2"><a href="#ch9-2" class="headerlink" title="ch9-2"></a>ch9-2</h2><ol>
<li><p>复习加法器原理，考试可能考在PL或FOL上</p>
</li>
<li><p>优化方法解释：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602150656533.png" alt="image-20250602150656533"></p>
<ol>
<li><p>消除公共⼦表达式：顾名思义</p>
</li>
<li><p>对归纳变量进⾏强度消减：</p>
<ol>
<li>将<strong>计算代价高的运算</strong>（如乘法、除法）转换为<strong>计算代价低的运算</strong>（如加法、移位），<strong>前提是语义不变</strong>。</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601154304668.png" alt="image-20250601154304668"></li>
</ol>
</li>
<li><p>消除归纳变量：</p>
<ol>
<li><p><strong>归纳变量</strong>是指在循环中<strong>线性变化的变量</strong>（如 <code>i = i + 1</code>, <code>j = j + 2</code>, <code>x = x - 3</code>）。</p>
<blockquote>
<p>如果一个归纳变量能被另一个归纳变量线性表示，就可以<strong>消除冗余变量</strong>，减少空间&#x2F;计算。</p>
</blockquote>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601154519643.png" alt="image-20250601154519643"></p>
</li>
</ol>
</li>
<li><p>复制传播和死代码消除：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250602150853983.png" alt="image-20250602150853983"></p>
</li>
<li><p>常量折叠</p>
</li>
<li><p>代码移动</p>
</li>
</ol>
</li>
</ol>
<h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>1.<br>2. Tseitin Transformation：</p>
<ol>
<li>Tseitin Transformation 是一种将命题逻辑公式转换为合取范式（CNF）的方法，同时保持可满足性不变，即转换后的公式与原公式等可满足</li>
<li>步骤：<ol>
<li>把原来的每个节点全部用新的符号代替，然后把</li>
</ol>
</li>
</ol>
<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ol>
<li>依赖图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250415103857514.png" alt="image-20250415103857514"></li>
<li></li>
</ol>
<h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1><ol>
<li><p>IFDS问题。画图<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250520105953438.png" alt="image-20250520105953438"><br>1. </p>
</li>
<li><p><strong>CS-DDA</strong></p>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250527113455654.png" alt="image-20250527113455654"></p>
</li>
<li><p>Andersen算法和图</p>
<ol>
<li>如何根据程序表示集合关系，如何画图，</li>
</ol>
</li>
</ol>
<h1 id="复习重点"><a href="#复习重点" class="headerlink" title="复习重点"></a>复习重点</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="part1-·-Regex，NFA，DFA"><a href="#part1-·-Regex，NFA，DFA" class="headerlink" title="part1 · Regex，NFA，DFA"></a>part1 · Regex，NFA，DFA</h3><ol>
<li>正则语言是指能够被NFA接受的语言</li>
<li>掌握正则到NFA到（min）DFA的转换<ol>
<li>$正则\to{NFA}$<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618131723617.png" alt="image-20250618131723617"></li>
<li>$NFA\to{DAF}$：子集构造法</li>
<li>$DFA\to{(min)DFA}$</li>
</ol>
</li>
<li>掌握正则语言</li>
</ol>
<h3 id="part2-·-CFG-and-Parsing"><a href="#part2-·-CFG-and-Parsing" class="headerlink" title="part2 · CFG and Parsing"></a>part2 · CFG and Parsing</h3><ol>
<li><p>一个上下文无关语言是一个四元组：G &#x3D; ( N, T, S, P )</p>
<ol>
<li>N：非终结符集合</li>
<li>T：终结符集合</li>
<li>S：起始符号（S ∈ N）</li>
<li>P：产生式规则集合</li>
</ol>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618135828457.png" alt="image-20250618135828457"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618135811577.png" alt="image-20250618135811577"></p>
</li>
<li><p>递归下降</p>
<ol>
<li>左递归问题<ol>
<li>直接左递归：用公式<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618140443487.png" alt="image-20250618140443487"></li>
<li>间接左递归：<strong>怎么消？</strong><ol>
<li>带入消除<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618140627168.png" alt="image-20250618140627168"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618140635824.png" alt="image-20250618140635824"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618140654350.png" alt="image-20250618140654350"></li>
<li>对于B的部分就可以不用管了，因为打破了间接循环依赖</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>回溯问题<ol>
<li>LL(1)文法：<ol>
<li>特征：<ol>
<li>无左递归</li>
<li>无二义性</li>
<li>最左推导</li>
<li>除此之外要注意：一次只看一个符号</li>
</ol>
</li>
<li>建立<strong>预测表</strong><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618142606727.png" alt="image-20250618142606727"><ol>
<li>栈是要推导的文法，而输入是待匹配的字符串</li>
<li>左侧非终结符是栈顶符号，输入字符就是下一个待匹配的字符</li>
</ol>
</li>
<li>计算First，Follow：<ol>
<li>First(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身<ol>
<li>First(A)要么是终结符，要么是𝜖</li>
</ol>
</li>
<li>Follow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。<ol>
<li>理解：<ol>
<li>Follow(A)要么是终结符，要么是$。</li>
<li>S是开头，$是结尾</li>
<li>不能有𝜖</li>
</ol>
</li>
<li>计算：<ol>
<li>Follow(S) &#x3D; {$}</li>
<li>若$A\to{BD}$，则把First(D) \ {𝜖}加入Follow(B)</li>
<li>若$A\to{aB}$，注意，此时A的follow一定是B的follow，换言之Follow(A)是Follow(B)的子集。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如何构建预测表：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618143451757.png" alt="image-20250618143451757"></li>
<li>若对应位置已有内容，不要覆盖</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="part3-·-IR-Generation"><a href="#part3-·-IR-Generation" class="headerlink" title="part3 · IR Generation"></a>part3 · IR Generation</h3><ol>
<li>三地址码<ol>
<li>注意t &#x3D; a [ p ]不用手动乘元素大小</li>
<li>快排</li>
</ol>
</li>
<li>SSA<ol>
<li>特征<ol>
<li>每个变量只有一次定义</li>
<li>用φ合并</li>
</ol>
</li>
</ol>
</li>
<li>支配树<ol>
<li>支配的相关概念：<ol>
<li>立即支配：Immediate dominance – A strict-dom B, but there’s no C, such that A strict-dom C, C strict-dom B</li>
</ol>
</li>
<li>什么是支配树，或者说如何构建支配树<ol>
<li>支配树是一个有向树结构，反映了控制流图中所有基本快之间的支配关系</li>
<li><strong>支配树中的父节点立即支配子节点</strong></li>
</ol>
</li>
<li>证明支配树为什么是树，即证明表示支配关系的图一定是树？<ol>
<li>要证明一个图是树，就要证明三点：<ol>
<li>除了根节点之外，每个节点只有一个父节点</li>
<li>图是连通的</li>
<li>无环</li>
</ol>
</li>
<li>要证明立即支配图是树结构，也是从这三点下手<ol>
<li>唯一父节点：显然，根节点就是入口节点。除此之外，所有节点的立即支配节点是唯一的。<ol>
<li>反证法：假设节点A有两个立即支配节点B, C，作为两个同时支配A的节点，他们之间一定有支配关系。但是这违反了立即支配的定义，所以假设不成立。</li>
</ol>
</li>
<li>图是连通的：显然。</li>
<li>图是无环的：<ol>
<li>反证法：假设存在环路，则可以推导出 A 立即支配 A 本身，立即支配是严格支配，则说明A !&#x3D; A，矛盾。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>支配前沿（DF）<ol>
<li>定义：<ol>
<li>给定控制流图（CFG）中的基本块 <em>D</em>，它的**支配前沿（DF）**是所有满足以下条件的基本块 <em>X</em> 的集合：<ol>
<li><em>D</em> <strong>支配</strong> <em>X</em> 的某个<strong>前驱（predecessor）</strong> <em>P</em>（即 <em>D</em> dom <em>P</em>），</li>
<li>但 <em>D</em> <strong>不严格支配</strong> <em>X</em>（即 <em>D</em> 不是 <em>X</em> 的最近支配者，或者说 <em>X</em> 不在 <em>D</em> 的支配树子树中）。</li>
</ol>
</li>
</ol>
</li>
<li>迭代支配前沿（IDF）<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618153542522.png" alt="image-20250618153542522"></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="中端"><a href="#中端" class="headerlink" title="中端"></a>中端</h2><h3 id="part1-·-Data-Flow-Analysis"><a href="#part1-·-Data-Flow-Analysis" class="headerlink" title="part1 · Data Flow Analysis"></a>part1 · Data Flow Analysis</h3><ol>
<li><p>三大数据流分析</p>
<ol>
<li>reaching definition<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162651074.png" alt="image-20250601162651074"></li>
</ol>
</li>
<li>Available Expressions<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162721099.png" alt="image-20250601162721099"></li>
<li>gen中这些表达式都在本块中<strong>被明确计算</strong>，并且在到达前、计算后，<strong>没有变量被重新赋值影响它们</strong>。换言之，凡是包含重新定义的表达式都是kill</li>
<li>注意这里的表达式都是‘&#x3D;’右边的式子</li>
<li>注意是<strong>取交集</strong></li>
<li>注意kill要检查的表达式包括块内使用的和 IN 中的表达式。都要检查</li>
</ol>
</li>
<li>Live Variable Analysis<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250601162709850.png" alt="image-20250601162709850"></li>
<li>注意是<strong>逆向分析</strong></li>
</ol>
</li>
</ol>
</li>
<li><p>worklist算法</p>
<ol>
<li><p>大意：</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618155858785.png" alt="image-20250618155858785"></li>
<li>初始化所有 basic block 的 IN[B] &#x2F; OUT[B]；</li>
<li>把所有 block 加入工作列表；</li>
<li>while 工作列表非空：<ol>
<li>从列表中取出一个 block；</li>
<li>用 transfer function 和 meet operator 更新 OUT[B] 或 IN[B]；</li>
<li>如果值变化了，则把它的前驱&#x2F;后继加入列表。</li>
</ol>
</li>
</ol>
</li>
<li><p>证明该算法的收敛性：</p>
<ol>
<li>有限性：数据流值域是有限集合的半格。数据流框架中的每个变量取值都是从某个有限集中选出的，n个元素最多有2^n^个集合。</li>
<li>单调性：每次更新一个节点的 IN&#x2F;OUT 时，都是在偏序半格上“下降”（如求交 ∩）或“上升”（如求并 ∪）</li>
<li>单调有限则收敛</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="part2-·-Symbolic-Execution"><a href="#part2-·-Symbolic-Execution" class="headerlink" title="part2 · Symbolic Execution"></a>part2 · Symbolic Execution</h3><ol>
<li><p>分类：</p>
<ol>
<li>Path Sensitivity：分析会区分程序中的<strong>不同执行路径</strong>（如 if-else 分支），并分别处理每条路径上可能的状态。</li>
<li>Flow Sensitivity：分析考虑程序中<strong>指令执行的顺序</strong>，即变量值随时间变化的过程。</li>
<li>Context Sensitivity：分析考虑<strong>函数调用时的上下文</strong>，即不同调用点会分别分析函数的行为。</li>
</ol>
</li>
<li><p>掌握三类的定义，要送分</p>
</li>
<li><p>三个问题：</p>
<ol>
<li><strong>Path Explosion（路径爆炸）</strong>：指程序中<strong>可执行路径数量呈指数级增长</strong>，随着分支语句（如 if、switch）增加，分析工具必须探索的路径数迅速变得难以控制。</li>
<li><strong>Constraint Solving（约束求解）</strong>：将路径条件转化为逻辑公式，并使用约束求解器（如 SMT solver）判断是否<strong>可满足（satisfiable）</strong>，从而验证路径是否可行或生成满足条件的输入。</li>
<li><strong>External Function Call（外部函数调用）</strong>：指程序中调用了<strong>无法深入分析的函数</strong>，例如库函数、系统调用、动态链接函数，分析工具无法查看其内部实现。</li>
</ol>
</li>
<li><p>路径约束求解（Solving Path Constraints）</p>
<ol>
<li><p>命题逻辑（PL）</p>
<ol>
<li>定义：<ol>
<li>只处理布尔变量（True &#x2F; False），不包含量词、变量、函数或算术。</li>
<li>表达式例子：<code>(A ∨ B) ∧ ¬C</code></li>
<li>用于最基础的<strong>SAT（可满足性）问题</strong></li>
</ol>
</li>
<li></li>
</ol>
</li>
<li><p>一阶逻辑（FOL）</p>
<ol>
<li><p>定义：</p>
<ol>
<li>引入<strong>变量、函数、谓词、量词</strong>（如 ∀x, ∃x）</li>
<li>表达能力远高于命题逻辑，可表达整数、结构体、指针等</li>
<li>示例：<code>∀x. (x &gt; 0 → P(x))</code></li>
</ol>
<ul>
<li><strong>FOL 的可满足性是不可判定的</strong>，但很多子逻辑可以处理。</li>
</ul>
</li>
<li><p>转换为PL</p>
</li>
</ol>
</li>
<li><p>Satisfiability Modulo Theories (SMT)：</p>
<ol>
<li>定义：<strong>SMT（Satisfiability Modulo Theories）</strong> 是指判断<strong>带理论支持的一阶逻辑公式</strong>是否可满足（satisfiable）</li>
<li>简单说：<strong>SMT &#x3D; 一阶逻辑 + 理论（如整数、数组、位运算）</strong></li>
<li>解决步骤：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618171712068.png" alt="image-20250618171712068"><ol>
<li>Word-Level Preprocessing（字级预处理）<ol>
<li>例：<code>(x &amp; 0xFF) | 0x00</code> 直接简化为 <code>x &amp; 0xFF</code></li>
<li>似乎就是化简</li>
</ol>
</li>
<li>Bit-Blasting（位爆破）<ol>
<li>把位向量逻辑公式 <strong>从一阶逻辑（FOL）转换成命题逻辑（PL）</strong></li>
<li>将每个位向量变量展开成单个位（bit）变量的集合</li>
<li>将位操作转换成对应的位层级逻辑门表达式</li>
<li>例如：一个 8 位向量变量变成 8 个布尔变量</li>
<li>这样公式就变成纯布尔公式，便于 SAT 求解器处理</li>
</ol>
</li>
<li>使用DPLL或CDCL</li>
</ol>
</li>
<li>例子：<ol>
<li>假设我们有下面的位向量公式：<ul>
<li>(x &amp; 0b1111) &#x3D; 0b1010</li>
</ul>
</li>
<li>step 1：没有可以简化的了，跳过</li>
<li>step 2：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618172323976.png" alt="image-20250618172323976"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618172334864.png" alt="image-20250618172334864"></li>
<li>step 3：用算法</li>
</ol>
</li>
</ol>
</li>
<li><p>Bit Vector Theory</p>
<ol>
<li><strong>Bit Vector Theory</strong> 是 SMT（Satisfiability Modulo Theories）中专门用于处理<strong>固定宽度二进制整数（bit vectors）及其操作</strong>的理论。</li>
<li>简单说，它让 SMT 求解器能像 CPU 那样准确处理溢出、移位、按位操作等底层行为。</li>
</ol>
</li>
</ol>
</li>
<li><p>SAT问题<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250603110011894.png" alt="image-20250603110011894"></p>
<ol>
<li>步骤:<ol>
<li>通过tseitin转换为CNF</li>
<li>用DPLL算法</li>
</ol>
</li>
</ol>
</li>
<li><p>什么是CNF, DNF, NNF</p>
<ol>
<li>NNF（否定范式）：NNF 是一种逻辑表达式的形式，其中所有否定操作（NOT）仅应用于变量，而不是子表达式。</li>
<li>CNF（合取范式）：CNF 是一种逻辑表达式的形式，其中整个表达式是一个合取（AND）的子句集合，每个子句是一个析取（OR）的原子命题（变量或其否定）集合。</li>
<li>DNF（析取范式）：DNF 是一种逻辑表达式的形式，其中整个表达式是一个析取（OR）的子句集合，每个子句是一个合取（AND）的原子命题（变量或其否定）集合。</li>
</ol>
</li>
<li><p>逻辑推导：</p>
<ol>
<li>蕴含：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618170337256.png" alt="image-20250618170337256"></li>
<li>否定：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618170056744.png" alt="image-20250618170056744"></li>
<li>分配律：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618170204728.png" alt="image-20250618170204728"></li>
</ol>
</li>
<li><p>DPLL算法：</p>
<ol>
<li>理解：就是不断地假设变量的值，使得表达式最终为真。如果推出矛盾，就回溯。如果穷举了所有可能性都没有满足的赋值，则说明不可满足。</li>
</ol>
</li>
<li><p>CDCL算法：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618172816314.png" alt="image-20250618172816314"></p>
<ol>
<li>理解：是对DPLL算法的改进。每次假设时要记录，并且推导时要画图</li>
<li>如上图的冲突图，假设x1&#x3D;0，就新建一个入度为零的节点</li>
<li>如果推出矛盾，就要分析矛盾原因。本例中就是$x_3&#x3D;1,x_7&#x3D;1,x_8&#x3D;0$导致冲突，那就说明这三个条件不能同时满足，那就把$¬x_3 ∨ ¬x_7 ∨ x_8$加入到前面，并且回溯到x3前面重新假设</li>
</ol>
</li>
<li><p>Tseitin Transformation（特斯林变换）</p>
<ol>
<li>基本思想：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618171443973.png" alt="image-20250618171443973"><ol>
<li><strong>对原公式中每个子公式</strong>，引入一个新的布尔变量，代表该子公式的值。</li>
<li><strong>用约束子句</strong>表达这个变量和子公式的等价关系。</li>
<li>最后，<strong>主变量（代表整个公式）也被引入</strong>，最后的 CNF 是这些约束和主变量的合取。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="part3-·-Pointer-Analysis"><a href="#part3-·-Pointer-Analysis" class="headerlink" title="part3 · Pointer Analysis"></a>part3 · Pointer Analysis</h3><ol>
<li>Andersen Alg. &amp; Steensgaard Alg.<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618173441994.png" alt="image-20250618173441994"><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618175218831.png" alt="image-20250618175218831"><ol>
<li>注意：<ol>
<li>这是求解缺数的表格</li>
<li>pts(p)代表p可能指向的所有对象的集合</li>
<li>x, y这些变量的本质是指针，是地址</li>
</ol>
</li>
</ol>
</li>
<li>Andersen算法:<ol>
<li>目标：静态分析程序中指针变量的 <strong>指向关系（points-to set）</strong>，即找出每个指针可能指向的所有变量或内存对象。</li>
<li>核心思想：<ol>
<li><strong>初始化</strong><br> 所有指针的 <code>pts</code> 集合为空</li>
<li><strong>扫描程序所有语句，生成约束</strong><br> 根据上面规则，将语句转为集合包含约束和元素添加约束</li>
<li><strong>约束传播</strong><br> 不断迭代求解这些约束，更新 <code>pts</code> 集合直到不再变化（达到固定点）</li>
<li><strong>结果</strong><br> 最终每个指针变量的 <code>pts</code> 集合就是它的可能指向集合</li>
</ol>
</li>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618175614916.png" alt="image-20250618175614916"></li>
</ol>
</li>
<li>Steensgaard算法：<ol>
<li>把集合包含变成等价合并</li>
</ol>
</li>
</ol>
<h3 id="part4-·-Datalog-Based-Analysis"><a href="#part4-·-Datalog-Based-Analysis" class="headerlink" title="part4 · Datalog-Based Analysis"></a>part4 · Datalog-Based Analysis</h3><ul>
<li><strong>Datalog-based analysis</strong> 就是把静态分析的规则用 Datalog 写出来，交给逻辑引擎去执行，从而实现自动、高效的程序分析。</li>
</ul>
<ol>
<li>到达定义的DataLog表示法<ol>
<li><p>三个谓词<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618193019411.png" alt="image-20250618193019411"></p>
<ol>
<li>def(B, N, X)：在 基本块 B（Block B） 中，第 N 条语句（statement N） 定义了变量 <strong>X</strong>。</li>
<li>succ(B, N, C)：按照PPT的说法，基本块C是基本块B的后继，且B有N条语句。</li>
<li>rd(B, N, C, M, X)：变量 <strong><code>X</code></strong> 在基本块 <strong><code>C</code></strong> 的第 <strong><code>M</code></strong> 条语句中被定义，该定义 可以在控制流图中传播到 基本块 <strong><code>B</code></strong> 的第 <strong><code>N</code></strong> 条语句。</li>
</ol>
</li>
<li><p>三个规则</p>
<ul>
<li>“:-”的意思是从右向左推导，如果右边成立，那么左边就成立</li>
</ul>
<ol>
<li>定义即到达：<ol>
<li><strong>rd(B, N, B, N, X) :- def(B, N, X)</strong></li>
<li>定义可以到达它自己</li>
</ol>
</li>
<li>语句内部前向传播（顺序语句）<ol>
<li><strong>rd(B, N, C, M, X) :- rd(B, N-1, C, M, X), def(B, N, Y), X≠Y</strong></li>
<li>如果定义 <code>X</code> 到达了语句 <code>N-1</code>，并且语句 <code>N</code> 没有重定义 <code>X</code>，那么 <code>X</code> 的定义也能到达语句 <code>N</code>。</li>
</ol>
</li>
<li>跨基本块传播<ol>
<li><strong>rd(B, 0, C, M, X) :- rd(D, N, C, M, X), succ(D, N, B)</strong></li>
<li>如果 <code>X</code> 的定义在 <code>(C, M)</code> 能到达基本块 <code>D</code> 的语句 <code>N</code>，并且 <code>D</code> 的语句 <code>N</code> 有控制流边到达基本块 <code>B</code>，那么我们认为这个定义在 <code>B</code> 的“开始处”（第 0 行）可达。</li>
<li>第 0 行是一个虚拟位置，代表基本块入口；</li>
</ol>
</li>
</ol>
</li>
<li><p>用法：“我们只定义规则和事实，分析过程有Datalog引擎自动完成”<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618194058524.png" alt="image-20250618194058524"></p>
</li>
<li><p>考的比较灵活，要理解。考试中可能出现新定义的谓词和规则</p>
</li>
</ol>
</li>
</ol>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="part1-·-Instruction-Selection"><a href="#part1-·-Instruction-Selection" class="headerlink" title="part1 · Instruction Selection"></a>part1 · Instruction Selection</h3><ol>
<li><p>三地址指令变机器码</p>
<ol>
<li><p>指令：写一些伪指令就好了：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618194722884.png" alt="image-20250618194722884"></p>
</li>
<li><p>注意寻址模式（<strong>How we compute the addr</strong>）：</p>
<ul>
<li>假设R2的内容是x</li>
</ul>
<ol>
<li>LD R1, a(R2)：addr &#x3D; x + a</li>
<li>LD R1, 100(R2)：addr &#x3D; x + 100</li>
<li>LD R1, #100（立即数）：R1 &#x3D; 100 </li>
<li>LD R1, *R2：addr &#x3D; MEM[ x ]</li>
<li>LD R1, *100(R2)：addr &#x3D; MEM[ x + 100 ]</li>
</ol>
</li>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618212144681.png" alt="image-20250618212144681"></p>
</li>
<li><p>对于跳转的操作符：goto, ifTrue</p>
</li>
<li><p>对于数组的操作符：</p>
<ol start="6">
<li><p>[ ]：( [ ], b, t1, t2 )     &#x2F;&#x2F; t2 &#x3D; b[ j ]</p>
</li>
<li><p>[ ]&#x3D;：( [ ]&#x3D;, a, t4, t3 )    &#x2F;&#x2F; a[ t4 ] &#x3D; t3</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="part2-·-Register-Allocation"><a href="#part2-·-Register-Allocation" class="headerlink" title="part2 · Register Allocation"></a>part2 · Register Allocation</h3><ol>
<li><p>局部寄存器分配</p>
<ol>
<li>线性扫描</li>
</ol>
</li>
<li><p>全局寄存器分配</p>
<ol>
<li><p>图着色算法Chaitin’s Algorithm：</p>
<ol>
<li><p>步骤：</p>
<ul>
<li>易知，若节点的度<strong>小于</strong>k，则容易用k色着色</li>
</ul>
<ol>
<li>所以，我们先把度<strong>小于</strong>k的节点压栈，最后着色</li>
<li>如果没有，则选择一个度最小的节点放入列表。</li>
<li>若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。</li>
<li>迭代第1、2、3条</li>
</ol>
</li>
<li><p>什么时候压栈，什么时候溢出</p>
<ol>
<li>压栈：找到度数小于k的</li>
<li>溢出：度数都不小于k</li>
<li>着色：所有节点都入栈或溢出</li>
</ol>
</li>
</ol>
</li>
<li><p>Chaitin-Briggs Algorithm（前一个算法的改进）</p>
<ul>
<li>思想是不急着spilling，减少spill code</li>
<li>即使没有满足要求的节点，我们也尝试把一个节点压栈。</li>
<li>不一定成功</li>
</ul>
</li>
</ol>
</li>
<li><p>为什么需要指令调度？</p>
<ol>
<li>从硬件的角度说，尽量利用并行性</li>
<li>从软件的角度说，把并行度高的排在一起，以便硬件并行操作</li>
</ol>
</li>
</ol>
<h3 id="part3-·-Instruction-Scheduling"><a href="#part3-·-Instruction-Scheduling" class="headerlink" title="part3 · Instruction Scheduling"></a>part3 · Instruction Scheduling</h3><ol>
<li><p>为什么要调度？</p>
<ol>
<li>现代高性能处理器每个时钟周期可以执行多个操作</li>
</ol>
</li>
<li><p>为什么编译器很重要？</p>
<ol>
<li><p>硬件只能执行已经取出的指令。</p>
<ol>
<li>处理器只能对“已经被取指单元抓取到的指令”进行操作。</li>
<li>如果下一条指令因为数据依赖、缓存未命中等原因卡住了，硬件就会停下来等，效率降低。</li>
</ol>
</li>
<li><p>硬件缓冲资源有限</p>
<ol>
<li>这些缓冲区空间非常有限，一旦塞满，就不得不停止取指、停止执行</li>
</ol>
</li>
<li><p>编译器可以通过指令调度提升效率</p>
<ol>
<li>译器分析指令之间的依赖关系，可以把无依赖的指令排在一起，尽量避免空等。</li>
<li>这使得处理器可以在一个周期里执行多个指令，提高硬件利用率</li>
</ol>
</li>
</ol>
</li>
<li><p>跨块调度不考</p>
</li>
<li><p>块内调度要考：</p>
<ol>
<li>真假依赖<ol>
<li>真：写后读</li>
<li>假：写后写，读后写</li>
</ol>
</li>
<li>依赖图：<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618203329396.png" alt="image-20250618203329396"></li>
<li>要先消除假依赖</li>
<li>标记时钟周期（深度）</li>
</ol>
</li>
<li>List Scheduling 算法<ol>
<li>只能先调度没有依赖的指令</li>
<li>优先调度深度大的</li>
<li>指令结束后从依赖图中删去</li>
<li>如果有空操作，用NOP（no operation）填充</li>
<li>迭代</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="part4-·-Exercises"><a href="#part4-·-Exercises" class="headerlink" title="part4 · Exercises"></a>part4 · Exercises</h3><ol>
<li><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618203446736.png" alt="image-20250618203446736"></p>
<ol>
<li><p>为什么需要寄存器分配？</p>
<ol>
<li>Speed: Registers &gt; Memory</li>
<li>Physical machines have limited number of registers</li>
<li><strong>Register allocation</strong>: ∞ virtual registers ➞ k physical registers</li>
</ol>
</li>
<li><p>最少需要几个寄存器？</p>
<ol>
<li>2个</li>
</ol>
</li>
<li><pre><code>LD R1, b
LD R2, c
ADD R1, R1, R2
DIV R1, R1, #3
LD R2, d
ADD R1, R2
LD R2, a
SUB R2, #1
MUL R1, R1, R2
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ![image-20250618203504267](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618203504267.png)</span><br><span class="line"></span><br><span class="line">   1. 注意要在寄存器的视角下考虑共存，不能在代码基本块的视角上看</span><br><span class="line"></span><br><span class="line">3. “重中之重”![image-20250618203535253](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250618203535253.png)</span><br><span class="line"></span><br><span class="line">   1. 注意每行出现的寄存器，仔细考虑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 笔记</span><br><span class="line"></span><br><span class="line">1. 快排写为三地址码：</span><br><span class="line"></span><br><span class="line">   1. 快排：</span><br><span class="line"></span><br><span class="line">      1. ```c++</span><br><span class="line">         procedure quicksort(A, low, high)</span><br><span class="line">         &#123;</span><br><span class="line">             if (low &lt; high)</span><br><span class="line">             &#123;</span><br><span class="line">                 pivot = partition(A, low, high)</span><br><span class="line">                 quicksort(A, low, pivot)</span><br><span class="line">                 quicksort(A, pivot + 1, high)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         procedure partition(A, low, high)</span><br><span class="line">         &#123;</span><br><span class="line">             pivot = A[low]               // 选择第一个元素作为枢轴</span><br><span class="line">             i = low - 1</span><br><span class="line">             j = high + 1</span><br><span class="line">         </span><br><span class="line">             while (true)</span><br><span class="line">             &#123;</span><br><span class="line">                 // 从左向右找第一个 &gt;= pivot 的元素</span><br><span class="line">                 repeat</span><br><span class="line">                     i = i + 1</span><br><span class="line">                 until A[i] &gt;= pivot</span><br><span class="line">         </span><br><span class="line">                 // 从右向左找第一个 &lt;= pivot 的元素</span><br><span class="line">                 repeat</span><br><span class="line">                     j = j - 1</span><br><span class="line">                 until A[j] &lt;= pivot</span><br><span class="line">         </span><br><span class="line">                 // 两指针相遇则分区完成，返回右指针 j</span><br><span class="line">                 if (i &gt;= j)</span><br><span class="line">                     return j</span><br><span class="line">         </span><br><span class="line">                 swap A[i] and A[j]        // 交换左右两边不符合顺序的元素</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>三地址码：</p>
<ol>
<li><pre><code class="language-C++">t1 = low            // i = low - 1; 但Hoare的i初始化为low - 1，稍改成low - 1
t2 = t1 - 1
i = t2

t3 = high           // j = high + 1
t4 = t3 + 1
j = t4

t5 = A[low]         // pivot = A[low]
pivot = t5

LABEL_PARTITION_LOOP:
  // 从左往右找第一个 A[i] &gt;= pivot
LABEL_SCAN_I:
  t6 = i + 1
  i = t6
  t7 = A[i]
  t8 = t7 &lt; pivot
  if t8 == true goto LABEL_SCAN_I

  // 从右往左找第一个 A[j] &lt;= pivot
LABEL_SCAN_J:
  t9 = j - 1
  j = t9
  t10 = A[j]
  t11 = t10 &gt; pivot
  if t11 == true goto LABEL_SCAN_J

  // 如果i &gt;= j跳出循环
  t12 = i &gt;= j
  if t12 == true goto LABEL_RETURN_J

  // 交换 A[i] 和 A[j]
  t13 = A[i]
  t14 = A[j]
  A[i] = t14
  A[j] = t13

  goto LABEL_PARTITION_LOOP

LABEL_RETURN_J:
return j
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><ol>
<li>开卷考试。把复习内容整理好，打印下来。</li>
<li>有三十分是概念题</li>
<li>第一题是词法分析</li>
<li>第二题是语法分析</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/blog/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
