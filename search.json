[{"title":"Java与JVM","url":"/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","content":"基础Java生命周期\n编码阶段（Writing Code）\n\n\n开发者编写源代码，文件后缀为 .java。比如：HelloWorld.java。\n源代码中包含类（class）、方法（method）等，使用 Java 语法。\n\n\n\n编译阶段（Compiling）\n\n\n使用 Java 编译器 javac 将 .java 文件编译成 字节码文件（.class）。\njavac HelloWorld.java\n\n编译后生成 HelloWorld.class 文件。\n\n注意：字节码不是机器码，而是一种中间形式，跨平台。\n\n\n\n\n类加载阶段（Class Loading）\n\n\n当运行程序时（java HelloWorld），类加载器（ClassLoader） 会把需要的 .class 文件加载进内存。\n类加载过程分为三个小步骤：\n加载（Loading）：把字节码读到内存。\n连接（Linking）：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。\n初始化（Initialization）：执行静态代码块、给静态变量赋初值。\n\n\n\n\n\n字节码执行阶段（Execution）\n\n\nJava 虚拟机（JVM）解释执行字节码，也可能使用 JIT（即时编译器） 把热点代码编译成本地机器码，以提高运行效率。\n\n执行的起点是程序入口：\npublic static void main(String[] args) &#123; ... &#125;\n\n\n\n程序运行时（Runtime）\n\n\nJVM 在运行时会：\n内存管理：使用 堆、栈、方法区、运行时常量池 等。\n垃圾回收（GC）：回收不再使用的对象内存。\n异常处理：执行过程中出现异常时，JVM 按照异常机制处理。\n\n\n\n\n\n程序终止（Termination）\n\n\n当 main 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。\n在退出前，可能会执行 finally 块、shutdown hook（关闭钩子）。\n\n\n程序生命\n\n$$.java(源码) \\underset{\\text{decompile}}{\\overset{\\text{compile}}{\\longleftrightarrow}} .class(字节码)\\xrightarrow{\\text{load}}class类\\xrightarrow{\\text{execution}}机器码\\xrightarrow{\\text{run}}结果$$\n\nJVM, JRE, JDK的关系\n\n\n\n名称\n全称\n作用\n是否包含编译器\n是否必需开发 Java 程序\n说明\n\n\n\nJVM\nJava Virtual Machine（Java 虚拟机）\n运行 Java 字节码的虚拟计算机，负责加载字节码并执行\n❌ 不包含\n❌ 不单独用于开发\n是运行 Java 程序的“引擎”\n\n\nJRE\nJava Runtime Environment（Java 运行时环境）\n运行 Java 程序所需的环境，包含 JVM + 核心类库\n❌ 不包含\n❌ 仅能运行，不能开发\n如果你只需要运行 Java 程序（比如别人的软件），安装 JRE 就够了\n\n\nJDK\nJava Development Kit（Java 开发工具包）\n开发 Java 程序所需的完整工具包，包含 JRE + 编译器（javac） + 调试工具等\n✅ 包含（javac）\n✅ 必需\n开发 Java 程序必须安装 JDK\n\n\n编译字节码（.class文件）\n.class文件是 Java 源代码（.java）经过 javac编译后生成的字节码文件，它是 平台无关的中间代码，不能直接被操作系统执行，但可以被 Java 虚拟机（JVM）加载和执行。\n\n文件结构ClassFile &#123;    u4             magic; // 魔数CAFEBABY，仅代表这个文件是java文件，没有其他作用    u2             minor_version; // 副版本号    u2             major_version; // 主版本号    u2             constant_pool_count;         // 常量池大小    cp_info        constant_pool[constant_pool_count-1]; // 常量池    u2             access_flags;                // 访问标志(public, private)    u2             this_class; // 指向当前类，是cp_info的下标    u2             super_class; // 指向父类    u2             interfaces_count;     u2             interfaces[interfaces_count]; // 接口信息    u2             fields_count;                     field_info     fields[fields_count]; // 字段信息    u2             methods_count;                   method_info    methods[methods_count]; // 方法信息    u2             attributes_count;                attribute_info attributes[attributes_count]; // 属性信息&#125;\n\ncp_infocp_info&#123;\tu1 tag;\tu1 info[]; // 大小是可变的。例如Integer就是u4 byte, String就是u2 length, u1 byte[length]。&#125;\n\n\ntag的取值表：\nthis_class指向CONSTANT_Class_Info，后者又指向一个字符串(name)。\n\nfield_infofield_info &#123;    u2             access_flags;    u2             name_index; // 本质是个下标，指向常量池    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n\naccess_flag的取值：字段可以叠加，Value取或\n\nmethod_infomethod_info &#123;    u2             access_flags;    u2             name_index;    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n描述符\n规范：前缀+类完整名（包含分号）（如果不是以下的基本类型）\n\n前缀：\n1. \n\n\n\n\nJava 类型\n描述符\n说明\n\n\n\nbyte\nB\n8-bit 整数\n\n\nchar\nC\n16-bit Unicode 字符\n\n\ndouble\nD\n64-bit 双精度浮点数\n\n\nfloat\nF\n32-bit 单精度浮点数\n\n\nint\nI\n32-bit 整数\n\n\nlong\nJ\n64-bit 整数\n\n\nshort\nS\n16-bit 整数\n\n\nboolean\nZ\n布尔类型（true&#x2F;false）\n\n\nvoid\nV\n仅用于返回类型，表示无返回\n\n\narray\n[\n表示返回数组\n\n\n\n\n\n入参的表示：用小括号包裹。\n\n例\nint func(String s) --&gt; &lt;(Ljava/lang/String;)I&gt;,   void func() --&gt; &lt;()V&gt;,  float func(double[] d ) --&gt; &lt;([D)F&gt;\n\nattributes\n属性太多了，这里仅介绍几个常见的\n\n\nConstantValue：只针对常量static final的基础类型或字符串的属性，在编译器赋值，而不是运行时，提高效率。\nCode：函数体的内容，这个是非常重要的，尤其是后面学习ASM指令，一个类主要承载的功能，都反应在了method的code里。\nException：函数中声明的抛出的异常，可以有多个。注意这里是声明的抛出的异常，不包含一些运行时的异常。\n区分Code异常表和Exception属性：通过try-catch的异常会出现在code异常表。\n\n\nLineNumberTable\nLocalVariableTable\nSignature：与泛型密切相关\n\n函数code中的指令\nload &#x2F; push\n\nload的形式有很多种，比如我们可以把本地变量load到栈顶\niload_{y}按照int或byte或char或boolean或short类型，加载第y个变量。\nlload_{y}按照long类型加载第y个变量。\nfload_{y}按照float类型加载第y个变量。\ndload_{y}按照double类型加载第y个变量。\naload_{y}按照对象类型加载第y个变量，aload_0加载this，默认第0个位置是this或者常量load到栈顶\n\n\nbipush针对byte范围的int值的load\nsipush针对short范围的int值的load\n\n\nstore：理同load\n\nreturn：\n\nreturn之后需要保证栈是空的，不然编译会验证不通过。\n\nreturn等于代码return，不消耗栈顶\nireturn消耗栈顶一帧，返回一个int或byte或char或boolean或short类型\nfreturn消耗栈顶一帧返回一个float\nlreturn消耗栈顶2帧返回一个long\ndreturn消耗栈顶2帧返回一个double\nareturn消耗栈顶一帧返回一个地址，即返回一个对象类型的内存地址\n\n注意：return不一定是代码结束的地方，可能有判断分支有多个return语句，而且还有可能是athrow抛出异常。\n\n\n\npop &#x2F; dup &#x2F; new\n\npop：如果一个栈上的操作数，想要直接消耗掉，则直接用pop指令消耗一个栈帧，比如运行了一个函数操作后，直接忽略函数的返回值就可以pop消耗掉，如果返回值是long/double可以pop两次，或者pop2指令消耗。\ndup：复制栈顶栈帧。用法同pop。这经常用于new一个对象。\nnew的过程：对应字节码，如下new指令作用是，创建一个对象会在堆上分配内存，并将内存的地址放到操作数栈上；注意这里有个dup把地址复制了一份，这是new对象的一个固定操作，因为invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;这个构造方法与普通非静态方法一样，会消耗掉一个操作数作为this。所以需要提前把地址备份一下，不然new完地址就丢了，下面会说invoke相关指令。\n\n\ninvoke\n\ninvoke是函数调用的指令，他主要有5种，\ninvokevirtual普通的可访问的方法，需要依次把对象，参数从左到右放到栈顶。\ninvokestatic静态方法，需要依次把参数从左到右放到栈顶。\ninvokespecial特殊方法，构造方法，私有方法，父类中的方法，接口的default实现等，根据情况参考上面的操作数顺序。\ninvokeinterface接口方法，栈顶操作数顺序参考上面。\ninvokedynamic动态方法，一般是lambda表达式，栈顶操作数顺序参考上面。\n\n\n\n\n跳转\n\n注意，long &#x2F; double占两个局部变量\n其实try-catch是专门记录到code的异常表中的，上面提到过异常表和异常属性的区别。\n\n\n\n常量池概述\n常量池（Constant Pool）是 Java .class文件中的一个重要组成部分，它是一个结构化的、预定义的常量表，用于存储：字面量（如字符串、数字等），符号引用（如类名、方法名、字段名、方法描述符等），其他在程序运行时或类加载时可能需要引用的常量信息。\n它不是程序运行时动态生成的，也不是只在编译期间临时存在的东西。\n字面量（Literal）如 int a = 1; 里的 1，或者 &quot;Hello&quot; 这样的字符串。\n符号引用（Symbolic Reference）\n类和接口的全限定名（例如 java/lang/String）\n字段名和描述符\n方法名和描述符\n\n\n\n分类\n静态常量池（Class File Constant Pool）\n\n位置：位于 .class 文件中。\n生成时机：编译阶段由编译器写入。\n内容：\n字面量（Literal）\n基本类型常量（如 1.2f, 100）\n字符串字面量（如 &quot;Hello&quot;）\nfinal 常量（编译期可确定的值）\n\n\n符号引用（Symbolic Reference）\n类和接口的全限定名（如 java/lang/String）\n字段名和描述符\n方法名和方法描述符\n\n\n\n\n作用：为类加载时提供原始数据。\n\n注意：静态常量池是“死”的，只存在于 .class 文件里，不会变化。\n\n\n运行时常量池（Runtime Constant Pool）\n\n\n位置：方法区的一部分（JDK 8 之后是元空间 Metaspace 中）。\n\n生成时机：类加载的 加载 → 链接 过程中，JVM 会把 .class 文件中的静态常量池信息拷贝到运行时常量池。\n\n内容：\n\n解析后的字面量（真正的 int、float、String 对象引用）。\n符号引用在 解析（Resolution）阶段 转换为 直接引用（比如指向方法区中某个方法的指针）。\n\n\n特点：\n\n是动态的，可以在运行时产生新的常量，比如 String.intern() 会把字符串放到运行时常量池。\n不仅包含编译期的常量，还包含运行期解析出来的引用。\n\n\n字符串常量池（String Constant Pool）\n\n属于运行时常量池的一部分。但是在堆区中。即逻辑上属于运行时常量池，但是物理上不在一个区。\n专门存放字符串字面量的池子。\n早期（JDK 6 及之前）在方法区，JDK 7 后移到了堆中。\n\n\n\n\n\n字符串常量池\n字符串常量池在堆中，可能存在在E区、S区、O区。在讲解时默认在E区\n\n如果通过字面量赋值，则字符串对象直接出现在常量池中。\n\nString s &#x3D; “lizhi”;\n\n\nString s &#x3D; new String(“lizhi”);\n\n\nString a = &quot;lizhi&quot;;\nString b = new String(&quot;lizhi&quot;);\nString c = &quot;li&quot; + new String(&quot;zhi&quot;);\n      ![image-20250902205758484](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205758484.png)3. intern（）方法   1. 从注释中可以比较清楚地看到，当调用intern()方法时，会判断字符串常量池中是否有该对象的引用，通过equal()方法判断，如果存在就返回字符串常量池中的对象引用。如果不存在，就把当前字符串对象直接添加到字符串常量池中，**注意这里说的把该字符串对象添加到常量池池，是指把堆中对象的引用添加到常量池，并不是在常量池中再创建一个该字符串的对象**，然后返回该对象的引用。![image-20250902205439336](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205439336.png)# 类加载## 类加载过程### 加载1. 将类的字节码载入**方法区**，并创建.class对象。   1. JVM 找到并加载类的二进制字节流。   2. 常见来源：class 文件、JAR 包、网络、甚至动态生成（如 `ASM`、`CGLIB`）。   3. JVM 为这个类生成一个 `Class` 对象，作为方法区/元空间中该类的访问入口。   4. 如果此类的父类没有加载，先加载父类   5. 加载是懒惰执行      1. 懒惰执行：需要用到的时候才执行### 链接1. 验证：验证类是否符合class规范，做合法性、安全性检查2. 准备：为**静态变量**分配空间，设置**默认值**   &gt; *可以理解为，为了安全性必须赋初始值*3. 解析：将常量池的符号引用解析为直接引用。例如方法调用时，编译期只知道方法的符号引用（静态常量池），解析阶段才会绑定到真正的方法地址。   &gt; *这里很形象，原本只是符号引用，但是解析之后就用指针把调用链串起来了。很有“链接”的意思*### 初始化1. **执行静态代码块**与**非final静态变量的赋值**   1. 执行类构造器 `&lt;clinit&gt;()` 方法（编译器自动生成），对静态变量赋值、执行静态代码块。   2. 初始化是类加载的 最后一步，也是程序员能控制的阶段。      `&lt;clinit&gt;()` 方法由编译器收集：      - 所有 **静态变量的显式赋值**      - 所有 **静态代码块**按照源码中的顺序合并。2. 初始化时懒惰执行## 触发时机1. 只会加载 / 链接，不会初始化的情况：   1. 引用一个 `static final`       &gt; 常量会在编译期被放入调用类的常量池，也就是说，运行时根本没有去访问类，只是直接用常量池里的值。   2. 获取类的 `Class` 对象（如 `String.class`）。      &gt; JVM 只需要返回一个指向 **类元信息的引用**2. 必须初始化的情况   1. `new` 一个对象。      &gt; 在创建对象前，需要保证该类的 **静态变量、静态方法、父类状态** 都处于可用的、已知的状态。   2. 访问类的静态变量或调用静态方法（非常量）。   3. 反射调用 `Class.forName()`。   4. 初始化一个类时，若其父类还没初始化，会先初始化父类。   5. JVM 启动时，执行 `main` 方法所在的类。\n\n\n\n\n\n例子：class A {    static {        System.out.println(“A init”);    }    public static final int X &#x3D; 100;   &#x2F;&#x2F; 编译期常量    public static final int Y &#x3D; new java.util.Random().nextInt(10); &#x2F;&#x2F; 运行期常量}\npublic class Test {    public static void main(String[] args) {        System.out.println(A.X); &#x2F;&#x2F; 访问 X        System.out.println(A.Y); &#x2F;&#x2F; 访问 Y    }\n}输出结果：100A init123Q1：为什么访问 X 不会触发初始化？A1：\tX &#x3D; 100 是 编译期可确定的常量（字面量）。\tJava 编译器在编译 Test 类的时候，就把 A.X 直接替换为字面量 100，并存到 Test 的常量池 中。\t也就是说，运行时根本没有去访问 A 类，只是直接用常量池里的值。\t所以不会触发 A 的初始化。\t这就是所谓的 常量传播&#x2F;常量折叠优化。\nQ2：为什么访问 Y 会触发初始化？A2：\tY 的值依赖于 new Random().nextInt(10)，这是运行时才能确定的。\t编译器无法在编译期把它折叠进常量池。\t所以，运行时访问 A.Y 时，必须先执行类的 () 方法来初始化 Y。\t这就会触发 A 的初始化。\n## 类加载器### 分类在 JVM 中，类的加载是由类加载器完成的。常见的三层体系：1. 启动类加载器（Bootstrap ClassLoader）   - C++ 实现，JVM 自带，不是 Java 类。   - 负责加载核心类库（`rt.jar`，Java 9 之后是 `java.base` 模块），即`%JAVA_HOME%/lib`2. 扩展类加载器（Extension ClassLoader / Platform ClassLoader）   - 负责加载 `JAVA_HOME/jre/lib/ext` 或 `java.ext.dirs` 下的类库，即即`%JAVA_HOME%/lib/etc`   - Java 9 之后改为 Platform ClassLoader。3. 应用类加载器（AppClassLoader）   - 负责加载 classpath 下的类（我们写的应用代码）。另外，还可以有 自定义类加载器，一般继承 `ClassLoader`。### 特性1. 用来确定类的唯一性   1. 一个类在 JVM 内存中只能有一个唯一的定义，由**类加载器 + 类的全限定名**唯一确定。二元组&lt;N（全限定名）, L（类加载器）&gt;。   1. **一个类由哪个类加载器真正加载了，那么它的 `getClassLoader()`方法返回的就是那个类加载器。**2. 传递性   ![image-20250902154447055](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154447055.png)   1. 如果类A是由L0加载的，那么A所依赖的类也要通过L0加载。   2. 即使是核心类库中的类，也要通过L0加载，但是会被委派到Bootstrap ClassLoader加载3. 可见性   ![image-20250902154812128](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154812128.png)   1. 我们说类B对于类A可见，含义是：加载A的加载器L，也可以直接或委派间接加载B   1. 在 Java 中，一个类加载器只能看到它自身以及它的 父类加载器（Parent ClassLoader）所加载的类，但看不到它的 子类加载器（Child ClassLoader） 所加载的类。## 双亲委派机制### 概述1. 为什么要双亲委派？   1. 避免重复加载（保证类的唯一性）：**如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。**   2. 保证核心类库的安全性（比如 `java.lang.String` 不会被随便篡改）。2. 什么时候打破？   1. 一般出现在一些 **特殊场景** 下，尤其是框架 / 容器需要加载用户自定义类、插件类，或者隔离不同模块时：      1. 自定义类加载器加载应用类/插件类         - 典型例子：**Tomcat、Jetty 等 Web 容器**         - 它们需要加载不同 Web 应用的类，避免不同应用之间互相干扰（类隔离）。         - Tomcat 会自己实现类加载器，不完全遵循双亲委派。      2. 实现热加载（Hot Deployment）         - 开发工具（如 IDEA、Eclipse）、Spring Boot DevTools 热部署功能，需要在运行时重新加载类。         - 如果走双亲委派，父加载器一旦加载过，就无法替换，需要自己写类加载器打破机制。      3. SPI（Service Provider Interface）机制：**顶层加载器需要调用应用类加载器**。顶层提供接口，底层实现         - Java 自带的 `ServiceLoader` 需要加载厂商提供的实现类（通常在 `META-INF/services` 里）。         - 这些实现类不能放在 JDK 的核心类加载器里，只能由 **线程上下文类加载器（Thread Context ClassLoader）** 去加载，突破双亲委派。      4. 模块/插件化系统         - 比如 OSGi、各种插件化框架，需要动态加载第三方 jar 包，并且允许卸载/升级插件。         - 通常需要定制自己的类加载逻辑，不完全依赖父加载器。      5. 字节码增强 / 动态代理         - 一些框架（Spring、MyBatis、JVM Agent、字节码增强工具 ASM/CGLIB）在运行时生成代理类。         - 这些类需要在运行时被加载进 JVM，往往会使用自定义类加载器绕过双亲委派。### 机制内容![image-20250902153715595](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153715595.png)![image-20250902153959633](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153959633.png)1. 工作过程   1. 当应用类加载器要加载一个类时，比如 `java.lang.String`。   2. 它不会自己去尝试加载，而是先 **委托给父加载器（Platform ClassLoader）**。   3. Platform ClassLoader 又委托给 Bootstrap ClassLoader   4. Bootstrap ClassLoader 如果能加载（发现 String 在核心库里），就直接返回。   5. 如果父加载器都没找到，才由子加载器自己去加载。2. 作用核心目的就是 **安全性和一致性**：   1. **保证核心类库不会被篡改**      1. 假设你写了一个自定义的 `java.lang.String` 类，如果没有双亲委派，你的 `String` 可能会被应用类加载器加载并替代系统的核心类，这是极其危险的。      2. 但因为双亲委派，加载 `java.lang.String` 的请求会交给 Bootstrap ClassLoader，它会优先加载 JDK 自带的版本，从而保证安全。   2. **保证类的唯一性**      1. 一个类在 JVM 内存中只能有一个唯一的定义（由 **类加载器 + 类的全限定名** 唯一确定）。      2. 如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。### 依赖冲突- 有一个典型的题目：有一个项目P，依赖于包B、C，这两个包又分别依赖A1.0、A2.0，且如果B用A2.0或者C用A1.0都会出错。此时如何让项目正常运行。  1. 一个类在JVM中的定义是由**&lt;类加载器+全限定名&gt;**决定的，如果在项目中用同一个类加载器加载了同一个路径下的A，就会导致冲突  2. 核心思路是让B、C分别依赖不同版本的包A，所以就要让他们依赖的A的类加载器或全限定名不一样。- 由此提出以下解决方案：  - 重构包名  - 打破双亲委派模型，使用自定义类加载器来实现类隔离  - 在Maven中显式指定依赖  - 使用兼容包### 打破双亲委派1. 重写ClassLoader中的loadClass方法2. 使用线程上下文加载器3. 为什么要打破双清委派？   1. **类隔离需求**：不同的框架、应用或模块可能需要加载 **同名但不同版本的类**，例如两个 Web 应用都用了不同版本的同一个库（如 Log4j）。如果都遵循双亲委派，所有类都由同一个类加载器加载，就会导致版本冲突。   2. **热部署 / 热加载**：在服务器环境中，我们可能希望在不重启整个 JVM 的情况下重新加载某个应用或模块，这就要求该模块的类能被独立加载和卸载，而双亲委派模型不利于这种灵活的类生命周期管理。   3. **框架/容器需要加载用户代码**：比如在 Web 容器中，容器本身和用户部署的 Web 应用可能都会用到一些公共的类（如 Servlet 相关类），但容器希望 **对这些类有统一的控制权**，同时又能让每个 Web 应用自己的类库相互隔离，避免互相干扰。## 数组类1. 所有数组实例都属于Object，每个数组实例都有自己的class2. 数组类本身不通过类加载器创建，而是通过JVM直接创建3. 数组类的元素需要类加载器创建4. 数组类也需要通过&lt;N, L&gt;唯一确定# 运行## 垃圾回收![image-20250902111808844](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902111808844.png)1. GC（Garbage Collection）发生在堆区2. 过程：   1. new对象出生在E区。当E区快满了，触发youngGC。扫描young区所有类，如果某个对象没有引用了，就打个标记，最后删除。幸存的对象复制到S区   2. S0和S1交替使用   3. 每幸存一轮，对象age加一   4. 如果某个对象达到一定年龄（可以是6岁），则转移到O区。   5. O区存放**老年对象**或**大对象**。   6. 如果O区快满了，则触发oldGC，暂停程序，全力垃圾回收。3. E区比S0区为8:14. 老年代比年轻代为2:1### 标记算法1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。   2. 有多个根对象，但是只会选用一个。      1. 栈中引用的对象      2. 常量引用的对象      3. 类静态属性引用的对象      4. Native方法引用的对象### 回收算法1. **标记清除算法**   1. 基本思想      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。   2. 优点      1. 不需要移动对象，实现相对简单   3. 缺点      1. 内存碎片化严重      2. 效率问题2. **复制算法**   1. 基本思想      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）      2. 每次只使用其中一块（如 From 区）来分配对象      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）      4. 交换角色：原来的 To 区成为新的 From 区，继续使用   2. 优点      1. 没有内存碎片！      2. 分配效率高      3. 适合对象存活率低的场景   3. 缺点      1. 浪费了一半的内存空间      2. 不适合存活对象多的场景3. **标记压缩算法**   1. 基本思想      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间   2. 优点      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）      2. 内存利用率高，适合大对象和长期存活对象分配   3. 缺点      1. 移动对象成本高！### 垃圾回收器不是所有垃圾回收的阶段都会触发 STW，但 **很多关键阶段必须 STW**，以下是一些常见 GC 算法的 STW 情况：1. **Serial GC / Serial Old GC（单线程 GC）**- **特点：** 单线程，适合客户端应用或小内存环境- STW：标记阶段（标记存活对象）清除/整理阶段都是 STW 的！整个过程都会暂停所有应用线程&gt; ✅ 用户线程完全停止，卡顿感明显，不适合高并发服务端应用2. **Parallel GC（多线程版本的 Serial，也叫吞吐量优先 GC）**- **特点：** 多线程并行执行 GC，适合后台计算型任务- STW：标记、清除、压缩等阶段大多是 STW 的同样会暂停所有应用线程&gt; ✅ 吞吐量高，但停顿时间仍然较长3. **CMS（Concurrent Mark-Sweep，老年代 GC，并发标记清除）**- **特点：** 目的是 **减少 STW 时间**，适合对延迟敏感的应用- **STW 阶段：**  - 初始标记（Initial Mark）**：**STW，只标记 GC Roots **直接**关联的对象（很快）  - 并发标记（Concurrent Mark）**：**与应用线程并发执行，不 STW。存在错标、漏标。  - 重新标记（Remark）**：**STW**，修正并发标记期间用户线程修改的引用关系（关键！）**  - 并发清除（Concurrent Sweep）**：**不 STW&gt; ✅ **CMS 通过并发标记减少了 STW 时间，但仍有 2 次较短的 STW（初始标记和重新标记）**4. **G1 GC（Garbage First，JDK 9+ 默认 GC）**- **特点：** 面向服务端，将堆划分为多个 Region，目标是控制停顿时间- STW 阶段：  - 初始标记（Initial Mark）**：**STW并发标记  - 最终标记（Remark）**：**STW  - 筛选回收（Cleanup / Evacuation）：部分阶段 STW&gt; ✅ G1 通过分 Region 和并发/并行结合，进一步优化了 STW 时间，是 JDK 9 后的默认 GC- | 设计点                                                       | 说明                                                         |  | :----------------------------------------------------------- | :----------------------------------------------------------- |  | **1. 堆的逻辑结构改变：不再分“年轻代”“老年代”物理隔离**      | 而是将整个 Java 堆划分为多个大小相等的 **Region（区域）**，每个 Region 可以是 Eden、Survivor 或 Old 区，**动态分配角色** |  | **2. 可预测的停顿时间模型（Pause Prediction Model）**        | 你可以设置一个目标停顿时间（比如 200ms），G1 会尽量在每次 GC 时控制在这个范围内 |  | **3. 分 Region 回收，优先回收垃圾最多的 Region（Garbage First）** | G1 会优先选择 **垃圾比例最高（存活对象最少）的 Region** 进行回收，从而提高回收效率，这就是名字中 **“Garbage First”** 的来源 |  | **4. 并发与并行结合**                                        | - 并发标记（和应用线程一起运行） - 并行回收（STW，多线程加速） |5. **ZGC（Z Garbage Collector，JDK 11+ 实验性，JDK 17+ 生产可用） &amp; Shenandoah**- **特点：** **超低延迟 GC，目标 STW 时间不超过 10ms，甚至 1ms**- STW：极短，大部分阶段都是并发执行的只会在极少数关键阶段有非常短暂的 STW&gt; ✅ ZGC 是目前最先进的低延迟 GC，适合超大堆、超低延迟场景（如金融、游戏、实时系统）# 编程## JVM详解## 内存区![image-20250902110508883](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902110508883.png)### 堆1. 是 JVM 中 最大的一块内存区域，用于存放**所有**对象实例和数组（即通过 `new`创建的对象）。2. 是 垃圾回收器（Garbage Collector, GC）主要管理的区域。### 栈（虚拟机栈）1. 每个线程运行时都会创建一个 **虚拟机栈**，用于存储 **栈帧（Stack Frame）**，每个栈帧对应一个方法调用。2. 栈帧中包含：   1. 局部变量表（Local Variables）：存储方法参数和局部变量   2. 操作数栈（Operand Stack）：用于计算   3. 动态链接（Dynamic Linking）   4. 方法返回地址（Return Address）### 方法区1. 作用：   - 用于存储 已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。   - 是 Java 类的“元数据”存储区域。2. 特点：   - 线程共享   - 存放内容：类的结构信息（如类名、方法、字段、父类、接口等）**静态变量（static 变量）常量池（运行时常量池）**JIT 编译后的代码   - 在 HotSpot 虚拟机中，方法区的实现叫 “永久代（PermGen，Java 7 及之前）” 或 “元空间（Metaspace，Java 8 及之后）”   &gt; ⚠️ 注意：方法区是 JVM 规范中定义的逻辑区域，而永久代 / 元空间 是 HotSpot 的具体实现。3. **运行时常量池（Runtime Constant Pool）【线程共享，属于方法区的一部分】**   - 是方法区的一部分，用于存放 **编译期间生成的各种字面量和符号引用**，如：字符串常量（如 `&quot;Hello&quot;`）final 常量类/方法/字段的符号引用### 本地方法栈1. 作用   - 为 JVM 调用的 **Native 方法（如 C/C++ 写的方法，通过 JNI 调用）** 服务   - 类似于 Java 虚拟机栈，但是服务于本地（非 Java）方法### 程序计数器1. 作用：   - 是一块较小的内存空间，是 **当前线程执行的字节码的行号指示器**   - 用于记录当前线程正在执行的字节码指令地址，线程切换时能恢复执行位置2. 特点：   - **线程私有**   - **唯一一个在 JVM 规范中没有任何 OutOfMemoryError 情况的区域**   - 如果线程执行的是 Java 方法，计数器记录的是正在执行的字节码指令地址；   - 如果执行的是 Native 方法，则计数器值为空（Undefined）## 数据结构### List#### ArrayList1. 概述   1. 是一种集合，底层基于 **可扩容数组**。   2. 底层通过数组实现，初始大小为10；   3. 扩容以1.5倍放大2. 用法   1.    2. | 分类      | 方法                    | 说明                 |      | --------- | ----------------------- | -------------------- |      | 增加      | `add(E e)`              | 在末尾添加           |      |           | `add(int index, E e)`   | 在指定位置插入       |      | 删除      | `remove(int index)`     | 删除指定下标的元素   |      |           | `remove(Object o)`      | 删除匹配的第一个元素 |      |           | `clear()`               | 清空列表             |      | 修改/获取 | `get(int index)`        | 获取指定下标元素     |      |           | `set(int index, E e)`   | 修改指定下标元素     |      |           | `size()`                | 返回大小             |      |           | `isEmpty()`             | 是否为空             |      | 查找      | `contains(Object o)`    | 是否包含元素         |      |           | `indexOf(Object o)`     | 返回第一个匹配下标   |      |           | `lastIndexOf(Object o)` | 返回最后一个匹配下标 |#### LinkeList1. 概述2. 用法   1.    2. | 分类 | 方法                         | 说明                          |      | ---- | ---------------------------- | ----------------------------- |      | 增加 | `add(E e)`                   | 在末尾添加                    |      |      | `addFirst(E e)`              | 在头部添加                    |      |      | `addLast(E e)`               | 在尾部添加                    |      |      | `push(E e)`                  | 入栈（= addFirst）            |      | 删除 | `remove()` / `removeFirst()` | 删除并返回头部元素            |      |      | `removeLast()`               | 删除并返回尾部元素            |      |      | `remove(Object o)`           | 删除指定对象                  |      |      | `pop()`                      | 出栈（= removeFirst）         |      |      | `clear()`                    | 清空                          |      | 获取 | `get(int index)`             | 获取指定下标元素              |      |      | `getFirst()`                 | 获取头部元素（不删除）        |      |      | `getLast()`                  | 获取尾部元素（不删除）        |      |      | `peek()` / `peekFirst()`     | 查看头部元素，空时返回 `null` |      |      | `peekLast()`                 | 查看尾部元素，空时返回 `null` |      | 其他 | `size()`                     | 返回大小                      |      |      | `isEmpty()`                  | 是否为空                      |### CopyOnWriteArrayList1. CopyOnWriteArrayList 的核心原理 —— **写时复制（Copy-On-Write）**   什么是写时复制？   1. “写时复制” 的意思就是：当你要修改这个 List（比如 add / remove / set）时，不直接在原数组上修改，而是先复制一份新的数组，在新数组上进行修改，改完后再让内部的数组引用指向这个新数组。   2. 而对于读操作（如 get、iterator），始终是从原数组（可能是旧数组）上读取，不需要加锁，也不关心是否有写操作正在进行。2. `CopyOnWriteArrayList`是一个线程安全的 List，采用 “写时复制（Copy-On-Write）” 机制实现并发安全，适合读多写少的并发场景。### Map#### HashMap1. 概述   1. 底层是数组实现，大小必须是2的幂次   2. 哈希冲突会在对应位置生成链表（桶）   3. JDK8之后，链表达到一定长度后会变成红黑树2. 用法   1.    2. | 分类      | 方法                                       | 说明                         |      | --------- | ------------------------------------------ | ---------------------------- |      | 增加/修改 | `put(K key, V value)`                      | 插入键值对（若键存在则替换） |      |           | `putAll(Map m)`                            | 批量插入                     |      |           | `putIfAbsent(K key, V value)`              | 键不存在时才插入             |      | 删除      | `remove(Object key)`                       | 删除键并返回对应的值         |      |           | `remove(Object key, Object value)`         | 键和值都匹配时才删除         |      |           | `clear()`                                  | 清空                         |      | 获取      | `get(Object key)`                          | 获取值，不存在返回 `null`    |      |           | `getOrDefault(Object key, V defaultValue)` | 不存在时返回默认值           |      |           | `containsKey(Object key)`                  | 是否包含某个键               |      |           | `containsValue(Object value)`              | 是否包含某个值               |      | 遍历      | `keySet()`                                 | 返回所有键                   |      |           | `values()`                                 | 返回所有值                   |      |           | `entrySet()`                               | 返回键值对集合               |      | 其他      | `size()`                                   | 返回大小                     |      |           | `isEmpty()`                                | 是否为空                     |      |           | `replace(K key, V value)`                  | 替换指定键的值               |      |           | `replace(K key, V oldValue, V newValue)`   | 旧值匹配时才替换             |#### LinkedHashMap1. 底层实现几乎和HashMap一样2. 在每个元素中添加了一个链表，指向下一个插入的数据#### TreeMap1. 底层用红黑树实现2. 特点是按照Key进行排序#### HashTable1. 是线程安全的（并发安全）2. 进行写操作时会对整个HashTable上锁#### ConcurrentHashTable1. 和HashTable的区别就是只对桶上锁### Set1. 本身是通过Map实现的2. 把Value设置为null，只用Key| 方法签名                     | 说明                                                         | 示例                                        || :--------------------------- | :----------------------------------------------------------- | :------------------------------------------ || `boolean add(E e)`           | 添加元素到集合，如果集合中 **已存在该元素则不会重复添加，并返回 false** | `set.add(&quot;apple&quot;)`                          || `boolean remove(Object o)`   | 移除指定元素，成功返回 true，否则返回 false                  | `set.remove(&quot;banana&quot;)`                      || `boolean contains(Object o)` | 判断集合中是否包含某个元素                                   | `set.contains(&quot;apple&quot;)`→ true/false         || `int size()`                 | 返回集合中元素的个数                                         | `set.size()`                                || `boolean isEmpty()`          | 判断集合是否为空                                             | `set.isEmpty()`                             || `void clear()`               | 清空集合中的所有元素                                         | `set.clear()`                               || `Iterator&lt;E&gt; iterator()`     | 返回集合中元素的迭代器，用于遍历                             | `for (String s : set) &#123; ... &#125;`              || `Object[] toArray()`         | 将集合转换为 Object 数组                                     | `Object[] arr = set.toArray()`              || `&lt;T&gt; T[] toArray(T[] a)`     | 将集合转换为指定类型的数组                                   | `String[] arr = set.toArray(new String[0])` |### Queue| 分类         | 方法                 | 功能                   | 队列为空/满时的表现                     || ------------ | -------------------- | ---------------------- | --------------------------------------- || **插入**     | `add(E e)`           | 插入一个元素           | 队列满时抛异常 `IllegalStateException`  ||              | `offer(E e)`         | 插入一个元素           | 队列满时返回 `false`                    || **查看队头** | `element()`          | 获取队头元素，但不删除 | 队列空时抛异常 `NoSuchElementException` ||              | `peek()`             | 获取队头元素，但不删除 | 队列空时返回 `null`                     || **移除队头** | `remove()`           | 删除并返回队头元素     | 队列空时抛异常 `NoSuchElementException` ||              | `poll()`             | 删除并返回队头元素     | 队列空时返回 `null`                     || **其他**     | `size()`             | 返回队列元素个数       | 0（如果队列空）                         ||              | `isEmpty()`          | 判断队列是否为空       | true/false                              ||              | `clear()`            | 清空队列               | 队列变空                                ||              | `contains(Object o)` | 判断是否包含某元素     | true/false                              |#### PriorityQueue1. 概述   1. `PriorityQueue&lt;E&gt;` 是 Java 提供的 **基于堆 (Heap)** 的优先队列实现类。      1. 插入元素：`O(log n)`      2. 删除堆顶：`O(log n)`      3. 获取堆顶：`O(1)`      4. 遍历 `PriorityQueue` 得到的结果 **不是排序好的**      5. **允许重复元素**，不允许 `null`。   2. 默认大小是11.      1. 当元素个数超过当前容量时，会 **自动扩容**。         扩容规则：         1. 如果旧容量 &lt; 64 → 新容量 = `(旧容量 * 2) + 2`            （比如 11 → 24 → 50 …）         2. 如果旧容量 ≥ 64 → 新容量 = `旧容量 + (旧容量 &gt;&gt; 1)`            （相当于 1.5 倍扩容，比如 64 → 96 → 144 …）   3. 默认是 **最小堆**：堆顶元素是“最小值”。   4. 如果要最大堆，需要自定义 **比较器 (Comparator)**。   5. 常见应用：**Top K 问题、任务调度、最短路径算法 (Dijkstra)、Huffman 编码** 等。2. 用法   1. 构造方法      1. ```java         PriorityQueue&lt;Integer&gt; pq1 = new PriorityQueue&lt;&gt;();           // 默认最小堆                  PriorityQueue&lt;Integer&gt; pq2 = new PriorityQueue&lt;&gt;(Collections.reverseOrder());           // 最大堆                  PriorityQueue&lt;String&gt; pq3 = new PriorityQueue&lt;&gt;(Comparator.comparingInt(String::length));           // 自定义比较规则：字符串长度         \n\n\n调用方法参考普通队列\n\n双端队列\n构造：Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();。从中可以看出，其本质就是一个链表。只不过为了面向接口编程，这样定义不会误用其他方法。\n用法：\nofferFirst、offerLast等等\n\n\n\n红黑树\n也是对树结构的平衡，但是和AVL树有区别\nAVL 树（严格平衡，查找快）\n红黑树（相对平衡，插入&#x2F;删除更快，综合性能更好）\n\n\n\n\n五大原则\n每个节点要么是红色，要么是黑色。​​\n根节点必须是黑色。\n叶子节点（NIL &#x2F; 空节点）视为黑色。\n红色节点的两个子节点都必须是黑色（即不能有两个连续的红色节点）。\n从任意一个节点到其所有后代叶子节点的路径上，黑色节点的数量相同（称为黑高相同）。\n\n\n\n\n口诀：左根右（二叉搜索树），根叶黑，不红红，黑路同\n\n\n插入\n\n默认插入点（cur）节点是红色的\n破坏了根叶黑：若插入节点是根节点，直接变黑\n破坏了不红红：\n若插入节点的“叔叔”节点（父节点的兄弟节点）是红色，则叔父爷变色，cur指向爷爷，然后递归判定原则\n若插入节点的叔叔节点是黑色，则进行旋转（同AVL树），然后旋转中心点和旋转点变色\n\n\n\n\n删除：\n\n\n理念：\n对于一般的二叉搜索树，删除都有三种情况：叶节点，有一个子树，有两个子树。但是有两个子树的情况最终是转换成前两种情况。所以针对红黑树，我们只需要研究前两种就好了\n针对红黑树，只有一个子树时，子树一定只有一个节点。否则要么违反不红红，要么违反黑路同\n\n\n删除叶节点：\n红色：直接删除\n黑色：我们把要调整的节点成为“双黑节点”，代表经过它的路径都少一个黑节点\n兄弟节点是黑色：\n兄弟节点至少有一个红色孩子：\n变色：兄弟节点、其红孩子和父节点都要集成对应的上级节点的颜色\n旋转\n\n\n兄弟节点只有黑孩子：\n把兄弟节点变为红色，那么就恢复了局部的黑路同，双黑节点交给父节点\n递归处理\n\n\n\n\n兄弟是红节点：兄父变色，朝双黑旋转\n\n\n\n\n\n\n\nB+树\n和B树的区别\n\n很像。当我们要遍历树中元素时，对于B树，需要中序遍历，这要求指针来回跳跃，非常耗时。\n\n而B+数则要求在叶节点上保存所有的元素，并且从小到大链接起来\n\n对于非叶子结点，每个元素代表对应子节点的最大值。\n\n非叶子节点相当于只是索引\n\n\n\n\n异常处理异常体系\n所有异常都来自于顶级父类Throwable\nThrowable下有两个子类：Exception, Error\nError：表示非常严重的错误（JVM或系统级），程序无法解决。\n比如，OutOfMemoryError（内存不足，堆内存溢出），StackOverflowError，（栈溢出，比如无限递归）\n\n\nException：表示程序可以解决的异常。Exception一般又可以分为RuntimeException和Checked Exception（受检异常 &#x2F; 必检异常）。\nRuntimeException：运行时异常，一般为逻辑错误。\nChecked Exception：检查异常，由编译器要求必须处理\n\n\n\n\n\n异常处理\ntry-catch-finally\n用于 捕获并处理异常：\ntry &#123;    // 可能抛出异常的代码&#125; catch (IOException e) &#123;    // 捕获并处理 IOException    e.printStackTrace();&#125; catch (Exception e) &#123;    // 捕获其他异常&#125; finally &#123;    // 无论是否异常都会执行的代码（如关闭资源）&#125;\n\n\n\nthrows（声明抛出）\n\n如果当前方法 不想处理某个受检异常，可以将其抛给调用者处理：\npublic void readFile() throws IOException &#123;    // 可能抛出 IOException 的代码&#125;\n\n调用者必须继续处理这个异常（catch 或继续 throws）。\n\n\n自定义异常\n你可以根据业务需求定义自己的异常类，通常继承自：\n\nException（受检异常）\nRuntimeException（运行时异常）\n\n示例：自定义受检异常\npublic class MyCheckedException extends Exception &#123;    public MyCheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n示例：自定义运行时异常\npublic class MyUncheckedException extends RuntimeException &#123;    public MyUncheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n泛型和多态\n泛型的实现\n\n泛型（Generics）是如何实现的？ → 核心机制：类型擦除（Type Erasure）\n\n✅ 1. 泛型的本质：编译期的类型检查，运行时类型擦除\n\nJava 的泛型是通过 “类型擦除（Type Erasure）” 实现的，这意味着泛型信息只在编译阶段存在，用于类型检查，而在编译成字节码后，类型参数会被擦除，替换为默认类型（通常是 Object 或指定的边界类型）。\n\n\n✅ 2. 举个例子 👇\n你写这样的泛型代码：List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);String s = list.get(0); // 不需要强转\n\n但在编译后（字节码层面），它实际上变成了：List list = new ArrayList(); // 类型参数 &lt;String&gt; 被擦除了list.add(&quot;Hello&quot;);String s = (String) list.get(0); // 编译器自动插入了强制类型转换\n\n\n✅ 编译器在编译时保证了你只能放入 String，取出时也自动帮你转回 String，但运行时 JVM 看到的只是原始类型 List。\n\n\n✅ 3. 类型擦除的规则\n\n\n\n情况\n擦除后变成什么\n\n\n\nList&lt;T&gt;\n擦除为 List&lt;Object&gt;（JDK 1.5 早期）或更准确地说是 List（原始类型）\n\n\nList&lt;String&gt;\n擦除为 List，但编译器会做类型检查并插入强制转换\n\n\nT extends Number（比如 List&lt;Integer&gt;）\n擦除为 Number，即上限类型\n\n\nT没有指定边界\n擦除为 Object\n\n\n\n✅ 4. 为什么用类型擦除实现泛型？\n\n历史原因：为了兼容 Java 5 之前的代码（非泛型代码），保证泛型引入后 旧代码依然能运行，不破坏二进制兼容性。\nJVM 层面没有泛型支持：Java 的虚拟机（JVM）本身并不直接认识泛型类型，它是基于原始类型运作的。\n\n\n✅ 总结：泛型是 Java 编译器层面的语法糖，它通过类型擦除在编译时提供类型安全，运行时则“擦除”掉具体类型信息。\n\n\n\n\n\n线程创建\n\n\n方式\n说明\n是否推荐\n适用场景\n\n\n\n1️⃣ 继承 Thread类\n自定义类继承 Thread，重写 run()方法\n⭐ 不推荐\n简单示例、学习线程基础\n\n\n2️⃣ 实现 Runnable接口\n实现 Runnable接口，实现 run()方法，传给 Thread 对象\n⭐⭐⭐⭐ 推荐\n大多数场景，灵活、面向接口\n\n\n3️⃣ 实现 Callable&lt;V&gt;接口 + FutureTask\n类似 Runnable，但可以有返回值，能抛异常\n⭐⭐⭐ 推荐（需要返回值时）\n需要获取线程执行结果的场景\n\n\n4️⃣ 使用线程池（Executor 框架）\n通过线程池（如 Executors）管理线程的创建和执行\n⭐⭐⭐⭐⭐ 强烈推荐\n生产环境、高并发、线程复用\n\n\n\n创建线程池参数\n\npublic ThreadPoolExecutor(\n    int corePoolSize,                  // 核心线程数\n    int maximumPoolSize,               // 最大线程数\n    long keepAliveTime,                // 空闲线程存活时间\n    TimeUnit unit,                     // 时间单位\n    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列\n    ThreadFactory threadFactory,       // 线程工厂\n    RejectedExecutionHandler handler   // 拒绝策略\n)\n\n### 线程池1. 工作原理   1. 步骤 1：如果当前线程数 &lt; 核心线程数（corePoolSize）      - 线程池会 立即创建一个新线程 来执行这个任务      - 该线程执行完任务后 不会被销毁，而是进入线程池中 等待下一个任务   2. 步骤 2：如果线程数 ≥ 核心线程数，但任务队列未满      - 线程池 不会创建新线程      - 而是把任务放入 任务队列（workQueue）中等待      - 空闲的核心线程会 从队列中取出任务执行   3. 步骤 3：如果任务队列已满，但线程数 &lt; 最大线程数（maximumPoolSize）      - 线程池会 创建新的线程（非核心线程） 来执行这个任务      - 这些线程在完成任务后，如果 空闲时间超过 keepAliveTime，就会被销毁   4. 步骤 4：如果线程数已达最大线程数，且任务队列已满      - 线程池会触发 拒绝策略（RejectedExecutionHandler）比如抛出异常、丢弃任务、由调用线程自己执行等2. 注意，是等待队列满了之后才会创建新线程。### ThreadLocal1. 是什么？   1. `ThreadLocal`是 Java 中一个非常有特色的线程绑定机制，它提供了一种**线程本地存储**（Thread-local Storage）的方式，即 每个线程都有自己独立的变量副本，线程之间互不干扰，从而避免了多线程环境下的共享变量同步问题。   2. **ThreadLocal 本身是用来存储单个线程的单一变量（一个 ThreadLocal 对应一个值）**2. 应用场景   1. 线程上下文信息传递（如用户登录信息、请求上下文）      在 Web 应用或服务端程序中，一个请求往往由一个线程处理，我们经常需要在处理过程中传递一些上下文信息，比如：      - 当前登录用户信息（User）      - 请求 ID（traceId / requestId）      - 数据源信息      - 事务上下文      如果通过方法参数一层层传递，代码会非常冗余。使用 `ThreadLocal`可以优雅地解决这个问题，让这些信息**在当前线程中“全局可见”**   2. 数据库连接、Session 等线程隔离资源管理      1. 为了保证每个线程使用独立的数据库连接，避免多线程并发问题，会使用 `ThreadLocal`来保存当前线程的 Connection 或 Session。3. 底层原理   1. 每个 Thread 对象内部都有一个 ThreadLocalMap   2. 数据结构：ThreadLocalMap（类似简易的 HashMap）      - `ThreadLocalMap`是 ThreadLocal 的静态内部类      - 它的 **key 是 ThreadLocal 对象本身（弱引用）**      - value 是线程本地存储的实际值      - 它是一个 定制化的哈希表，专门为 ThreadLocal 服务   3. ```java      Thread      └── threadLocals: ThreadLocalMap             ├── key: ThreadLocal 对象1（弱引用） → value: 线程1的变量值1             ├── key: ThreadLocal 对象2（弱引用） → value: 线程1的变量值2             └── ...                   （每个线程都有自己的 threadLocals，彼此独立）\n\n\n\n\n内存泄露问题\n\nEntry 的 key 是 ThreadLocal 对象的弱引用，但 value 是强引用\n当你不再引用这个ThreadLocal，但是线程长期存活时，当遇到GC，key就会被回收（因为是弱引用），但是value没法回收。造成泄露。\n一定要用threadLocal.remove()手动回收\n\n\n\n同步乐观锁和悲观锁\n\n\n对比维度\n悲观锁（Pessimistic Locking）\n乐观锁（Optimistic Locking）\n\n\n\n核心思想\n“总会有人抢，先加锁，防止冲突”\n“大家不一定会冲突，先尝试，冲突了再处理”\n\n\n锁的获取\n操作数据前先加锁，阻止其他人修改\n操作数据前不加锁，提交时检查是否被修改过\n\n\n并发性能\n并发度低，线程会阻塞，上下文切换开销大\n并发度高，无阻塞，靠重试或版本控制解决冲突\n\n\n适用场景\n冲突频繁，写多读少（如银行转账）\n冲突较少，读多写少（如计数器、浏览量）\n\n\n实现方式\nsynchronized、ReentrantLock、数据库行锁&#x2F;表锁等\nCAS、版本号（version）、时间戳等\n\n\n典型实现\nsynchronized、Lock 接口、数据库的 SELECT ... FOR UPDATE\nCAS（Compare-And-Swap）、version字段、AtomicXXX\n\n\n是否阻塞\n是（线程会等待锁）\n否（线程不会阻塞，冲突时重试或失败）\n\n\nAQS\n\n\n项目\n说明\n\n\n\nAQS 是什么\nJava 并发包中实现锁和同步器的底层核心框架（如 ReentrantLock、Semaphore 的基础）\n\n\n核心功能\n管理同步状态（state）、线程排队（CLH 队列）、阻塞与唤醒\n\n\n核心变量\nvolatile int state：表示同步状态（比如锁是否被占用、剩余许可数等）\n\n\n核心机制\n线程获取资源失败时进入队列等待，资源可用时被唤醒\n\n\n两种模式\n独占模式（如锁）、共享模式（如信号量、读锁）\n\n\n子类实现\n开发者通过重写 tryAcquire&#x2F; tryRelease等方法，定义资源获取与释放逻辑\n\n\n应用广泛\n是 Java 中大部分同步工具（如 Lock、Semaphore、CountDownLatch）的底层实现基础\n\n\n\nAQS（AbstractQueuedSynchronizer，抽象队列同步器） 是 Java 并发包（java.util.concurrent）中 最核心、最基础的同步框架，它是 构建锁和同步器（如 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）的基石。\n\n作用\n\n同步状态的管理（比如锁是否被占用、资源数是否足够）\n线程的排队与阻塞（当资源不可用时，线程进入等待队列）\n线程的唤醒与通知（当资源可用时，唤醒等待线程）\n\n它主要用于构建 锁（Lock）和同步器（Synchronizer），是 实现线程安全与并发控制的重要基础框架。\n\n工作原理\n\n同步状态（State）\nAQS 内部维护了一个 volatile int 类型的 state 变量，表示 同步状态，这个状态的意义取决于具体的同步器实现\n\n线程的排队（CLH 队列）\n当某个线程尝试获取资源（比如锁、许可）但 失败时（比如锁被占用、许可不足），AQS 会将该线程封装成一个 Node 节点，并加入到一个 FIFO（先进先出）的等待队列中，这个队列叫做 CLH 队列（Craig, Landin, and Hagersten 队列）。\n\n阻塞与唤醒\n\n当线程获取资源失败时，AQS 会通过 LockSupport.park() 将线程阻塞（挂起）\n当资源可用时（比如其他线程释放了锁或许可），AQS 会通过 LockSupport.unpark() 唤醒队列中的线程\n\n\n\n\nAQS 底层数据结构 —— CLH 队列（简化理解）\n\n当线程获取资源失败时，AQS 会将线程封装成 Node 节点，并加入到一个 FIFO 队列（CLH 队列） 中等待。\n每个 Node 代表一个等待的线程\n队列是 双向链表结构\n头节点一般是占用资源的线程，后续节点是排队等待的线程\n\n\n\n\n\nsynchronized\n在 Java 中，当多个线程同时访问共享资源（比如一个变量、对象、集合等）时，如果没有合理的同步措施，就可能导致数据不一致、线程安全问题。\n\n\n同步关键字 synchonized\n\nsynchronized是 Java 提供的最基本的线程同步机制，它基于 对象监视器（monitor），可以修饰 方法 或 代码块，保证同一时刻 只有一个线程能进入被 synchronized 保护的代码区域。\n\n使用方法（只展示如何锁住代码块）：\n\npublic class Counter {\n    private int count = 0;\n    private final Object lock = new Object(); // 任意对象，作为锁对象\n\n    public void increment() {\n        synchronized (lock) {  // 只锁定需要同步的代码块，不是整个方法\n            count++;\n        }\n    }\n}\n2. 锁升级：   1. 根据线程竞争的情况，synchronized 锁会从 偏向锁 → 轻量级锁 → 重量级锁 逐步升级，尽量以最小的性能代价实现线程同步。   2. 三层锁状态      1.       2. | 锁状态                              | 说明                                                         | 适用场景                                        | 底层实现                                                  |         | :---------------------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------------- |         | **1. 偏向锁（Biased Lock）**        | 假设锁只会被 **一个线程访问**，不存在竞争，**加锁时几乎没有额外开销** | 单线程访问同步代码块的场景                      | 通过对象头 Mark Word 中记录偏向线程ID                     |         | **2. 轻量级锁（Lightweight Lock）** | 假设锁 **只有少量线程交替访问，竞争不激烈**，采用 **CAS 自旋方式获取锁，线程不阻塞** | 多线程交替执行，但 **没有或很少真正的并发争抢** | 通过 CAS 操作和栈帧中的 **Lock Record** 实现              |         | **3. 重量级锁（Heavyweight Lock）** | 当多个线程 **真正并发竞争锁时**，轻量级锁升级为重量级锁，线程会进入 **阻塞状态，由操作系统管理** | 高并发、多线程同时争抢锁                        | 基于操作系统 **Mutex Lock（互斥锁）**，涉及线程挂起与唤醒 |   3. 锁升级流程      1. ```java         无锁状态            ↓ （第一次被线程访问，且没有竞争）         偏向锁（Biased Lock）            ↓ （当有第二个线程尝试获取锁，发现不是自己）         轻量级锁（Lightweight Lock，通过 CAS 自旋）            ↓ （如果自旋超过阈值，或等待线程较多，竞争激烈）         重量级锁（Heavyweight Lock，线程进入阻塞，由 OS 管理）\n\n\n线程1第一次获取锁\n       ↓\n     偏向锁（记录线程1的ID，几乎无开销）\n       ↓\n线程2来尝试获取锁（不是线程1）\n       ↓\n   偏向锁撤销，升级为轻量级锁\n       ↓\n线程1释放，线程2通过 CAS 获取锁（自旋）\n       ↓\n如果自旋多次仍失败，或竞争激烈\n       ↓\n     升级为重量级锁（线程阻塞，OS 管理）\n   4. 自旋：      1. 当一个线程尝试获取某个资源（比如锁）失败时，它不会立即被阻塞（挂起）、让出 CPU，而是通过循环（忙等 / busy-waiting）的方式，不停地尝试重新获取锁，直到成功为止。      2. 简单来说就是：线程不放弃 CPU，而是“原地打转”，反复尝试，直到成功获取所需资源。#### ReentrantLock1. 用法   1. 创建：`private final Lock lock = new ReentrantLock();`   2. 在访问共享资源之前，调用 `lock.lock()`加锁。这个方法会阻塞线程，直到加到锁。   3. 执行你的临界区代码（操作共享资源）   4. **在 finally 块中调用 `lock.unlock()`释放锁**（⚠️ 必须做，防止遇到**异常**导致无法解锁）   5. `trylock()`会尝试枷锁，不会阻塞线程。加到锁返回true，否则返回false。   6. 例子   ```java    // 加锁保证线程安全    public void add() &#123;        lock.lock();      // 1. 加锁        try &#123;            count++;      // 2. 临界区代码（操作共享资源）        &#125; finally &#123;            lock.unlock(); // 3. 一定要在 finally 中解锁        &#125;    &#125;\n\n\n\n\n作用范围是从lock到unlock的中间代码块\n\n\n\n公平锁和非公平锁\n1. \n\n\n\n\n特性\n公平锁（Fair Lock）\n非公平锁（Nonfair Lock）\n\n\n\n定义\n按照线程请求锁的 先后顺序 获取锁，先到先得\n线程获取锁时，不排队，直接尝试抢锁，谁抢到算谁的\n\n\n是否排队\n✅ 按 FIFO（先进先出）顺序获取锁\n❌ 不保证顺序，允许插队\n\n\n可能导致饥饿\n❌ 不会，所有线程最终都能获得锁\n✅ 可能，某些线程可能一直抢不到锁\n\n\n吞吐量（性能）\n⬇️ 较低，因为要维护顺序\n⬆️ 较高，减少线程切换和等待\n\n\n实现方式\n加锁前先检查是否有线程在排队\n直接尝试 CAS 抢锁，抢不到再排队\n\n\n创建方式\nnew ReentrantLock(true)\nnew ReentrantLock(false)或默认\n\n\n\n底层原理\n\nReentrantLock的公平与非公平实现，核心都依赖于 AQS（AbstractQueuedSynchronizer，抽象队列同步器）。\n\nAQS 的核心机制\nAQS 内部维护了一个 FIFO 等待队列（CLH 队列），以及一个 volatile 状态变量 state 表示锁的状态：\n\nstate &#x3D; 0：表示锁未被占用\nstate &gt; 0：表示锁被占用，数值代表重入次数\n\n当线程尝试获取锁时：\n\n如果锁是空闲的（state &#x3D;&#x3D; 0），尝试通过 CAS（Compare And Swap） 抢锁\n如果锁被占用，线程进入等待队列中排队\n\n\n非公平锁（Nonfair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n直接尝试 CAS 抢锁（不排队！）使用 CAS 将 state 从 0 改为 1，如果成功，当前线程获得锁\n如果 CAS 失败（锁被占用），才进入 AQS 队列等待\n唤醒后继续尝试抢锁\n\n\n优点：吞吐量高，减少线程挂起和切换，性能更好\n缺点：可能导致某些线程一直抢不到锁（饥饿）\n\n\n公平锁（Fair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n先检查是否有线程在排队（hasQueuedPredecessors()）如果队列中 已经有其它线程在等待，那么当前线程 不去抢锁，直接进入队列排队\n如果队列为空，才尝试 CAS 抢锁\n如果 CAS 成功，获得锁；失败则进入队列\n\n\n优点：避免饥饿，每个线程最终都能获得锁，公平性好\n缺点：性能较差，增加了线程切换和排队时间\n\n\n\n\n\n\n\nCountDownLatch\n倒计时门闩：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待，直到其他线程完成一组操作。你可以把它想象成一个“倒计时器”：主线程等待 N 个子线程完成各自任务后，再继续执行。\n工作原理\nCountDownLatch内部基于 AQS 实现\n初始化时设置一个 state &#x3D; count（计数值）\n每调用一次 countDown()，state 减 1（通过 CAS 操作）\n调用 await()的线程会阻塞，直到 state &#x3D;&#x3D; 0\nCountDownLatch 只能用一次，计数归零后不能重置！\n\n\n\nSemaphore\nSemaphore 是一个计数信号量，用于控制同时访问某个资源的线程数量，常用于限流、资源池管理。\n工作原理\nSemaphore也基于 AQS 实现\n内部维护了一组 可用的许可（permits），也就是 state 值\n调用 acquire()时：如果还有许可（state &gt; 0），则 state 减 1，线程继续执行如果没有许可，则线程进入 AQS 队列等待\n调用 release()时：state 加 1，唤醒等待队列中的一个线程\nSemaphore 可以重复使用，许可可以动态获取和释放\n\n\n\n网络编程基本的通信架构\nCS架构（Client客户端 &#x2F; Server服务端）\nBS架构（Browser浏览器 &#x2F; Server服务端）\n\nIPInetAddress\n是JAVA中的一个类，用于表示 IP 地址（可以是 IPv4 或 IPv6），并提供了与 IP 地址相关的一些常用操作，比如解析主机名、获取本机地址等\n\n常用方法\n\n\n\n\n\n方法\n说明\n\n\n\nstatic InetAddress getByName(String host)\n根据主机名（如 &quot;www.baidu.com&quot;）或 IP 地址字符串（如 &quot;14.215.177.39&quot;）返回对应的 InetAddress实例。\n\n\nstatic InetAddress[] getAllByName(String host)\n返回与给定主机名关联的所有 IP 地址（因为一个域名可能对应多个 IP）。返回的是一个数组。\n\n\nstatic InetAddress getLocalHost()\n获取本机（localhost）的 InetAddress对象。\n\n\nString getHostName()\n获取此 IP 地址对应的主机名。\n\n\nString getHostAddress()\n获取该对象的 IP 地址字符串表示（如 &quot;192.168.1.100&quot;）。\n\n\nboolean isReachable(int timeout)\n测试该地址是否可达（通过网络 ping），timeout 是超时时间（毫秒）。注意：这个方法不一定在所有环境下都有效，比如受防火墙限制。\n\n\nPort\n周知窗口：0-1023\n注册端口：1024-49151\n动态端口：49152-65535\n\n通信协议UDP协议\n特点：无连接，不可靠\n不事先建立连接。发出去就不管了\n每次把数据封装在包内（lim 64KB）\n\nTCP协议\n面向连接，可靠通信\n三次握手，四次挥手\n\nUDP通信DatagramSocket 、DatagramPacket\nDatagramSocket用于收发数据报\n\nDatagramPacket表示一个实际的数据包包括数据内容，目标IP和端口，来源IP和端口。\n\n常用方法\n\n\n\n\nDatagramSocket()\n创建一个 UDP 套接字，系统自动分配端口（常用于客户端）\n\n\n\nDatagramSocket(int port)\n创建并绑定到指定端口（常用于服务端）\n\n\nvoid send(DatagramPacket p)\n发送一个数据报包\n\n\nvoid receive(DatagramPacket p)\n接收一个数据报包（阻塞）\n\n\nvoid close()\n关闭套接字，释放资源\n\n\nvoid setSoTimeout(int timeout)\n设置接收超时时间（毫秒）\n\n\nint getLocalPort()\n获取本地绑定的端口号\n\n\nboolean isBound()\n是否已绑定端口\n\n\nboolean isClosed()\n是否已关闭\n\n\n\n\n\n\njava.net.Socket\n常用方法\n1. \n\n\n\n\nSocket(String host, int port)\n创建 Socket 并连接到指定主机和端口\n\n\n\nInputStream getInputStream()\n获取输入流，用于读取服务器数据\n\n\nOutputStream getOutputStream()\n获取输出流，用于向服务器发送数据\n\n\nvoid close()\n关闭 Socket 和相关资源\n\n\nvoid setSoTimeout(int timeout)\n设置读取超时（毫秒）\n\n\nInetAddress getInetAddress()\n获取远程服务器 IP\n\n\nint getPort()\n获取远程服务器端口\n\n\nboolean isConnected()\n判断是否已连接\n\n\nboolean isClosed()\n判断是否已关闭\n\n\n\n\n\n\njava.net.ServerSocket","categories":["技术"],"tags":["Java","后端"]},{"title":"C++编程","url":"/2025/12/04/C++%E7%AC%94%E8%AE%B0/","content":"课程内容第一章（C1、C2） · 介绍主流编程范式对比\n面向对象编程（OOP）\n起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言\n核心概念：类&#x2F;对象、继承、多态、垃圾回收\n设计哲学：自底向上程序设计，虚拟过程机制\n\n\n函数式编程（FP）\n理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑\n核心特性：数据不可变性、无副作用、函数一等公民引用透明性：相同输入始终产生相同输出\n应用场景：实时游戏状态管理、高频交易系统\n局限：学习曲线陡峭，调试复杂，不适合状态密集型场景\n\n\n逻辑编程\n代表语言：Prolog\n特点：基于公理、推理规则和查询的自动证明\n经典案例：专家系统诊断、鸡兔同笼问题、斑马逻辑谜题\n\n\n并发编程与泛型编程\n\n\n并发编程：程序分解为可独立运行部分的能力\n泛型编程：通过抽象找到算法实现的共性，提高代码复用性\n\n\n\nC++的独特价值与设计哲学\n核心优势：零开销抽象\n设计原则：\n不用的特性不需要付出代价\n使用的特性无法手工编码得更好\n\n\n硬件访问与抽象的结合：直接映射语言结构到硬件设施\n\n\n与C语言的关系\n超集特性：C++支持C的所有编程技巧\n兼容性：任何C程序都能用C++以基本相同方式编写，具备同等开销\n\n\n当代C++发展\nLLM代码生成工具：介绍了Cursor、Augmentcode、Copilot等主流工具\nBjarne Stroustrup的观点：强调教授现代C++，关注AI代码质量风险\n未来方向：C++26改进异步支持，静态反射等新特性\n\n\n\n第二章（C3、C4） · DataType基本数据类型\nshort型\n\n占2字节\n\n\nint型\n\n无符号整型（uint）类型有溢出回绕机制\n有符号整型(int)的溢出是UB。\n\n\nfloat型\n\n特殊浮点数类型\n\n无穷大（Infinity）：\n\nnumeric_limits&lt;double&gt;::infinity() + numeric_limits&lt;double&gt;::infinity();  // ∞ + ∞ = ∞numeric_limits&lt;double&gt;::infinity() * numeric_limits&lt;double&gt;::infinity();  // ∞ × ∞ = ∞\n\n\n非数（NaN，Not a Number）：\n\n// NaN: 0 11111111 10000000000000000000000numeric_limits&lt;float&gt;::quiet_NaN();                    // 静态NaNnumeric_limits&lt;double&gt;::infinity() / numeric_limits&lt;double&gt;::infinity();  // ∞/∞ = NaNnumeric_limits&lt;float&gt;::infinity() - numeric_limits&lt;float&gt;::infinity();    // ∞-∞ = NaNnumeric_limits&lt;double&gt;::infinity() * 0.0;              // ∞×0 = NaNfloat f = 0.0f / 0.0f;                                // 0/0 = NaNfloat fs = sqrt(-1.0f);                                // √(-1) = NaNfloat fl = log(-1.0f);                                 // ln(-1) = NaN\n\n次正规数\n\n\n\n\n项目\n正规数\n次正规数（非规格化数）\n\n\n\n指数字段\n不为全 0，也不为全 1\n全为 0\n\n\n尾数字段\n隐含前导 1（如 1.xxx…）\n无隐含 1，以 0.xxx… 开头\n\n\n数值范围\n较大，常规浮点数范围\n极小，比最小正规数还小\n\n\n是否支持极小非零值\n否（会下溢为 0）\n是，可表示极小非零值\n\n\n精度\n较高\n相对较低\n\n\n目的\n常规数值表示\n填补零与正规数之间的空隙，支持渐进下溢\n\n\n\n#include &lt;cmath&gt;\nstd::fpclassify(subnormal_num);  // 返回FP_SUBNORMAL\nstd::isnormal(n);                // 检查是否为正规数\n### 类型转换机制1. 静态类型转换（`static_cast&lt;&gt;`）   1. 整型转换有高位截断风险（int转short）   2. 浮点数转换有精度损失.2. 重新解释转换（`reinterpret_cast&lt;&gt;`）   1. 是什么      1. `reinterpret_cast`是 C++ 中的一种 类型强制转换运算符，用于在不改变底层二进制数据的前提下，将一种类型的指针或引用转换为另一种完全不同类型的指针或引用。**它是最“底层”、最“危险”的类型转换之一**，通常用于一些特殊的、与系统底层或硬件相关的编程场景。### 数据序列化（Serialize）1. 序列化是将数据结构或对象状态转换为可以存储或传输的形式（如二进制、文本等），以便之后可以在相同或不同环境中重建数据的过程。2. POD类型   1. 一个类型（或类/结构体）被认为是 POD，通常具备以下特征：      1. 类似 C 的数据结构         1. 没有用户自定义的构造函数、析构函数。         2. 没有虚函数（即没有虚函数表 vtable）。         3. 没有继承关系（不是从其它类继承来的）。         4. 所有成员变量也都是 POD 类型。      2. 支持逐字节拷贝（memcpy 安全）         1. 可以安全地使用 `memcpy`、`memset`等函数对其进行内存操作，不会破坏其内部状态。         2. 可以直接进行二进制读写（比如读写文件、网络传输）。      3. 内存布局是确定且简单的         1. 成员变量的排列顺序和内存布局是明确的，通常与声明顺序一致（尤其是在使用了 `#pragma pack`等对齐控制后）。         2. 没有隐藏的成员（比如虚表指针）。      4. 不是POD的例子         1. ```c++            class Person &#123;            public:                Person() &#123;&#125;                    // 有用户定义的构造函数                virtual ~Person() &#123;&#125;           // 有虚析构函数（隐含虚表）                std::string name;              // 成员是非 POD 类型（std::string）            &#125;;\n\n\n\n\n内存对齐设置：\n\n#pragma pack(push, 1)  // 1字节对齐\nstruct PacketHeader {\n    std::uint32_t packetId;    // 4字节\n    std::uint16_t payloadSize; // 2字节  \n    std::uint8_t flags;        // 1字节\n};  // 总共7字节，无填充\n#pragma pack(pop)\n      2. 通过 `#pragma pack(push, 1)`和 `#pragma pack(pop)`这两个编译器指令，对 `PacketHeader`结构体的内存对齐方式进行了设置。这里设置为按 1 字节对齐，目的是让结构体成员在内存中紧密排列，不存在额外的填充字节。这样做在涉及网络传输或者文件存储时，能够确保数据在不同平台上具有一致性，避免因不同平台的默认内存对齐规则差异导致数据解析错误。### any类型#### 概述1. 特性| 特性                                         | 说明                                                         || :------------------------------------------- | :----------------------------------------------------------- || **类型安全**                                 | 存储任意类型，但取出的时候必须匹配原类型，否则会抛出 `std::bad_any_cast`异常。 || **动态类型**                                 | 可以存储任何可复制（或可移动）构造的类型，不需要提前知道具体类型。 || **不需要模板参数**                           | 不像 `std::vector&lt;T&gt;`需要在编译期指定类型，`std::any`是运行时多态的。 || **支持拷贝和移动语义**                       | 可以拷贝或移动 `std::any`对象，但内部存储的值也会相应拷贝或移动。 || **底层实现通常基于类型擦除（type erasure）** | 一般通过继承、虚函数、模板等技术实现运行时类型信息（RTTI）管理。 |1. 常见用法   1.    2. | 功能 / 用法                  | 方法 / 操作                           | 代码示例                                                     | 说明                                                         |      | :--------------------------- | :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |      | **创建并存储任意类型值**     | 直接赋值                              | `std::any a = 42;` `std::any b = std::string(&quot;Hello&quot;);` `std::any c = 3.14;` | 可存储 `int`、`string`、自定义类等几乎任何类型。             |      | **检查是否有存储值**         | `.has_value()`                        | `if (a.has_value()) &#123; /* 有值 */ &#125;`                          | 返回 `bool`，表示当前 `std::any`是否持有某个对象。           |      | **获取存储的值（类型安全）** | `std::any_cast&lt;T&gt;(any_obj)`           | `int x = std::any_cast&lt;int&gt;(a);` `std::string s = std::any_cast&lt;std::string&gt;(b);` | 必须与存入时的类型 **完全一致**，否则抛出 `std::bad_any_cast`异常。 |      | **安全获取值（避免异常）**   | 先检查 `.type()`再 `any_cast`         | `if (a.type() == typeid(int)) &#123; int x = std::any_cast&lt;int&gt;(a); &#125;` | 推荐做法：先通过 `type()`判断类型，再安全转换。              |      | **获取当前存储值的类型信息** | `.type()`                             | `if (a.type() == typeid(std::string)) &#123; ... &#125;`               | 返回 `std::type_info`，可用于与 `typeid(T)`比较，判断存储了什么类型。 |      | **处理类型转换失败**         | `try / catch`捕获 `std::bad_any_cast` | `&lt;br&gt;try &#123;&lt;br&gt;    auto s = std::any_cast&lt;std::string&gt;(a);&lt;br&gt;&#125; catch (const std::bad_any_cast&amp; e) &#123;&lt;br&gt;    std::cerr &lt;&lt; &quot;转换失败: &quot; &lt;&lt; e.what();&lt;br&gt;&#125;&lt;br&gt;` | 当 `any_cast`的类型不匹配时，会抛出此异常。                  |      | **移动语义支持**             | 移动构造 / 赋值                       | `std::any a = std::string(&quot;Hi&quot;);` `std::any b = std::move(a);` | 支持移动构造和移动赋值，避免不必要的拷贝（特别是大对象）。   |      | **清空 / 重置 any 对象**     | 赋值为 `std::any()`或赋新值           | `a = std::any();`或 `a = 42;`（覆盖）                        | 将其置为空状态（无值），或直接覆盖为新值。                   |      | **判断存储类型是否为某类型** | `type() == typeid(T)`                 | `if (a.type() == typeid(double)) &#123; ... &#125;`                    | 用于在运行时判断当前 `any`中存储的对象类型。                 |3. 注意事项   1. 不要滥用 `std::any`，**如果能用模板、具体类型、`std::variant`，优先考虑它们**，因为它们更高效、更安全。   2. 存储引用需谨慎（一般不推荐），建议存储值或智能指针。   3. 有性能开销，适用于灵活性优先、性能要求不极致的场景。#### any的底层数据结构`std::any`的内部实现通常包含如下两个关键成员（或类似结构）：```c++struct any &#123;    using _Handler = ...;  // 函数指针类型，用于管理对象的生命周期、拷贝、移动等    _Handler _h_;          // 管理函数指针（存储了针对当前类型T的处理逻辑）    union Storage &#123;        // 联合体，用于存储对象指针或内联缓冲区        void* ptr;         // 指向堆上分配的对象        __any_imp::__Buffer __buf;  // 内部小对象缓冲区（SSO）    &#125; _s_;                 // 实际存储区域&#125;;\n\n\n\n\n\n\n\n\nstd::any内部通常由两部分构成：\n\n_Handler _h_：一个函数指针（或函数对象），负责管理当前存储对象的所有操作（构造、析构、拷贝、移动、获取类型信息等）。它本质上是类型擦除的核心，通过函数指针动态分发操作。\n_Storage _s_：一个联合体（union），用于实际存储数据。它可能包含：一个 void* ptr：指向堆上分配的对象（当对象太大，无法放入内部缓冲区时）。一个 __Buffer __buf：内部的小对象缓冲区（通常几个机器字长，用于小对象优化，直接存储对象，避免堆分配）\n\n\n类型擦除与函数指针调度\n什么是类型擦除？\n\n\n类型擦除（Type Erasure）是一种设计技术，它允许我们在运行时处理不同类型的对象，但在编译期不依赖具体类型。std::any通过类型擦除，把不同类型对象的操作（构造、析构、拷贝、移动等）统一封装到一组函数指针中。\n\n\n函数指针类型定义（来自第5张图）：\n\nusing _HandleFuncPtr = void* (*)( _Action act,                                   const any* self,                                   any* other,                                   const std::type_info* info,                                   const std::type_info* fallback );\n\n\n这是一个通用函数指针类型，它接收一个 _Action（表示要执行的操作类型，比如拷贝、析构、获取类型信息等），以及一些上下文参数（比如当前 any对象、目标对象、类型信息等）。\n通过这个函数指针，std::any可以在运行时动态调用与当前存储类型 T 相关的正确操作函数。\n\n\n操作类型枚举（_Action，来自第5张图）：\n\nenum class _Action &#123;    _Destroy,   // 析构当前存储的对象    _Copy,      // 拷贝构造一个新对象    _Move,      // 移动构造一个新对象    _Get,       // 获取存储的对象（类型安全地 cast 出来）    _TypeInfo   // 获取类型信息（std::type_info）&#125;;\n\n\n每当你对 std::any执行某个操作（比如拷贝、析构、获取值），std::any内部的 _Handler函数指针就会被调用，并根据 _Action参数，执行对应的逻辑。\n\n存储策略与小对象优化（SSO）\n什么是小对象优化（SSO）？\n\n对于较小的对象（比如 int、float、小型结构体），std::any不会在堆上分配内存，而是直接将其存储在 any对象内部的**固定大小的缓冲区（__Buffer）**中，这样可以：\n避免堆分配的开销（malloc&#x2F;new）\n提高性能（访问局部性更好）\n减少内存碎片\n\n\n\n\n内部缓冲区：\n\n\nunion Storage &#123;    void* ptr;                        // 指向堆内存（大对象）    __any_imp::__Buffer __buf;        // 内部缓冲区（小对象，SSO）&#125;;\n\n\n如果存储的对象足够小（比如小于等于 3 个机器字长，约 24~32 字节），std::any会直接把对象存到内部的 __buf缓冲区中，不分配堆内存。\n如果对象太大，则会通过 new在堆上分配内存，并将指针存到 ptr中。\n\nunion类型\n是什么\n\n联合体(Union)是C++中的一种特殊数据类型，允许多个成员变量共享同一块内存空间。与结构体(struct)不同，union的所有成员从同一内存地址开始存储。\n\n内存布局原理\n\n0x1000 ┌─────────────┐ ← char b (1字节)\n       │             │\n       │             │ ← int a (4字节)  \n       │             │\n0x1004 ├─────────────┤ ← double c (8字节)\n       │             │\n       │             │\n       │             │\n       │             │\n0x1008 └─────────────┘\n2. Union的技术优势与局限性   1.  技术优势      1. **内存高效**：极大节省存储空间，特别适合嵌入式系统      2. **数据多态**：同一内存块可解释为不同类型数据      3. **硬件接口**：直接映射到硬件寄存器或协议格式      4. **类型转换**：避免reinterpret_cast的显式转换   2. 局限性      1. **类型安全**：缺乏运行时类型检查，容易误用      2. **构造析构**：不能包含需要构造/析构的成员（C++11后放宽）      3. **继承限制**：不能作为基类参与继承体系      4. **维护困难**：需要手动管理当前有效成员   3. 现代C++中的替代方案      1. `std::variant`：类型安全的union替代品      2.  继承多态：面向对象的标准解决方案      3. 模板特化：编译时多态机制### Variant类型#### 概述1. 是什么   1. **类型安全的union**。它可以在同一个内存位置上存储一组预定义类型中的某一个值，但同一时间只能存储其中一个类型。可以把它理解为一个类型安全的、有限选择的“万能盒子”，比如这个盒子只能装 `int`、`double`或 `std::string`中的某一个，但你不能同时装多个，也不能装这三种之外的类型。2. 用法   1. variant 初始状态：默认会初始化为第一个类型（如这里的 `int`）的值初始化   2. 访问错误类型会怎样：如果当前 `variant`不是类型 `T`，调用 `std::get&lt;T&gt;(v)`会抛出异常：`std::bad_variant_access`。   3. 常见使用场景：适用于：JSON 值、配置项、事件携带数据、状态机返回值等需要存储“某一类可能类型”但不确定具体是哪一个的场景。   4. | 功能 / 用法                                | 方法 / 操作                                           | 代码示例                                                     | 说明                                                         |      | :----------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |      | **定义**                                   | `std::variant&lt;T1, T2, ...&gt;`                           | `std::variant&lt;int, double, std::string&gt; v;`                  | 定义一个可以存储 `int`、`double`或 `std::string`中某一个值的变量 `v`，但**同一时间只能存其中一个**。 |      | **赋值**                                   | 直接赋值 `v = value;`                                 | `v = 42;` `v = 3.14;` `v = std::string(&quot;Hello&quot;);`            | 给 `variant`赋一个它支持的类型值，会替换掉当前存储的值。     |      | **检查当前存储的类型（编译期/运行时）**    | `v.index()`                                           | `int idx = v.index();` // 返回当前存储类型在模板参数列表中的索引（从 0 开始） | 比如 `std::variant&lt;int, string&gt;`中，`int`是 0，`string`是 1。 |      | **按类型安全地获取值**                     | `std::get&lt;T&gt;(v)`                                      | `int x = std::get&lt;int&gt;(v);` `std::string s = std::get&lt;std::string&gt;(v);` | 获取当前存储的值，但 **必须类型完全匹配**，否则抛出 `std::bad_variant_access`异常。 |      | **安全地按类型获取值**                     | `std::get_if&lt;T&gt;(&amp;v)`                                  | `if (auto p = std::get_if&lt;int&gt;(&amp;v)) &#123; /* 使用 *p */ &#125;`       | 如果当前存储的是类型 `T`，则返回指向该值的指针，否则返回 `nullptr`，更安全。 |      | **安全访问所有可能类型）**                 | `std::visit(visitor, v)`                              | `&lt;br&gt;std::visit([](auto&amp;&amp; arg) &#123;&lt;br&gt;    using T = decltype(arg);&lt;br&gt;    if constexpr (std::is_same_v&lt;T, int&gt;) &#123; /* int 处理 */ &#125;&lt;br&gt;    else if constexpr (std::is_same_v&lt;T, std::string&gt;) &#123; /* string 处理 */ &#125;&lt;br&gt;&#125;, v);&lt;br&gt;` | 最强大、最通用的方式，通过 **访问者（visitor）** 处理 `variant`当前可能的所有类型，支持编译期多态。 |      | **判断当前存储的是否是某个类型（运行时）** | `v.index() == N`或结合 `std::holds_alternative&lt;T&gt;(v)` | `if (std::holds_alternative&lt;std::string&gt;(v)) &#123; /* 是 string */ &#125;` | `std::holds_alternative&lt;T&gt;(v)`是类型安全的判断，返回 `bool`，表示当前是否存储了类型 `T`。 |3. 和any比较   1. 能用variant就尽量用，因为效率高   2. | 特性             | std::any            | std::variant    |      | :--------------- | :------------------ | :-------------- |      | **类型确定时机** | 运行时检查          | 编译期确定      |      | **类型安全性**   | 运行时类型检查      | 编译期类型检查  |      | **访问开销**     | 函数调用+类型比较   | 直接索引访问    |      | **内存布局**     | 类型擦除+小对象优化 | 联合体+类型标签 |#### variant的内部结构1. **`variant`的内部可以理解为一个 “带索引的联合体（union + index）”**2. 主要包含三个部分：   1. **索引（index）**：一个整数（通常是 `unsigned int`），表示当前存储的是联合体中的哪个类型（比如 0 表示 `int`，1 表示 `double`，2 表示 `string`）。   2. **值（value）**：一个联合体（union），实际存储了 `int`/ `double`/ `string`等类型的某一个值。   3. **对齐填充（alignment）**:用填充字节把整个 Variant 填到对齐边界上.![image-20251116162658657](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251116162658657.png)### 访问者模式（visitor partten）1. 是什么   1. 访问者（Visitor）模式是一种行为型设计模式，它允许你在不改变各元素类的前提下定义作用于这些元素的新操作。2. 下面结合你提供的修正后更清晰的代码片段，一步步拆解**访问者（Visitor）模式**在这段 C++ 代码里的体现与运作逻辑：   1. 整体功能概览      这段代码演示了如何用「访问者模式」来给不同的几何形状（圆形、矩形）**动态地附加“计算面积”这一操作**。核心思路是：把「对元素的操作」从元素类本身抽离出来，放到专门的「访问者（Visitor）」类中；这样既能让元素类保持简洁，又能在不修改元素类的情况下，灵活添加新操作（比如未来再加“绘制形状”“导出 SVG”等）。   2. 代码逐部分解析      1. 先看「抽象元素（Shape）」与「具体元素（Circle、Rectangle）」   ```c++   // --------------------------   // 1. 抽象元素：Shape 基类   // --------------------------   class Shape &#123;   public:       virtual ~Shape() = default;       // 虚析构，保证多态销毁       virtual void accept(ShapeVisitor* visitor) = 0;  // 核心：接受访问者的抽象方法   &#125;;      // --------------------------   // 2. 具体元素：Circle（圆形）   // --------------------------   class Circle : public Shape &#123;   private:       double radius;   public:       Circle(double r) : radius(r) &#123;&#125;          // 构造时传入半径          // 获取半径（供访问者后续计算用）       double getRadius() const &#123; return radius; &#125;            // 实现 accept：把自己（this）交给访问者去“访问”       void accept(ShapeVisitor* visitor) override &#123;             visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Circle*) 方法       &#125;   &#125;;      // --------------------------   // 3. 具体元素：Rectangle（矩形）   // --------------------------   class Rectangle : public Shape &#123;   private:       double width, height;   public:       Rectangle(double w, double h) : width(w), height(h) &#123;&#125;  // 构造时传入宽高          // 获取宽、高（供访问者后续计算用）       double getWidth() const &#123; return width; &#125;          double getHeight() const &#123; return height; &#125;            // 实现 accept：把自己（this）交给访问者去“访问”       void accept(ShapeVisitor* visitor) override &#123;             visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Rectangle*) 方法       &#125;   &#125;;\n\n\n\n\n\n\n设计意图：Shape是所有几何形状的“根”，它只定义了一个抽象方法 accept，用来接收「访问者」。这样不管未来加多少种形状（三角形、椭圆…），都只要继承 Shape并实现 accept即可。\naccept方法的意义：它是「双分派（Double Dispatch）」的关键入口。你可以简单理解成：“我是什么类型的元素” + “你是什么类型的访问者” 这两层信息，共同决定要执行哪一段逻辑。\n\n\n再看「抽象访问者（ShapeVisitor）」与「具体访问者（AreaCalculator）」\n\n// --------------------------// 4. 抽象访问者：ShapeVisitor// --------------------------class ShapeVisitor &#123;public:    virtual ~ShapeVisitor() = default;  // 虚析构，保证多态销毁    // 对圆形的访问接口（纯虚函数，子类必须实现）    virtual void visit(Circle* circle) = 0;      // 对矩形的访问接口（纯虚函数，子类必须实现）    virtual void visit(Rectangle* rectangle) = 0;  &#125;;// --------------------------// 5. 具体访问者：AreaCalculator（面积计算器）// --------------------------class AreaCalculator : public ShapeVisitor &#123;private:    double totalArea = 0.0;  // 累加所有形状的面积public:    // 实现对 Circle 的访问：计算圆形面积并累加    void visit(Circle* circle) override &#123;          double area = 3.14159 * circle-&gt;getRadius() * circle-&gt;getRadius();        std::cout &lt;&lt; &quot;Circle area: &quot; &lt;&lt; area &lt;&lt; std::endl;        totalArea += area;    &#125;    // 实现对 Rectangle 的访问：计算矩形面积并累加    void visit(Rectangle* rectangle) override &#123;          double area = rectangle-&gt;getWidth() * rectangle-&gt;getHeight();        std::cout &lt;&lt; &quot;Rectangle area: &quot; &lt;&lt; area &lt;&lt; std::endl;        totalArea += area;    &#125;    // 对外提供获取总面积的方法    double getTotalArea() const &#123; return totalArea; &#125;&#125;;\n\n\n设计意图：ShapeVisitor定义了「对每种具体元素要执行的操作」的接口（visit(Circle*)、visit(Rectangle*)）。这样以后想加新操作（比如“绘制形状”“导出 JSON”），只需要新增一个继承 ShapeVisitor的类、实现对应的 visit即可，不用碰原来的 Shape及其子类。\nAreaCalculator的职责：它专门干“计算面积”这件事。里面针对 Circle和 Rectangle各自实现了不同的计算逻辑；同时用 totalArea来累加所有形状的面积，最后能通过 getTotalArea()拿到结果。\n\n\n最后看「客户端如何组织 &amp; 执行访问逻辑」\n\nint main() &#123;    // 1. 准备对象结构：装各种 Shape 的容器    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;    // 2. 往容器里塞具体的形状（Circle、Rectangle）    shapes.emplace_back(std::make_unique&lt;Circle&gt;(5.0));     // 半径 5 的圆    shapes.emplace_back(std::make_unique&lt;Rectangle&gt;(4.0, 6.0)); // 宽4 高6 的矩形    // 3. 创建「访问者」实例    AreaCalculator areaCalc;    // 4. 遍历所有形状，让每个形状“接受”访问者    for (auto&amp; shape : shapes) &#123;        shape-&gt;accept(&amp;areaCalc);  // 关键：触发双分派！    &#125;    // 5. 拿到访问者计算的“总面积”    std::cout &lt;&lt; &quot;Total area of all shapes: &quot; &lt;&lt; areaCalc.getTotalArea() &lt;&lt; std::endl;    return 0;&#125;\n\n\n流程解释：\n先创建一个 vector，里面存的是各种 Shape的智能指针（这里用了 unique_ptr管理内存）。\n往这个 vector里分别 emplace_back了 Circle和 Rectangle的实例——这就是所谓的「对象结构」：一组不同类型的元素，统一用基类指针管理。\n新建 AreaCalculator（具体访问者）的实例 areaCalc。\n遍历 shapes里的每一个 Shape，调用它的 accept(&amp;areaCalc)。这时候就会触发「双分派」：\n首先，shape自己会判断自己是 Circle还是 Rectangle，然后调用 visitor-&gt;visit(this)—— 如果是 Circle，就调用 areaCalc.visit(Circle*)；如果是 Rectangle，就调用 areaCalc.visit(Rectangle*)。\n\n\n进入到 visit之后，访问者内部根据元素类型，执行对应的面积计算逻辑，还能累加总面积。\n最后打印出总面积，演示「访问者帮我们完成了跨元素的通用操作」。\n\n\n\n\n访问者模式的核心要点总结\n\n**双分派（Double Dispatch）**第一次分派：由「元素（如 Circle&#x2F;Rectangle）」决定调用哪个 accept方法（多态）。第二次分派：在 accept里调用 visitor-&gt;visit(this)时，又由「访问者（如 AreaCalculator）」决定调用哪个 visit重载（多态）。通过这两次动态绑定，最终执行哪段逻辑，既取决于“元素是什么类型”，也取决于“访问者是什么类型”。\n元素与操作的解耦Shape及其子类只负责“自己是哪种形状、有哪些属性”，完全不关心“要怎么计算面积、怎么绘制”这些操作。所有操作都被收拢到 ShapeVisitor及其子类里。想加新操作？只需要新增 Visitor 子类，不用改任何 Shape代码。\n**符合开闭原则（OCP）**对扩展开放：要新增操作（比如“绘制形状”），只需要写新的 Visitor 类，实现 visit(Circle*)、visit(Rectangle*)… 不用碰原有元素类。对修改封闭：原有的 Shape、Circle、Rectangle… 都不用因为加了新操作而改动。\n\n\n什么时候该用访问者模式？\n\n对象结构稳定，但操作频繁变化：比如游戏里的各种 NPC、道具，它们的类型相对固定，但运营过程中可能不断加“统计战力”“批量强化”“导出清单”等新操作 → 用 Visitor 把操作抽出去，方便扩展。\n需要对复杂对象结构做多种不相关操作：比如编译器的抽象语法树（AST），节点类型很多，但要分别做“语法检查”“代码生成”“优化”等完全不同的操作 → 每个操作写一个 Visitor，遍历 AST 时传入不同 Visitor 即可。\n元素类已经有较多方法，不想再往里面塞新方法：如果直接在 Shape里加 calculateArea()，会让 Shape变得臃肿；用 Visitor 就能把 calculateArea相关逻辑挪到外面，让 Shape保持简洁。\n\n\n\n多返回值  &#x2F; 多输出参数\n这部分内容围绕 C++ 中用于返回或处理多个值的不同技术和工具展开，分别介绍了 元组（tuple）、可选类型（optional） ，核心是解决函数如何优雅地返回多个值、处理可能缺失的值、以及更现代的初始化与解包方式。\n\n元组（tuple）\n是什么\n\nstd::tuple是一个固定大小（编译期确定）、可以存储多个不同类型（异构）数据的模板类，它将多个值“打包”成一个整体对象，便于一起返回、传递或存储。\n\n\n使用场景\n\n函数返回多个值：std::tuple&lt;int, float&gt; calculate();\n组合异构数据：std::tuple&lt;int, std::string, double&gt; user = {1, &quot;Tom&quot;, 3.5};\n\n\n三种解包方式\n1. \n\n\n\n\n方式\n语法\n优点\n缺点\n适用标准\n\n\n\nstd::get&lt;N&gt;(t)\n按索引访问，如 std::get&lt;0&gt;(t)\n精准访问某个位置的值\n需记住索引，类型不匹配编译报错\nC++11 起\n\n\nstd::tie(var1, std::ignore, var2)\n解包到已有变量，可配合 std::ignore\n可选择性接收部分返回值\n需提前定义变量，代码稍显冗长\nC++11 起\n\n\nauto [v1, v2, ...] = t（结构化绑定）\nC++17 最简洁的解包方式\n代码最清晰、可读性最强，自动绑定\n仅限 C++17 及以上\nC++17 起\n\n\n\n\n\n\n可选类型（optional）\nstd::optional&lt;T&gt;是 C++17 标准库引入的一个类型安全的容器类，用于表示一个可能包含某个类型 T的值，也可能不包含任何值（即“空”） 的对象。\n\n示例：\n\n定义\n\n// 示例：根据用户名查找用户 ID，可能找到也可能找不到\nstd::optional&lt;int&gt; findUserID(const std::string&amp; username) {\n    if (username == &quot;Alice&quot;) {\n        return 1001;  // 找到了，返回 ID\n    } else {\n        return std::nullopt;  // 没找到，返回“空”\n    }\n}\n2. 调用   1. ```c++      int main() &#123;          auto idOpt = findUserID(&quot;Alice&quot;);                    if (idOpt.has_value()) &#123;            // 检查是否有值              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; idOpt.value() &lt;&lt; std::endl;          &#125; else &#123;              std::cout &lt;&lt; &quot;未找到该用户&quot; &lt;&lt; std::endl;          &#125;                // 更推荐的简洁方式（C++17 起）：          if (idOpt) &#123;  // 可隐式转换为 bool，判断是否有值              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; *idOpt &lt;&lt; std::endl;  // 用 * 解引用获取值          &#125;                // 提供默认值（如果没找到，返回 -1）          int id = idOpt.value_or(-1);  // 如果没有值，返回 -1，不会抛异常          std::cout &lt;&lt; &quot;用户ID（带默认值）: &quot; &lt;&lt; id &lt;&lt; std::endl;                return 0;      &#125;\n\n\n\n\n\n\n\n第三章（C5） · PointerFuncarray\n多维数组的表示\n\n最常见int a[1][2]\n\n使用类型别名：等价于上面的表示\nusing T = int[2];    T a[1];T* b; // 表示b是一个指向int[2]的指针，即int(*)[2]或int[][2]  \n\n等效于传统写法：\ntypedef int[2] T;  // 等效的 typedef 写法\n\n\n数组升维\n\nvoid main(){\n    int b[1];\n    \n    // 如何把b存给一个需要二维数组的函数呢\n    // 用类型别名\n    using T = int[2];\n    func2( (T*)b );\n}\n\nvoid fnc(int a[][2]){...}\n### 内存管理#### malloc1. 概述   1. `malloc`是 C 标准库（通常是 `&lt;stdlib.h&gt;`或 `&lt;cstdlib&gt;`）提供的一个函数，用于在 程序的**堆（heap）**内存区域上动态分配指定大小的内存块。   2. `malloc`通常会先从进程的堆内存中管理的一块“内存池”里分配，只有当剩余内存不足时，才会向操作系统申请更多的堆内存（通常通过 `brk`或 `mmap`系统调用）   3. `malloc`的返回值：只是地址，内存未初始化！2. 系统调用   `malloc`底层会依赖操作系统的系统调用来真正获取或释放内存，PPT 中提到了两种最常用的系统调用：   - **`brk`**：`brk`是一个比较基础的用于调整进程堆空间（heap）大小的系统调用。简单来说，它会移动进程的 “堆顶指针”（break pointer），从而扩大或缩小堆的空间范围。`malloc`在小内存分配场景下，经常通过调整 `brk`来获得连续的堆内存。   - **`mmap`/`munmap`**：**`mmap`（memory map）可以把一个文件或者其他设备映射到进程的地址空间，也可以直接用来申请一块匿名内存**（不对应任何文件的纯内存区域）。3. 设计原则   1. **减少系统调用**   2. **快速匹配**   3. **减少锁竞争**#### 设计模式RAII1. 概述：RAII（Resource Acquisition Is Initialization，资源获取即初始化）的设计模式，以及如何通过智能指针类来避免内存泄漏。   &gt; 理解：把资源和相关操作封装到对象中，这样就可以利用构造函数和析构函数管理资源，避免内存泄露风险。   &gt;   &gt; 比如智能指针、vector都是RAII设计模式。2. 核心思想：   1. **“谁申请，谁释放”**：资源的生命周期由其所有者（通常是封装资源的对象）管理。   2. **利用栈展开（Stack Unwinding）**：当函数退出（正常返回或异常抛出）时，C++ 会自动调用栈上对象的析构函数。   3. **异常安全**：即使发生异常，资源也能被正确释放，避免泄漏。   4. **零开销抽象**：运行时性能与手动管理相同（无额外动态分配或虚函数调用开销）。3. 理解   1. **传统方式（old_use）—— 存在内存泄漏风险**      ```c++      void old_use(Args a) &#123;          auto q = new Blob(a);  // 在堆上分配内存，返回指针          // ...          if (foo) throw Bad();  // 抛出异常 → 函数提前退出          if (bar) return;       // 正常返回 → 函数提前退出          // ...          delete q;  // 如果前面抛出异常或提前返回，此句不会执行 → 内存泄漏！      &#125;\n\n**问题**：\n\n- 手动管理内存（`new`/`delete`）需要严格匹配，若中途因异常或 `return`提前退出，会导致 `delete`被跳过，引发内存泄漏。\n- 代码复杂且易出错，尤其是多层嵌套的资源管理。\n\n**2. RAII 方式（newer_use）—— 自动管理内存**\n\nvoid newer_use(Args a) &#123;    auto p = int_ptr(new Blob(a));  // 使用智能指针包装资源    // ...    if (foo) throw Bad();  // 异常抛出 → 函数退出时 p 的析构函数自动调用    if (bar) return;       // 提前返回 → 函数退出时 p 的析构函数自动调用    // ...&#125;  // 函数结束时，p 被销毁 → 析构函数自动调用 delete 释放内存\n\n**优势**：\n\n- 无需手动调用 `delete`，资源随对象生命周期自动释放。\n- 即使发生异常或提前返回，析构函数也会被调用，保证内存安全。\n\n**3. 智能指针类 `int_ptr`的实现**\n\nclass int_ptr &#123;public:    // 构造函数：接收裸指针并接管资源    int_ptr(int* p = nullptr) : ptr(p) &#123;&#125;          // 析构函数：释放资源    ~int_ptr() &#123; delete ptr; &#125;          // 重载 -&gt; 操作符：让 int_ptr 对象像指针一样访问成员    int* operator-&gt;() const &#123; return ptr; &#125;          // 重载 * 操作符：让 int_ptr 对象像指针一样解引用    int&amp; operator*() const &#123; return *ptr; &#125;  private:    int* ptr;  // 存储裸指针&#125;;\n\n关键点解析\n\n1. **构造函数 `int_ptr(int\\* p)`**：接收裸指针 `p`并初始化成员变量 `ptr`，完成资源的“获取”。默认参数 `p = nullptr`允许空指针初始化（防止未初始化）。\n2. **析构函数 `~int_ptr()`**：释放 `ptr`指向的内存（`delete ptr`），完成资源的“释放”。当 `int_ptr`对象离开作用域（函数结束、异常抛出等）时，析构函数自动调用。\n3. **操作符重载 `operator-&gt;`和 `operator*`**：**`operator-&gt;`**：返回裸指针 `ptr`，使得 `int_ptr`对象可以通过 `-&gt;`访问指向对象的成员。示例：`p-&gt;someMethod()`等价于 `(p.operator-&gt;())-&gt;someMethod()`。**`operator*`**：返回裸指针解引用的结果（`*ptr`），使得 `int_ptr`对象可以通过 `*`直接访问指向的值。示例：`*p`等价于 `*(p.operator*())`。\n\n为什么需要操作符重载？\n\n- **语法兼容性**：让智能指针的使用方式与原生指针几乎一致，降低学习成本。\n- **封装安全性**：虽然内部持有裸指针，但外部无法直接访问（`ptr`是私有成员），只能通过受控的操作符（`-&gt;`和 `*`）访问资源，防止误操作（如悬垂指针、重复释放等）。\n\n\n\n\n\n智能指针\nauto_ptr\n\n概述\n在前面的介绍中，我们实现了int_ptr，那么为什么不能有其他的智能指针呢？所以有了auto_ptr\n\n\nauto_ptr有什么问题？\n反直觉的拷贝语义：当使用赋值操作符或拷贝构造函数对auto_ptr进行操作时，会发生所有权的转移。\n不适合STL容器：由于auto_ptr的这种非传统的拷贝语义，在STL容器中使用auto_ptr会导致未定义行为。例如，向vector&lt;auto_ptr&lt;int&gt;&gt;中插入元素时，可能会触发容器的重新分配内存，从而导致资源的所有权混乱。\n不支持数组：auto_ptr的析构函数使用delete来释放资源，而不是delete[]，因此不能用于管理动态分配的数组。\n\n\n\n\nunique_ptr\n\n为了改进auto_ptr，增加了以下特性：\n禁止拷贝构造和赋值：unique_ptr通过删除拷贝构造函数和赋值操作符，确保每个资源只有一个所有者，避免了auto_ptr的所有权转移问题。\n移动语义：unique_ptr支持移动构造函数和移动赋值操作符，允许资源所有权的转移，但需要显式使用std::move。\n支持自定义删除器：unique_ptr可以接受自定义的删除器，这使得它能够管理更复杂的资源，如文件句柄、网络连接等。\n\n\n\n\nshared_ptr\n\n核心特性：\n引用计数：shared_ptr内部维护一个“引用计数器”，记录有多少个 shared_ptr实例共同指向同一块资源。当最后一个 shared_ptr被销毁（或其引用计数减到 0）时，才会自动释放资源。\n共享所有权：允许多个 shared_ptr同时拥有对同一资源的控制权，适合多个对象&#x2F;模块需要协作管理同一块内存的场景。\n\n\n注意\n注意事项：\n循环引用：如果两个（或多个）shared_ptr彼此持有对方的指针，就会形成循环引用，导致引用计数永远无法归 0，资源泄漏。这时需要配合 weak_ptr来打破循环。\n\n\n\n\n\n\nweak_ptr\n\n核心特性：\n不增加强引用计数：weak_ptr不会增加 shared_ptr的引用计数，它只“观察”shared_ptr管理的资源，本身并不拥有资源。\n解决循环引用：常与 shared_ptr配合使用，用来打破 shared_ptr之间可能出现的循环引用，防止内存泄漏。\n临时获取资源：可以通过 lock()方法临时获取一个有效的 shared_ptr，如果资源还存在（即原 shared_ptr还没被销毁），则返回一个指向该资源的 shared_ptr；否则返回空。\n\n\n如何配合shared_ptr解决循环引用（以双链表为例）\nnext用shared_ptr，prev用weak_ptr\n\n\n\n\n\nFunction\nc++允许同名函数\n\n执行机制：\n\n函数的执行机制\n建立被调用函数的栈空间\n参数传递\n值传递 (call by value)\n引用传递 (call by reference)\n\n\n保存调用函数的运行状态\n将控制转交被调函数\n\n\n\n\nFunction Call\n\n\n\n\n\n第四章（C6） · Function函数调用\n调用流程\n\n\n\n调用约定\n\n_cdecl1. \n参数传递顺序：从右到左将参数压入堆栈。\n堆栈清理：由调用者（caller）负责清理堆栈。\n支持可变参数函数：比如 printf就是使用 cdecl，因为它需要支持可变数量的参数，只有调用者知道传了多少参数，所以必须由调用者来清理堆栈。\n\n\n_stdcall\n参数传递顺序：也是从右到左将参数压入堆栈。\n堆栈清理：由**被调用函数（callee）**负责清理堆栈。\n不支持可变参数函数：因为只有调用者知道传了几个参数，而被调用者负责清理堆栈，所以在参数数量不固定的情况下无法正确清理。因此，像 printf这样的函数就不能用 stdcall。\n\n\n_fastcall\n参数传递方式：部分或全部参数优先通过寄存器传递（通常是前两个或前三个），其余的仍然通过堆栈传递。\n堆栈清理：通常是 被调用者（callee） 负责清理堆栈（和 stdcall类似），但也有编译器实现不同。\n\n\n_thiscall\n\n\n混合编程\n\n由前面可知，C++允许同名函数，但是C不能，所以二者的符号表不同。如果C++程序想调用C的库函数，需要把函数写为extern &#39;C&#39; void func()\n\n\n内联函数inline\n\n由前面可知，函数调用需要额外的开销，包括参数、返回地址等等的空间，以及指针跳转的时间。对于一个小函数来说，没必要使用函数调用。\n\n优点\n\n减少函数调用的开销，提高程序运行效率\n适用于：\n\n函数体很小（比如只有一两行代码）；\n调用非常频繁（比如在循环中被多次调用）；\n追求极致性能的场景，如嵌入式系统、游戏引擎、高频交易等。\n\n\n\n\n实现方式：编译器把inline函数的代码逻辑复制到调用点。和宏类似，但是有区别。\n\n\n\n\n特性\n宏（Macro）\n内联函数（Inline Function）\n\n\n\n类型安全\n❌ 无类型检查\n✅ 有类型检查，是真正的函数\n\n\n调试支持\n❌ 难以调试\n✅ 可以调试\n\n\n防止副作用\n❌ 容易产生副作用\n✅ 参数只求值一次，更安全\n\n\n代码可读性\n❌ 差\n✅ 好\n\n\n编译器优化\n❌ 无智能优化\n✅ 编译器可以做更多优化\n\n\n🔒 结论：在 C++ 中，应该优先使用内联函数，而不是宏，来实现类似“代码展开”的功能。\n\ninline只能申请内联，最终决定权在编译器\n\n\n\n限制：\n\n不能递归\n没有函数指针\n\n\n\n\n\nFunctional Programming\n两种编程范式的比较\n\nImperative Programming\n把计算看做状态机，通过一系列语句改变状态\n\n\nFunctional Programming\n把计算看做数学函数的求值，避免状态和可变数据\n\n\n\n\n对比的例子\n\n// C++ 示例（命令式风格）\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int sum = 0;\n\n    for (int num : nums) {\n        int squared = num * num;  // 每个数平方\n        sum += squared;           // 累加到总和（修改状态）\n    }\n\n    std::cout &lt;&lt; &quot;Sum of squares: &quot; &lt;&lt; sum &lt;&lt; std::endl;\n    return 0;\n}\n\n   1. 用 **for 循环** 逐步遍历   2. 用 **变量（sum, squared）存储中间状态并不断修改**   3. 强调 **“如何一步步做”**2. ```python   # Python 示例（函数式风格）   nums = [1, 2, 3, 4]      # map: 每个元素平方   squared = map(lambda x: x ** 2, nums)      # reduce: 求和（这里用 sum() 更简单，但为了展示函数组合，可以用 reduce）   from functools import reduce   total = reduce(lambda x, y: x + y, squared)      print(&quot;Sum of squares:&quot;, total)\n\n1. 没有显式循环，通过 **map（映射）、reduce（归约）** 等高阶函数处理数据\n2. 没有中间变量被修改，强调 **数据变换的流水线**\n3. 更接近 **“做什么”** 而非 **“怎么做”**\n\n\n\n\n\n第五章（C7、C8） ·  封装面向对象编程OOP\n为什么要用OO（Non-OO有什么问题）\n非面向对象的实现方式虽然直观，但暴露了内部数据结构，缺乏封装，容易导致错误和安全问题，从而引出为什么要考虑更安全的面向对象方案。\n面向对象可以将数据和行为封装在一起，限制对内部状态的直接访问，提高代码的安全性、可维护性和模块化程度，这是对非OO方案问题的改进。\n封装为类之后，可以通过访问关键字控制权限，可以通过构造函数隐藏信息等等\n\n\n\n\nOO的基本概念\n内容要点：Concepts（概念）：\n程序是由多个对象组成的（Program &#x3D; Object1 + Object2 + …）\n对象包含数据与操作（Data + Operation）\n消息传递本质是函数调用\n类 是对象的模板或蓝图\n\n\nClassify（分类）：\n面向对象（Object-Oriented）：具备封装、继承、多态等完整特性。\n基于对象（Object-Based）：如Ada语言，有对象和封装，但没有继承等高级特性。\n\n\n小结：这张PPT从理论层面解释了什么是OOP，它的基本构建单元是对象与类，并对OOP的不同实现层次进行了分类，帮助理解OOP的范畴与特征。\n\n\n\n类\n类的声明和实现一般是分开的。声明在头文件，实现在源文件\n\n源文件中实现对象方法的例子\n\n// SetDate 的实现：把传入的 y/m/d 分别赋值给成员变量 year/month/day\nvoid TDate::SetDate(int y, int m, int d) {  \n    year = y;\n    month = m;\n    day = d;\n}\n\n// IsLeapYear 的实现：判断是否为闰年的逻辑\nint TDate::IsLeapYear() {  \n    return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);\n}\n   2. 但是有一些短小的函数可以在头文件中**内联**   1. ```c++      class TDate &#123;      public:          inline void SetDate(int y, int m, int d) &#123;                year = y; month = m; day = d;           &#125;          int IsLeapYear() &#123;                return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);           &#125;      private:          int year, month, day;      &#125;;\n\n\n\n\n\n\n类的创建于初始化\n\n在栈上创建:TDate g;这样的写法表示 g是一个值类型的对象，在栈上分配内存，生命周期随作用域结束自动销毁。\n\nDate g;\ng.SetDate(2000, 1, 1);    // 给对象 g 设置日期为 2000-1-1\n// \n2. 在堆上创建：与值对象相对的是指针/引用等方式管理的对象（比如堆上的 `p`）。   1. ```c++      TDate *p = new TDate;      p-&gt;SetDate(2015, 11, 17);  // 给指针 p 所指向的对象设置日期      // （注意：实际项目中要记得用 delete p; 释放内存，避免内存泄漏）\n\n\n\n\n\n\n\n\n模块\n\nfoo.cppm文件\n\nexport module M;import K;export int func(int x) &#123;    return 2 + square(x);&#125;\n\n此代码定义了一个名为 M的模块，导入了模块 K，并导出了一个函数 func，该函数调用 square函数并返回计算结果。\n\nClang 模块相关信息\n模块单元文件扩展名：在 Clang 中，模块单元文件使用 .cppm或 .ixx作为扩展名。\n编译后输出：可导入的 pcm（Precompiled Module）：模块经过预编译后生成的中间文件，便于后续快速导入和使用。可链接的对象文件：包含模块代码的机器码文件，可用于链接生成最终可执行文件。\n编译过程：首先使用 make编译模块 K，因为模块 M依赖于 K，所以需要先编译 K。接着使用 make编译模块 M，此时 K已经编译完成可供其导入。最后使用 make编译其他源文件，如 bar.cpp。\n这种模块化的编程方式有助于组织和管理大型项目的代码，减少编译依赖和重复编译等问题。\n\n\n\n构造函数\n是什么\n\n构造函数是 与类同名、无返回类型（连 void也没有）的特殊成员函数，用于 对象的初始化（如为成员变量赋初值、分配资源等）。它在 创建对象时自动调用，开发者无需显式调用，且 不可手动直接调用（如 obj.构造函数()是错误的）。\n\n\n关键特性\n\n可重载：一个类可以定义多个构造函数（参数列表不同），根据对象创建时的实参匹配对应的构造函数（例如支持无参初始化、带参初始化等场景）。\n\n默认构造函数：若类中 未显式定义任何构造函数，编译系统会自动生成一个 无参数的默认构造函数（即 类名() {}）；但 一旦自定义了任意构造函数（无论是否有参数），编译器就不再提供默认构造函数（需手动补全无参版本，否则 类名 obj;这种无参创建方式会报错）。\n\n访问控制：构造函数可以被定义为 public（默认，允许外部直接创建对象）或 private（限制外部直接创建，常用于 单例模式&#x2F;工厂模式 中接管对象创建逻辑，例如通过静态方法间接生成对象）。\n\n委托构造：允许一个构造函数调用同一个类中的 其他构造函数，从而 复用初始化代码，避免重复逻辑，提高代码可维护性。\n\nclass MyClass {\npublic:\n    // 目标构造函数（真正的初始化逻辑）\n    MyClass(int x, int y) : a(x), b(y) { /* ... */ }\n\n    // 委托构造函数（调用目标构造函数）\n    MyClass(int x) : MyClass(x, 0) {  // ✅ 委托调用\n        // ⬇️ 这里可以写额外的逻辑（函数体）\n        // 但是不允许再初始化成员变量了\n        std::cout &lt;&lt; &quot;委托构造，x = &quot; &lt;&lt; x &lt;&lt; std::endl;\n    }\n    \nprivate:\n    int a;\n    int b;\n};\n3. 构造函数的调用   1. **自动调用场景**      1. 构造函数会在 **对象定义时自动触发**，无需手动干预。第2张图通过 `class A`的三种构造函数（无参 `A()`、带 `int`参数 `A(int i)`、带 `char*`参数 `A(char* p)`）演示了不同对象定义方式对应的构造函数调用逻辑。   2. **典型调用示例与等价写法**      1. `A a1 = A(1);`⇔ `A a1(1);`⇔ `A a1 = 1;`→ 均调用 带 `int`参数的构造函数 `A(int i)`（前两种是显式调用，第三种是**隐式类型转换后调用**）。      2. `A a2 = A();`⇔ `A a2;`→ 调用 无参构造函数 `A()`；但 **`A a2();`是错误写法**！它会被编译器解析为 ****函数声明****（声明了一个返回 `A`类型、无参数的函数 `a2`），而非对象定义。      3. `A a3 = A(&quot;abcd&quot;);`⇔ `A a3(&quot;abcd&quot;);`⇔ `A a3 = &quot;abcd&quot;;`→ 调用 带 `char\\*`参数的构造函数 `A(char\\* p)`（同样存在隐式转换逻辑）。   3. **数组对象的构造**：`A a[4];`→ 定义包含4个 `A`对象的数组，每个元素会自动调用 **无参构造函数 `A()`**（依次初始化 `a[0]`到 `a[3]`）。`A b[5] = &#123; A(), A(1), A(&quot;abcd&quot;), 2, &quot;xyz&quot; &#125;;`→ 初始化5个元素的数组：前3个分别显式调用 `A()`、`A(int i)`、`A(char* p)`；后2个（`2`和 `&quot;xyz&quot;`）会尝试 **隐式转换为 `A`对象**（需类中存在对应的构造函数，例如 `A(int)`或 `A(const char*)`，否则编译报错）。### 成员初始化表1. 定义   1. 成员初始化表（Member Initializer List） 是 构造函数的一部分，位于 **构造函数参数列表之后、函数体之前**，以冒号 `:`开头，后面跟着一系列 **成员变量初始化项**，各初始化项之间用逗号分隔。   2. 语法格式：      ```c++      类名(参数列表) : 成员1(值1), 成员2(值2), ... &#123;          // 构造函数函数体（可选）      &#125;\n\n\n\n\n\n\n核心作用\n\n用于初始化类的数据成员（尤其是那些 不能或不应该在构造函数体内赋值 的成员）。是构造函数的补充（不是替代，但推荐优先使用）。\n\n\n执行顺序\n\n先于构造函数体执行（即成员初始化发生在进入构造函数 { ... }之前）。\n按类中数据成员的声明顺序初始化（不是按初始化表中的书写顺序！）。\n\n\n为什么能“减轻 Compiler 负担”？\n\n如果没有成员初始化表，某些成员（如 const成员、引用成员、没有默认构造函数的类对象成员）必须依赖构造函数体内的赋值语句，但这类成员 无法被赋值（只能初始化），编译器会报错。\n使用成员初始化表 可以 直接初始化这些成员，避免额外的默认构造 + 赋值操作，从而 提高效率并减少编译器的隐式处理负担。\n\n\n典型使用场景\n\n推荐在构造函数中尽量使用成员初始化表取代赋值动作\n\n必须使用成员初始化表的场景\n\n初始化 const成员\n\n\nconst成员变量 必须在声明时或构造函数初始化列表中初始化，不能在构造函数体内赋值（因为 const变量一旦初始化后就不能再修改）。\nclass A &#123;    const int y;public:    A() : y(1) &#123;&#125;  // ✅ 正确：必须在初始化列表中初始化    // A() &#123; y = 1; &#125;  // ❌ 错误：不能在构造函数体内赋值&#125;;\n\n\n初始化引用成员\n\n引用成员 必须在定义时绑定到一个对象，因此 只能在初始化列表中初始化，不能后期赋值。\nclass A &#123;    int&amp; z;  // 引用成员    int x;public:    A(int&amp; ref) : z(ref), x(0) &#123;&#125;  // ✅ 正确：引用必须在初始化列表中绑定    // A(int&amp; ref) &#123; z = ref; &#125;  // ❌ 错误：引用不能在构造函数体内赋值&#125;;\n\n\n初始化没有默认构造函数的对象成员\n\n如果类中包含 其他类的对象成员，且该对象 没有默认构造函数，则必须通过成员初始化表 显式调用其有参构造函数。\nclass B &#123;public:    B(int x) &#123;&#125;  // 没有默认构造函数&#125;;class A &#123;    B b;  // B 没有默认构造函数public:    A() : b(10) &#123;&#125;  // ✅ 必须通过初始化列表调用 B(int)    // A() &#123; b = B(10); &#125;  // ❌ 错误：先默认构造 B（不存在），再赋值（不允许）&#125;;\n\n\n\n\n\n\n\n析构函数\n基本定义\n语法格式：~类名()（例如 ~A()、~String()）。\n作用：在 对象生命周期结束时（消亡时）自动调用，主要用于 释放对象持有的非内存资源（因为内存资源即栈上资源是会自动回收的），如动态分配的内存、文件句柄、网络连接等。\n调用时机：当对象离开其作用域（如局部对象在函数结束时）、被 delete删除（动态对象）、或程序终止时，系统 自动调用析构函数。\n默认是 public（允许对象正常销毁）可显式定义为 private\n\n\n访问控制与特殊用法\n访问权限灵活性\n默认 public：允许对象正常销毁（如局部对象作用域结束、delete动态对象）。\n可定义为 private：\n用途：禁止外部直接调用 delete或对象离开作用域时自动销毁（例如实现单例模式、对象池等）。\n示例：若析构函数为 private，则必须通过类内部的特定方法（如 destroy()）手动控制销毁逻辑。\n\n\n\n\n强制自主控制对象存储分配\n通过将析构函数设为 private并提供自定义销毁方法（如 destroy()），可以实现强制自主控制对象的存储分配与释放（避免依赖自动析构）。\n\n\n\n\n使用场景\n析构函数默认是空实现\n如果在类中有动态分配的内存、文件句柄、网络连接等非内存资源，就必须手动写析构函数。\n\n\n\n拷贝构造函数\n是什么\n\n拷贝构造函数（Copy Constructor） 是一种 特殊的构造函数，用于 用一个已存在的同类对象来初始化一个新对象。\n语法形式：A(const A&amp; a)（参数是对同类对象的 常量引用）。\n\n\n核心特点\n\n自动调用：在特定场景下（如对象初始化、函数传参、返回对象等），编译器会自动调用拷贝构造函数。\n与普通构造函数区分：普通构造函数用于创建新对象，而拷贝构造函数用于 基于已有对象创建新对象。\n\n\n典型调用场景（拷贝构造函数在以下情况会被 自动调用）\n\n对象初始化时用另一个对象赋值：A a; A b = a;\n函数传参时传递对象（按值传递）：f(A a)，调用时传入对象会触发拷贝构造。\n函数返回对象（按值返回）：A f() { A a; return a; }，返回时会调用拷贝构造（可能被编译器优化）。\n\n\n定义拷贝构造\n\n默认拷贝构造函数\n\n如果类未显式定义拷贝构造函数，编译器会自动生成一个默认拷贝构造函数。\n默认行为：逐个成员初始化（member-wise initialization）\n对于 基本类型（如 int、float）：直接复制值。\n对于 对象成员：递归调用其自身的拷贝构造函数（即深层次地依次初始化每个成员对象）。\n\n\n\n\n何时需要自定义拷贝构造函数？\n\n当类中包含指针成员并管理动态内存时，默认拷贝构造函数会导致**“浅拷贝”**问题，进而可能引发 悬挂指针、双重释放等严重错误。\n\n浅拷贝问题示例：默认拷贝构造函数只会 简单复制指针的值（地址），而 不会复制指针指向的实际内存内容。导致多个对象共享同一块动态内存，当其中一个对象析构并释放内存后，其他对象的指针会变成 “悬挂指针”（指向已释放的内存），后续访问会导致程序崩溃。\n\n解决方案：深拷贝\n\n自定义拷贝构造函数，为指针成员分配新的内存，并复制原对象指针指向的内容，从而实现 深拷贝（deep copy）。\n\n示例代码：\nclass string &#123;    char* p;  // 动态分配的字符指针public:    // 自定义拷贝构造函数（深拷贝实现）    string(const string&amp; s) &#123;        p = new char[strlen(s.p) + 1];  // 为新对象分配新内存        strcpy(p, s.p);  // 复制原字符串内容到新内存    &#125;&#125;;\n\n\n效果：string s2 = s1;时，s2的指针 p会指向 新分配的内存，并复制 s1的字符串内容，避免与 s1共享内存，从而防止悬挂指针问题。\n\n\n\n\n\n\n自定义拷贝构造函数的风险\n\n默认拷贝构造函数会自动调用成员对象的拷贝构造函数，这是正确的。\n自定义拷贝构造函数，如果没有主动调用成员对象的拷贝构造函数，可能会触发成员对象的默认构造函数，导致没能复制成员对象。\n\n\n\n\n\n右值引用\n左值（LValue）\n\n定义：具有程序运行时可访问的存储地址的值，通常是变量或具有名称的对象。\n\n示例：\na = 1 + 2;\n\n\n变量 a → 有名字、有内存地址 → 是 左值（Lvalue）\n表达式 1 + 2 → 临时计算结果，没有名字、没有固定存储位置 → 是 右值（Rvalue）\n\n\n\n\n右值\n\n定义：通常是临时值、字面量、表达式结果或临时对象，没有持久的内存地址，一般不能被取地址，也不能出现在赋值语句左边。\n\n示例（第1张图右下角）：\n\nclass A &#123;&#125;;int main() &#123;    A a = A();  // A() 是一个临时对象（构造出的匿名对象）&#125;\n\n\nA() → 是一个临时构造出来的对象，没有变量名，无法直接访问 → 是 右值（Rvalue），图中已用箭头标出。\n\n\n核心特点：只能绑定到右值！ ，为移动语义（Move Semantics）和完美转发奠定基础。\n\n使用示例\n\n右值引用（A&amp;&amp;）绑定到右值（重点！）\nA &amp;&amp;aa = getA();  // ✅ 合法：A&amp;&amp; 是右值引用，getA() 返回临时对象（右值）aa.setVal(2);     // ✅ 可以通过右值引用修改该临时对象（前提是该对象非 const）\n\n\n主要用途（为什么要用右值引用）\n\n实现 移动语义（Move Semantics），通过移动构造函数&#x2F;移动赋值运算符，“窃取”临时对象的资源，避免深拷贝，极大提升程序运行效率。\n\nclass Buffer {\n...\n    // 移动构造函数（使用右值引用 T&amp;&amp;）\n    Buffer(Buffer&amp;&amp; other) noexcept {\n        data = other.data;  // 直接“窃取”资源\n        size = other.size;\n        other.data = nullptr;  // 避免原对象析构时 delete data\n        other.size = 0;\n        std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;\n    }\n...\n};\n\nBuffer createBuffer() {\n    Buffer temp(&quot;Hello from temp!&quot;);\n    return temp;  // 返回临时对象（右值），可触发移动构造\n}\n\nint main() {\n    Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！\n}\n   2. 2. 支持 **std::move**，将左值显式转化为右值，主动触发移动而非拷贝。   1. ```c++      int main() &#123;          BigData a(1000);         // 普通构造          BigData b(std::move(a)); // 显式转为右值，触发移动构造！      &#125;\n\n\n\n\n是 完美转发（Perfect Forwarding） 的基础，用于高效传递参数（尤其在模板和标准库中）。\n\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// 目标函数\nvoid process(int&amp; x) { std::cout &lt;&lt; &quot;处理左值: &quot; &lt;&lt; x &lt;&lt; std::endl; }\nvoid process(int&amp;&amp; x) { std::cout &lt;&lt; &quot;处理右值: &quot; &lt;&lt; x &lt;&lt; std::endl; }\n\n// 模板转发函数\ntemplate&lt;typename T&gt;\nvoid forwarder(T&amp;&amp; arg) {\n    process(std::forward&lt;T&gt;(arg));  // 完美转发：保持左值/右值性质\n}\n\nint main() {\n    int x = 42;\n    forwarder(x);            // 传左值 -&gt; 调用 process(int&amp;)\n    forwarder(123);          // 传右值 -&gt; 调用 process(int&amp;&amp;)\n}\n      4. 优化标准库容器（如 `std::vector`、`std::string`）在插入、扩容、返回值等场景下的性能表现。### 三种引用类型对比| 类型       | 绑定对象   | 是否可修改被引用对象 | 示例 / 说明           | 典型用途                                    || :--------- | :--------- | :------------------- | --------------------- | :------------------------------------------ || 非常量引用 | 左值       | ✅ 能                 | int &amp;ra = a;          | 函数内要修改传入的对象                      || 常量引用   | 左值、右值 | ❌ 不能               | const A &amp;ca = getA(); | 只读访问，避免拷贝（如传参时）              || 右值引用   | 右值       | ✅ 能（通常自己管理） | A &amp;&amp;aa = getA();      | 移动语义、高效资源管理、完美转发（C++11起） |### 移动构造函数| 特性           | 拷贝构造函数（Copy Constructor）           | 移动构造函数（Move Constructor）                     || :------------- | :----------------------------------------- | :--------------------------------------------------- || **语法**       | `A(const A&amp; a)`（常量左值引用）            | `B(B&amp;&amp; b)`（右值引用）                               || **资源操作**   | **复制资源**（如深拷贝动态内存、复制内容） | **转移资源所有权**（如指针指向的资源直接“接管”）     || **适用场景**   | 一般对象初始化、需要独立副本时             | **临时对象、大资源管理（避免深拷贝开销）**           || **性能影响**   | 可能较慢（如深拷贝大内存）                 | **更快（仅转移指针等轻量操作）**                     || **原对象状态** | 原对象保持有效，资源独立                   | **原对象资源被“掏空”（如指针置空），不再管理原资源** |1. 移动构造函数的实现   1. **接收一个右值引用参数（`T&amp;&amp;`）**，表示它只能绑定到临时对象（右值）。   2. **“窃取”源对象（右值）内部的资源（如动态内存指针、文件句柄等）**，而不是重新分配和深拷贝。   3. **将源对象的资源指针“置空”或置为有效但无害的状态**，防止原对象析构时误释放已转移的资源，或产生双重释放。2. 示例   1. ```c++      class Buffer &#123;      ...          // 移动构造函数（使用右值引用 T&amp;&amp;）          Buffer(Buffer&amp;&amp; other) noexcept &#123;              data = other.data;  // 直接“窃取”资源              size = other.size;              other.data = nullptr;  // 避免原对象析构时 delete data              other.size = 0;              std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;          &#125;      ...      &#125;;            Buffer createBuffer() &#123;          Buffer temp(&quot;Hello from temp!&quot;);          return temp;  // 返回临时对象（右值），可触发移动构造      &#125;            int main() &#123;          Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！      &#125;\n\n\n\n\n\n\n\n\n\n动态内存管理\n操作系统内的内存管理\n\n两种类型：栈和堆\n\nC &#x2F; C++对比\n\n\n\n\n操作\nC (malloc/free)\nC++ (new/delete)\n\n\n\n分配内存\nmalloc(sizeof(T))\nnew T\n\n\n释放内存\nfree(ptr)\ndelete ptr\n\n\n调用构造函数&#x2F;析构函数？\n❌ 不调用\n✅ 调用\n\n\n是否类型安全？\n❌ 不安全（返回 void*）\n✅ 类型安全操作\n\n\n\nC 语言：\n\nmalloc()：分配内存\nfree()：释放内存\n⚠️ 不会调用构造函数和析构函数\n\n\nC++ 语言：\n\nnew：分配内存 并调用构造函数\ndelete：释放内存 并调用析构函数\n\n\n\n\n\n\nC++ 动态对象（new&#x2F; delete）\n\n动态对象：在 堆（Heap） 上创建的对象，生命周期由程序员控制。\n\nnew的作用：\n\n分配内存 并调用构造函数（比 malloc更安全）。\n语法：\n\nT* ptr = new T;          // 无参构造T* ptr = new T(args...); // 带参构造\n\ndelete的作用：\n\n释放内存 并调用析构函数（比 free更安全）。\n语法：\n\ndelete ptr;       // 单个对象delete[] ptrArr;  // 对象数组\n\n注意事项：\n\nnew和 delete必须配对（new[]必须对应 delete[]）。\n\n释放后置空指针（ptr = nullptr），避免 悬空指针（Dangling Pointer）。\n\n不要混用 malloc/free和 new/delete（可能导致未定义行为）。\n\n\n\n\n\n动态数组\n\n一维动态数组创建与释放\n\n创建动态数组：\nT* arr = new T[100];  // 100 个 T 对象（调用默认构造函数）\n\n释放动态数组：\ndelete[] arr;  // 必须用 delete[]，否则行为未定义！\n\n关键点：\n\n类必须提供默认构造函数（否则 new T[100]编译失败）。\ndelete[]不能漏掉 []，否则可能只释放第一个对象，导致内存泄漏。\n\n\n\n\n二维动态数组创建与释放\n\n分配方式（分两步）：\n\n分配行指针数组（char**）\n为每一行分配列数组（char*）\n\nconst int ROWS = 3, COLS = 4;char** arr2D = new char*[ROWS];  // 分配行指针for (int i = 0; i &lt; ROWS; i++) &#123;    arr2D[i] = new char[COLS];   // 每行分配列&#125;\n\n释放方式（逆向释放）：\nfor (int i = 0; i &lt; ROWS; i++) &#123;    delete[] arr2D[i];  // 先释放每一行的列&#125;delete[] arr2D;  // 再释放行指针数组\n\n关键点：必须按分配顺序逆向释放（先释放“子数组”）。new[]和 delete[]必须配对，否则内存泄漏。\n\n\n\n\n\n\nconst成员\nconst成员变量\n\nconst成员变量 是类的成员变量，一旦初始化后 不能被修改。\n必须通过构造函数的成员初始化列表（Member Initializer List）进行初始化，不能在构造函数体内直接赋值。\n\nclass A &#123;private:    const int x;  // const 成员变量public:    // 必须通过成员初始化列表初始化 const 成员变量    A(int val) : x(val) &#123;&#125;  // ✅ 正确    // A(int val) &#123; x = val; &#125;  // ❌ 错误！不能在构造函数体内赋值&#125;;\n\nconst成员函数（常量成员函数）\n\n定义\n\nconst成员函数 是 不会修改对象状态 的成员函数，用 const修饰。\n承诺不会修改类的任何非 mutable成员变量。\n可以访问 const和非 const对象，但非 const成员函数只能访问非 const对象。\n\n\n示例\n\n\nclass TDate &#123;private:    int year;public:    int GetYear() const &#123;  // const 成员函数        return year;       // 只能读取，不能修改 year    &#125;    void SetYear(int y) &#123;  // 非 const 成员函数        year = y;          // 可以修改 year    &#125;&#125;;\n\n\n关键点\nconst成员函数不能修改成员变量（除非变量是 mutable）。\n\nconst对象只能调用 const成员函数，非 const对象可以调用所有成员函数。\n\n很好理解，如果const对象可以调用非const函数，就可能间接修改了对象状态。\n\n\nconst成员函数可以重载（例如，GetYear()和 GetYear() const可以同时存在）。\n\n\n\n\n\nmutable（可变成员变量）\n\n定义\n\nmutable 用于修饰 即使在 const成员函数中也可以被修改的成员变量。\n通常用于 缓存、日志、调试计数等不影响对象逻辑状态的变量。\n\n\n示例\n\n\nclass CacheExample &#123;private:    mutable int cacheHits;  // 即使在 const 函数中也可以修改    int data;public:    int GetData() const &#123;        cacheHits++;  // ✅ 允许，因为 cacheHits 是 mutable        return data;    &#125;&#125;;\n\n\n关键点\n\n\nmutable变量可以绕过 const限制，但应谨慎使用（通常用于内部优化）。\n\n\nconst参数（函数参数）\n\n定义\nconst参数 表示 函数内部不会修改该参数。\n可以用于 指针、引用，防止意外修改传入的数据。\n\n\n示例\n\nvoid Print(const std::string&amp; str) &#123;  // str 不会被修改    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;void Modify(int* const p) &#123;  // p 本身不能改（指针不能指向别的地址），但 *p 可以改    // p = nullptr;  // ❌ 错误！p 是 const 的    *p = 100;  // ✅ 可以修改 *p&#125;\n\n\n关键点\n\nconst T&amp;（常量引用）：避免拷贝，同时防止修改。\n\nconst T*（指向常量的指针）：指针可以改，但指向的数据不能改。\n\nT* const（常量指针）：指针不能改，但指向的数据可以改。\n\n\n\n\n\n\n常量表达式\n是什么\n\n常量表达式 是指 在编译期就能计算出结果的表达式（即不需要等到运行时才计算）。\n\n\n核心优势：更快：因为计算在编译期完成，运行时无需额外开销。更安全：错误（如非法计算、类型不匹配）能在编译期提前暴露，而不是等到运行时崩溃。\n\n两个关键字\n\n\n\n\n概念\n说明\n适用场景\n示例\n\n\n\nconstexpr\n可编译期或运行期求值\n数组大小、模板参数、查表、位运算\nconstexpr int sqr(int x) { return x * x; }\n\n\nconsteval(C++20)\n必须编译期求值，调用点必须为常量\n强制编译期计算\nconsteval int pow2(int n) { return 1 &lt;&lt; n; }\n\n\n\nconstexpr（C++11 起）\n\n定义\n\nconstexpr 表示 该函数或变量可以在编译期求值，但也允许在运行期使用（灵活性更高）。\n适用对象：变量：constexpr int x = 10;（编译期常量）函数：constexpr int sqr(int x) { return x * x; }（若参数是编译期常量，则结果也是编译期常量）\n\n\n特点\n\n可以在编译期或运行期求值（取决于调用时的参数是否为编译期常量）。\n适用于数组大小、模板参数、switch-case标签等需要编译期确定值的场景。\n提升运行时效率（因为很多计算提前到编译期完成）。\n\n\n示例\n\nstruct Point {\n    int x, y;\n    constexpr Point(int xx, int yy) : x(xx), y(yy) { }  // constexpr 构造函数\n};\n\nint main() {\n    constexpr Point origo(0, 0);  // 编译期对象\n    constexpr int z = origo.x;    // 编译期访问成员\n    constexpr Point a[] = {       // 编译期数组\n        Point(0, 0), Point(1, 1), Point(2, 2)\n    };\n    constexpr int x = a[1].x;     // 编译期计算，x = 1\n}\n      2. 3. **`consteval`（C++20 新增）**   1. 定义      - `consteval` 是 C++20 引入的关键字，比 `constexpr`更严格。      - 要求函数必须在编译期执行，并且 调用点必须传入编译期常量，否则 编译报错。      - 适用场景：当你 强制要求某个函数只能在编译期运行（不允许运行期调用）。   2. 特点      1. **只能在函数声明上使用。**      2. **函数调用必须在编译期完成（参数必须是编译期常量）。**      3. **如果调用时传入运行期变量（非编译期常量），则编译报错。**   3. 示例      1. ```c++         constexpr int sqr(int x) &#123; return x * x; &#125;  // 可编译期/运行期求值         constexpr int A = sqr(10);  // ✅ 编译期计算         int y = 3;         int B = sqr(y);  // ✅ 允许（运行期计算）                  consteval int pow2(int n) &#123; return 1 &lt;&lt; n; &#125;  // 必须编译期求值         constexpr int M = pow2(8);  // ✅ 编译期计算（合法）         // int r = pow2(y);  // ❌ 编译报错！y 不是编译期常量\n\n\n\n\n\n\n\n\n\n\n静态成员\n是什么\n\n静态成员属于类本身，而不是某个对象，是 类的所有对象共享的。\n\n\n静态成员变量（Static Member Variables）\n\n定义\n静态成员变量 是类的所有对象 共享的变量，只有一份拷贝，无论创建多少个对象。\n必须要在类外单独定义和初始化（C++17 前），C++17 开始可以用 inline在类内直接初始化。\n\n\n语法\n\nclass A &#123;public:    int x, y;                    // 普通成员变量（每个对象独立一份）    static int shared;           // 静态成员变量声明（类内声明）    &#123;    \t// C++17 支持：    inline static int shared = 0; （类内直接初始化）    &#125;&#125;;// 类外定义并初始化（C++17 前必须这样做）int A::shared = 0;  int main() &#123;    A a, b;  // a 和 b 共享同一个 shared 变量&#125;\n\n静态成员函数\n\n同Java静态函数\n\n特性\n1. \n\n\n\n\n特性\n说明\n\n\n\n只能访问静态成员\n不能直接访问 非静态成员变量&#x2F;函数\n\n\n没有 this指针\n因为它不依赖于某个具体对象\n\n\n可通过类名直接调用\n如 A::f()，无需创建对象\n\n\n遵循类访问控制\n可声明为 public&#x2F; private&#x2F; protected\n\n\n\n\n\n\n\n静态成员的应用\n1. **单例模式**\n\n1. 利用 **静态成员变量（保存唯一实例）** 和 **静态成员函数（获取实例）** 实现。\n\n2. ```c++\n   class Singleton {\n   protected:\n       Singleton() {}  // 构造函数保护，防止外部创建对象\n       Singleton(const Singleton&amp;) = delete;  // 禁止拷贝\n   \n   public:\n       // 获取唯一实例（静态函数）\n       static Singleton* instance() {\n           if (m_instance == nullptr)\n               m_instance = new Singleton();\n           return m_instance;\n       }\n   \n       // 销毁实例（静态函数）\n       static void destroy() {\n           delete m_instance;\n           m_instance = nullptr;\n       }\n   \n   private:\n       static Singleton* m_instance;  // 唯一实例指针\n   };\n   \n   // 类外初始化静态成员\n   Singleton* Singleton::m_instance = nullptr;\n   2. 对象计数1. ```c++           class A &#123;       static int obj_count;  // 静态成员变量，记录对象个数     public:       A() &#123; obj_count++; &#125;          // 构造时 +1       ~A() &#123; obj_count--; &#125;         // 析构时 -1         // 静态函数，返回当前对象数       static int get_num_of_obj() &#123;           return obj_count;       &#125;   &#125;;     // 类外定义静态成员变量   int A::obj_count = 0;     int main() &#123;       A a1, a2;       std::cout &lt;&lt; A::get_num_of_obj();  // 输出 2   &#125;\n    \n    2.\n\n\n\n友元\n是什么\n\nC++ 的封装性 要求类的 私有（private）和保护（protected）成员只能被本类的成员函数访问。\n但有时，某些外部函数或类也需要访问这些私有成员（比如运算符重载、矩阵运算、工具函数等）。\n友元机制 提供了一种 “特殊权限”，允许 指定的外部函数或类访问当前类的私有成员，突破封装限制，但仅限于被声明为友元的部分。\n\n\n使用场景\n\n\n\n\n类型\n说明\n示例（代码片段）\n\n\n\n友元函数（Friend Function）\n一个 普通函数（非成员函数），被声明为某个类的友元后，可以访问该类的 私有（private）和保护（protected）成员\nfriend void func();（在类内声明）\n\n\n友元类（Friend Class）\n一个 类（Class B） 被声明为另一个类（Class A）的友元后，该类的所有成员函数 都可以访问 Class A 的 私有成员\nfriend class B;\n\n\n友元类成员函数（Friend Class Member Function）\n某个特定类（如 Class C）的某个成员函数（如 void f()） 被声明为友元，只有这个函数 可以访问当前类的私有成员\nfriend void C::f();\n\n\n\n\n\n使用方法\n\nclass A {\nprivate:\n    int secret;\npublic:\n    friend void func();             // 友元函数\n    friend class B;                 // 友元类\n    friend void C::f();             // 友元类成员函数（需提前声明 C 和 f）\n};\n4. 重要特性   1. | 特性                 | 说明                                                         |      | :------------------- | :----------------------------------------------------------- |      | **友元不具有传递性** | 如果 A 是 B 的友元，B 是 C 的友元，**不代表 A 是 C 的友元**  |      | **友元不具有继承性** | 如果 B 是 A 的友元，B 的子类 **不自动成为 A 的友元**         |      | **友元关系是单向的** | 如果 A 声明 B 是友元，**不代表 B 也自动声明 A 是友元**       |      | **编译检查**         | 友元函数/类必须在类 **外部定义**，但必须在类 **内部声明为 friend** |## 第六章（C9） · 继承### 继承1. 概述   1. 定义：继承是面向对象程序设计中的核心机制，它允许新的类（派生类）基于已有的类（基类）来构建，从而实现**代码复用**和**层次化分类**。   2. 主要作用      1. **基于目标代码的复用**：避免重复编写相同功能的代码      2. **对事物进行分类**：通过层次结构清晰地描述现实世界的关系      3. **增量开发**：在现有类的基础上扩展新功能，实现渐进式开发2. 语法：   1. ```c++      // 以单继承为例      class 基类 &#123;          // 基类的成员（数据成员和成员函数）      &#125;;            class 派生类 : 访问控制 基类 &#123;          // 派生类的成员      &#125;;\n\n\n\n\n三种继承类别\n1. \n\n\n\n\n访问级别（基类的访问控制）\n说明\n\n\n\npublic\n成员可以被任何代码访问，包括类的使用者、派生类等\n\n\nprotected\n成员只能被该类自身及其派生类访问，外部代码不能直接访问\n\n\nprivate\n成员只能被该类自身访问，派生类和外部代码均不能直接访问\n\n\n\n\n\n\n继承方式（继承时指出）\n说明\n基类成员访问权限变化\n\n\n\npublic\n公有继承\n保持原有访问权限\n\n\nprotected\n保护继承\npublic→protected\n\n\nprivate\n私有继承\n所有成员→private\n\n\n\n\n\n常见问题：\n\n名覆盖：\n\n在派生类中定义了和基类中同名的函数或类，会导致基类中的对象不可见（被隐藏、被覆盖），调用时可能找不到而报错。如果要调用需要显示指明命名空间。\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base {\npublic:\n    void show() {\n        cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; endl;\n    }\n\n    void show(int x) {\n        cout &lt;&lt; &quot;Base::show(int): &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void show() {  // 派生类定义了一个同名的 show() 函数\n        cout &lt;&lt; &quot;Derived::show()&quot; &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Derived d;\n    d.show();        // OK，调用 Derived::show()\n    // d.show(10);   // 错误！Base::show(int) 被隐藏了，找不到这个函数\n    d.Base::show(10); // 正确：通过 Base:: 明确调用基类的版本\n    return 0;\n}\n   2. 对象切片      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。      2. 对象身份变化分析         - 派生类特有的成员被&quot;切掉&quot;         - 只保留基类部分的成员         - 对象身份从派生类变为基类类型   3. 私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数5. 构造与析构   1. 构造顺序      1. 第一，基类构造函数      2. 第二，派生类的成员类的构造函数（所依赖的类）      3. 第三，派生类构造函数   2. 析构顺序：和构造顺序相反   3. 如何调用基类的构造函数      1. 基类有默认构造函数（无参构造函数）         1. 如果你的基类有一个无参构造函数（默认构造函数），而你在派生类中没有显式调用基类构造函数，编译器会**自动调用基类的默认构造函数**。         2. ```c++            class Base &#123;            public:                Base() &#123;                    cout &lt;&lt; &quot;Base 默认构造函数&quot; &lt;&lt; endl;                &#125;            &#125;;                        class Derived : public Base &#123;            public:                Derived() &#123;                    cout &lt;&lt; &quot;Derived 默认构造函数&quot; &lt;&lt; endl;                &#125;            &#125;;                        int main() &#123;                Derived d;  // 先调用 Base()，再调用 Derived()                return 0;            &#125;\n\n3. \n\n\n基类没有默认构造函数，或你想调用指定的基类构造函数\n\n如果基类没有无参构造函数，或者你想要调用基类的某个有参构造函数，那么你必须在派生类的构造函数初始化列表中显式调用基类的构造函数\n\nclass Base {\npublic:\n    Base(int x) {\n        cout &lt;&lt; &quot;Base(int): &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    Derived(int y) : Base(y) {  // 显式调用基类构造函数\n        cout &lt;&lt; &quot;Derived(int): &quot; &lt;&lt; y &lt;&lt; endl;\n    }\n};\n         3. ### 虚函数#### 虚函数的定义与特性1. 通过上面的介绍我们知道了：**虚函数就是多态函数**2. 重定义规则：   1. 如果基类函数声明为`virtual`，派生类中的重定义函数自动成为虚函数   2. 重定义函数必须与基类虚函数具有相同的签名   3. 使用`override`关键字（C++11）可以增强安全性3. 限制条件   1. | 函数类型     | 能否为虚函数 | 说明                       |      | :----------- | :----------- | :------------------------- |      | 普通成员函数 | ✅            | 主要的虚函数应用场景       |      | 静态成员函数 | ❌            | 与具体对象无关             |      | 内联成员函数 | ❌            | 编译时展开，与动态绑定冲突 |      | 构造函数     | ❌            | 对象构造期间虚表未完全建立 |      | 析构函数     | ✅            | 应该声明为虚函数           |   2. 在 C++ 的**继承与多态**场景中，**如果基类的析构函数不是虚函数（non-virtual destructor），而你通过基类指针删除派生类对象，就可能导致派生类部分的资源没有被正确释放，从而引发内存泄漏或其他未定义行为。**      1. 经典且推荐的实现：`virtual ~B() = default;`#### 类型相容与对象赋值机制1. 基础概念：   1. 类型相容是指不同数据类型之间能否进行赋值操作的兼容性规则。在继承体系中，派生类对象可以赋值给基类对象，但反之不成立。   2. 这里引出了**对象切片**的问题。      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。      2. 对象身份变化分析         - 派生类特有的成员被&quot;切掉&quot;         - 只保留基类部分的成员         - 对象身份从派生类变为基类类型2. 指针和引用的类型相容   1. 基类的指针或引用可以指向派生类对象，这是实现多态的基础：   2. ```c++      B* pb = new B();      A* pa = pb;     // 合法：基类指针指向派生类对象      A&amp; ra = *pb;    // 合法：基类引用绑定派生类对象\n\n\n\n\n\n\n\n\n对象身份发生变化，调用命名空间随之变化。\n\n\n虚函数的绑定机制\n引入\n\n\nfunc2()调用的是A还是B呢？这涉及到绑定机制。C++在默认情况下，是静态绑定，那么就会按照参数类型调用A::f()。如果需要动态绑定，则需要手动用virtual显式指出。\n\n\n静态绑定\n\n发生时机：编译时刻\n\n依据：对象的静态类型（声明类型）\n\n优点：执行效率高\n\n缺点：灵活性差\n\nclass Base {\npublic:\n    void nonVirtual() { cout &lt;&lt; &quot;Base::nonVirtual&quot;; }\n};\n\nBase* ptr = new Derived();\nptr-&gt;nonVirtual();  // 总是调用Base::nonVirtual（前期绑定）\n3. 动态绑定   1. 发生时机：运行时刻   2. 依据：对象的实际类型（动态类型）   3. 优点：灵活性高，支持多态   4. 缺点：效率相对较低   5. ```c++      class Base &#123;      public:          virtual void virtualFunc() &#123; cout &lt;&lt; &quot;Base::virtualFunc&quot;; &#125;      &#125;;            Base* ptr = new Derived();      ptr-&gt;virtualFunc();  // 根据实际对象类型调用（动态绑定）\n\n\n\n\n\n后期绑定的实现\n虚函数表的内存布局\n每个包含虚函数的类都有一个虚函数表（vtable），对象中包含指向该表的指针（vptr）。\nclass A &#123;    int x, y;public:    virtual void f();    virtual void g();    void h();&#125;;class B : public A &#123;    int z;public:    void f() override;  // 重写虚函数    void h();           // 重定义普通函数&#125;;\n\n虚函数调用过程\n\n通过对象的vptr找到虚函数表\n在虚函数表中查找函数地址\n根据实际对象类型调用正确的函数\n\nA a; B b;A* p = &amp;b;p-&gt;f();  // 调用B::f（通过虚函数表动态绑定）\n\n构造函数中的虚函数调用\n构造函数中的虚函数调用\n\n虚函数表是在构造函数中完成的，这就意味着构造到哪里，身份就到哪里。\n\n在构造函数执行期间，虚函数机制尚未完全建立：\n\n虚函数表指针（vptr）在构造函数中逐步设置\n在基类构造函数中调用虚函数，实际调用的是当前类的版本\n直到构造函数返回后，对象才能正常使用虚函数机制\n\n\nclass A {\npublic:\n    A() { f(); }  // 构造函数中调用虚函数\n    virtual void f() { cout &lt;&lt; &quot;A::f&quot;; }\n    void g() { cout &lt;&lt; &quot;A::g&quot;; }\n    void h() { f(); g(); }\n};\n\nclass B : public A {\npublic:\n    void f() override { g(); }  // 调用g()函数\n    void g() { cout &lt;&lt; &quot;B::g&quot;; }\n};\n\nB b;           // 输出：A::f（构造函数中调用A::f） *** 重点看这里 ***\nA* p = &amp;b;\np-&gt;f();        // 输出：B::g（通过虚函数表调用B::f，其中调用B::g）\np-&gt;g();        // 输出：A::g（非虚函数，静态绑定）\np-&gt;h();        // 输出：B::g A::g（h()中f()动态绑定，g()静态绑定） *** 重点看这里 ***\n#### 友元与protected1. 友元的友元不是友元2. 派生类的友元不是友元   1. ```c++      class Base &#123;      protected:          int prot_mem; // protected 成员      &#125;;            class Sneaky : public Base &#123;          friend void clobber(Sneaky&amp;);  // 能访问Sneaky::prot_mem          friend void clobber(Base&amp;);    // 不能访问Base::prot_mem          int j;                         // j 默认是private      &#125;;\n\n\nfriend void clobber(Base&amp;);：表示 clobber函数是 Base类的友元吗？不，这里是 Sneaky类把 clobber(Base&amp;)声明为友元。但 protected成员的访问权限有个关键限制：派生类只能让自己的友元访问自己继承来的 protected 成员，而不能直接让友元去访问基类的 protected 成员（除非友元是基类本身声明的，或者有其他特殊继承&#x2F;友元关系）。所以这个 clobber(Base&amp;)虽然是 Sneaky的友元，但它并不能访问 Base类里的 prot_mem。\n\n\n\n\n纯虚函数与抽象类\n纯虚函数\n是什么\n在 C++ 中，如果一个虚函数没有具体的实现，并且在声明时被赋值为 0，这样的函数就称为纯虚函数。\nvirtual 返回类型 函数名(参数列表) = 0;\n注意纯虚函数没有函数体（可以没有实现）。\n\n\n为什么要纯虚函数\n它定义了一个接口，要求派生类必须去实现它（除非派生类也是抽象类）。\n\n\n\n\n抽象类\n是什么\n如果一个类包含至少一个纯虚函数，那么这个类就称为抽象类。\n抽象类不能创建对象（不能实例化），它只能作为基类被继承。\n抽象类的目的是为了定义一个通用的接口或行为规范，强制派生类去实现这些行为。\n一般作为指针类型实现接口。\n\n\n\n\n\nfinal与override\nstruct B &#123;    virtual void f1(int) const;    virtual void f2();    void f3();    virtual void f5(int) final;&#125;;struct D : B &#123;    void f1(int) const override; // 正确: f1与基类中的f1 匹配    void f2(int) override;       // 错误: B没有形如f2(int) 的函数。int f2()?    void f3() override;          // 错误: f3不是虚函数    void f4() override;          // 错误: B没有名为f4的函数    void f5(int);                // 错误: B已经将f5声明成final&#125;;\n\n建议重写虚函数时要用上override关键字\n\n为什么要使用override\n\n编译时检查：确保重写的函数确实存在于基类\n代码可读性：明确标识这是重写函数\n维护性：当基类虚函数改变时，派生类中的override会报错\n\n\n为什么要使用final\n\n设计约束：明确某些类或函数不应该被进一步扩展\n性能优化：编译器可能对final函数进行去虚拟化优化\n安全性：防止意外的重写或继承\n\n\n\n访问控制\n访问控制检查在编译时期执行，因此只会检查静态类型\n\n如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。\n\n所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。\n\n\n\n设计原则\n确定共有继承是真正意义的 ‘is_a’ 关系\n\n在面向对象设计里，public继承表示 “是一种（is-a）” 关系。例如，如果写 class Dog : public Animal，就意味着 “狗是一种动物”——Dog 必须能替代 Animal 做所有 Animal 能做的事（里氏替换原则 Liskov Substitution Principle）。\n反过来，如果不是 “is-a” 关系，就不应该用 public继承；否则会导致语义混乱、代码难以维护甚至出现难以调试的错误。\n\n\n不要定义与继承而来的非虚成员函数同名的成员函数\n\n如果基类里有非虚成员函数，派生类里又定义了一个同名的成员函数，这在 C++ 里属于 “隐藏（Name Hiding）”，而非 “重写（Override）”。这很容易让程序员误以为是 “多态”，结果却出现和预期完全不同的行为（比如根据指针&#x2F;引用类型调用到不同函数，而不是根据实际对象类型）。\n更糟糕的是，一旦基类把那个函数改成 virtual，派生类里同名的函数就会自动变成 “重写”，行为可能瞬间改变，埋下隐患。\n\n\n保持派生类实现与基类虚函数的访问控制一致\n\n如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。\n所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。\n\n\n慎用私有继承\n\n私有继承常用于 “Implemented - in - term - of” 场景，也就是当派生类想要复用基类的实现（比如使用基类的 protected成员，或者重写基类的虚函数），但又不希望把基类暴露给外部客户端时，就可以使用私有继承。\n\n私有继承在 “设计层面” 并没有太多语义上的含义（不像公有继承那样表达 “is - a” 关系），它更多是在 “实现层面” 帮我们复用代码。\n\n私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数（就像示例中 eat(b)会报错那样）\n\nclass CHumanBeing { ... };\nclass CStudent: private CHumanBeing { ... };\nvoid eat(const CHumanBeing&amp; h) { ... }\nCHumanBeing a; CStudent b;\neat(a);\neat(b); // Error\n5. **绝对不要重新定义继承而来的缺省参数值**   1. 核心问题      1. **虚函数** 是实现**动态绑定（运行时多态）** 的关键。 虚函数的调用会根据对象的**实际类型** 来决定调用哪个类的虚函数版本。      2. **默认参数** 是在**编译时期** 就确定下来的，属于**静态绑定**。 默认参数的值由**指针或引用的声明类型** 决定，而不是对象的**实际类型** 决定。      3. 当你在派生类中重新定义了从基类继承而来的虚函数的默认参数值时，就会产生混淆和潜在的错误，因为：         - 函数调用是动态绑定的（决定调用哪个虚函数）。         - 默认参数值是静态绑定的（决定用什么默认值）。      4. 这会导致**函数的调用版本** 和 **默认参数的值** 可能不匹配， 从而出现不符合预期的行为。   2. 代码分析      1. ```c++         class A          &#123;          public:              virtual void f(int x=0) =0;          &#125;;                  class B: public A          &#123;          public:              virtual void f(int x=1)   // ❌ 错误示范：重新定义了继承来的默认参数！             &#123; cout &lt;&lt; x;&#125;          &#125;;                  class C: public A          &#123;          public:              virtual void f(int x) &#123; cout&lt;&lt; x;&#125;          &#125;;                  // 主逻辑：         A *p_a;          B b;          p_a = &amp;b;          p_a-&gt;f();                   A *p_a1;          C c;          p_a1 = &amp;c;          p_a1-&gt;f();\n\n2. 分析函数调用和默认参数\n\n   1. 调用 `p_a-&gt;f()`（p_a 指向 B 对象 b）\n\n      1. 虚函数调用（动态绑定）： 因为 `p_a`是指向 `A`的指针，而 `A`中的 `f`是虚函数，并且 `b`实际上是 `B`类型，所以会**动态绑定到 `B::f`**。\n\n      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a`的声明类型 `A\\*` 决定的，而不是由 `p_a`实际指向的对象类型 `B`决定的。所以，`B::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`**（而不是 `B`中错误定义的 `x=1`）**。因此，`p_a-&gt;f()`等价于 `B::f(0)`， 输出 `0`。\n\n   3. 调用 `p_a1-&gt;f()`（p_a1 指向 C 对象 c）\n\n      1. 虚函数调用（动态绑定）： `p_a1`是指向 `A`的指针，`A`中的 `f`是虚函数，并且 `c`实际上是 `C`类型，所以会**动态绑定到 `C::f`**。\n\n      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a1`的声明类型 `A\\*` 决定的，而不是由 `p_a1`实际指向的对象类型 `C`决定的。所以，`C::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`（因为 `C`中没有重新定义默认参数）。因此，`p_a1-&gt;f()`等价于 `C::f(0)`， 输出 `0`。\n\n\n\n\n\n多继承概述\n是什么\n\n定义：多继承是C++面向对象编程中的重要特性，它允许一个派生类同时从多个基类继承属性和方法。这种机制提供了更大的灵活性，但也带来了更复杂的语义和实现问题。\n\n基本语法：\n\nclass &lt;派生类名&gt; : [&lt;继承方式&gt;] &lt;基类名1&gt;, [&lt;继承方式&gt;] &lt;基类名2&gt;, ...\n{\n    &lt;成员表&gt;\n};\n      2. 2. 多继承中的名冲突问题   1. ```c++      class Base1 &#123;      public:          void display() &#123; cout &lt;&lt; &quot;Base1 display&quot; &lt;&lt; endl; &#125;          int value = 10;      &#125;;            class Base2 &#123;      public:          void display() &#123; cout &lt;&lt; &quot;Base2 display&quot; &lt;&lt; endl; &#125;          int value = 20;      &#125;;            class Derived : public Base1, public Base2 &#123;      public:          void show() &#123;              // display();     // 错误：名冲突，不知道调用哪个display              // cout &lt;&lt; value; // 错误：名冲突，不知道访问哪个value          &#125;      &#125;;\t      \n\n\n\n\n当多个基类包含同名成员时，会产生名冲突（Name Conflict）\n\n用使用作用域解析运算符明确指定要访问的成员\n\n\n\n菱形继承的数据冗余问题\n\n是什么：\n\n当B，C继承自A，而D多继承自B，C，那么D中就会出现B::x和C::x，然而x实际上都来自A::x，这就造成了冗余。\n\n\n造成的后果\n\n派生类D中将包含两份A的成员副本\n访问A的成员时会产生二义性\n内存布局复杂，存在冗余数据\n\n\n解决方案：虚继承\n\n\n\n\n虚继承\n虚继承是解决菱形继承问题的关键技术，它确保公共基类在派生类中只有一个副本：\n\n示例：\n\nclass A {\npublic:\n    int x;\n};\n\nclass B : virtual public A {  // 虚继承\n    // 虚继承A\n};\n\nclass C : public virtual A {  // 虚继承，两种写法等价\n    // 虚继承A\n};\n\nclass D : public B, public C {\n    // 现在D中只有一份A的成员x\n};\n2. 虚继承的工作原理   1. 虚继承通过引入**虚基类表指针**来实现：      1. 每个虚继承的类包含一个指向共享基类的指针      2. 最终派生类负责初始化虚基类      3. 所有中间类共享同一个基类实例   2. 内存模型      1. ```         D对象：         +-------------------+         | 虚基类表指针(B)   |         | B特有成员         |         +-------------------+         | 虚基类表指针(C)   |         | C特有成员         |         +-------------------+         | D特有成员         |         +-------------------+         | 共享的A部分       |  ← B和C通过指针共享         +-------------------+\n\n2.\n\n\n\n\n虚继承的特殊规则\n\n构造函数调用顺序\n虚基类的构造函数调用有特殊规则：\n\n虚基类的构造函数优先执行\n然后按声明顺序执行非虚基类的构造函数\n最后执行派生类自身的构造函数\n\nclass A &#123;public:    A() &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : virtual public A &#123;public:    B() &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125;&#125;;class C : virtual public A &#123;public:    C() &#123; cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; endl; &#125;&#125;;class D : public B, public C &#123;public:    D() &#123; cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl; &#125;&#125;;// 创建D对象时的输出顺序：// A constructor (虚基类优先)// B constructor// C constructor  // D constructor\n\n\n最新派生类责任\n在虚继承中，最底层派生类负责直接初始化所有虚基类\n\n\n\nclass A &#123;public:    A(int x) &#123; cout &lt;&lt; &quot;A(&quot; &lt;&lt; x &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;&#125;;class B : virtual public A &#123;public:    B() : A(1) &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125;&#125;;class C : virtual public A &#123;public:    C() : A(2) &#123; cout &lt;&lt; &quot;C()&quot; &lt;&lt; endl; &#125;&#125;;class D : public B, public C &#123;public:    // 必须直接初始化虚基类A    D() : A(100), B(), C() &#123;          cout &lt;&lt; &quot;D()&quot; &lt;&lt; endl;    &#125;&#125;;// 输出结果：// A(100)  - 虚基类由D直接初始化，B和C中的A初始化被忽略// B()// C()// D() \n\n\n虚基类表\n\n每个虚继承的类都包含一个虚基类表，记录：\n虚基类相对于当前对象的偏移量\n虚基类成员的访问信息\n\n\n\n\n\n常用库“algorithm”\n\n\n函数&#x2F;算法\n功能描述\n是否修改原数据\n适用对象\n备注 &#x2F; 示例关键词\n\n\n\nstd::sort***\n对范围进行排序（默认升序）\n✅ 是\n支持随机访问迭代器（如 vector, deque, 普通数组）\nstd::sort(v.begin(), v.end())\n\n\nstd::stable_sort\n稳定排序（相等元素相对顺序不变）\n✅ 是\n同上\n适合需要保持顺序的场景\n\n\nstd::reverse***\n反转范围内的元素顺序\n✅ 是\n双向迭代器（如 vector, list, deque）\nstd::reverse(v.begin(), v.end())\n\n\nstd::find\n查找某个值，返回第一个匹配的迭代器\n❌ 否\n输入迭代器\nfind(v.begin(), v.end(), 42)\n\n\nstd::find_if\n按条件查找（使用谓词 predicate）\n❌ 否\n输入迭代器\nfind_if(v.begin(), v.end(), [](int x){...})\n\n\nstd::count\n统计某个值出现的次数\n❌ 否\n输入迭代器\ncount(v.begin(), v.end(), 10)\n\n\nstd::count_if\n按条件统计个数\n❌ 否\n输入迭代器\ncount_if(v.begin(), v.end(), [](int x){...})\n\n\nstd::copy\n复制一个范围的元素到另一个位置\n❌ 否（目标被修改）\n输入 → 输出迭代器\ncopy(src.begin(), src.end(), dest.begin())\n\n\nstd::copy_if\n按条件复制元素\n❌ 否\n输入 → 输出迭代器\ncopy_if(v.begin(), v.end(), out, predicate)\n\n\nstd::transform\n对每个元素进行变换，生成新序列或原地修改\n✅ &#x2F; ❌ 取决于用法\n输入&#x2F;输出迭代器\n可用于 map-like 操作\n\n\nstd::for_each\n对每个元素执行某个操作（函数&#x2F;lambda）\n❌ 通常否\n输入迭代器\nfor_each(v.begin(), v.end(), func)\n\n\nstd::min&#x2F; std::max\n返回两个（或多个）值中的最小&#x2F;最大值\n❌ 否\n值\nmin(a, b), max(a, b)\n\n\nstd::min_element&#x2F; std::max_element\n返回范围内最小&#x2F;最大元素的迭代器\n❌ 否\n输入迭代器\nmin_element(v.begin(), v.end())\n\n\nstd::clamp（C++17）\n将值限制在 [low, high] 范围内\n❌ 否\n值\nclamp(x, low, high)\n\n\nstd::swap***\n交换两个对象的值\n✅ 是\n任意可交换类型\nswap(a, b)或 std::swap(a, b)\n\n\nstd::unique\n移除相邻的重复元素（需先排序）\n✅ 是（实际是移动到前面，需配合 erase）\n双向迭代器\n通常与 sort+ erase配合使用\n\n\nstd::fill\n用指定值填充某个范围\n✅ 是\n输出迭代器\nfill(v.begin(), v.end(), 0)\n\n\nstd::generate\n用生成器函数填充范围\n✅ 是\n输出迭代器\n常用于生成随机数等\n\n\nstd::accumulate（在 &lt;numeric&gt;）\n计算累计值（如求和、累积）\n❌ 否\n输入迭代器\n常与 lambda 配合做自定义累加\n\n\nstd::lower_bound\n返回第一个 不小于 指定值的迭代器（二分查找）\n❌ 否\n已排序的范围，随机访问迭代器\n用于有序容器\n\n\nstd::upper_bound\n返回第一个 大于 指定值的迭代器\n❌ 否\n已排序的范围\n与 lower_bound 一起可确定插入位置\n\n\nstd::binary_search\n判断某个值是否存在于已排序的范围中\n❌ 否\n已排序\n返回 true/false\n\n\nstd::equal\n判断两个范围是否相等\n❌ 否\n两个输入范围\n比较两段数据内容是否相同\n\n\nstd::all_of&#x2F; any_of&#x2F; none_of\n判断范围内是否全部&#x2F;任一&#x2F;无满足条件\n❌ 否\n输入迭代器 + 谓词\n常搭配 lambda 使用\n\n\n“fstream”\n\n\n类别\n方法&#x2F;对象\n调用示例\n返回值\n解释\n\n\n\n文件输出\nstd::ofstream\nstd::ofstream fout(&quot;file.txt&quot;);\nofstream对象\n输出文件流（写入文件）\n\n\n\nfout &lt;&lt; &quot;text&quot;;\nfout &lt;&lt; data;\nostream&amp;\n写入内容到文件\n\n\n\nfout.open(&quot;file.txt&quot;)\nfout.open(&quot;data.txt&quot;);\nvoid\n打开文件\n\n\n\nfout.close()\nfout.close();\nvoid\n关闭文件\n\n\n文件输入\nstd::ifstream\nstd::ifstream fin(&quot;file.txt&quot;);\nifstream对象\n输入文件流（读取文件）\n\n\n\nfin &gt;&gt; x;\nfin &gt;&gt; value;\nistream&amp;\n从文件读取变量\n\n\n\nstd::getline(fin, str)\nstd::getline(fin, line);\nistream&amp;\n读取文件中的一行文本\n\n\n\nfin.open(&quot;file.txt&quot;)\nfin.open(&quot;data.txt&quot;);\nvoid\n打开文件\n\n\n\nfin.close()\nfin.close();\nvoid\n关闭文件\n\n\n“memory”\n\n\n\n类别&#x2F;方法\n方法&#x2F;函数\n调用示例\n返回值\n解释说明\n\n\n\n智能指针类型\nstd::unique_ptr&lt;T&gt;\nstd::unique_ptr&lt;int&gt; p(new int(10)); 或更推荐：auto p = std::make_unique&lt;int&gt;(10);(C++14)\nstd::unique_ptr&lt;T&gt;对象\n独占所有权的智能指针，不能复制，只能移动，离开作用域时自动释放资源。\n\n\n\nstd::shared_ptr&lt;T&gt;\nstd::shared_ptr&lt;int&gt; p(new int(20)); 或推荐：auto p = std::make_shared&lt;int&gt;(20);\nstd::shared_ptr&lt;T&gt;对象\n共享所有权的智能指针，多个 shared_ptr可指向同一对象，通过引用计数管理生命周期。\n\n\n\nstd::weak_ptr&lt;T&gt;\nstd::weak_ptr&lt;int&gt; wp(sp);（sp 是 shared_ptr）\nstd::weak_ptr&lt;T&gt;对象\n弱引用指针，不增加引用计数，常用于解决 shared_ptr的循环引用问题，或安全访问可能已释放的资源。\n\n\n工厂函数（推荐）\nstd::make_unique&lt;T&gt;(args...)\nauto p = std::make_unique&lt;int&gt;(42); （C++14 起支持）\nstd::unique_ptr&lt;T&gt;\n安全、高效地创建 unique_ptr，避免显式使用 new，推荐首选方式。\n\n\n\nstd::make_shared&lt;T&gt;(args...)\nauto p = std::make_shared&lt;int&gt;(42); （C++11 起支持）\nstd::shared_ptr&lt;T&gt;\n安全、高效地创建 shared_ptr，通常比 new+ shared_ptr构造更高效（一次分配）。\n\n\n通用方法（适用于 shared_ptr &#x2F; unique_ptr）\n.get()\nint* raw = p.get();\nT*（原始指针）\n返回智能指针管理的原始指针，但不释放所有权，慎用，避免手动 delete。\n\n\n\n.reset()\np.reset();或 p.reset(new int(100));\nvoid\n释放当前管理的对象（如果有），并可选择指向一个新对象。如果无参数，则释放当前资源。\n\n\n\n.release()\nint* raw = p.release();\nT*\n释放所有权，返回原始指针，智能指针不再管理该内存，需手动管理（如 delete）。慎用！\n\n\nshared_ptr 独有方法\n.use_count()\nint count = sp.use_count();\nlong（或 size_t，取决于实现）\n返回当前有多少个 shared_ptr共享该对象（即引用计数），主要用于调试，不建议用于逻辑控制。\n\n\n\n.unique()\nbool is_unique = sp.unique();\nbool\n判断当前 shared_ptr是否是唯一拥有该对象的指针（即 use_count &#x3D;&#x3D; 1），C++17 起被标记为 deprecated，推荐用 use_count() == 1。\n\n\nweak_ptr 独有方法\n.lock()\nif (auto tmp = wp.lock()) { /* 使用 tmp */ }\nstd::shared_ptr&lt;T&gt;（如果资源还在） 或 nullptr（如果资源已释放）\n尝试将 weak_ptr提升为 shared_ptr，如果对象还存在则返回有效的 shared_ptr，否则返回空。用于安全访问可能被释放的资源。\n\n\n析构行为（隐式）\n析构函数 ~unique_ptr() ~shared_ptr() ~weak_ptr()\n无需显式调用，在对象离开作用域时自动调用\nvoid\n自动释放所管理的资源： - unique_ptr：直接 delete资源 - shared_ptr：引用计数减 1，归零时 delete - weak_ptr：不影响引用计数，仅观察\n\n\n\n\n“queue”\n\n\n方法\n用法示例\n说明\n\n\n\npush(x)\nq.push(10);\n元素入队（到队尾）\n\n\npop()\nq.pop();\n队首元素出队（无返回值）\n\n\nfront()\nint a = q.front();\n访问队首元素（不删除）\n\n\nback()\nint b = q.back();\n访问队尾元素（不删除）\n\n\nempty()\nif(q.empty()) ...\n判断队列是否为空\n\n\nsize()\nint n = q.size();\n返回元素个数\n\n\npriority_queue\n概述\n\nC++ 的 std::priority_queue 本质上是对 std::vector + 堆算法 (std::make_heap &#x2F; std::push_heap &#x2F; std::pop_heap) 的封装。\n默认实现是 大顶堆（堆顶是最大元素）。\n小顶堆或自定义顺序，其实是改比较器（greater&lt;T&gt; 或自定义 cmp）。\n\n\n构造\n1. \n\n\n\n\n用法\n示例代码\n说明\n\n\n\n默认大顶堆\npriority_queue&lt;int&gt; pq;\n取出最大元素\n\n\n小顶堆\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n取出最小元素\n\n\n自定义比较\npriority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;\n可定义结构体比较方式\n\n\n\n\n\n用法\n1. \n\n\n\n\n方法\n用法示例\n说明\n\n\n\npush(x)\npq.push(5);\n插入一个元素（自动调整堆）\n\n\npop()\npq.pop();\n删除当前最大元素（或最小，取决于堆类型）\n\n\ntop()\nint t = pq.top();\n返回堆顶元素（最大&#x2F;最小）\n\n\nempty()\nif(pq.empty()) ...\n判断是否为空\n\n\nsize()\nint n = pq.size();\n返回元素个数\n\n\n\n\n\n\n“string”\ngetline\n\nstd::getline(std::cin, str);  // 读取一行，包含空格\nstd::getline(std::cin, str, &#39;,&#39;);  // 读取直到逗号为止\n\n   2. 构造与初始化   | 方法                  | 说明                        | 示例                               |   | :-------------------- | :-------------------------- | :--------------------------------- |   | `string s;`           | 构造空字符串                | `string s;`→ `s = &quot;&quot;`              |   | `string s(&quot;hello&quot;);`  | 用 C 风格字符串初始化       | `string s(&quot;abc&quot;);`                 |   | `string s = &quot;world&quot;;` | 用字符串字面量初始化        | `string s = &quot;xyz&quot;;`                |   | `string s(5, &#x27;a&#x27;);`   | 构造 5 个 `&#x27;a&#x27;`组成的字符串 | `string s(3, &#x27;x&#x27;);`→ `&quot;xxx&quot;`       |   | `string s(other);`    | 拷贝构造                    | `string s1 = &quot;hi&quot;; string s2(s1);` |   ------   2️⃣ 容量相关   | 方法                      | 说明                                                  | 示例                      |   | :------------------------ | :---------------------------------------------------- | :------------------------ |   | `s.size()`或 `s.length()` | 返回字符串中字符的个数（不包括 `\\0`）                 | `s.size()`→ 如 `&quot;abc&quot;`→ 3 |   | `s.capacity()`            | 返回当前分配的存储空间（可能 ≥ size）                 | 一般用于优化，不常用      |   | `s.empty()`               | 判断字符串是否为空（size == 0）                       | `if (s.empty()) &#123;...&#125;`    |   | `s.resize(n)`             | 将字符串调整为 n 个字符（多出的补空字符，少则截断）   | `s.resize(5);`            |   | `s.resize(n, c)`          | 调整大小为 n，新增的字符为 `c`                        | `s.resize(5, &#x27;*&#x27;);`       |   | `s.reserve(n)`            | 预留至少能容纳 n 个字符的空间（优化用，避免多次扩容） | `s.reserve(100);`         |   &gt; ✅ `size()`和 `length()`是完全等价的，都返回字符数。   ------   3️⃣ 访问元素   | 方法      | 说明                                                    | 示例                |   | :-------- | :------------------------------------------------------ | :------------------ |   | `s[i]`    | 访问第 i 个字符（不检查越界）                           | `char c = s[0];`    |   | `s.at(i)` | 访问第 i 个字符（**越界会抛异常** `std::out_of_range`） | `char c = s.at(2);` |   &gt; ⚠️ 推荐在不确定索引是否合法时使用 `at()`，更安全。   ------   4️⃣ 修改字符串   | 方法                          | 说明                                   | 示例                      |   | :---------------------------- | :------------------------------------- | :------------------------ |   | `s.clear()`                   | 清空字符串                             | `s.clear();`→ `s == &quot;&quot;`   |   | `s.push_back(ch)`             | 在末尾添加一个字符                     | `s.push_back(&#x27;a&#x27;);`       |   | `s.pop_back()`                | 删除最后一个字符（字符串非空）         | `s.pop_back();`           |   | `s.append(str)`               | 在末尾追加字符串（或字符、C 字符串等） | `s.append(&quot;123&quot;);`        |   | `s += str`                    | 追加字符串（常用简洁写法）             | `s += &quot;abc&quot;;`             |   | `s.insert(pos, str)`          | 在 pos 位置插入字符串                  | `s.insert(2, &quot;XX&quot;);`      |   | `s.erase(pos, len)`           | 从 pos 开始删除 len 个字符             | `s.erase(1, 2);`          |   | `s.replace(pos, len, newStr)` | 替换从 pos 开始的 len 个字符为新字符串 | `s.replace(1, 2, &quot;123&quot;);` |   ------   5️⃣ 查找相关   | 方法                         | 说明                                                      | 示例                         |   | :--------------------------- | :-------------------------------------------------------- | :--------------------------- |   | `s.find(sub)`                | 查找子串 `sub`第一次出现的位置，找不到返回 `string::npos` | `size_t pos = s.find(&quot;lo&quot;);` |   | `s.find(ch)`                 | 查找字符第一次出现的位置                                  | `size_t pos = s.find(&#x27;a&#x27;);`  |   | `s.rfind(sub)`               | 查找子串最后一次出现的位置                                | `s.rfind(&quot;lo&quot;);`             |   | `s.find_first_of(&quot;abc&quot;)`     | 查找第一个出现在 `&quot;abc&quot;`中的字符                          |                              |   | `s.find_last_of(&quot;abc&quot;)`      | 查找最后一个出现在 `&quot;abc&quot;`中的字符                        |                              |   | `s.find_first_not_of(&quot;abc&quot;)` | 查找第一个 **不**在 `&quot;abc&quot;`中的字符                       |                              |   | `s.find_last_not_of(&quot;abc&quot;)`  | 查找最后一个 **不**在 `&quot;abc&quot;`中的字符                     |                              |   &gt; ⚠️ 找不到时返回 `string::npos`（一个很大的数，通常是 `size_t(-1)`），判断时要用：\n\n\n\nif (pos !&#x3D; string::npos) { &#x2F;* 找到了 *&#x2F; }\n   ------   6️⃣ 子串操作   | 方法                 | 说明                                                         | 示例                                                       |   | :------------------- | :----------------------------------------------------------- | :--------------------------------------------------------- |   | `s.substr(pos, len)` | 返回从 pos 开始，长度为 len 的子串 （len 可省略，表示到末尾） | `string sub = s.substr(2, 3);` `string sub = s.substr(1);` |   &gt; ⚠️ `pos`不能越界，否则未定义行为（最好先检查范围）。   ------   7️⃣ 比较操作   | 方法                                          | 说明                                                  | 示例                               |   | :-------------------------------------------- | :---------------------------------------------------- | :--------------------------------- |   | `s.compare(str)`                              | 比较两个字符串 返回 0 表示相等，&lt;0 或 &gt;0 表示大小关系 | `if (s.compare(&quot;abc&quot;) == 0) &#123;...&#125;` |   | 也可以直接用 `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=` | 更直观的比较方式                                      | `if (s == &quot;test&quot;) &#123;...&#125;`✅推荐      |   &gt; ✅ 推荐直接使用 `==`、`!=`等运算符，更简洁直观！   ------   8️⃣ 其他实用方法   | 方法                     | 说明                                                         | 示例                                             |   | :----------------------- | :----------------------------------------------------------- | :----------------------------------------------- |   | `s.c_str()`              | 返回 C 风格字符串（`const char*`），以 `\\0`结尾              | 常用于兼容 C 函数，如 `printf(&quot;%s&quot;, s.c_str());` |   | `s.data()`               | C++17 起也返回 `const char*`，但不保证以 `\\0`结尾（一般也可当 C 字符串用） | 类似 `c_str()`                                   |   | `s.copy(dest, len, pos)` | 将字符串的一部分拷贝到 dest 缓冲区（C 风格）                 | 较少使用                                         |   | `s.swap(other)`          | 交换两个字符串的内容                                         | `s.swap(s2);`                                    |   - 转换     -      - | 函数              | 说明                   | 转换目标类型  |       | :---------------- | :--------------------- | :------------ |       | `std::stoi(str)`  | 字符串 → `int`         | `int`         |       | `std::stol(str)`  | 字符串 → `long`        | `long`        |       | `std::stoll(str)` | 字符串 → `long long`   | `long long`   |       | `std::stof(str)`  | 字符串 → `float`       | `float`       |       | `std::stod(str)`  | 字符串 → `double`      | `double`      |       | `std::stold(str)` | 字符串 → `long double` | `long double` |     -      - | **`std::to_string(int)`** | `std::to_string(num)` | ✅ **最推荐** | C++11 及以上，简单直接的 int → string |       | ------------------------- | --------------------- | ------------ | ------------------------------------- |## &quot;vector&quot;1. 2. | 分类     | 方法/示例                                                   | 返回值（文字说明）           | 说明                     |   | -------- | ----------------------------------------------------------- | ---------------------------- | ------------------------ |   | **定义** | `vector&lt;int&gt; v1;`                                           | 空容器                       | 定义一个空 vector        |   |          | `vector&lt;int&gt; v2(5);`                                        | 含 5 个元素，值为 0          | 指定大小，默认初始化     |   |          | `vector&lt;int&gt; v3(5, 100);`                                   | 含 5 个元素，值全是 100      | 指定大小和值             |   |          | `vector&lt;int&gt; v4 = &#123;1,2,3&#125;;`                                 | 含 3 个元素：1,2,3           | 列表初始化               |   | **访问** | `v4[0]`                                                     | 元素引用（可能越界，不检查） | 下标访问                 |   |          | `v4.at(1)`                                                  | 元素引用（带越界检查）       | 越界会抛 `out_of_range`  |   |          | `v4.front()`                                                | 第一个元素引用               | 访问首元素               |   |          | `v4.back()`                                                 | 最后一个元素引用             | 访问尾元素               |   |          | `v4.begin()`                                                | 指向首元素的迭代器           | 迭代遍历起点             |   |          | `v4.end()`                                                  | 指向尾后元素的迭代器         | 遍历终点（左闭右开）     |   | **修改** | `ans.push_back(10);`                                        | 无返回值                     | 在尾部追加元素           |   |          | `ans.emplace_back(20);`                                     | 无返回值                     | 原地构造，效率更高       |   |          | `ans.pop_back();`                                           | 无返回值                     | 删除最后一个元素         |   |          | `ans.insert(ans.begin()+1, 99);`                            | 指向新元素的迭代器           | 在第 2 个位置插入 99     |   |          | `ans.insert(ans.end(), &#123;7,8,9&#125;);`                           | 指向第一个新元素的迭代器     | 在尾部插入多个元素       |   |          | `ans.erase(ans.begin());`                                   | 指向被删元素后的迭代器       | 删除第一个元素           |   |          | `ans.erase(ans.begin()+1, ans.begin()+3);`                  | 指向区间后的迭代器           | 删除区间 `[2,3)`         |   |          | `ans.clear();`                                              | 无返回值                     | 清空所有元素             |   |          | `ans.swap(other);`                                          | 无返回值                     | 与另一个 vector 交换内容 |   | **遍历** | `for (auto it=ans.begin(); it!=ans.end(); it++) cout&lt;&lt;*it;` | 无返回值                     | 迭代器遍历               |   |          | `for (auto &amp;x : ans) cout&lt;&lt;x;`                              | 无返回值                     | 范围 for 遍历            |   | **容量** | `ans.size();`                                               | 当前元素数量                 | O(1)                     |   |          | `ans.empty();`                                              | 布尔值                       | 是否为空                 |   |          | `ans.capacity();`                                           | 已分配的容量                 | 可能大于 size            |   |          | `ans.reserve(100);`                                         | 无返回值                     | 预留至少 100 个容量      |   |          | `ans.shrink_to_fit();`                                      | 无返回值                     | 收缩容量到 size          |   | **算法** | `sort(ans.begin(), ans.end());`                             | 无返回值                     | 升序排序                 |   |          | `sort(ans.rbegin(), ans.rend());`                           | 无返回值                     | 降序排序                 |   |          | `reverse(ans.begin(), ans.end());`                          | 无返回值                     | 反转元素顺序             |3. 注意，算法需要导入算法库：\\#include &lt;algorithm&gt;## 关联容器| 容器            | 底层   | 是否有序 | 是否允许重复 | 查找/插入/删除 || --------------- | ------ | -------- | ------------ | -------------- || `map`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       || `set`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       || `unordered_map` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      || `unordered_set` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      |### &quot;map&quot;1. 有序存放键值对2. 用法   1.    2. | 方法         | 用法                   | 返回值（文字说明）                                           |      | ------------ | ---------------------- | ------------------------------------------------------------ |      | `insert`     | `m.insert(&#123;1,&quot;one&quot;&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（表示是否插入成功） |      | `operator[]` | `m[2] = &quot;two&quot;;`        | 返回指定键对应的值的引用（如果键不存在会新建）               |      | `at`         | `m.at(2)`              | 返回指定键对应的值的引用（如果键不存在会抛异常）             |      | `find`       | `m.find(2)`            | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `m.erase(2)`           | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `m.erase(it)`          | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `m.count(2)`           | 返回匹配的元素个数（在 map 中永远是 0 或 1）                 |      | `size`       | `m.size()`             | 返回当前存储的元素数量                                       |      | `empty`      | `m.empty()`            | 返回是否为空（true/false）                                   |   3. ### &quot;set&quot;1. 有序存放键（没有值）2. 用法   1.    2. | 方法         | 用法            | 返回值（文字说明）                                           |      | ------------ | --------------- | ------------------------------------------------------------ |      | `insert`     | `s.insert(10);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |      | `find`       | `s.find(10)`    | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `s.erase(10)`   | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `s.erase(it)`   | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `s.count(10)`   | 返回匹配的元素个数（在 set 中永远是 0 或 1）                 |      | `size`       | `s.size()`      | 返回当前存储的元素数量                                       |      | `empty`      | `s.empty()`     | 返回是否为空（true/false）                                   |   3. ### &quot;unordered_map&quot;（哈希表）1. 无序存放键值对2. 用法   1.    2. | 方法         | 用法                      | 返回值（文字说明）                                           |      | ------------ | ------------------------- | ------------------------------------------------------------ |      | `insert`     | `um.insert(&#123;&quot;apple&quot;,3&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |      | `operator[]` | `um[&quot;banana&quot;]=5;`         | 返回指定键对应的值的引用（如果键不存在会新建）               |      | `at`         | `um.at(&quot;apple&quot;)`          | 返回指定键对应的值的引用（如果键不存在会抛异常）             |      | `find`       | `um.find(&quot;apple&quot;)`        | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `um.erase(&quot;apple&quot;)`       | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `um.erase(it)`            | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `um.count(&quot;apple&quot;)`       | 返回匹配的元素个数（在 unordered_map 中永远是 0 或 1）       |      | `size`       | `um.size()`               | 返回当前存储的元素数量                                       |      | `empty`      | `um.empty()`              | 返回是否为空（true/false）                                   |   3. 我想进行如下操作：如果表中已存在，则取出值并操作，否则新建并设置默认值：         1. ```c++         // 包含隐式创建默认对象         std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; graphMap;                  int node = 1;                  // 直接使用 operator[]，如果 node 不存在，会自动插入一个空的 vector&lt;int&gt;         std::vector&lt;int&gt;&amp; neighbors = graphMap[node]; // 如果不存在，会创建空vector\n\n\n如果希望显示创建，则使用find（）\n\n\n\n“unordered_set”（哈希表）\n无序存放键（没有值）\n\n用法\n1. \n\n\n\n\n方法\n用法\n返回值（文字说明）\n\n\n\ninsert\nus.insert(100);\n返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功）\n\n\nfind\nus.find(100)\n返回一个迭代器，指向找到的元素；如果没找到，返回 end()\n\n\nerase(key)\nus.erase(100)\n返回删除的元素个数（0 或 1）\n\n\nerase(it)\nus.erase(it)\n返回一个迭代器，指向下一个有效元素\n\n\ncount(key)\nus.count(100)\n返回匹配的元素个数（在 unordered_set 中永远是 0 或 1）\n\n\nsize\nus.size()\n返回当前存储的元素数量\n\n\nempty\nus.empty()\n返回是否为空（true&#x2F;false）\n\n\n\n\n\n\n其他Lambda匿名函数\n基本语法\n一个最基本的 Lambda 表达式的语法如下：\n[捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;\n\n其中：\n\n[捕获列表]：定义了 Lambda 表达式能访问的外部变量及其方式（值捕获、引用捕获等），可以为空。\n(参数列表)：和普通函数的参数列表一样，如果不需要参数，可以省略，但括号不能省略（除非使用特殊形式）。\n-&gt; 返回类型：可省略，编译器会自动推导返回类型（如果只有一条 return 语句，或者没有 return）。\n{ 函数体 }：函数的实现部分。\n\n\n注意：如果引用的变量在 Lambda 执行前已经被销毁（比如局部变量离开作用域），会导致未定义行为（悬空引用）。\n\n\n值传递和引用\nfor(T sth : sths)的逻辑是值传递，不能修改对象本身。而for(int i = 0 ...) {sths[i]} 是直接访问对象。\n\n如果希望简化写法直接修改对象，应该写作for(T&amp; sth : sths)\n\n\n&amp;引用：&amp;操作符用于别名时：\n\n作用：\n&amp;用于声明 引用（reference），引用是一个别名，是某个已存在变量的另一个名字，对引用的操作就是对被引用对象的操作。\n\n特点：\n\n必须初始化（不能先声明再赋值）。\n不能重新绑定到其他对象。\n引用本身不是对象，没有自己的内存地址（不像指针）。\n更安全，更直观，常用于函数参数传递和返回值优化。\n\n\n示例：\nint a = 10;int&amp; ref = a;  // ref 是 a 的引用（别名）ref = 20;      // 实际上是修改了 acout &lt;&lt; a;     // 输出 20\n\n引用 vs 指针（简要对比）\n\n\n\n特性\n引用 (&amp;)\n指针 (*)\n\n\n\n是否必须初始化\n✅ 必须初始化\n❌ 可以不初始化（但不推荐）\n\n\n是否可重新绑定\n❌ 不能重新绑定到其他对象\n✅ 可以修改指向的对象\n\n\n是否占用额外内存\n❌ 一般不占用（是别名）\n✅ 占用内存（存储地址）\n\n\n是否可以为空\n❌ 不能为空\n✅ 可以为 nullptr\n\n\n语法简洁性\n✅ 更简洁，更安全\n❌ 需要解引用，容易出错\n\n\n\n&amp;在C++中的主要用途\n1. \n\n\n\n\n号\n用法类别\n说明\n示例\n\n\n\n1\n引用声明\n声明一个变量的引用（别名）\nint&amp; ref = a;\n\n\n2\n取地址运算符\n获取变量的内存地址，用于指针\nint* p = &amp;a;\n\n\n3\n引用参数\n函数参数传引用，避免拷贝，可修改原值\nvoid func(int&amp; x)\n\n\n4\n引用返回值\n函数返回引用，可修改原对象或支持链式调用\nint&amp; getElement()\n\n\n5\n指针的引用\n引用指向指针，用于修改指针本身\nint*&amp; refPtr = ptr;\n\n\n\n\n\n\n\n\n输入输出操作\ngetline用法：\n\ngetline(cin, str)：把一行读到str中\ngetline(cin, str, delimiter)：读一行，知道遇见第一个隔断符\n\n\nstringstream用法\n\nstringsstream ss(str)：把字符串作为字符串流。这样可以搭配getline。\n\n示例\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::string str = &quot;apple,banana,orange&quot;;\n    char delimiter = &#39;,&#39;;  // 按逗号分割\n\n    std::vector&lt;std::string&gt; tokens;  // 存储分割后的子串\n    std::stringstream ss(str);        // 将字符串放入字符串流\n    std::string token;\n\n    // 按 delimiter 分割\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token);\n    }\n\n    // 输出分割结果\n    for (const auto&amp; t : tokens) {\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n\n## 操作符重载1. 是什么：   1. 让你可以用内置操作符的方式来操作你自己定义的类型（比如类对象）2. 基本语法   1. 操作符重载本质上就是 **定义一个特殊的成员函数 或 友元函数**，函数名是 `operator`加上要重载的操作符符号。      1. 一般形式（成员函数）：      ```c++      返回类型 operator操作符(参数列表) &#123;          // 自定义操作符的实现      &#125;      // 参数个数 = 操作符需要的操作数个数 - 1（因为左操作数是 this)\n\n  2. 它可以是一个：\n       1. **成员函数**（常见，操作符左边的对象是当前对象，即 `this`）\n       2. **友元函数**（当左操作数不是当前类对象，或者需要访问私有成员但又不能是成员时）\n\n\n友元函数方式：\n\nfriend 返回类型 operator操作符(参数1, 参数2);\n\nfriend 返回类型 operator操作符(参数1, 参数2);\n// 参数个数 = 操作符总的操作数个数\n2. 举例   1. ```c++      #include &lt;iostream&gt;      using namespace std;            class MyArray &#123;      private:          int data[5];  // 假设我们只管理 5 个整数      public:          // 构造函数，初始化数组          MyArray() &#123;              for (int i = 0; i &lt; 5; ++i) &#123;                  data[i] = i * 10;  // 0, 10, 20, 30, 40              &#125;          &#125;                // 重载 [] 操作符 —— 用于访问元素（读写）          int&amp; operator[](int index) &#123;              return data[index];  // 返回第 index 个元素的引用          &#125;      &#125;;      \n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["技术"],"tags":["C++"]}]