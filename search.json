[{"title":"MatLab笔记","url":"/2024/12/04/MatLab%E7%AC%94%E8%AE%B0/","content":"基础知识指令\nclc：清除命令行\nclear：清除工作区\n\n二维绘图\n流程\n\n变量设置\nx &#x3D; 0 : 0.01 : 2*pi\ny &#x3D; sin(x)\nxlimiti\n\n\n幕布初始化（figure)\n绘制：plot(x, y)，plotyy(x, y1, y2)\n命名\n创立标题：title(‘y &#x3D; sin(x)’)\nxlabel(‘x’)\nylabel(‘y’)\nAX(1)表示左侧轴，AX(2)表示右侧轴\nset(get(AX(1), ‘YLabel’), ‘String Decay’)\n\n\n\n\n\n\n函数\n\nplot：ploy(x1, y1, s1, x2, y2, s2, …)\nlegend：图例\n\n\n参数：\n\n颜色\n红(r)，绿(g)，蓝(b)，黄(y)，粉红(m)，青(c)，白(w)，黑(k)\n\n\n线型：\n实线(-)，虚线(- -)，冒号线(:)，点画线(-.)\n\n\n数据标记点![屏幕截图 2024-10-16 120138](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-16 120138.png)\n\n\n样例\nx = 0:0.1:2*pi; % 创建 x 数据% 第一个图像：sin 函数曲线y1 = sin(x);     % 创建第一个 y 数据plot(x, y1);     % 绘制第一个图像hold on;         % 保持当前图形% 第二个图像：cos 函数曲线y2 = cos(x);     % 创建第二个 y 数据plot(x, y2);     % 绘制第二个图像xlabel(&#x27;X-axis&#x27;); % 添加 x 轴标签ylabel(&#x27;Y-axis&#x27;); % 添加 y 轴标签title(&#x27;Multiple Plots&#x27;); % 添加图标题legend(&#x27;sin(x)&#x27;, &#x27;cos(x)&#x27;); % 添加图例，说明各曲线含义grid on;         % 显示网格线\n\n三维绘图\n函数：\nplot3\nmeshgrid\nmesh：网格线\nsurf：曲面\n\n\n\n语法\n其实和python很像\n\n\n其他：’ % ‘\n\n运算：\n\n幂运算：2 ^ n\n\n\n循环结构\n\nfor…end结构：\nfor n = 1:2:9\tcnt = cnt + 1;end\n\nwhile…end结构:\nwhile n&lt;=10\tcnt = cnt + 1end\n\n\n分支结构\n\nif…else…end\nswich…case…otherwise…end\n\n\n\n函数\nrand:\nrand(m, n)：生成m行n列的伪随机数\nrandn：生成标准正态分布的伪随机数\nrandi：生成均匀的伪随机整数\n\n\nmagic：生成幻方\ndeal：给多个变量赋值：\n[a, b, c] &#x3D; deal(1， 2， 3)\n\n\nnum2cell：把向量变成单元数据，以便枚举\n\n数据结构\n索引全部从1开始\n\n\n矩阵：\n\n表示方法：A &#x3D; [1 2 3; 4 5 6; 7 8 9]。\n\n操作\n\n操作是列优先的，例如find就是优先从一列中查找，sum就列求和\n\n\n转置：B &#x3D; A’\n拉长（注意，是一列一列的拉）：C &#x3D; A(:)\n逆矩阵：C &#x3D; inv(A)\nA * B：正常的矩阵乘法\nA  .* B：对应项相乘\nA  &#x2F;  B：A乘以B的逆，即A * inv(B)\nA .&#x2F; B：对应项相除\n取值：A(2, 3), A(2, :)\n查找：find。返回符合条件的索引。\n旋转：flidud(上下)，flidlr（左右）\n求和：sum\nsum(A, 2)行求和\n\n\n\n\n构造\n\n零矩阵：O &#x3D; zeros(2, 3, 4)\n2行，3列，4维\n\n\n单位矩阵：eye(3)，3维单位阵\n随机生成：rand\n“切片”：D &#x3D; 1: 2: 9\n在[1, 9]中以2为步长选取数字，构造行向量\n\n\n“复制”：repmat(B, 2, 3)\n把B横着复制1次，竖着复制2次\n\n\n全一阵：ones(4, 4)\n幻方矩阵：magic(4)\n\n\n\n\n元胞数组：\n\n类比数组\n\n\n表示方法：A &#x3D; cell(1, 2)\n注意：索引从1开始！！！\n\n\n\n\n结构体：\n\n类比字典\n\n表示方法：books &#x3D; (‘name’,  A, ‘price’, [30, 40])\n​                                     ^           ^\n​                                    键          值\n\n小括号取的是cell，中括号是取出字符串\n\n\n\n\n\n\n系统学习第一章  · 基础知识系统环境\n搜索路径：\n先检查变量名，再检查内置函数，最后是文件\n\n\n\n数值数据\n输出格式format命令：format后面跟输出格式参数，没有参数就是恢复默认\n常用数学函数：\nsind, cosd, tand：角度制三角函数\nabd：求负数的绝对值，复数的模，字符串的ASCll码\n取整：\nround：四舍五入\nceil：向上取整\nfloor：向下取整\nfix：向零取整（取整数部分）\n\n\nrem：取模求余。m &#x3D; rem(x, 10)\nisprime：是否为素数。\nsqrt\nexp\n\n\n\n变量及其操作\nwho &#x2F; whos ：显示现存变量信息。后者更详细\n\n内存变量文件：\n\nsave：保存。\n\nsave madata x y\n\n\nload：载入\n\nload mydata\n\n\n\n\n\n矩阵的表示\n建立：\n\n直接输入\n元素之间可以用空格或逗号分隔\n\n\n现有矩阵拼接\n实部矩阵和虚部矩阵合称\n实部虚部要同型\n\n\n冒号表达式：1:2:3\nlinspace：linspace(start, end, nr)\n\n\n结构矩阵\n\n格式：元素.成员名&#x3D;表达式\n\n\n单位矩阵\n\n用大括号\n每个元素可以是不同数据类型\n\n\n\n矩阵元素的引用\n矩阵不会访问越界\n\n矩阵的索引是列优先，先数第一列，再数第二列。\n\n$A_{3*3}$：A(1, 2)&#x3D;A(4)\n\n\nsub2ind（subscript to index）：根据下标获得索引。\n\nA &#x3D; [1, 2, 3; 4, 5, 6]\nD &#x3D; sub2ind(size(A), 1, 2) &#x3D; 4\n\n\nind2sub：根据索引获得下标\n\n利用冒号获得子矩阵\n\nend运算符：表示一维矩阵的末尾元素下标\n\nA：4*5\nD &#x3D; A（end，：）\n\n\n删除：赋为空矩阵[]。\n\nreshape：改变行数和列数，不改变元素个数。仍然是列优先\n\nA（:）：把矩阵堆叠为一个列向量\n\n\n基本运算\n算术运算：是在矩阵的意义下定义的。\n\n加减\n标量可以和矩阵做加减\n\n\n乘法\n除法\n右除（’&#x2F;‘）：如果A是非奇异方阵，则B&#x2F;A &lt;&#x3D;&gt; B*inv(A)\n左除（’\\‘）：如果B是非奇异方阵，则B&#x2F;A &lt;&#x3D;&gt; inv(B)*A\n\n\n乘方(^)\n点运算\n注意，在表达式运算中要用点运算，否则就变成矩阵相乘了\n\n\n\n\n关系运算\n\n不等于：~&#x3D;\n如果符号两边是矩阵，必须同型，对矩阵中对应标量运算，返回一个01矩阵。注意，不能比较两个矩阵是否相同。\n可以一边是标量\n\n\n逻辑运算\n\n&amp;，|，~\n可以两边是同型矩阵\n\n\n\n字符串处理\n表示和引用：\n\n字符串用单引号包裹\n\n字符串内的单引号要用两个来表示\n\n‘I’’m a student.’\n\n\n字符串矩阵\n\n\n\n字符串处理和操作：\n\n反转：str(end:  -1: 1)\n执行：eva(s)。把s的内容作为命令执行\n字符和数值的转换：\nabs, double可以把字符串换成ASCII码矩阵\nchar函数可以反过来\n\n\n比较：\n直接比较：比较的是字符串中每个字符的ASCII码，关系成立为1，否则为0.\n函数：\nstrcmp\nstrncmp\nstrcmpi：忽略大小写的比较\n\n\n\n\n查找\nfindstr(s1, s2)：返回短字符串在长字符串中的起始位置\nstrrep(s1, s2, s3)：把s1中的s2换成s3\n\n\n\n\n\n第二章 · 矩阵处理特殊矩阵\n通用特殊矩阵\nzeros\nones\neye：生成对角线为1的矩阵，可以不是方阵\nrand：生成取值在(0, 1)区间内的随机矩阵\nrandn：生成方差为1，均值为0的标准正态分布随机矩阵\n\n\n专门学科的特殊矩阵 \n幻方：magic\n范德蒙矩阵：vander(V)\n希尔伯特矩阵：\nH(i, j) &#x3D; 1 &#x2F; (i+j-1)\nH &#x3D; hilb（n)\n\n\n多项式伴随矩阵\n伴随矩阵的特征值，是多项式方程的根\ncompan(p)\np是多项式的系数向量\n\n\n帕斯卡矩阵\n就是把杨辉三角的顶角放在矩阵左上角。每个元素是其左方、上方元素的和\npascal(n)\n\n\n\n\n\n矩阵变换\n对角阵\n\n提取对角阵：\ndiag(A)：提取主对角线\ndiag(A, k)：提取第k条对角线。主对角线向上数为第1、2条，下方为-1、-2条。\n\n\n构造对角阵\ndiag(V)\ndiag(V, k)\n\n\n\n\n三角阵\n\n提取三角阵\n\ntriu（tri - 三角，u - up）\n\ntriu(A)\ntriu(A, k)\n\n\ntril（tri - 三角，l - low）\n\n\n\n\n\n转置\n\n一般转置：.’（是点+单引号）\n共轭转置：’ （只有单引号）\n\n\n旋转\n\nrot90(A, k)：逆时针旋转k个90度\n\n\n翻转：\n\nfliplr(A)（flip - 翻转，l - left，r - right）：左右翻转\nflipud(A)：上下翻转\n\n\n\n矩阵求值\n方阵的行列式：det(A)\n矩阵的秩：rank(A)\n矩阵的迹：trace(A)\n范数：\n定义\n1-范数：向量元素的绝对值之和\n2-范数：向量元素绝对值的平方和的平方根（像求距离）\n无穷大-范数：所有向量元素的最大绝对值\n\n\n向量的3种常用范数\nnorm(V, 1)：求1-范数\nnorm(V) 或 norm(V, 2)：求2-范数\nnorm(V, inf)：求无穷大范数\n\n\n矩阵的范数：从属于向量范数，调用格式相同\n矩阵的1-范数：矩阵列向量1-范数的最大值\n矩阵的2-范数：A’A的最大特征值的平方根\n矩阵的无穷大范数：行向量的绝对值之和的最大值\n\n\n\n\n条件数：用于描述矩阵性能。条件数等于A的范数乘以inv(A)的范数，总是大于1。越接近1，性能越好。\ncond(A, 1)：1-范数下的条件数\ncond(A, 2)\ncond(A, inf)\n\n\n\n矩阵的特征值和特征向量\n特征值与特征向量：\nE &#x3D; eig(A)：得到全部特征值\n[X, D] &#x3D; eig(A)：求矩阵的全部特征值，生成对角矩阵D，X的各列为对应的特征向量\n\n\n几何意义\neigshow\n\n\n\n稀疏矩阵\n是指零元素个数远远大于非零元素个数\n\n\n矩阵的存储方式\n完全存储方式：按列完全存储\n稀疏存储方式：只存储非零元素的值和位置。也是按列存储\n\n\n稀疏存储方式的产生：\nfull：转换为完全存储\nsparse：转换为稀疏存储\n\n\n\n第三章 · 程序流程控制文件的建立与调用\n分类：\n\n脚本文件（能跑的文件）\n函数文件\n\n\n\n建立函数文件\n​    func C &#x3D; f(A, B)\nA，B为输入参数，C为输出参数\n\n调用函数文件\n​    &gt;&gt; A &#x3D; [1 2 3]\n​    &gt;&gt; B &#x3D; [4 5 6]\n​    &gt;&gt; C &#x3D; f(A, B)\n\n\n\n\n\n顺序结构\n输入函数：input\n输出函数：disp\n程序暂停：pause。接受参数为暂停秒数，若无参数，则暂停至用户按下任意键\n\n选择结构\nif语句可以接矩阵，若矩阵非空且不包含零元素，则条件成立。\nswich语句：\ncase会自动跳出，即不用break\n若有多中取值的情况，用大括号括起来\n\n\n\n循环结构\nfor n = [1 2 3]\n\nn实际上被赋值为列向量，但是这个列向量只有一个元素\n\n\n\n第四章 · 绘图二维曲线\nplot函数\n用例：\n\nplot(x, y），用坐标画曲线\nplot(x)，以元素下标为横坐标，值为纵坐标\n\n\n参数：\n\n颜色\n红(r)，绿(g)，蓝(b)，黄(y)，粉红(m)，青(c)，白(w)，黑(k)\n\n\n线型：\n实线(-)，虚线(- -)，冒号线(:)，点画线(-.)\n\n\n数据标记点![屏幕截图 2024-10-16 120138](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-16 120138.png)\n\n\n\n\n自适应调整采样间隔的绘图函数：fplot函数\n调用格式\nfplot(f, lims, 选项)：f代表一个函数，通常采用函数句柄的形式。lims代表取值范围。\n双参数：fplot(funx, funy,  tlims, 选项)：参数方程可用\n\n\n\n\n\n绘制图形的辅助操作\n图形标注：\n图形标题title：用于添加标题\n可以用LaTeX语言，要用大括号括起来\n\n\nxlabel, ylabel：横纵坐标标签\n说明文本text：text(x, y, 文本)。\ngtext：不用手动设置坐标，用鼠标点\n\n\nlegend图例\n\n\n坐标控制\naxis函数：控制坐标轴范围\ngrid on &#x2F; off：显示网格线\nbox on &#x2F; off：显示边框线\n\n\n图形保持：hold on &#x2F; off：保留原有图像\n窗口分割：subplot\n\n其他形式的二维曲线\n其他坐标下的二维曲线\n对数坐标图\nsemilogx &#x2F; semilogy：半对数坐标图。用法和plot一致\nloglog：全对数坐标图\n\n\n极坐标图：polar\n\n\n统计图\n条形类\n\n柱状统计图\n\nbar (y, style)\n\ny为数据\nstyle分为簇状分组（默认）和柱状分组\n\n\nbar(x, y, style)\n\n\n\n直方图\n\nhist(y)：y为数据\nhist(y, x)： x为指定区间的划分方式，默认为10\nrose(theta, x)，theta为角度，x为数据\n\n\n\n\n面积类\n\n扇形图\n\npie(x, explode)\n\n\n面积图\n\narea\n\n\n\n\n散点类\n\n散点图：scatter\n\nscatter(x, y, 选项, ‘filled’（表示实心点）)\n\n\n阶梯图：stairs\n\n杆图：stem\n\n\n\n矢量类\n\n罗盘图：compass\n羽毛图：feather\n箭头图：quiver\n\n\n\n\n\n三维绘图\nplot3函数\n\n","categories":["课业"]},{"title":"Java八股","url":"/2025/12/04/Java%E5%85%AB%E8%82%A1/","content":"Java SEJava中有哪些创建线程的方式？\n\n\n方式\n说明\n优点\n缺点\n适用场景\n\n\n\n1️⃣ 继承 Thread类\n自定义类继承 Thread，并重写 run()方法，然后调用 start()启动线程\n实现简单，直观易懂\nJava 是单继承，继承了 Thread后不能再继承其他类；耦合性高，不够灵活\n适用于简单的示例代码、初学者理解线程基本概念\n\n\n2️⃣ 实现 Runnable接口\n自定义类实现 Runnable接口，实现 run()方法，将实例作为参数传给 Thread对象，再调用 start()\n实现接口，不占用继承名额，更灵活；适合多个线程共享同一个 Runnable 实例；面向接口编程\n依然需要显式创建 Thread 对象，不能直接获取返回值\n适用于大多数异步任务、线程任务无返回值的场景，是主流推荐方式之一\n\n\n3️⃣ 实现 Callable&lt;V&gt;接口 + 线程池&#x2F;Future\n实现 Callable&lt;V&gt;接口，重写 call()方法（有返回值，可抛异常），通过 ExecutorService.submit(Callable)提交，返回 Future&lt;V&gt;对象获取结果\n可以返回执行结果，支持抛出异常，功能更强大\n使用稍复杂，需要依赖线程池和 Future 机制\n适用于需要获取线程执行结果、处理异常、并发计算等复杂任务\n\n\n4️⃣ 使用线程池（Executor 框架）\n通过 Executors或 ThreadPoolExecutor创建线程池，提交 Runnable或 Callable任务，由线程池管理线程的创建与调度\n线程复用，避免频繁创建&#x2F;销毁线程的开销；统一管理线程生命周期；提高性能与资源利用率\n需要对线程池有一定了解，使用不当可能引发资源耗尽等问题\n生产环境、高并发、需要高效管理线程的场景，是业界最佳实践\n\n\n\n继承 Thread类\n\n继承Thread类并重写run方法\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        // 线程执行的代码\n        System.out.println(&quot;线程运行中（继承Thread类）：&quot; + Thread.currentThread().getName());\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start(); // 启动线程，调用run()\n    }\n}\n2. 实现 `Runnable`接口   1. 重写（实现）run方法   2. ```java      class MyRunnable implements Runnable &#123;          @Override          public void run() &#123;              System.out.println(&quot;线程运行中（实现Runnable接口）：&quot; + Thread.currentThread().getName());          &#125;      &#125;            public class Main &#123;          public static void main(String[] args) &#123;              Thread thread = new Thread(new MyRunnable());              thread.start();          &#125;      &#125;\n\n\n基于runnable的lambda表达式\n\nnew Thread(() -&gt; {\n    System.out.println(&quot;线程运行中（Lambda表达式）：&quot; + Thread.currentThread().getName());\n}).start();\n         3. 实现 `Callable&lt;V&gt;`接口 + `FutureTask`   1. 类似 Runnable，但可以**有返回值**，能抛异常   2. ```JAVA      import java.util.concurrent.*;            class MyCallable implements Callable&lt;String&gt; &#123;          @Override          public String call() throws Exception &#123;              return &quot;线程返回值（实现Callable接口）：&quot; + Thread.currentThread().getName();          &#125;      &#125;            public class Main &#123;          public static void main(String[] args) throws Exception &#123;              // 创建线程池              ExecutorService executor = Executors.newSingleThreadExecutor();                    // 提交 Callable 任务，返回 Future              Future&lt;String&gt; future = executor.submit(new MyCallable());                    // 获取返回值（会阻塞直到任务完成）              String result = future.get();              System.out.println(result);                    // 关闭线程池              executor.shutdown();          &#125;      &#125;\n\n\n\n\n\n\n使用线程池（Executor 框架）\n\n通过线程池（如 Executors）管理线程的创建和执行\n\nimport java.util.concurrent.*;\n\npublic class ThreadPoolExample {\n    public static void main(String[] args) {\n        // 创建 ThreadPoolExecutor\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n            2,                      // 核心线程数（corePoolSize）\n            4,                      // 最大线程数（maximumPoolSize）\n            60,                     // 空闲线程存活时间\n            TimeUnit.SECONDS,       // 时间单位\n            new LinkedBlockingQueue&lt;&gt;(2),  // 任务队列（容量为2）\n            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略：直接抛出异常\n        );\n\n        // 提交 8 个任务，观察线程池行为\n        for (int i = 1; i &lt;= 8; i++) {\n            final int taskId = i;\n            executor.execute(() -&gt; {\n                System.out.println(&quot;正在执行任务 &quot; + taskId + &quot;，线程：&quot; + Thread.currentThread().getName());\n                try {\n                    Thread.sleep(2000); // 模拟任务执行\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(&quot;任务 &quot; + taskId + &quot; 执行完毕&quot;);\n            });\n        }\n\n        // 关闭线程池（不再接受新任务，等待已提交任务完成）\n        executor.shutdown();\n        System.out.println(&quot;所有任务已提交，线程池准备关闭...&quot;);\n    }\n}\n### 为什么不建议使用Excutors创建线程池？1. `Executors`是 Java 并发包 `java.util.concurrent`中的一个**工具类**，提供了几个静态工厂方法，用于**快速创建常见类型的线程池**。2. 不建议直接使用 `Executors`工具类提供的快捷方法（如 `newFixedThreadPool`、`newCachedThreadPool`等）来创建线程池，是因为这些方法在某些场景下可能导致资源耗尽、线程爆炸、任务堆积、内存溢出（OOM）等严重问题，存在潜在风险。   1. 原因：      1. 底层其实都是调用了 `ThreadPoolExecutor`或 `ScheduledThreadPoolExecutor`，但是对参数进行了**封装和默认设置**      2. 使用的是**无界队列** `LinkedBlockingQueue`，队列容量为 Integer.MAX_VALUE（约 2^31-1，非常大）      3. 如果任务提交速度 &gt; 线程处理速度，任务会不断堆积在队列中      4. 最终可能导致 **内存耗尽（OOM，OutOfMemoryError）**，因为任务对象、数据不断累积，队列无限增长3. 推荐使用 `ThreadPoolExecutor`手动构造线程池，以精确控制线程池行为，提高稳定性和可控性。### 线程池有哪几种状态？5种。| 状态名         | 值（高 3 位）                          | 含义                     | 说明                                                         || :------------- | :------------------------------------- | :----------------------- | :----------------------------------------------------------- || **RUNNING**    | 111 （二进制） 即 -536870912（十进制） | **运行中**               | **接受新任务，并处理队列中的任务**                           || **SHUTDOWN**   | 000 （二进制） 即 0（十进制）          | **关闭（不接受新任务）** | **不再接受新任务，但会继续处理队列中的任务**                 || **STOP**       | 001 （二进制） 即 1（十进制）          | **停止**                 | **不再接受新任务，也不处理队列中的任务，并中断正在执行的任务** || **TIDYING**    | 010 （二进制） 即 2（十进制）          | **整理中**               | **所有任务都已终止，workerCount = 0，线程池即将执行 terminated() 钩子方法** || **TERMINATED** | 011 （二进制） 即 3（十进制）          | **已终止**               | **terminated() 方法已经执行完毕，线程池完全停止**            |### ThreadLocal详见笔记《ThreadLocal》### Tomcat为什么要用自定义类加载器？1. 在Tomcat中可能存在同名类。为了避免冲突和隔离资源，应该使用自定义类加载器。2. **Tomcat 是一个 Servlet 容器**，它负责运行多个独立的 Web 应用。每个 Web 应用可能有自己依赖的库，甚至可能用到相同库的不同版本。为了实现：   - **应用间类隔离**   - **核心库与用户库的区分加载**   - **支持热部署和灵活管理**   Tomcat **不得不打破双亲委派模型**。3. Tomcat 的类加载器架构（简化版）   1. Tomcat 设计了多种类加载器，典型的类加载器层次结构如下（从上到下）：      1. Bootstrap ClassLoader（JVM 提供，加载核心 Java 类，如 `java.*`）      2. Extension ClassLoader（加载扩展库，如 `javax.*`或 `$JAVA_HOME/lib/ext`下的类）      3. Application ClassLoader（即系统类加载器，加载 `classpath`下的类，通常是你的工程依赖）      4. **Common ClassLoader**（Tomcat 提供，加载 `CATALINA_HOME/lib`下的类，如 `servlet-api.jar`，这些是所有 Web 应用共享的）      5. **Webapp ClassLoader**（每个 Web 应用独有，加载该应用 `WEB-INF/classes`和 `WEB-INF/lib`下的类）4. Tomcat 如何打破双亲委派？   1. 关键点在于 **WebappClassLoader（Web 应用类加载器）** 的加载行为      1. 默认情况下（即标准双亲委派）：      - 当加载一个类时，类加载器会先委派给父加载器去加载，只有在父加载器找不到时，自己才尝试加载。   2. 但 Tomcat 的 WebappClassLoader **刻意颠倒了这一逻辑（部分打破双亲委派）**：对于 **Web 应用私有的类（如 WEB-INF 下的类）**，**WebappClassLoader 会优先尝试自己加载，而不是先委派给父加载器！*      1. 换句话说：      - 当 Web 应用需要加载一个类时，Tomcat 的 WebappClassLoader 会首先从当前应用的 `WEB-INF/classes`和 `WEB-INF/lib`中查找并加载类；      - 只有当找不到时，才会委派给父类加载器（如 CommonClassLoader 或更上层）去加载；5. 意义：   1. 不同 Web 应用可以拥有相同类库的不同版本，因为它们各自用自己的 WebappClassLoader 加载，互不干扰；   2. 核心类（如 Servlet API）仍然由 CommonClassLoader 或更上层加载，保证一致性；   3. **实现了类隔离与应用独立性**；6. 但 Tomcat 并没有完全抛弃双亲委派！   1. 对于一些 关键的、应该由全局统一管理的类（如 Servlet API、JSP 相关类等），Tomcat 仍然希望它们由公共的类加载器（如 CommonClassLoader）加载，而不是由每个 Web 应用自己的加载器加载，以避免混乱和冲突。   2. 因此，Tomcat 在实现 WebappClassLoader 时，对于 一些指定的包名（如 `javax.\\*`, `org.apache.tomcat.\\*`, `java.\\*`等），仍然会优先走双亲委派，确保这些类由上层加载器加载，而不是由 Web 应用私自提供。### hashCode（）和 equals（）的联系1. 如果两个对象通过 `equals()`方法比较是相等的，那么它们的 `hashCode()`**必须相同**！2. 如果两个对象的 `hashCode()`相同，它们 **不一定** `equals()`为 true！   1. 这被称为 **哈希碰撞（Hash Collision）**，即不同的对象可能计算出相同的哈希值。这是 **允许的，并且很常见**，好的 hashCode 方法应尽量减少碰撞，但不能完全避免。3. 一定要同时重写 hashCode() 和 equals()### String，StringBuffer，StringBuilder1. String是常量，不可变2. StringBuilder可变，线程不安全。3. StringBuffer可变，线程安全（有synchronized修饰）### &quot;==&quot;和equals()的区别1. ==：如果比较的是基础数据类型，则比较值；如果是引用类型，则比较引用地址2. equals（）有比较逻辑### 重载和重写的区别（细节）1. 重载：发生在同一个类中，**方法名必须相同，必须要求参数列表不同**，如类型、个数、顺序不同。与返回值类型、访问修饰符、抛出的异常等无关。发生在编译时。2. 重写：发生在父子类中，方法名、参数列表必须相同。返回值、抛出异常的范围不大于父类，访问修饰符范围不小于父类（所以父类的private方法不可重写）。发生在运行时。### List和Set的区别1. ## 2. | 区别维度             | **List（列表）**                                             | **Set（集合）**                                              |   | :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |   | **是否允许重复元素** | **允许重复**                                                 | **不允许重复**（如果试图添加已存在的元素，添加失败，返回 false） |   | **是否有序**         | **有序**（按照元素的插入顺序保存，遍历时按插入顺序输出）     | **默认无序**（不保证顺序，但某些实现如 `LinkedHashSet`和 `TreeSet`有特定顺序） |   | **访问方式**         | 允许下标访问和迭代器遍历。                                   | 不允许下表访问，可以用迭代器访问。                           |   | **底层常用实现类**   | `ArrayList`、`LinkedList`、`Vector`                          | `HashSet`、`LinkedHashSet`、`TreeSet`                        |   | **主要用途**         | 适合存储 **有序的、可能重复的数据列表**，比如用户列表、商品列表等 | 适合存储 **唯一值的集合**，比如标签、黑名单、不重复的用户 ID 等 |   | **接口继承自**       | `Collection`                                                 | `Collection`                                                 |   | **元素排序**         | 按插入顺序                                                   | 默认无序，但： • `TreeSet`：**自然排序 或 自定义排序** • `LinkedHashSet`：**按插入顺序** |### HashMap 是线程安全的吗？不是的话，多线程操作会导致什么问题？- （1.7 的死循环问题了解吗？1.8 数据覆盖问题了解吗？）1. **JDK 1.7 中 HashMap 的并发问题（经典死循环问题！）**   1. 问题背景：   在 JDK 1.7 的 HashMap 中，多线程并发执行 put 操作，并且触发了扩容（rehash），可能会导致链表形成环形结构（环形链表），进而导致后续 get() 操作时 CPU 100%、死循环！   2. 问题原因（核心）：      - JDK 1.7 的扩容机制是：创建新数组，然后对原数组每个桶上的 Entry 链表进行头插法迁移      - 头插法：新节点插入链表头部      - 多线程并发扩容时，多个线程同时对同一个链表进行头插，可能导致链表节点互相引用，形成环   3. 举例说明（简化版）：      1. 假设线程 A 和线程 B 同时触发扩容，都操作同一个链表：         - 原链表：A → B → C         - 线程 A 执行了一半，链表变成了 B → A         - 线程 B 也执行，可能把链表改成了 C → B → A → C → …（形成环）         - 当你后续调用 `get(key)`，遍历这个链表时，就会 陷入死循环，CPU 飙升！   4. 根本原因：      - JDK 1.7 的扩容是头插法 + 单线程逐个迁移 + 没有同步机制      - 多线程并发扩容时，链表可能倒置、成环，造成死循环   &gt; **这是 JDK 1.7 HashMap 最著名、最严重的并发 Bug 之一，在生产环境中出现过多次事故！**2. **JDK 1.8 中 HashMap 的并发问题**   1. JDK 1.8 对 HashMap 做了重大优化，包括：      1. 改用 尾插法（解决了 1.7 头插法导致的链表倒置与死循环问题）      2. 引入 红黑树（优化查询效率）      3. 优化了 hash 计算与扩容机制      - 但！**JDK 1.8 的 HashMap 仍然是线程不安全的！**   2. 在多线程环境下，JDK 1.8 的 HashMap 可能出现以下问题：      1. **数据覆盖（Lost Update）**         - 多个线程同时 put 同一个 key，后写入的线程可能覆盖先写入的线程的值         - 因为 put 操作没有加锁，没有原子性保证      2. **数据丢失**         - 多线程同时执行 put，某些线程的 put 可能因为并发问题没有成功写入      3. **扩容时的数据错乱**         - 虽然 1.8 改用 尾插法，不再容易形成环形链表，但多线程并发扩容时，仍然可能导致链表或树结构混乱，数据错乱或丢失         - 比如多个线程同时迁移数据，可能没有正确链接节点      4. **仍然是非原子操作**         - 比如 **putIfAbsent、computeIfAbsent** 等复合逻辑，在多线程下也可能有问题，除非使用 ConcurrentHashMap 提供的对应原子方法### hashMap的扩容机制详见下面的ConcurrentHashMap的扩容机制。只不过线程不安全且不能多线程扩容。### 谈谈ConcurrentHashMap的扩容机制1. 为什么要扩容   1. 和 `HashMap`一样，`ConcurrentHashMap`也是基于 **哈希表（数组 + 链表/红黑树）** 实现的。      随着不断向 `ConcurrentHashMap`中 添加元素（put），哈希冲突可能增多，当某个桶（bucket）中的元素越来越多时：      - 如果是链表形式，查询效率会从 O(1) 退化为 O(n)；      - 如果链表长度超过阈值（默认为 8），并且数组长度达到一定大小，链表会转为 红黑树（O(log n)）；      - 但即便有了红黑树，如果 整个哈希表中的数据量很大，而底层数组（table）容量较小，依然会导致 哈希冲突严重，性能下降。      👉 因此，为了保证查询、插入的高效性，当元素数量达到一定阈值时，ConcurrentHashMap 会进行扩容（resize），即扩大底层数组的大小，重新分配元素，降低哈希冲突。2. 以Java 8为主，讲解扩容机制   1. 扩容触发条件      1. 当 **元素的总数量（默认16）超过 负载因子（默认 0.75） × 当前容量（capacity）** 时，即：\nsize &gt;= capacity * loadFactor（默认 0.75）\n      也就是说，当 哈希表中的元素数量“过密”时，就会触发扩容。      2. **链表长度超过阈值（8），但数组长度较小（&lt; 64）时，也可能先触发扩容而非树化**         1. 链表转红黑树之前，可能先触发扩容   2. 扩容目标      - 扩容就是将 原数组（table）的容量扩大为原来的 2 倍（即 newCapacity = oldCapacity &lt;&lt; 1）。      - 扩容过程中，需要将旧数组中的每个 桶（bucket）中的元素，重新计算在新数组中的位置，并迁移到新数组中。   3. 扩容的核心思想：**多线程协同扩容（协助迁移）**      这是 Java 8 `ConcurrentHashMap`扩容机制中一个非常 **厉害且高效的设计** 👇：      &gt; **扩容不再由某一个线程全权负责，而是支持多个线程并发地协助进行数据迁移，大大提升了扩容效率，避免了单线程扩容成为瓶颈。**      - **table**：当前正在使用的哈希桶数组。      - **nextTable**：扩容时创建的新数组，大小是原数组的两倍。      - **transferIndex**：表示当前迁移进度，从高位（数组末尾）开始，逐步向低位（数组开头）迁移。      - **sizeCtl**：控制标识符，用于表示当前容器的状态，比如是否正在初始化、是否正在扩容等。当 `sizeCtl &lt; 0`时，可能表示正在初始化或扩容。扩容时，它还用于控制并发扩容的线程数等。   4. 扩容大致流程（简化版）      1. **检测是否需要扩容**：当插入新元素后，总元素数超过 `capacity * loadFactor`，或者某个桶太满时，触发扩容检查。      2. **初始化 nextTable（新数组）**：创建一个新的数组，容量是原数组的 **2 倍**。      3. **多线程协同迁移（transfer）**：将原数组（table）中的每个 bucket 上的节点，**重新计算在新数组（nextTable）中的位置，并迁移过去**。每个线程会负责迁移一部分 bucket，通过 `transferIndex`控制迁移区间，避免冲突。每个 bucket 的迁移是通过 **锁住当前桶（synchronized 锁住链表头/树根节点）** 来进行的，保证线程安全。      4. **迁移完成后切换引用**：当所有 bucket 都迁移完成后，将 `table`指向 `nextTable`，`nextTable`成为新的主表，完成扩容。   5. 为什么能支持多线程协助扩容？      这是 Java 8 `ConcurrentHashMap`扩容最牛的地方之一 ✨：      - 在扩容过程中，如果某个线程 put 时发现正在扩容，**它不会等待，而是主动参与迁移工作（协助扩容）**。      - 每个线程会分配到一部分 bucket 去迁移，通过 CAS 和 `transferIndex`控制各自负责的范围，避免重复和冲突。      - 这种 **“众人拾柴火焰高”** 的设计，极大地提升了大容量情况下的扩容速度，充分利用了多核 CPU 的能力。         6. 扩容期间访问怎么办？      - 在扩容过程中，**读操作（get）可以正常进行**，即使数据正在迁移。      - 如果读线程访问的 bucket **尚未迁移**，则从旧数组 table 中读取；      - 如果 **已经迁移**，则从新数组 nextTable 中读取；      - 写操作（put/remove）如果发现正在扩容，也可能 **协助迁移或等待迁移完成后再操作**。3. Java7是怎么实现的呢   1. 分段锁（Segment 继承 ReentrantLock）   2. 数据结构：      - ConcurrentHashMap 由多个 Segment 组成（默认是 16 个）      - 每个 Segment 继承自 ReentrantLock，是一个小的 HashMap（数组 + 链表）      - 每个 Segment 内部维护了一个 HashEntry&lt;K,V&gt;[] table   3.  线程安全如何保证？      - 对某个 Segment 的操作（如 put、get），只需要锁住该 Segment      - 不同 Segment 之间的操作是 并发安全且互不阻塞 的   4. 优点：      - 相比 Hashtable 的全表锁，并发度更高（默认支持 16 个线程并发写）      - 细化锁粒度，提升吞吐量   5. 缺点：      - 结构复杂：外层是 Segment 数组，内层是 HashEntry 数组      - 锁的粒度仍然较粗（一个 Segment 内还是锁整个桶）      - 不支持链表转红黑树，链表过长时性能下降明显      - 代码可维护性较差### 深拷贝和浅拷贝1. 浅拷贝会复制基本数据类型，但是对于引用对象只会复制一个地址。即，引用对象还是指向同一个。2. 深拷贝既会复制基本数据类型，也会复制引用对象。即，引用对象不是同一个。### 引用类型Java 主要提供了 **4 种引用类型**，按强度从强到弱依次为：1. **强引用（Strong Reference）** —— 默认的引用类型   1. 强引用是 Java 中最常见、默认的引用类型。只要强引用存在，对象就绝对不会被垃圾回收器回收。2. **软引用（Soft Reference）**   1. 软引用是一种比强引用弱、但比弱引用强的引用类型。如果一个对象只被软引用指向，在内存不足时，它才会被垃圾回收。3. **弱引用（Weak Reference）**   1. 弱引用比软引用更弱。只要发生垃圾回收，无论内存是否充足，只要对象只被弱引用指向，它就会被回收。4. **虚引用（Phantom Reference）**   1. get() 方法永远返回 null！   2. 无法通过虚引用来获取对象   3. 虚引用唯一的作用，是通过 ReferenceQueue 监听对象是否已被回收### Java中的异常体系详见笔记《异常处理》### 什么时候应该抛出异常，什么时候捕获异常1. **抛出异常（throw / throws）：** 是 **发现问题、抛出问题**，通常由 **底层方法、工具类、数据校验模块** 完成，表示 “这里可能出错了，我处理不了，交给调用者决定”。2. **捕获异常（try-catch）：** 是 **处理问题、解决问题**，通常由 **调用方、业务逻辑层、UI 层、控制器层** 完成，表示 “我知道这里可能出错，我来处理”。### JVM中那些是线程共享区| 区域                                       | 是否线程共享   | 说明                                                         || :----------------------------------------- | :------------- | :----------------------------------------------------------- || **堆（Heap）**                             | ✅ **线程共享** | 所有对象实例和数组都在这里分配，是 GC 主要管理的区域         || **方法区（Method Area）**                  | ✅ **线程共享** | 存储已被虚拟机加载的 **类信息、常量、静态变量、即时编译器编译后的代码等** || **Java 虚拟机栈（JVM Stack）**             | ❌ **线程私有** | 每个线程私有，存储 **栈帧（局部变量表、操作数栈、动态链接、方法出口等）** || **本地方法栈（Native Method Stack）**      | ❌ **线程私有** | 为 JVM 调用的 **Native 方法服务**                            || **程序计数器（Program Counter Register）** | ❌ **线程私有** | 当前线程执行的字节码行号指示器（线程切换时能恢复执行位置）   |### 如何排查JVM的问题？（待学习）- 我会去问LLM- - | 步骤 | 操作                 | 工具/命令                                        | 目的                             |  | :--- | :------------------- | :----------------------------------------------- | :------------------------------- |  | 1    | 查看 OOM 错误日志    | 控制台 / 日志文件                                | 确定 OOM 类型（堆、元空间等）    |  | 2    | 生成 Heap Dump       | `jmap -dump`或 `-XX:+HeapDumpOnOutOfMemoryError` | 获取堆内存快照                   |  | 3    | 分析 Heap Dump       | Eclipse MAT / VisualVM                           | 找到大对象、内存泄漏、对象引用链 |  | 4    | 查看线程状态（可选） | `jstack &lt;pid&gt;`                                   | 分析线程死锁、线程数过多等问题   |  | 5    | 定位代码问题         | 结合 dump 分析 + 业务代码                        | 修复内存泄漏、优化对象使用       |1. 一般而言，排查问题可以从以下方面入手   1. 对于还在运行的系统，通过jmap, jstack, jstat等工具查看系统信息。   2. 对于已经发生OOM的系统，可以去看日志2. 常见类型：   1. 内存溢出，CPU使用率过高，线程问题，GC问题3. OOM怎么解决### 一个对象从加载到JVM，再到被GC处理，经历了什么？1. 类加载：把字节码（.class）加载到方法区2. 创建对象：在堆中分配内存3. 在堆中E区、S区、O区流转4. 被GC清理### 怎么确定一个对象是不是垃圾？1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。   2. 有多个根对象，但是只会选用一个。### 有哪些GC算法1. **标记清除算法**   1. 基本思想      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。   2. 优点      1. 不需要移动对象，实现相对简单   3. 缺点      1. 内存碎片化严重      2. 效率问题2. **复制算法**   1. 基本思想      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）      2. 每次只使用其中一块（如 From 区）来分配对象      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）      4. 交换角色：原来的 To 区成为新的 From 区，继续使用   2. 优点      1. 没有内存碎片！      2. 分配效率高      3. 适合对象存活率低的场景   3. 缺点      1. 浪费了一半的内存空间      2. 不适合存活对象多的场景3. **标记压缩算法**   1. 基本思想      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间   2. 优点      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）      2. 内存利用率高，适合大对象和长期存活对象分配   3. 缺点      1. 移动对象成本高！### 什么是STW1. 全称Stop-The-World2. 在垃圾回收（GC）过程中，Java 虚拟机（JVM）为了保证垃圾回收的正确性，会暂停所有的应用线程（也就是用户线程 / 业务线程），只让垃圾回收线程运行。### 什么是反射- **反射（Reflection）** 是一种强大的机制，它允许程序在**运行时**（而不是编译时）获取类的信息，并且可以动态地操作类或对象的属性、方法和构造器等。-  反射使得程序可以在运行时“发现”和“操作”类，而不需要在编译期明确知道这些类的具体信息## 线程### 线程安全1. 线程安全（Thread Safety） 是指：当一个类、方法或代码块在多线程环境下被多个线程同时访问时，仍然能正确地工作，不会导致数据错误、逻辑混乱或程序崩溃，那么它就是线程安全的。2. 针对某一段代码，多线程同时执行时，不会造成混乱3. 举例：   1. ```java      public class UnsafeCounter &#123;          private int count = 0;                public void increment() &#123;              count++; // 实际上是 read -&gt; add -&gt; write，非原子！          &#125;      &#125;\n\n\n上面的代码，如果有两个线程执行，那么应该一个结果是1，一个结果是2。如果不是，就说明造成了混乱。\n\n\n\n\n守护线程\n守护线程（Daemon Thread） 是 Java 线程中的一种特殊线程，它的作用通常是 为其他线程（用户线程 &#x2F; 非守护线程）提供后台服务支持\n\n守护线程和用户线程对比\n1. \n\n\n\n\n对比项\n守护线程（Daemon Thread）\n用户线程（User Thread &#x2F; 非守护线程）\n\n\n\n作用\n为其他线程提供后台服务\n执行主要任务，是程序的核心逻辑\n\n\nJVM 是否会等待其结束\n不会，只要用户线程结束，JVM 就会退出，不管守护线程是否还在运行\n会，JVM 会等待所有用户线程执行完毕才会退出\n\n\n默认情况\n线程默认是用户线程\n是\n\n\n如何设置\n通过 setDaemon(true)设置\n不设置或设置为 false\n\n\n典型例子\n垃圾回收线程、日志线程、监控线程\n主线程、业务逻辑线程、用户交互线程\n\n\n\n\n\n\n并发、并行、串行\n串行：一个一个执行\n并行：物理世界，同时进行。比如一边跑步一遍听歌。\n并发：两个任务轮流执行，但是轮转很快。比如CPU分时的处理两个请求\n\n死锁如何解决\n产生的必要条件\n\n\n\n\n条件\n说明\n是否必须\n\n\n\n1. 互斥条件（Mutual Exclusion）\n某资源一次只能被一个线程占用（如锁、对象、文件等）\n✅ 必须\n\n\n2. 占有并等待（Hold and Wait）\n线程持有至少一个资源，并等待获取其他被占用的资源\n✅ 必须\n\n\n3. 不可剥夺（No Preemption）\n线程已获得的资源，在未使用完之前，不能被其他线程强行夺取，只能由自己释放\n✅ 必须\n\n\n4. 循环依赖（Circular Wait）\n存在一个线程的循环等待链，比如 T1 等 T2 的资源，T2 等 T1 的资源，形成一个闭环\n✅ 必须\n\n\n\n\n\n如何排查？\n\n用jstack到处堆内存快照，然后分析文件。jastack会为你分析出是否存在死锁。\n\n\n如何避免\n\n破坏循环依赖（推荐）—— 按固定顺序获取锁\n破坏循环依赖占有并等待——使用超时机制（tryLock）\n检测与恢复（高级 &#x2F; 系统级，预防措施）\n\n\n\nCountDownLatch和Semaphore的区别和底层实现详见笔记《Java学习笔记》\nsynchronized的偏向锁，轻量级锁，重量级锁详见笔记《Java学习笔记》\nsynchronized和ReentrantLock的区别\n\n\n对比维度\nsynchronized（内置锁）\nReentrantLock（可重入锁）\n\n\n\n类型\nJava 关键字（语法层面，JVM 实现）\nJava 类（java.util.concurrent.locks.ReentrantLock，API 层面）\n\n\n使用方式\n直接修饰方法或代码块，语法简洁\n需要手动加锁 lock()和解锁 unlock()，通常配合 try-finally使用\n\n\n锁的获取与释放\n自动加锁与释放（进入同步块加锁，退出时释放）\n手动加锁与释放，必须显式调用 lock()和 unlock()，推荐在 finally块中释放\n\n\n可重入性\n✅ 支持（同一个线程可重复获取同一把锁）\n✅ 支持（同一个线程可多次获取锁，必须释放同样次数）\n\n\n公平性\n❌ 非公平锁（不保证等待顺序）\n✅ 可选择公平或非公平（构造方法传参）\n\n\n是否可中断\n❌ 不支持中断等待锁\n✅ 支持 lockInterruptibly()，可响应中断\n\n\n是否可设置超时\n❌ 不支持尝试获取锁的超时机制\n✅ 支持 tryLock(long time, TimeUnit unit)，可以设置超时等待\n\n\n是否支持多个条件变量（Condition）\n❌ 只有一个隐式的等待队列（通过 wait/notify）\n✅ 支持多个 Condition，可精细控制线程等待&#x2F;唤醒（如不同条件队列）\n\n\n谈谈你对AQS的理解详见笔记《Java学习笔记》\n如何保证操作的原子性\n使用AotmicXXX类\n\n// 使用 AtomicInteger 代替 int\nprivate static AtomicInteger i = new AtomicInteger(0);\n\ni.incrementAndGet()就是 // 原子版本的 i++\ngetAndIncrement() // 相当于 i++\naddAndGet(1) // 加一个指定的值\nget() // 获取当前值\nset(int newValue) // 设置值\n   2. 这是推荐做法，性能好，线程安全。2. `AtomicInteger`的核心实现依赖于：   - **CAS（Compare-And-Swap）**：一种硬件级别的原子操作   - 利用循环 + CAS 的方式实现 **无锁的线程安全操作（乐观锁）**3. CAS   1. CAS 是一种原子操作，它的功能是：比较某个内存位置的值与预期值，如果匹配，则将该内存位置的值更新为新值；如果不匹配，则不修改值。整个操作是原子的（不可中断），由 CPU 硬件保证。## Spring### 谈谈你对IOC的理解- IoC：控制反转1. 什么是控制？控制了什么？   1. 具体来说，控制了以下内容：      | 控制的内容         | 说明                                                        |      | :----------------- | :---------------------------------------------------------- |      | 对象的创建         | 谁负责 new 一个对象出来（比如 `new UserService()`）         |      | 依赖关系的组装     | 比如一个 Service 依赖一个 DAO，谁来把 DAO 注入到 Service 中 |      | 对象之间的耦合关系 | 对象之间如何关联、谁依赖谁、怎么管理这些依赖                |      | **对象的生命周期** | 比如对象什么时候创建、什么时候销毁、是否单例等              |      在传统编程中，这些控制都是由程序员在代码中显式完成的。2. 什么是反转？反转前是谁控制？反转后呢？如何控制的？   1. 反转前（传统方式）—— “正序控制” / “主动控制”      - 谁控制？ → 由程序员 / 开发者控制      - 控制什么？ → 对象的创建、依赖关系的手动组装      - 如何实现的？ → 通过 new 关键字、手动赋值、层层构造   2. 反转后（IoC 方式）—— **“控制权反转给容器”**      - 谁控制？ → 由外部容器（比如 Spring IoC 容器）控制      - 控制什么？ → 对象的创建、依赖注入、生命周期管理      - 如何实现的？ → 通过依赖注入（DI）、配置文件 / 注解，让容器来管理对象和依赖关系3. 为什么要反转？有什么好处？   1. 控制反转（IoC）的主要目的是为了解耦、提高代码的灵活性、可测试性和可维护性。### IoC和DI怎么通过反射实现的？1. **扫描类路径，找到需要管理的 Bean（使用反射）**   Spring 启动时，会扫描你指定的包路径（比如 `com.example`），找出所有带有 `@Component`、`@Service`、`@RestController`等注解的类。   &gt; 这一步是通过 **反射机制** 去**读取类上的注解信息**，判断哪些类需要由 Spring 管理，变成一个个 Bean。   ------2. **实例化 Bean（通过反射创建对象）**   对于每一个需要管理的类（比如 `UserService`和 `UserController`），Spring 会：   - 通过反射调用其构造器（通常是默认的无参构造器，或有参构造器），   - 动态地创建出一个对象实例，   比如：\n\n\n\nClass&lt;?&gt; clazz &#x3D; Class.forName(“com.example.UserService”);Object userServiceObj &#x3D; clazz.getDeclaredConstructor().newInstance(); &#x2F;&#x2F; 反射创建对象\n   &gt; 这一步就是用反射来代替你手动写 `new UserService()`。   ------3. **依赖注入（通过反射实现 @Autowired 等注入）**   如果一个类中有依赖其它 Bean 的字段（比如 `@Autowired private UserService userService;`），Spring 会：   1. 找到这个字段，   2. 知道它需要注入一个 `UserService`类型的 Bean，   3. 从容器中找出已经创建好的 `UserService`对象，   4. **通过反射调用 `Field.set(对象, 值)`，把这个依赖注入到目标字段中。**   即使这个字段是 `private`的，Spring 也会通过 `field.setAccessible(true)`来绕过访问限制，然后进行赋值。   &gt; 这就是通过反射实现的 **依赖注入（DI）**，而依赖注入是 IoC 的一种实现方式。   ------4. **管理 Bean 的生命周期、作用域等**   Spring 还会通过反射调用一些初始化方法（比如 `@PostConstruct`标记的方法）、销毁方法等，也是依赖反射来动态调用的。### 单例Bean和单例模式一定条件下，可以认为单利Bean是单例模式。1. 在单例模式下，一个类只能有一个对象。2. 但是单例Bean不一样。一个类可以有多个对象，但是通过同一个名字只能获得一个对象。3. 所以说，在Sping的范围内，如果只有一个Bean的话，我们可以认为单利Bean是单例模式### Spring事务传播机制详见《SSM学习笔记》- 事物传播就是指事务被调用时，还是不是事务，是嵌套事务还是合并事务等等### Spring事务什么时候会失效详见《SSM学习笔记》- 跟AOP、事务管理器相关### Spring事务如何实现的详见《SSM学习笔记》- 事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的- 两种调用方式：声明式事务（@Transactional）或编程式事务（TransactionTemplate）### Bean是线程安全的吗1. Bean的本质还是类2. 如果Bean是无状态的，那就是线程安全的。否则反之。### Bean的生命周期1. **实例化**：Spring 创建对象（相当于 `new`）2. **属性赋值 / 依赖注入**：给 Bean 注入依赖（DI, Dependency Injection）3. **初始化**：执行初始化方法（`@PostConstruct` / `InitializingBean.afterPropertiesSet()`）4. **使用**：在应用中被调用5. **销毁**：应用关闭时销毁 Bean（`@PreDestroy` / `DisposableBean.destroy()`）### ApplicationContext和BeanFactory的区别| 概念                   | 一句话解释                                                   || :--------------------- | :----------------------------------------------------------- || **BeanFactory**        | 是 Spring **最底层、最核心的 IoC 容器接口**，**负责管理 Bean 的创建与依赖注入，但功能相对基础，懒加载为主** || **ApplicationContext** | 是 **BeanFactory 的高级扩展接口**，不仅具备 BeanFactory 的所有功能，还提供了 **更多企业级特性，比如国际化、事件机制、AOP 支持、自动装配等**，是 Spring 应用中最常用的容器 |### Spring容器的启动流程```javaSpringApplication.run()       ↓创建 ApplicationContext（如 AnnotationConfigApplicationContext）       ↓扫描 @ComponentScan 包路径，解析 @Component、@Service、@Configuration 等       ↓生成 BeanDefinition（Bean 的定义信息）       ↓将 BeanDefinition 注册到容器中（BeanDefinitionRegistry）       ↓根据 BeanDefinition 实例化 Bean（创建对象，比如通过反射调用构造方法）// 这里只有急加载的Bean会实例化       ↓进行依赖注入（DI，比如 @Autowired 字段注入）       ↓执行初始化回调（@PostConstruct、InitializingBean、init-method）       ↓发布 ContextRefreshedEvent 事件（容器初始化完成）       ↓✅ Spring 容器启动完成，应用可正常运行\n\nSpring用了哪些设计模式\n\n\n设计模式\n应用场景\n说明\n\n\n\n工厂模式\nBeanFactory &#x2F; ApplicationContext\n管理 Bean 的创建\n\n\n单例模式\n默认的 Bean Scope\n一个 Bean 只有一个实例\n\n\n代理模式\nSpring AOP\n实现方法拦截与增强\n\n\n模板方法模式\nJdbcTemplate、RestTemplate\n封装固定流程\n\n\n观察者模式\nApplicationEvent &#x2F; Listener\n事件发布与订阅\n\n\n适配器模式\nHandlerAdapter、AdvisorAdapter\n接口转换与兼容\n\n\n装饰器模式\nBeanPostProcessor\n增强 Bean 功能\n\n\n策略模式\n事务管理器、视图解析器\n多种实现动态选择\n\n\n责任链模式\n过滤器链、拦截器链\n多个处理器依次处理请求\n\n\n原型模式\nBean Scope 为 prototype\n每次获取新实例\n\n\n组合模式\n树形结构数据（非核心）\n组合对象与叶子对象统一处理\n\n\n外观模式\n高级封装（如 JdbcTemplate）\n简化复杂 API\n\n\n建造者模式\nSpringApplicationBuilder\n分步骤构建复杂对象\n\n\nSpring常用的注解及其底层实现详见《SSM学习笔记》\nSpringBoot怎么启动Tomcat的\n先启动Spring容器\n自动配置： @EnableAutoConfiguration（包含在 @SpringBootApplication 中）启用自动配置。它会根据你的 classpath 下的依赖（比如 tomcat-embed-core.jar），自动加载一系列自动配置类。生成一个启动Tomcat的Bean。\nSpring容器创建完之后，启动Tomcat的Bean，创建对象，并绑定端口。\n\nMybatis\nMyBatis 是一个优秀的 Java 持久层框架，它简化了 JDBC 的操作，通过 XML 或注解的方式，将 Java 对象与 SQL 语句进行映射，让开发者可以更灵活、更高效地操作数据库，而不用过多关心底层的 JDBC 细节。\n\nMybatis的优缺点Mybatis中#{}和${}的区别是什么？MySQL设计MySQL表时应该注意什么遵循第三范式（3NF）\n第一范式（1NF）：字段不可再分，每列都是原子的。\n第二范式（2NF）：满足1NF，且非主键字段完全依赖于完整主键（针对联合主键的情况）。\n2NF 消除了部分函数依赖，即非主键字段不能只依赖主键的一部分。\n\n\n第三范式（3NF）：满足2NF，且非主键字段不传递依赖于主键。\n消除了传递依赖，不能通过其他非主键字段间接依赖。\n\n\n\n设计字段\n选择合适的数据类型\n尽量使用最小的满足需求的数据类型，以节省存储空间和提高性能。\n\n\n字段命名规范\n使用有意义的名称，采用下划线命名法，如 user_name、created_at。\n避免使用 MySQL 的保留关键字，如 order、group等，若必须使用，需用反引号括起。\n主键通常命名为 id，外键通常为 xxx_id。\n\n\n\n主键与索引设计\n主键设计\n每张表都应有一个主键，用于唯一标识一行。\n推荐使用 自增整型（如 BIGINT AUTO_INCREMENT） 作为主键，简单高效，有利于索引组织。\n如果使用业务字段作为主键（如手机号、身份证等），要确保其唯一、不变、简短。\n\n\n索引设计\n索引不是越多越好，每个索引都会占用空间并影响写入性能。\n为经常用于 WHERE、JOIN、ORDER BY、GROUP BY 的字段建立索引。\n合理使用 复合索引（联合索引），注意最左前缀原则。\n\n\n\n索引的基本原理\n索引的理解\n索引是数据库中一种特殊的数据结构，它可以帮助数据库系统快速定位到表中的特定数据行，类似于书籍的目录。\n可以说，索引就是把无序的数据化为有序\n没有索引时，查找一般要遍历全表。有索引之后可以降低时间复杂度。\n索引也存储在硬盘中\n\n\n常见的索引\nB+树。详见《Java学习笔记》\n为什么用B+树？\n树高更低，查询更快（减少磁盘 IO 次数，每次 IO 代价高）\n非叶子节点只存 key，能容纳更多索引，树更矮\n叶子节点之间有链表，范围查询非常高效\n查询稳定，所有查询都要走到叶子节点，性能可预测\n适合写平衡（插入、删除也相对稳定）\n\n\n\n\n\n\n\n索引的设计原则\n选择合适的列建立索引\n\n高选择性列优先：列中不同值越多（如用户ID、订单号），索引效果越好\n\n高频查询条件列：WHERE、JOIN、ORDER BY、GROUP BY中频繁使用的列\n\n等值查询列：精确匹配比范围查询更适合索引\n\n排序&#x2F;分组列：经常用于ORDER BY或GROUP BY的列\n\n\n\n避免过度索引\n\n每个索引都有成本：占用存储空间，降低写入速度(INSERT&#x2F;UPDATE&#x2F;DELETE)\n\n监控索引使用率：定期检查未使用的索引并删除\n\n小表不需要索引：数据量小(如&lt;1000行)时全表扫描可能更快\n\n\n\n\n聚簇索引和非聚簇索引的区别是什么\n\n\n对比项\n聚簇索引（Clustered Index）\n非聚簇索引（Non-clustered Index &#x2F; 二级索引）\n\n\n\n定义\n索引的叶子节点 直接存储整行数据，即 数据即索引，索引即数据\n索引的叶子节点 存储的是主键值（或指向数据的指针），不是完整的数据行\n\n\n存储方式\n数据按索引顺序物理存储（即表数据按聚簇索引的顺序存放）\n数据与索引分开存储，索引单独维护，指向数据的地址或主键\n\n\n数量\n一个表只能有一个聚簇索引（通常是主键，如果没有主键则选唯一键，否则隐藏行 ID）\n一个表可以有多个非聚簇索引（二级索引）\n\n\n查询效率\n查询时 如果使用聚簇索引，通常只需一次查找即可定位到完整数据，效率很高\n查询时可能需要 回表（先查索引，再根据主键查聚簇索引获取完整数据），多一次 IO\n\n\n适用场景\n主键查询、范围查询（如日期、ID 范围）非常高效\n适合根据非主键字段查询，但可能带来回表开销\n\n\n典型实现（MySQL）\nInnoDB 的主键索引就是聚簇索引\nInnoDB 的普通索引（如二级索引）就是非聚簇索引\n\n\n物理顺序\n数据按聚簇索引的键值顺序存储（物理有序）\n数据存储无序，索引单独组织（逻辑有序）\n\n\n事务的基本特性和隔离级别\n基本特性：ACID\n\n原子性 (Atomicity)\n通过 undo log（回滚日志） 实现：\n\n事务开始前，InnoDB 会记录修改前的数据到 undo log\n如果事务需要回滚，可以根据 undo log 恢复到原始状态\n\n\n一致性 (Consistency)\n通过以下机制共同保证：\n\n原子性、隔离性、持久性的组合\n数据库的约束（如主键、外键、唯一约束等）\n应用程序的业务逻辑\n\n\n隔离性 (Isolation)\n通过 锁机制 和 MVCC（多版本并发控制） 实现：\n\n锁机制：包括共享锁(S锁)、排他锁(X锁)、意向锁等\nMVCC：通过 read view 和版本链实现非锁定读，提高并发性能\n\n\n持久性 (Durability)\n通过 redo log（重做日志） 实现：\n\n事务提交时，先将修改写入 redo log（预写日志），确保即使系统崩溃也能恢复数据\n采用 WAL（Write-Ahead Logging）技术，先写日志再写磁盘\n\n\n\n\n隔离级别\n\nSQL标准定义了四种隔离级别。隔离级别越高，并发性能越低，但数据一致性越强。从低到高依次为：\n\n读未提交(Read Uncommitted)\n读已提交(Read Committed)\n可重复读(Repeatable Read) (MySQL默认级别)\n串行化(Serializable)\n\n\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n并发性能\n实现复杂度\n\n\n\n读 未提交\n可能\n可能\n可能\n最高\n最低\n\n\n读 已提交\n不可能\n可能\n可能\n高\n低\n\n\n可重复读\n不可能\n不可能\nMySQL中不可能*\n中等\n中等\n\n\n串行化\n不可能\n不可能\n不可能\n最低\n最高\n\n\n\n并发问题详解\n\n脏读(Dirty Read)\n定义：读取到其他事务未提交的数据\n风险：如果事务回滚，读取到的数据就是无效的\n解决方案：至少使用读已提交隔离级别\n\n\n不可重复读(Non-repeatable Read)\n定义：同一事务内多次读取同一数据，得到不同结果\n原因：其他事务提交了修改\n风险：基于第一次读取结果做出的决策可能失效\n解决方案：使用可重复读或更高隔离级别\n\n\n幻读(Phantom Read)\n定义：同一事务内两次执行相同查询，返回不同行数(新增或删除的行)\n原因：其他事务插入或删除了符合查询条件的行\n风险：统计结果不准确，业务逻辑可能出错\n解决方案：使用串行化或MySQL的可重复读(通过间隙锁防止)\n\n\n\n\n\n\n\nMVCC概述\n什么是MVCC\n\n为了并发问题，数据库提供了 事务隔离级别（如 Read Committed、Repeatable Read、Serializable）。\n\n但使用 悲观锁（如行锁、表锁） 去解决并发问题，虽然安全，但会 降低并发性能，导致读写互相阻塞。\n\n✅ MVCC 的出现，就是为了在不加锁（或减少加锁）的前提下，实现事务隔离，让读写可以并发执行，提高性能！\n\n\nMVCC：多版本并发控制。是一种并发控制机制，它允许事务在不互相阻塞的情况下同时读取和修改数据。与传统的基于锁的并发控制不同，MVCC通过为数据维护多个版本来实现这一目标。\n\n\n\nMVCC的核心思想\n\n读不阻塞写，写不阻塞读：这是MVCC最大的优势\n\n数据多版本化：每行数据可能有多个版本同时存在\n\n一致性读：事务读取的是某个时间点的数据快照，而不是最新数据\n\n版本链管理：通过特殊的结构跟踪和管理数据的不同版本\n\n\n\n时间线示例\n\nT1 启动（事务 ID &#x3D; 101）\nT2 启动（事务 ID &#x3D; 102）\nT2 执行 UPDATE balance &#x3D; 200 WHERE id &#x3D; 1，未提交\nT2 提交事务，此时 balance &#x3D; 200 的版本，事务 ID &#x3D; 102，变为“已提交”\nT1 执行 SELECTT1 的 ReadView 是在 T2 提交前生成的，它依然 看不到 T2 的修改（因为 T2 在 T1 的 ReadView 中是“活跃的” 或 “在其后创建的”）T1 仍然读的是旧版本 balance &#x3D; 100。但如果 T1 提交后再开启一个新事务 T3 去读，T3 就能看到 balance &#x3D; 200（因为 T2 已提交）\n\n\n优势\n\n高并发性能：读写操作互不阻塞，显著提高系统并发能力\n非阻塞读：读操作不需要等待写操作完成，也不会阻塞写操作\n一致性读：事务可以读取一致的数据快照，不受其他事务影响\n减少锁争用：降低了死锁发生的概率\n\n\n局限\t\n\n存储开销：需要存储多个数据版本，增加存储空间使用\n\n清理成本：需要定期清理不再需要的旧版本数据（purge操作）\n\n实现复杂：相比简单的锁机制，MVCC实现更加复杂\n\n不解决所有问题：如幻读问题需要结合其他机制解决（如InnoDB的间隙锁）\n\n\n\n\n实现原理\n思想：\n不是直接读最新数据，也不是直接修改原数据，而是：\n写操作：创建新版本，旧数据保留（通过 Undo Log）\n读操作：根据事务的 ReadView，找到一个对当前事务“可见”的数据版本（可能是旧数据）\n\n\n\n\n\n\n多版本数据：每行记录有多个版本\n\n在 InnoDB 中，数据行（record）并不是一成不变的，而是会随着更新产生多个版本。每行数据包含几个关键的 隐藏字段（Metadata Fields）：\n\n\n\n隐藏字段\n说明\n\n\n\nDB_TRX_ID\n最后一次修改（INSERT&#x2F;UPDATE）该行的事务 ID\n\n\nDB_ROLL_PTR\n指向该行上一个版本（旧数据）的指针，存放在 Undo Log 中\n\n\nDB_ROW_ID（可选）\n如果表没有主键，InnoDB 会自动生成一个行 ID\n\n\n\n每当一个事务对某行数据进行 更新（UPDATE） 时：\n\n不会直接覆盖原数据\n而是先将旧数据写入 Undo Log（回滚日志）\n然后插入新数据（或原地更新），并更新 DB_TRX_ID 为当前事务 ID\n通过 DB_ROLL_PTR 可以找到该行的旧版本，形成版本链\n\n\n\n\n\nUndo Log（回滚日志）：保存旧版本数据\n\nUndo Log 是 InnoDB 用来支持事务回滚和 MVCC 的重要日志。\n\n每当一个事务修改了某行数据，InnoDB 会：\n\n把修改前的旧数据（即被覆盖前的值）保存到 Undo Log\n这些旧数据 不会被立即删除，而是会保留一段时间，用于：事务回滚（Rollback）MVCC 中为其他事务提供历史版本数据（读一致性）\n\n\nMVCC 利用 Undo Log 实现了“数据的多版本存储”。\n\n\n\n\nReadView（读视图）：决定事务能看见哪些版本\n\n当一个事务执行 SELECT（读操作） 时，InnoDB 不会直接读取最新数据，而是根据一个叫 ReadView 的东西，决定当前事务应该看到哪个版本的数据。\n\n什么时候生成 ReadView？\n\n\n\n在事务执行读操作（如 SELECT）时生成，用于控制该事务的“数据可见性”。\n\n\nReadView 包含的关键信息：\n\n\n\n\n字段\n说明\n\n\n\nm_ids\n当前 活跃的（未提交）事务 ID 列表（即还有哪些事务没提交，可能修改了数据）\n\n\nmin_trx_id\n当前所有活跃事务中的最小事务 ID\n\n\nmax_trx_id\n系统即将分配给下一个事务的 ID（当前最大事务 ID + 1）\n\n\ncreator_trx_id\n当前事务自己的 ID\n\n\n\n\n可见性判断规则（核心！）：\n\n当一个事务要读取某条数据时，InnoDB 不是直接读取磁盘上的最新数据，而是：\n\n找到该数据行的最新版本；\n根据 Read View 的规则，判断这个版本是否对当前事务可见；\n如果不可见，则顺着 DB_ROLL_PTR找上一个版本，再次判断，直到找到一个对当前事务可见的版本，或者没有更多版本可找。\n\n这个过程就是 “多版本读取”，也就是 MVCC 的核心。\n\n对于某行数据的 DB_TRX_ID（最后修改它的事务 ID），InnoDB 通过以下规则判断当前事务是否能“看到”这个版本：\n\n\n\n\n\n\n\n条件\n是否可见\n说明\n\n\n\nDB_TRX_ID &#x3D;&#x3D; creator_trx_id（是自己修改的）\n✅ 可见\n自己事务修改的数据，当然可见\n\n\nDB_TRX_ID &lt; min_trx_id（比所有活跃事务都早）\n✅ 可见\n该数据在事务开始前已提交\n\n\nmin_trx_id ≤ DB_TRX_ID &lt; max_trx_id，且 DB_TRX_ID ∉ m_ids（已提交事务）\n✅ 可见\n该事务已提交，数据可见\n\n\nDB_TRX_ID ≥ max_trx_id 或 DB_TRX_ID ∈ m_ids（未提交或之后的事务）\n❌ 不可见\n该事务还未提交，或比当前事务晚，数据不可见\n\n\n\n✅ 如果当前版本不可见，就通过 DB_ROLL_PTR 找到更早的版本，继续判断，直到找到一个可见的版本为止。\n\n\n\nRead View 是什么时候生成的？\nRead View 是在事务进行“快照读”（如普通 SELECT）时生成的，而不是所有的 SELECT 都会生成。\n具体来说：\n\n对于普通的 SELECT（一致性非锁定读，快照读）：会生成一个 Read View，根据该视图去读取符合条件的“历史版本数据”。\n对于加锁的 SELECT（如 SELECT … FOR UPDATE &#x2F; LOCK IN SHARE MODE）：属于当前读（锁定读），不会使用 MVCC，而是直接读最新的数据，并加锁。\n\n\n\n在 RC（读已提交）和 RR（可重复读）级别下，Read View 的生成时机有什么不同？\n\n\n隔离级别\nRead View 生成时机\n说明\n\n\n\nRC（Read Committed，读已提交）\n每次执行快照读（普通 SELECT）时都会生成一个新的 Read View\n因此每次读都基于当前最新已提交的数据，可能读到其他事务已提交的新数据，导致不可重复读。\n\n\nRR（Repeatable Read，可重复读）\n仅在事务中第一次执行快照读时生成一个 Read View，后续复用该 View\n因此在整个事务中，读到的数据都是基于事务开始时（或第一次读时）的快照，保证多次读取结果一致，解决不可重复读。\n\n\nMySQL 的 RR 级别解决了幻读问题吗？\nRR 级别是否解决了幻读？\n答案是：MySQL 的 RR 级别，通过 MVCC + Gap Lock &#x2F; Next-Key Lock 的组合，实际上已经解决了幻读问题！\n但是要注意：\n\n单纯依靠 MVCC（多版本控制）是无法解决幻读的！\n真正解决幻读，靠的是 InnoDB 的锁机制：Gap Lock（间隙锁）和 Next-Key Lock（临键锁）！\n\n\n\nInnoDB 如何通过锁解决幻读？\n在 RR 级别下，InnoDB 对于范围查询会使用：\n\nNext-Key Lock &#x3D; Record Lock（记录锁） + Gap Lock（间隙锁）\n\n\nRecord Lock（记录锁）：\n\n锁住索引记录本身，比如某条 id&#x3D;10 的记录。\n\nGap Lock（间隙锁）：\n\n锁住索引记录之间的间隙，防止其他事务在这个间隙中插入新的数据。\n\nNext-Key Lock：\n\n是两者的组合，既锁住记录本身，也锁住该记录前面的间隙。例如，对索引范围 (5, 10] 加 Next-Key Lock，意味着：\n\n锁住了索引值 10 这条记录（Record Lock）\n同时锁住了 (5, 10) 这个区间，防止插入 id&#x3D;6~9 的新数据（Gap Lock）\n\n\n\n举例说明幻读的避免\n假设表中有 id 为 1, 5, 10 的记录，事务 A 执行：\nSELECT * FROM t WHERE id &gt; 5 AND id &lt; 15 FOR UPDATE;\n\n在 RR 级别下，InnoDB 会对 id &gt;5 且 &lt;15 的范围加上 Next-Key Lock，包括：\n\n记录锁：id&#x3D;10\n间隙锁：(5,10), (10,15)\n\n此时，如果另一个事务 B 尝试：\nINSERT INTO t (id) VALUES (7);   -- 会被阻塞，因为 (5,10) 被锁INSERT INTO t (id) VALUES (12);  -- 会被阻塞，因为 (10,15) 被锁\n\n这样就防止了其他事务插入“幻影行”，从而避免了幻读。\n\n\n索引覆盖是什么\n索引覆盖：指的是当查询所需的所有列都包含在索引中时，数据库可以直接从索引中获取所需数据，而无需回表查询数据行。\n索引覆盖的工作原理\n普通查询流程（无索引覆盖）\n通过索引定位数据：使用索引找到满足条件的行位置（如主键值）\n回表查询：根据索引提供的位置信息，再到数据表（聚簇索引）中查找完整的行数据\n返回结果：从完整行数据中提取所需的列\n这个过程需要两次查找操作：一次在索引上，一次在数据表上。\n\n\n\n\n索引覆盖查询流程\n通过索引定位数据：使用索引找到满足条件的行\n直接从索引获取数据：因为所需的所有列都包含在索引中，直接从索引结构中提取数据\n返回结果：无需访问数据表\n这个过程只需要一次查找操作，且数据来源是更轻量的索引结构。\n\n\n\n\n\n\n\nExplain\n是什么\n\nEXPLAIN 是 MySQL 提供的一个 SQL 命令，用于显示 MySQL 如何执行 SQL 语句的执行计划。通过 EXPLAIN，你可以看到查询优化器选择的执行路径、使用的索引、连接类型、数据读取方式等关键信息。\n\n\n作用\n\n分析查询性能瓶颈\n查看索引使用情况\n理解查询执行策略\n优化 SQL 语句\n预测查询性能\n\n\nexplain的基础列详解\n\n\n\n\n列名\n数据类型\n说明\n重要解读\n\n\n\nid\nint\nSELECT 查询的标识符\n表示查询中 SELECT 语句的执行顺序。id相同，执行顺序从上往下；id不同，数值越大越先执行\n\n\nselect_type\nvarchar\n查询类型\n表明查询是简单查询还是复杂查询，如 SIMPLE(简单SELECT)、PRIMARY(最外层SELECT)、SUBQUERY(子查询)、DERIVED(派生表)等\n\n\ntable\nvarchar\n访问的表名\n显示这一行数据是关于哪张表的，可能是表名、别名、派生表或临时表\n\n\npartitions\nvarchar\n匹配的分区\n对于分区表，显示查询访问了哪些分区，非分区表通常为NULL\n\n\ntype\nvarchar\n访问类型\n查询性能关键指标，表示MySQL在表中找到所需行的方式，从好到坏：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL\n\n\npossible_keys\nvarchar\n可能使用的索引\n查询优化器可能考虑使用哪些索引来查找表中的行，但不一定实际使用，若为NULL表示没有可用索引\n\n\nkey\nvarchar\n实际使用的索引\n查询优化器实际选择的索引，若为NULL则表示没有使用索引，显示的是索引名称\n\n\nkey_len\nint\n使用的索引长度(字节)\n显示使用的索引字段的长度，可以帮助判断使用了索引的哪些部分，数值越小通常越好\n\n\nref\nvarchar\n索引参考列\n显示索引的哪一列被使用了，或者常量值，如 const、func、NULL 或列名\n\n\nrows\nint\n预估扫描行数\n查询性能关键指标，MySQL估计为了找到所需的行而要读取的行数，数值越小越好，是优化器估算值\n\n\nfiltered\ndecimal(5,2)\n过滤百分比\n存储引擎返回的数据在server层过滤后，还剩余多少比例(百分比)，值越高越好，MySQL 5.7+引入\n\n\nExtra\nvarchar\n额外信息\n查询性能关键信息，包含不适合在其他列中显示但十分重要的额外信息，如 Using index、Using where、Using temporary 等\n\n\n\n\n\n\n最左前缀原则\n是什么\n最左前缀原则指的是：对于复合索引（包含多个列的索引），查询必须使用索引的最左列（第一个列）才能使用该索引，并且查询条件中的列顺序必须与索引列定义顺序相匹配，从最左边的列开始连续使用。\n换句话说，如果有一个复合索引是 (A, B, C)，那么：\n查询条件必须从A列开始使用并保持相对顺序\n可以使用 \n(A)、(A, B)、(A, B, C)、(A, C)\n\n\n不能使用\n(B, C)、(A, C, B)、(B, A)\n\n\n\n\n\n\n\nMyISAM和InnoDB\nMyISAM和InnoDB是MySQL数据库中两种最重要的存储引擎，它们在架构设计、功能特性和适用场景上有显著区别\n存储引擎（Storage Engine）是MySQL中用于管理数据存储和检索的底层软件组件。它负责数据的存储、读取、索引管理、事务处理等核心功能。MySQL采用插件式架构，允许使用不同的存储引擎来处理不同的表。\nInnoDB是更先进的存储引擎。一般来说，只推荐用InnoDB。\n\n为什么MySQL要用B+树而不用B树\n更低的树高度：B+树通过只在非叶子节点存储索引键，可以容纳更多键值，大大减少树的高度，进而减少磁盘I&#x2F;O次数，提高查询效率\n更高效的范围查询：B+树的叶子节点通过指针连接形成有序链表，使得范围查询（如BETWEEN、&gt;、&lt;）和排序操作（ORDER BY）非常高效\n更高的存储密度：B+树的非叶子节点不存储实际数据，可以存储更多索引键，即更高的扇出，使得每个节点能容纳更多信息，进一步降低树的高度\n更稳定的查询性能：所有查询都必须到达叶子节点，使得查询路径长度完全一致，提供更稳定和可预测的查询性能\n更适合数据库特性：B+树的结构与数据库的读多写少、需要高效范围查询、排序和稳定性能的需求高度契合\n与InnoDB实现完美配合：特别是聚簇索引设计和磁盘页优化，使得B+树在MySQL中能够发挥最大效能\n\nMySQL的锁有哪些\n按锁的粒度分类\n\n\n\n锁类型\n说明\n优点\n缺点\n适用场景\n\n\n\n全局锁\n锁定整个数据库实例\n简单粗暴，保证全局一致性\n性能影响极大，几乎锁住所有操作\n全库备份、全库数据迁移\n\n\n表级锁\n锁定整张表\n实现简单，开销小，加锁快\n并发度低，锁冲突概率高\nMyISAM引擎、DDL操作、批量数据操作\n\n\n行级锁\n只锁定需要操作的行\n并发度高，冲突概率低\n实现复杂，开销大，加锁慢\nInnoDB引擎、高并发OLTP系统\n\n\n\n按锁的性质分类\n\n\n\n\n\n锁类型\n说明\n特点\n适用场景\n\n\n\n共享锁(S锁，Shared Lock)\n读锁，多个事务可同时持有\n允许其他事务读取，但禁止写入\n读操作、需要数据不被修改的场景\n\n\n排他锁(X锁，Exclusive Lock)\n写锁，一次只能由一个事务持有\n禁止其他事务读取和写入\n写操作、数据修改场景\n\n\n意向锁\n表级锁，表明事务打算在表中的行上获取什么类型的锁\n提高表级锁和行级锁的兼容性判断效率\nInnoDB引擎内部使用\n\n\n\n意向锁是表级锁。当读或写某一行时，会给对应的表加上IS或IX锁。\n\nRedis过期策略\n惰性删除：\n原理：访问某个Key时检查是否过期\n优点：CPU友好，节省了CPU资源\n缺点：大量过期的Key没有被访问，占内存资源\n\n\n定期删除：\n原理：每隔一段时间，扫描一部分Key，删除过期键\n\n\n定时过期：\n原理：给Key设置定时过期删除的属性\n\n\n\n事务实现\n实现流程\n\n事务开始\nMULTI启动事务模式（flag属性打开REDIS_MULTI标识）\n\n\n命令入队\n除了DISCADE,WATCH,EXEC等少数命令会立即执行外，其他命令都是入队。\n入队时会检查语法错误。如果有语法问题，则终止事务（flag属性关闭REDIS_MULTI标识）\n\n\n事务执行\n\n\n\n\n\nACID\n\n原子性如何实现？Redis没有回滚机制，是否破坏了原子性？\n\n我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断\n\n在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性\n\n虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。\n\n并且运行时错误多为编程错误，可以避免。\n\n一致性如何实现？\n\n内部一致性： Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。\n事务隔离性： I 的保证间接支撑了 C，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。\n\n\n隔离性如何实现？\n\nRedis 对隔离性的保证是非常强大的，因为它基于单线程模型。\n保证方式： Redis 使用 单线程 模型处理所有客户端请求（除了后台的持久化操作）。\n结果： MULTI&#x2F;EXEC 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。\n总结： Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离。\n\n\n\n\n持久性如何实现？\n\nRedis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，默认情况下持久性是有风险的。\n\nRedis 主要通过两种方式实现持久性：\n\nAOF (Append Only File) 模式：\n将所有写命令以日志形式追加到文件中。\n如果配置了 always 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。\n但为了性能，通常配置为 everysec（每秒同步一次），这意味着最近一秒内的数据可能会丢失。\n\n\nRDB (Redis Database) 快照模式：\n定期将内存中的数据生成一个二进制快照文件。\n由于是定期快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。\n\n\n\n\n总结： Redis 的持久性是可配置的。只有在启用 AOF 并设置为 always 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。\n\n\n\n\n\n\n\n\n\n持久机制\nRDB，AOF\n\n分布式锁底层怎么实现的\n使用 Redis 的 SET key value NX PX timeout命令，来实现：\n\n互斥性（Mutual Exclusion）：同一时刻只有一个客户端能成功设置锁\n避免死锁：锁必须要有过期时间，防止客户端崩溃后锁永远不释放\n锁的释放必须是原子的且只能由加锁者释放：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁\n\n\n\nRedis集群策略\n主从复制，哨兵模式，集群模式\n\n缓存穿透、缓存击穿、缓存雪崩Redis与MySQL如何保证数据的一致性\n为什么会不一致\n\n在常见的 “先更新数据库，再更新缓存” 或 “先删缓存，再更新数据库” 等策略中，如果操作顺序、并发控制不当，就可能出现以下情况：\n\n\n\n场景\n说明\n结果\n\n\n\n1. 程序 Bug 或异常\n更新了数据库，但忘记更新&#x2F;删除缓存\n缓存是旧数据，与数据库不一致\n\n\n2. 并发读写\n一个线程在更新数据库和缓存的过程中，另一个线程读了旧的缓存或写入了脏数据\n缓存与数据库数据出现偏差\n\n\n3. 崩溃或中断\n在更新数据库和缓存之间服务崩溃，导致两者状态不一致\n缓存和数据库“数据分裂”\n\n\n\n\n\n常用策略\n\n延时双删策略（Double Delete）\n\n为了解决 并发导致的脏数据回填问题，可以采用 双删策略，即在写操作的以下时机删除缓存：\n写操作之前，先删除一次缓存\n更新数据库\n延迟一段时间（如几百毫秒），再删除一次缓存\n\n\n为什么延迟删除？\n因为在更新数据库的过程中，可能有其他线程读了旧数据并回填了缓存，延迟删除可以尽量把这种脏缓存清除掉\n\n\n实现方式：\n可以使用 Java 的 ScheduledExecutorService、Thread.sleep()，或者消息队列延迟消费等方式实现“延迟删除”\n\n\n\n\n✅ 适合对一致性要求稍高一点的业务，但仍有 极小概率的不一致窗口期\n\n\n\n\n\nRedis单线程为什么这么快\n基于内存操作（最重要原因）\n\nRedis 的数据是存储在内存中的，内存的访问速度是纳秒级别（约 100ns），相比磁盘（毫秒级）快几个数量级。\n\n\n操作内存比操作磁盘或数据库快得多，不需要磁盘 I&#x2F;O、不需要复杂的事务日志、不需要锁等待。\n所有的读写操作几乎都是在内存中瞬间完成，这是 Redis 高性能的最核心原因。\n\n\n\n单线程避免了多线程的锁竞争和上下文切换\n\n在多线程模型中，多个线程访问共享数据时需要加锁（如互斥锁、读写锁），这会带来：\n锁竞争\n线程切换开销\n死锁风险\n编程复杂度高\n\n\nRedis 采用单线程模型，所有命令串行执行，无需考虑并发安全问题，没有锁竞争，也没有线程切换的开销，所以执行效率极高。\n\n\n✅ 单线程 &#x3D; 无锁 &#x3D; 无竞争 &#x3D; 更简单、更高效\n\n\n\n优秀的数据结构与高性能底层实现\nRedis 提供了多种高效的数据结构（如 String、Hash、List、Set、ZSet 等），并且这些数据结构在底层使用了非常高效的实现方式，比如：\n\nziplist、quicklist、哈希表优化、跳表（SkipList）等\n所有数据结构的操作都经过高度优化，使得命令执行非常快速\n\n\n\nI&#x2F;O 多路复用模型（核心网络模型）\n\nRedis 使用了 I&#x2F;O 多路复用技术（如 epoll、kqueue、select） 来处理大量的并发连接，这是它支撑高并发的关键。\n\n什么是 I&#x2F;O 多路复用？\n\n允许 一个线程同时监听多个 Socket 连接 的读写事件\n\n当某个连接有数据可读&#x2F;可写时，Redis 才去处理这个连接\n\n避免了为每个连接创建一个线程，极大节省了系统资源\n\n\n\n\n\n✅ Redis 通过 单线程 + I&#x2F;O 多路复用，就能高效处理数万甚至数十万的并发连接，而不会线程爆炸。\n\n\n\nRedis 命令执行是原子性的，无需额外同步\n\n每个 Redis 命令都是原子操作，比如 INCR、LPUSH 等，执行过程中不会被其他命令打断。\n因为是单线程，所以也不需要加锁来保证原子性，执行效率高，逻辑简单。\n\n\n\nRedis 是专门为高性能场景设计的网络存储中间件\n\nRedis 的代码是用 C 语言编写的，非常接近底层，运行效率极高\n没有复杂的企业级框架、没有冗余的中间层，整个系统非常轻量、高效\n\n\n\n\n\n\n优点\n说明\n\n\n\n✅ 基于内存，读写极快\n数据在内存中，访问速度是纳秒级\n\n\n✅ 单线程，无锁，无竞争\n不需要考虑并发安全，没有锁开销，执行路径简单\n\n\n✅ I&#x2F;O 多路复用，高并发支持好\n单线程可处理几万甚至几十万的并发连接\n\n\n✅ 命令执行是原子的\n无需加锁，执行效率高\n\n\n✅ 代码精简高效\nC 语言实现，无复杂框架，运行效率高\n\n\n✅ 扩展性强（Redis 6.0+ 多线程 I&#x2F;O）\n网络读写利用多核，进一步提升性能\n\n\n\n\n\n局限性\n说明\n\n\n\n❌ CPU 密集型任务可能阻塞\n如果某个命令执行特别耗时（如 KEYS *、大 Key 操作、复杂 Lua 脚本），会阻塞整个主线程，影响其他请求\n\n\n❌ 无法充分利用多核 CPU（命令执行层面）\n命令执行仍然是单线程的，不能发挥多核优势（但网络 I&#x2F;O 可以，Redis 6.0+）\n\n\n❌ 对单个大 Key 或慢查询敏感\n一个慢命令可能拖慢整个服务\n\n\n网络TCP的三次握手和四次挥手\n三次握手\n\n确保客户端和服务器双方的 发送和接收能力正常，并 同步双方的初始序列号（ISN, Initial Sequence Number），为后续可靠数据传输做准备。\n\n\n\n\n\n步骤\n方向\n消息类型\n说明\n\n\n\n1\nA → B\nSYN &#x3D; 1, seq &#x3D; x\n客户端向服务端发起连接请求，随机生成一个初始序列号 x，表示“我想和你建立连接”。\n\n\n2\nB → A\nSYN &#x3D; 1, ACK &#x3D; 1, seq &#x3D; y, ack &#x3D; x + 1\n服务端收到请求后，同意建立连接，也随机生成一个初始序列号 y，并确认客户端的序号 x+1（ACK &#x3D; x + 1）。\n\n\n3\nA → B\nACK &#x3D; 1, seq &#x3D; x + 1, ack &#x3D; y + 1\n客户端收到服务端的同意后，再发送一个确认报文，确认服务端的序号 y+1。此时连接建立成功。\n\n\n\n\n\n四次挥手\n\n由于 TCP 是全双工的（即双方可以同时发送和接收数据），因此每个方向上的数据传输都需要单独关闭，所以需要四次挥手来确保双方都完成数据发送并安全关闭连接。\n\n\n\n\n\n步骤\n方向\n消息类型\n说明\n\n\n\n1\nA → B\nFIN &#x3D; 1, seq &#x3D; u\n客户端 A 发送 FIN 报文，表示“我不再发送数据了，但还可以接收”。进入 FIN_WAIT_1 状态。\n\n\n2\nB → A\nACK &#x3D; 1, ack &#x3D; u + 1\n服务端 B 收到后，发送 ACK 确认，表示“我知道你不想发了，但我可能还有数据要发给你”。A 进入 FIN_WAIT_2。\n\n\n3\nB → A\nFIN &#x3D; 1, seq &#x3D; v\n服务端 B 处理完剩余数据后，也发送 FIN 报文，表示“我也不再发送数据了”。进入 LAST_ACK 状态。\n\n\n4\nA → B\nACK &#x3D; 1, ack &#x3D; v + 1\n客户端 A 收到后，发送最后的 ACK 确认。B 收到后关闭连接。A 等待一段时间（2MSL）后也关闭连接。\n\n\n\n\n\n\n浏览器发出一个请求到收到响应经历了那些过程\nURL 解析\nDNS 查询（域名 → IP 地址）\n建立 TCP 连接（三次握手）\n如果是 HTTPS，进行 TLS 握手（加密通道建立）\n发送 HTTP 请求（浏览器 → 服务器）\n服务器处理请求并返回 HTTP 响应\n浏览器解析 HTML 内容\n请求并加载外部资源\n页面渲染与显示\n\n跨域请求是什么？有什么问题？怎么解决？\n是什么\n\n跨域请求：当前网页的域名、协议、端口中的任意一个与请求的目标资源不一致，导致浏览器出于安全考虑阻止该请求。\n\n什么是“同源”？\n\n两个 URL 如果满足以下 三者完全相同，就属于同源（Same Origin），否则就是跨域（Cross-Origin）：\n\n\n\n\n组成部分\n是否必须相同\n示例\n\n\n\n协议（Protocol）\n✅ 必须相同\nhttpvs https就不同源\n\n\n域名（Host）\n✅ 必须相同\nwww.example.comvs api.example.com不同源\n\n\n端口（Port）\n✅ 必须相同\n80（HTTP默认） vs 443（HTTPS默认） 或 8080不同源\n\n\n\n用一个场景来理解\n\n场景 1：前端和后端运行在不同的端口（开发时最常见！）\n\n你用 React &#x2F; Vue 写了一个前端项目，运行在：http://localhost:3000（前端页面）\n你的 后端 API 服务（比如 Node.js、Java Spring、Python Django）运行在：http://localhost:8080或 http://localhost:3001\n\n\n你前端代码中发起请求：\nfetch(&#x27;http://localhost:8080/api/data&#x27;)\n\n会发生什么？\n\n请求确实发到了后端（你可以在后端看到请求日志），\n但浏览器收到响应后一看：“咦？你前端是 localhost:3000，却去访问 localhost:8080，端口不同，属于跨域！”\n于是浏览器就把响应拦下来了，你的 JavaScript 拿不到返回的数据！\n\n\n\n\n\n\n有什么问题？举个例子\n\n怎么解决\n\nCORS（跨域资源共享，主流推荐方案）\n\nCORS（Cross-Origin Resource Sharing） 是 W3C 标准，通过后端设置一些 HTTP 响应头，告诉浏览器：“这个跨域请求我是允许的”。\n后端需要设置的常见响应头：\n\n\n\n\nHeader\n说明\n\n\n\nAccess-Control-Allow-Origin: *或 http://your-frontend-domain.com\n表示允许哪些来源的网站访问资源。 *表示允许所有（不推荐在生产用，尤其带 Cookie 时） 最好明确指定域名，如 http://localhost:3000\n\n\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\n允许的 HTTP 方法\n\n\nAccess-Control-Allow-Headers: Content-Type, Authorization\n允许的请求头\n\n\nAccess-Control-Allow-Credentials: true\n是否允许发送 Cookie（需前端也设置 withCredentials: true）\n\n\n\n后端示例（以 Node.js&#x2F;Express 为例）：\n\napp.use((req, res, next) =&gt; &#123;  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:3000&quot;); // 或 *  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Authorization&quot;);  res.header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // 如需传 cookie  next();&#125;);\n\n\n✅ 只要后端正确配置了 CORS 头，浏览器就允许跨域请求！\n\n\n代理服务器（Proxy）【开发常用】\n\n在开发环境中，前端代码和后端 API 往往不在一个域，但你可以：\n\n通过 webpack devServer、vite、nginx 等设置代理，将前端发出的请求转发到目标 API 服务器，从而避免浏览器直接跨域\n反向代理的核心作用就是：让前端和后端都使用同一个域名和端口（比如 http://localhost:3000或 https://www.yoursite.com），让浏览器认为它访问的就是同源的资源，从而避免跨域问题。\n\n\n例子：Vue&#x2F;React 开发时配置代理（以 vite &#x2F; webpack 为例）\nvite.config.js 或 webpack.config.js 中配置代理：\n\n\n// vite.config.jsexport default defineConfig(&#123;  server: &#123;    proxy: &#123;      &#x27;/api&#x27;: &#123;        target: &#x27;http://backend-api-server.com&#x27;, // 后端真实地址        changeOrigin: true,        rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;),      &#125;,    &#125;,  &#125;,&#125;);\n\n这样，前端代码中请求：\nfetch(&#x27;/api/user&#x27;)  // 不是跨域！代理服务器会转发到 http://backend-api-server.com/user\n\n优点：前端无需关心跨域，由代理服务器解决\n\n\n\n\n\n\n\n代理在讲 反向代理 之前，先简单了解一下什么是 代理（Proxy）。\n\n正向代理（Forward Proxy）\n\n正向代理 是位于 客户端（用户） 和 互联网 之间的代理，代表客户端去访问服务器。\n\n常见用途：\n\n访问被墙的网站（比如通过代理服务器访问 Google）\n\n隐藏客户端的真实 IP\n\n企业内网上网控制\n\n\n\n谁用代理：客户端（用户）主动设置代理\n\n举例：\n\n你（客户端）想访问某个网站，但不想直接暴露自己，于是你通过一个代理服务器去访问，代理帮你请求网站，再将结果返回给你。\n\n\n\n\n反向代理（Reverse Proxy）\n\n反向代理：是位于 客户端（用户） 和 后端服务器（如你的应用服务器） 之间的代理，代表服务器接收客户端的请求，并将其转发给内部的服务器。\n\n常见用途：\n\n保护后端服务，隐藏其真实 IP 和端口\n\n实现 负载均衡\n\n提供 统一入口（比如通过域名访问多个服务）\n\n处理 SSL&#x2F;TLS 加密（HTTPS）\n\n缓存、压缩、静态文件服务\n\n实现 反向代理路由（如根据路径转发到不同后端）\n\n\n\n谁用代理：是服务器端设置的，对客户端透明（不可见）\n\n意义\n\n隐藏后端服务的真实 IP 和端口\n\n用户只访问 https://www.yourdomain.com，不知道后端是运行在哪个端口或机器上的。\n提升安全性，避免直接将后端服务暴露在公网。\n\n\n统一入口，多服务路由\n\n\n\n你可以用 Nginx 将不同的请求路径转发到不同的后端服务，比如：/api→ Node.js 后端/admin→ Java 后台/static→ Nginx 直接返回静态文件\n\n\n负载均衡\n\n\n将请求分发到多个后端实例，提高系统的可用性和性能，比如：\nupstream backend &#123;    server 127.0.0.1:3000;    server 127.0.0.1:3001;&#125;\n\n\n处理 HTTPS &#x2F; SSL 加密\n\n\n你可以通过 Nginx 配置 SSL 证书，让用户通过 https://安全访问，而不用在后端服务里处理复杂的 HTTPS 配置。\n\n\n静态资源服务\n\n\nNginx 非常擅长快速返回 HTML、CSS、JS、图片等静态文件，比 Node.js 或 Java 服务效率更高。\n\n\n缓存、压缩、安全防护等高级功能\n\n\nNginx 还提供访问控制、防爬虫、GZIP 压缩、缓存、限流等能力。\n\n\n\n\n\n零拷贝\n为什么要了解零拷贝\n在传统的数据传输过程中，数据通常需要在 内存、CPU、内核缓冲区、用户缓冲区、网卡缓冲区 等多个地方多次 拷贝，并且伴随着多次 CPU 上下文切换，这样会带来很大的 性能开销。\n而 零拷贝技术的核心目标就是：尽可能减少数据在内存中的拷贝次数，避免不必要的 CPU 拷贝和上下文切换，从而提升数据传输效率，降低延迟和 CPU 占用。\n\n\n什么是零拷贝\n零拷贝的核心思想是：\n尽量减少甚至避免数据在内存中的冗余拷贝，尤其是避免数据在 用户态 和 内核态 之间的 CPU 拷贝，从而提升性能\n它并不一定意味着 完全没有数据拷贝（物理上可能还是会有 DMA 拷贝），而是 尽量减少 CPU 参与的拷贝次数，尤其是用户态与内核态之间的拷贝。\n\n\n\n\n\n\n","categories":["技术"]},{"title":"PA实验课笔记","url":"/2024/12/04/PA%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%AC%94%E8%AE%B0/","content":"第一章 · C语言拾遗基础知识\n宏（#define）和引用(#include)的本质是复制粘贴。在预编译的时候会把目标文件或宏定义粘贴到对应位置。\n堆栈：在一个程序的进程空间中，栈是由高地址向低地址生长，堆则是由低向高。\n从下往上的相对位置为：代码区，数据区，堆，栈\n\n编译源文件.c —预编译(-E)—&gt; .i —编译(-S)—&gt; .s —汇编(-c)—&gt; .o —链接—&gt; .out\n\n预编译：预编译的时候会把引用的目标文件和宏定义粘贴到对应位置。\n链接：你的一些函数的实现在其他文件中，编译时找不到函数定义的入口，故用0来占位。链接之后把多个文件拼接成了.out文件，并把地址的偏移量填入，此过程称为重定位。这种方法是静态连接。\n动态链接的理解：如果我有多个进程，每个进程都要调用同一个函数，如果用静态连接的话，每一次都要把他写入ELF中，占用资源。动态链接就把函数放在了一个lib文件中，每次调用时调用其指向的函数即可。\n\n\nELF文件：\n\n汇编语言指令\nmov：它的作用是将数据从源操作数复制到目的操作数。\n\n后缀：\n\nmovb 代表字节（8 位）\nmovw 代表字（16 位）\nmovl 代表双字（32 位，long）\nmovq 代表四字（64 位，quad）\n\n\n例子：\n\nmovl $10, %eax    ; 将立即数 10 加载到寄存器 eax\nmovl %eax, -4(%rbp) ; 将 eax 的值存入栈中的偏移 -4 的位置\n\n\n\n\npush：将数据压入栈。\n\npop：从栈中弹出数据。\n\ncmp：比较两个操作数。\n\nje：如果相等则跳转（zero flag 为 1）\n\njg：如果大于则跳转。\n\ncall：调用子程序\n\nret：从子程序返回。\n\nnop：无操作，通常用于占位或对齐。\n\nint：调用中断，用于系统调用等操作。\n\n\n特殊变量名\nrbg：基址指针（Base Pointer）\n\nedi：默认为函数的第一个参数\n\n寄存器层次结构\n在 x86 架构中，寄存器分为不同的宽度，以处理不同位数的数据。\n\nRAX 是 64 位寄存器。\nEAX 是 RAX 的低 32 位。\nAX 是 EAX 的低 16 位。\nAH 和 AL 分别是 AX 的高 8 位和低 8 位\n\n\n\n第二章 ·git指令\n符号”–”表示要把后面的参数当作文件名\n\n\n第  章 ·函数调用\n内存空间：\n栈空间\n\n\n反序压栈：反序压栈（reverse stack pushing）通常是指在调用函数时，将参数或局部变量按照从高地址到低地址的顺序压入栈中。这样可以方便地管理函数的参数和返回地址。\n从栈顶开始：首先确定栈指针（sp）的初始位置。\n逆序压入参数：如果函数有多个参数，可以从最后一个参数开始压栈。比如，对于一个接受三个参数的函数，可以按如下顺序压栈：\npush arg3\npush arg2\npush arg1\n\n\n\n\n调用过程：\n反序压栈，压入参数\n返回位置入栈\n\n\n\n","categories":["课业"]},{"title":"C++编程","url":"/2025/12/04/C++%E7%AC%94%E8%AE%B0/","content":"课程内容第一章（C1、C2） · 介绍主流编程范式对比\n面向对象编程（OOP）\n起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言\n核心概念：类&#x2F;对象、继承、多态、垃圾回收\n设计哲学：自底向上程序设计，虚拟过程机制\n\n\n函数式编程（FP）\n理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑\n核心特性：数据不可变性、无副作用、函数一等公民引用透明性：相同输入始终产生相同输出\n应用场景：实时游戏状态管理、高频交易系统\n局限：学习曲线陡峭，调试复杂，不适合状态密集型场景\n\n\n逻辑编程\n代表语言：Prolog\n特点：基于公理、推理规则和查询的自动证明\n经典案例：专家系统诊断、鸡兔同笼问题、斑马逻辑谜题\n\n\n并发编程与泛型编程\n\n\n并发编程：程序分解为可独立运行部分的能力\n泛型编程：通过抽象找到算法实现的共性，提高代码复用性\n\n\n\nC++的独特价值与设计哲学\n核心优势：零开销抽象\n设计原则：\n不用的特性不需要付出代价\n使用的特性无法手工编码得更好\n\n\n硬件访问与抽象的结合：直接映射语言结构到硬件设施\n\n\n与C语言的关系\n超集特性：C++支持C的所有编程技巧\n兼容性：任何C程序都能用C++以基本相同方式编写，具备同等开销\n\n\n当代C++发展\nLLM代码生成工具：介绍了Cursor、Augmentcode、Copilot等主流工具\nBjarne Stroustrup的观点：强调教授现代C++，关注AI代码质量风险\n未来方向：C++26改进异步支持，静态反射等新特性\n\n\n\n第二章（C3、C4） · DataType基本数据类型\nshort型\n\n占2字节\n\n\nint型\n\n无符号整型（uint）类型有溢出回绕机制\n有符号整型(int)的溢出是UB。\n\n\nfloat型\n\n特殊浮点数类型\n\n无穷大（Infinity）：\n\nnumeric_limits&lt;double&gt;::infinity() + numeric_limits&lt;double&gt;::infinity();  // ∞ + ∞ = ∞numeric_limits&lt;double&gt;::infinity() * numeric_limits&lt;double&gt;::infinity();  // ∞ × ∞ = ∞\n\n\n非数（NaN，Not a Number）：\n\n// NaN: 0 11111111 10000000000000000000000numeric_limits&lt;float&gt;::quiet_NaN();                    // 静态NaNnumeric_limits&lt;double&gt;::infinity() / numeric_limits&lt;double&gt;::infinity();  // ∞/∞ = NaNnumeric_limits&lt;float&gt;::infinity() - numeric_limits&lt;float&gt;::infinity();    // ∞-∞ = NaNnumeric_limits&lt;double&gt;::infinity() * 0.0;              // ∞×0 = NaNfloat f = 0.0f / 0.0f;                                // 0/0 = NaNfloat fs = sqrt(-1.0f);                                // √(-1) = NaNfloat fl = log(-1.0f);                                 // ln(-1) = NaN\n\n次正规数\n\n\n\n\n项目\n正规数\n次正规数（非规格化数）\n\n\n\n指数字段\n不为全 0，也不为全 1\n全为 0\n\n\n尾数字段\n隐含前导 1（如 1.xxx…）\n无隐含 1，以 0.xxx… 开头\n\n\n数值范围\n较大，常规浮点数范围\n极小，比最小正规数还小\n\n\n是否支持极小非零值\n否（会下溢为 0）\n是，可表示极小非零值\n\n\n精度\n较高\n相对较低\n\n\n目的\n常规数值表示\n填补零与正规数之间的空隙，支持渐进下溢\n\n\n\n#include &lt;cmath&gt;\nstd::fpclassify(subnormal_num);  // 返回FP_SUBNORMAL\nstd::isnormal(n);                // 检查是否为正规数\n### 类型转换机制1. 静态类型转换（`static_cast&lt;&gt;`）   1. 整型转换有高位截断风险（int转short）   2. 浮点数转换有精度损失.2. 重新解释转换（`reinterpret_cast&lt;&gt;`）   1. 是什么      1. `reinterpret_cast`是 C++ 中的一种 类型强制转换运算符，用于在不改变底层二进制数据的前提下，将一种类型的指针或引用转换为另一种完全不同类型的指针或引用。**它是最“底层”、最“危险”的类型转换之一**，通常用于一些特殊的、与系统底层或硬件相关的编程场景。### 数据序列化（Serialize）1. 序列化是将数据结构或对象状态转换为可以存储或传输的形式（如二进制、文本等），以便之后可以在相同或不同环境中重建数据的过程。2. POD类型   1. 一个类型（或类/结构体）被认为是 POD，通常具备以下特征：      1. 类似 C 的数据结构         1. 没有用户自定义的构造函数、析构函数。         2. 没有虚函数（即没有虚函数表 vtable）。         3. 没有继承关系（不是从其它类继承来的）。         4. 所有成员变量也都是 POD 类型。      2. 支持逐字节拷贝（memcpy 安全）         1. 可以安全地使用 `memcpy`、`memset`等函数对其进行内存操作，不会破坏其内部状态。         2. 可以直接进行二进制读写（比如读写文件、网络传输）。      3. 内存布局是确定且简单的         1. 成员变量的排列顺序和内存布局是明确的，通常与声明顺序一致（尤其是在使用了 `#pragma pack`等对齐控制后）。         2. 没有隐藏的成员（比如虚表指针）。      4. 不是POD的例子         1. ```c++            class Person &#123;            public:                Person() &#123;&#125;                    // 有用户定义的构造函数                virtual ~Person() &#123;&#125;           // 有虚析构函数（隐含虚表）                std::string name;              // 成员是非 POD 类型（std::string）            &#125;;\n\n\n\n\n内存对齐设置：\n\n#pragma pack(push, 1)  // 1字节对齐\nstruct PacketHeader {\n    std::uint32_t packetId;    // 4字节\n    std::uint16_t payloadSize; // 2字节  \n    std::uint8_t flags;        // 1字节\n};  // 总共7字节，无填充\n#pragma pack(pop)\n      2. 通过 `#pragma pack(push, 1)`和 `#pragma pack(pop)`这两个编译器指令，对 `PacketHeader`结构体的内存对齐方式进行了设置。这里设置为按 1 字节对齐，目的是让结构体成员在内存中紧密排列，不存在额外的填充字节。这样做在涉及网络传输或者文件存储时，能够确保数据在不同平台上具有一致性，避免因不同平台的默认内存对齐规则差异导致数据解析错误。### any类型#### 概述1. 特性| 特性                                         | 说明                                                         || :------------------------------------------- | :----------------------------------------------------------- || **类型安全**                                 | 存储任意类型，但取出的时候必须匹配原类型，否则会抛出 `std::bad_any_cast`异常。 || **动态类型**                                 | 可以存储任何可复制（或可移动）构造的类型，不需要提前知道具体类型。 || **不需要模板参数**                           | 不像 `std::vector&lt;T&gt;`需要在编译期指定类型，`std::any`是运行时多态的。 || **支持拷贝和移动语义**                       | 可以拷贝或移动 `std::any`对象，但内部存储的值也会相应拷贝或移动。 || **底层实现通常基于类型擦除（type erasure）** | 一般通过继承、虚函数、模板等技术实现运行时类型信息（RTTI）管理。 |1. 常见用法   1.    2. | 功能 / 用法                  | 方法 / 操作                           | 代码示例                                                     | 说明                                                         |      | :--------------------------- | :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |      | **创建并存储任意类型值**     | 直接赋值                              | `std::any a = 42;` `std::any b = std::string(&quot;Hello&quot;);` `std::any c = 3.14;` | 可存储 `int`、`string`、自定义类等几乎任何类型。             |      | **检查是否有存储值**         | `.has_value()`                        | `if (a.has_value()) &#123; /* 有值 */ &#125;`                          | 返回 `bool`，表示当前 `std::any`是否持有某个对象。           |      | **获取存储的值（类型安全）** | `std::any_cast&lt;T&gt;(any_obj)`           | `int x = std::any_cast&lt;int&gt;(a);` `std::string s = std::any_cast&lt;std::string&gt;(b);` | 必须与存入时的类型 **完全一致**，否则抛出 `std::bad_any_cast`异常。 |      | **安全获取值（避免异常）**   | 先检查 `.type()`再 `any_cast`         | `if (a.type() == typeid(int)) &#123; int x = std::any_cast&lt;int&gt;(a); &#125;` | 推荐做法：先通过 `type()`判断类型，再安全转换。              |      | **获取当前存储值的类型信息** | `.type()`                             | `if (a.type() == typeid(std::string)) &#123; ... &#125;`               | 返回 `std::type_info`，可用于与 `typeid(T)`比较，判断存储了什么类型。 |      | **处理类型转换失败**         | `try / catch`捕获 `std::bad_any_cast` | `&lt;br&gt;try &#123;&lt;br&gt;    auto s = std::any_cast&lt;std::string&gt;(a);&lt;br&gt;&#125; catch (const std::bad_any_cast&amp; e) &#123;&lt;br&gt;    std::cerr &lt;&lt; &quot;转换失败: &quot; &lt;&lt; e.what();&lt;br&gt;&#125;&lt;br&gt;` | 当 `any_cast`的类型不匹配时，会抛出此异常。                  |      | **移动语义支持**             | 移动构造 / 赋值                       | `std::any a = std::string(&quot;Hi&quot;);` `std::any b = std::move(a);` | 支持移动构造和移动赋值，避免不必要的拷贝（特别是大对象）。   |      | **清空 / 重置 any 对象**     | 赋值为 `std::any()`或赋新值           | `a = std::any();`或 `a = 42;`（覆盖）                        | 将其置为空状态（无值），或直接覆盖为新值。                   |      | **判断存储类型是否为某类型** | `type() == typeid(T)`                 | `if (a.type() == typeid(double)) &#123; ... &#125;`                    | 用于在运行时判断当前 `any`中存储的对象类型。                 |3. 注意事项   1. 不要滥用 `std::any`，**如果能用模板、具体类型、`std::variant`，优先考虑它们**，因为它们更高效、更安全。   2. 存储引用需谨慎（一般不推荐），建议存储值或智能指针。   3. 有性能开销，适用于灵活性优先、性能要求不极致的场景。#### any的底层数据结构`std::any`的内部实现通常包含如下两个关键成员（或类似结构）：```c++struct any &#123;    using _Handler = ...;  // 函数指针类型，用于管理对象的生命周期、拷贝、移动等    _Handler _h_;          // 管理函数指针（存储了针对当前类型T的处理逻辑）    union Storage &#123;        // 联合体，用于存储对象指针或内联缓冲区        void* ptr;         // 指向堆上分配的对象        __any_imp::__Buffer __buf;  // 内部小对象缓冲区（SSO）    &#125; _s_;                 // 实际存储区域&#125;;\n\n\n\n\n\n\n\n\nstd::any内部通常由两部分构成：\n\n_Handler _h_：一个函数指针（或函数对象），负责管理当前存储对象的所有操作（构造、析构、拷贝、移动、获取类型信息等）。它本质上是类型擦除的核心，通过函数指针动态分发操作。\n_Storage _s_：一个联合体（union），用于实际存储数据。它可能包含：一个 void* ptr：指向堆上分配的对象（当对象太大，无法放入内部缓冲区时）。一个 __Buffer __buf：内部的小对象缓冲区（通常几个机器字长，用于小对象优化，直接存储对象，避免堆分配）\n\n\n类型擦除与函数指针调度\n什么是类型擦除？\n\n\n类型擦除（Type Erasure）是一种设计技术，它允许我们在运行时处理不同类型的对象，但在编译期不依赖具体类型。std::any通过类型擦除，把不同类型对象的操作（构造、析构、拷贝、移动等）统一封装到一组函数指针中。\n\n\n函数指针类型定义（来自第5张图）：\n\nusing _HandleFuncPtr = void* (*)( _Action act,                                   const any* self,                                   any* other,                                   const std::type_info* info,                                   const std::type_info* fallback );\n\n\n这是一个通用函数指针类型，它接收一个 _Action（表示要执行的操作类型，比如拷贝、析构、获取类型信息等），以及一些上下文参数（比如当前 any对象、目标对象、类型信息等）。\n通过这个函数指针，std::any可以在运行时动态调用与当前存储类型 T 相关的正确操作函数。\n\n\n操作类型枚举（_Action，来自第5张图）：\n\nenum class _Action &#123;    _Destroy,   // 析构当前存储的对象    _Copy,      // 拷贝构造一个新对象    _Move,      // 移动构造一个新对象    _Get,       // 获取存储的对象（类型安全地 cast 出来）    _TypeInfo   // 获取类型信息（std::type_info）&#125;;\n\n\n每当你对 std::any执行某个操作（比如拷贝、析构、获取值），std::any内部的 _Handler函数指针就会被调用，并根据 _Action参数，执行对应的逻辑。\n\n存储策略与小对象优化（SSO）\n什么是小对象优化（SSO）？\n\n对于较小的对象（比如 int、float、小型结构体），std::any不会在堆上分配内存，而是直接将其存储在 any对象内部的**固定大小的缓冲区（__Buffer）**中，这样可以：\n避免堆分配的开销（malloc&#x2F;new）\n提高性能（访问局部性更好）\n减少内存碎片\n\n\n\n\n内部缓冲区：\n\n\nunion Storage &#123;    void* ptr;                        // 指向堆内存（大对象）    __any_imp::__Buffer __buf;        // 内部缓冲区（小对象，SSO）&#125;;\n\n\n如果存储的对象足够小（比如小于等于 3 个机器字长，约 24~32 字节），std::any会直接把对象存到内部的 __buf缓冲区中，不分配堆内存。\n如果对象太大，则会通过 new在堆上分配内存，并将指针存到 ptr中。\n\nunion类型\n是什么\n\n联合体(Union)是C++中的一种特殊数据类型，允许多个成员变量共享同一块内存空间。与结构体(struct)不同，union的所有成员从同一内存地址开始存储。\n\n内存布局原理\n\n0x1000 ┌─────────────┐ ← char b (1字节)\n       │             │\n       │             │ ← int a (4字节)  \n       │             │\n0x1004 ├─────────────┤ ← double c (8字节)\n       │             │\n       │             │\n       │             │\n       │             │\n0x1008 └─────────────┘\n2. Union的技术优势与局限性   1.  技术优势      1. **内存高效**：极大节省存储空间，特别适合嵌入式系统      2. **数据多态**：同一内存块可解释为不同类型数据      3. **硬件接口**：直接映射到硬件寄存器或协议格式      4. **类型转换**：避免reinterpret_cast的显式转换   2. 局限性      1. **类型安全**：缺乏运行时类型检查，容易误用      2. **构造析构**：不能包含需要构造/析构的成员（C++11后放宽）      3. **继承限制**：不能作为基类参与继承体系      4. **维护困难**：需要手动管理当前有效成员   3. 现代C++中的替代方案      1. `std::variant`：类型安全的union替代品      2.  继承多态：面向对象的标准解决方案      3. 模板特化：编译时多态机制### Variant类型#### 概述1. 是什么   1. **类型安全的union**。它可以在同一个内存位置上存储一组预定义类型中的某一个值，但同一时间只能存储其中一个类型。可以把它理解为一个类型安全的、有限选择的“万能盒子”，比如这个盒子只能装 `int`、`double`或 `std::string`中的某一个，但你不能同时装多个，也不能装这三种之外的类型。2. 用法   1. variant 初始状态：默认会初始化为第一个类型（如这里的 `int`）的值初始化   2. 访问错误类型会怎样：如果当前 `variant`不是类型 `T`，调用 `std::get&lt;T&gt;(v)`会抛出异常：`std::bad_variant_access`。   3. 常见使用场景：适用于：JSON 值、配置项、事件携带数据、状态机返回值等需要存储“某一类可能类型”但不确定具体是哪一个的场景。   4. | 功能 / 用法                                | 方法 / 操作                                           | 代码示例                                                     | 说明                                                         |      | :----------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |      | **定义**                                   | `std::variant&lt;T1, T2, ...&gt;`                           | `std::variant&lt;int, double, std::string&gt; v;`                  | 定义一个可以存储 `int`、`double`或 `std::string`中某一个值的变量 `v`，但**同一时间只能存其中一个**。 |      | **赋值**                                   | 直接赋值 `v = value;`                                 | `v = 42;` `v = 3.14;` `v = std::string(&quot;Hello&quot;);`            | 给 `variant`赋一个它支持的类型值，会替换掉当前存储的值。     |      | **检查当前存储的类型（编译期/运行时）**    | `v.index()`                                           | `int idx = v.index();` // 返回当前存储类型在模板参数列表中的索引（从 0 开始） | 比如 `std::variant&lt;int, string&gt;`中，`int`是 0，`string`是 1。 |      | **按类型安全地获取值**                     | `std::get&lt;T&gt;(v)`                                      | `int x = std::get&lt;int&gt;(v);` `std::string s = std::get&lt;std::string&gt;(v);` | 获取当前存储的值，但 **必须类型完全匹配**，否则抛出 `std::bad_variant_access`异常。 |      | **安全地按类型获取值**                     | `std::get_if&lt;T&gt;(&amp;v)`                                  | `if (auto p = std::get_if&lt;int&gt;(&amp;v)) &#123; /* 使用 *p */ &#125;`       | 如果当前存储的是类型 `T`，则返回指向该值的指针，否则返回 `nullptr`，更安全。 |      | **安全访问所有可能类型）**                 | `std::visit(visitor, v)`                              | `&lt;br&gt;std::visit([](auto&amp;&amp; arg) &#123;&lt;br&gt;    using T = decltype(arg);&lt;br&gt;    if constexpr (std::is_same_v&lt;T, int&gt;) &#123; /* int 处理 */ &#125;&lt;br&gt;    else if constexpr (std::is_same_v&lt;T, std::string&gt;) &#123; /* string 处理 */ &#125;&lt;br&gt;&#125;, v);&lt;br&gt;` | 最强大、最通用的方式，通过 **访问者（visitor）** 处理 `variant`当前可能的所有类型，支持编译期多态。 |      | **判断当前存储的是否是某个类型（运行时）** | `v.index() == N`或结合 `std::holds_alternative&lt;T&gt;(v)` | `if (std::holds_alternative&lt;std::string&gt;(v)) &#123; /* 是 string */ &#125;` | `std::holds_alternative&lt;T&gt;(v)`是类型安全的判断，返回 `bool`，表示当前是否存储了类型 `T`。 |3. 和any比较   1. 能用variant就尽量用，因为效率高   2. | 特性             | std::any            | std::variant    |      | :--------------- | :------------------ | :-------------- |      | **类型确定时机** | 运行时检查          | 编译期确定      |      | **类型安全性**   | 运行时类型检查      | 编译期类型检查  |      | **访问开销**     | 函数调用+类型比较   | 直接索引访问    |      | **内存布局**     | 类型擦除+小对象优化 | 联合体+类型标签 |#### variant的内部结构1. **`variant`的内部可以理解为一个 “带索引的联合体（union + index）”**2. 主要包含三个部分：   1. **索引（index）**：一个整数（通常是 `unsigned int`），表示当前存储的是联合体中的哪个类型（比如 0 表示 `int`，1 表示 `double`，2 表示 `string`）。   2. **值（value）**：一个联合体（union），实际存储了 `int`/ `double`/ `string`等类型的某一个值。   3. **对齐填充（alignment）**:用填充字节把整个 Variant 填到对齐边界上.![image-20251116162658657](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20251116162658657.png)### 访问者模式（visitor partten）1. 是什么   1. 访问者（Visitor）模式是一种行为型设计模式，它允许你在不改变各元素类的前提下定义作用于这些元素的新操作。2. 下面结合你提供的修正后更清晰的代码片段，一步步拆解**访问者（Visitor）模式**在这段 C++ 代码里的体现与运作逻辑：   1. 整体功能概览      这段代码演示了如何用「访问者模式」来给不同的几何形状（圆形、矩形）**动态地附加“计算面积”这一操作**。核心思路是：把「对元素的操作」从元素类本身抽离出来，放到专门的「访问者（Visitor）」类中；这样既能让元素类保持简洁，又能在不修改元素类的情况下，灵活添加新操作（比如未来再加“绘制形状”“导出 SVG”等）。   2. 代码逐部分解析      1. 先看「抽象元素（Shape）」与「具体元素（Circle、Rectangle）」   ```c++   // --------------------------   // 1. 抽象元素：Shape 基类   // --------------------------   class Shape &#123;   public:       virtual ~Shape() = default;       // 虚析构，保证多态销毁       virtual void accept(ShapeVisitor* visitor) = 0;  // 核心：接受访问者的抽象方法   &#125;;      // --------------------------   // 2. 具体元素：Circle（圆形）   // --------------------------   class Circle : public Shape &#123;   private:       double radius;   public:       Circle(double r) : radius(r) &#123;&#125;          // 构造时传入半径          // 获取半径（供访问者后续计算用）       double getRadius() const &#123; return radius; &#125;            // 实现 accept：把自己（this）交给访问者去“访问”       void accept(ShapeVisitor* visitor) override &#123;             visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Circle*) 方法       &#125;   &#125;;      // --------------------------   // 3. 具体元素：Rectangle（矩形）   // --------------------------   class Rectangle : public Shape &#123;   private:       double width, height;   public:       Rectangle(double w, double h) : width(w), height(h) &#123;&#125;  // 构造时传入宽高          // 获取宽、高（供访问者后续计算用）       double getWidth() const &#123; return width; &#125;          double getHeight() const &#123; return height; &#125;            // 实现 accept：把自己（this）交给访问者去“访问”       void accept(ShapeVisitor* visitor) override &#123;             visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Rectangle*) 方法       &#125;   &#125;;\n\n\n\n\n\n\n设计意图：Shape是所有几何形状的“根”，它只定义了一个抽象方法 accept，用来接收「访问者」。这样不管未来加多少种形状（三角形、椭圆…），都只要继承 Shape并实现 accept即可。\naccept方法的意义：它是「双分派（Double Dispatch）」的关键入口。你可以简单理解成：“我是什么类型的元素” + “你是什么类型的访问者” 这两层信息，共同决定要执行哪一段逻辑。\n\n\n再看「抽象访问者（ShapeVisitor）」与「具体访问者（AreaCalculator）」\n\n// --------------------------// 4. 抽象访问者：ShapeVisitor// --------------------------class ShapeVisitor &#123;public:    virtual ~ShapeVisitor() = default;  // 虚析构，保证多态销毁    // 对圆形的访问接口（纯虚函数，子类必须实现）    virtual void visit(Circle* circle) = 0;      // 对矩形的访问接口（纯虚函数，子类必须实现）    virtual void visit(Rectangle* rectangle) = 0;  &#125;;// --------------------------// 5. 具体访问者：AreaCalculator（面积计算器）// --------------------------class AreaCalculator : public ShapeVisitor &#123;private:    double totalArea = 0.0;  // 累加所有形状的面积public:    // 实现对 Circle 的访问：计算圆形面积并累加    void visit(Circle* circle) override &#123;          double area = 3.14159 * circle-&gt;getRadius() * circle-&gt;getRadius();        std::cout &lt;&lt; &quot;Circle area: &quot; &lt;&lt; area &lt;&lt; std::endl;        totalArea += area;    &#125;    // 实现对 Rectangle 的访问：计算矩形面积并累加    void visit(Rectangle* rectangle) override &#123;          double area = rectangle-&gt;getWidth() * rectangle-&gt;getHeight();        std::cout &lt;&lt; &quot;Rectangle area: &quot; &lt;&lt; area &lt;&lt; std::endl;        totalArea += area;    &#125;    // 对外提供获取总面积的方法    double getTotalArea() const &#123; return totalArea; &#125;&#125;;\n\n\n设计意图：ShapeVisitor定义了「对每种具体元素要执行的操作」的接口（visit(Circle*)、visit(Rectangle*)）。这样以后想加新操作（比如“绘制形状”“导出 JSON”），只需要新增一个继承 ShapeVisitor的类、实现对应的 visit即可，不用碰原来的 Shape及其子类。\nAreaCalculator的职责：它专门干“计算面积”这件事。里面针对 Circle和 Rectangle各自实现了不同的计算逻辑；同时用 totalArea来累加所有形状的面积，最后能通过 getTotalArea()拿到结果。\n\n\n最后看「客户端如何组织 &amp; 执行访问逻辑」\n\nint main() &#123;    // 1. 准备对象结构：装各种 Shape 的容器    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;    // 2. 往容器里塞具体的形状（Circle、Rectangle）    shapes.emplace_back(std::make_unique&lt;Circle&gt;(5.0));     // 半径 5 的圆    shapes.emplace_back(std::make_unique&lt;Rectangle&gt;(4.0, 6.0)); // 宽4 高6 的矩形    // 3. 创建「访问者」实例    AreaCalculator areaCalc;    // 4. 遍历所有形状，让每个形状“接受”访问者    for (auto&amp; shape : shapes) &#123;        shape-&gt;accept(&amp;areaCalc);  // 关键：触发双分派！    &#125;    // 5. 拿到访问者计算的“总面积”    std::cout &lt;&lt; &quot;Total area of all shapes: &quot; &lt;&lt; areaCalc.getTotalArea() &lt;&lt; std::endl;    return 0;&#125;\n\n\n流程解释：\n先创建一个 vector，里面存的是各种 Shape的智能指针（这里用了 unique_ptr管理内存）。\n往这个 vector里分别 emplace_back了 Circle和 Rectangle的实例——这就是所谓的「对象结构」：一组不同类型的元素，统一用基类指针管理。\n新建 AreaCalculator（具体访问者）的实例 areaCalc。\n遍历 shapes里的每一个 Shape，调用它的 accept(&amp;areaCalc)。这时候就会触发「双分派」：\n首先，shape自己会判断自己是 Circle还是 Rectangle，然后调用 visitor-&gt;visit(this)—— 如果是 Circle，就调用 areaCalc.visit(Circle*)；如果是 Rectangle，就调用 areaCalc.visit(Rectangle*)。\n\n\n进入到 visit之后，访问者内部根据元素类型，执行对应的面积计算逻辑，还能累加总面积。\n最后打印出总面积，演示「访问者帮我们完成了跨元素的通用操作」。\n\n\n\n\n访问者模式的核心要点总结\n\n**双分派（Double Dispatch）**第一次分派：由「元素（如 Circle&#x2F;Rectangle）」决定调用哪个 accept方法（多态）。第二次分派：在 accept里调用 visitor-&gt;visit(this)时，又由「访问者（如 AreaCalculator）」决定调用哪个 visit重载（多态）。通过这两次动态绑定，最终执行哪段逻辑，既取决于“元素是什么类型”，也取决于“访问者是什么类型”。\n元素与操作的解耦Shape及其子类只负责“自己是哪种形状、有哪些属性”，完全不关心“要怎么计算面积、怎么绘制”这些操作。所有操作都被收拢到 ShapeVisitor及其子类里。想加新操作？只需要新增 Visitor 子类，不用改任何 Shape代码。\n**符合开闭原则（OCP）**对扩展开放：要新增操作（比如“绘制形状”），只需要写新的 Visitor 类，实现 visit(Circle*)、visit(Rectangle*)… 不用碰原有元素类。对修改封闭：原有的 Shape、Circle、Rectangle… 都不用因为加了新操作而改动。\n\n\n什么时候该用访问者模式？\n\n对象结构稳定，但操作频繁变化：比如游戏里的各种 NPC、道具，它们的类型相对固定，但运营过程中可能不断加“统计战力”“批量强化”“导出清单”等新操作 → 用 Visitor 把操作抽出去，方便扩展。\n需要对复杂对象结构做多种不相关操作：比如编译器的抽象语法树（AST），节点类型很多，但要分别做“语法检查”“代码生成”“优化”等完全不同的操作 → 每个操作写一个 Visitor，遍历 AST 时传入不同 Visitor 即可。\n元素类已经有较多方法，不想再往里面塞新方法：如果直接在 Shape里加 calculateArea()，会让 Shape变得臃肿；用 Visitor 就能把 calculateArea相关逻辑挪到外面，让 Shape保持简洁。\n\n\n\n多返回值  &#x2F; 多输出参数\n这部分内容围绕 C++ 中用于返回或处理多个值的不同技术和工具展开，分别介绍了 元组（tuple）、可选类型（optional） ，核心是解决函数如何优雅地返回多个值、处理可能缺失的值、以及更现代的初始化与解包方式。\n\n元组（tuple）\n是什么\n\nstd::tuple是一个固定大小（编译期确定）、可以存储多个不同类型（异构）数据的模板类，它将多个值“打包”成一个整体对象，便于一起返回、传递或存储。\n\n\n使用场景\n\n函数返回多个值：std::tuple&lt;int, float&gt; calculate();\n组合异构数据：std::tuple&lt;int, std::string, double&gt; user = {1, &quot;Tom&quot;, 3.5};\n\n\n三种解包方式\n1. \n\n\n\n\n方式\n语法\n优点\n缺点\n适用标准\n\n\n\nstd::get&lt;N&gt;(t)\n按索引访问，如 std::get&lt;0&gt;(t)\n精准访问某个位置的值\n需记住索引，类型不匹配编译报错\nC++11 起\n\n\nstd::tie(var1, std::ignore, var2)\n解包到已有变量，可配合 std::ignore\n可选择性接收部分返回值\n需提前定义变量，代码稍显冗长\nC++11 起\n\n\nauto [v1, v2, ...] = t（结构化绑定）\nC++17 最简洁的解包方式\n代码最清晰、可读性最强，自动绑定\n仅限 C++17 及以上\nC++17 起\n\n\n\n\n\n\n可选类型（optional）\nstd::optional&lt;T&gt;是 C++17 标准库引入的一个类型安全的容器类，用于表示一个可能包含某个类型 T的值，也可能不包含任何值（即“空”） 的对象。\n\n示例：\n\n定义\n\n// 示例：根据用户名查找用户 ID，可能找到也可能找不到\nstd::optional&lt;int&gt; findUserID(const std::string&amp; username) {\n    if (username == &quot;Alice&quot;) {\n        return 1001;  // 找到了，返回 ID\n    } else {\n        return std::nullopt;  // 没找到，返回“空”\n    }\n}\n2. 调用   1. ```c++      int main() &#123;          auto idOpt = findUserID(&quot;Alice&quot;);                    if (idOpt.has_value()) &#123;            // 检查是否有值              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; idOpt.value() &lt;&lt; std::endl;          &#125; else &#123;              std::cout &lt;&lt; &quot;未找到该用户&quot; &lt;&lt; std::endl;          &#125;                // 更推荐的简洁方式（C++17 起）：          if (idOpt) &#123;  // 可隐式转换为 bool，判断是否有值              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; *idOpt &lt;&lt; std::endl;  // 用 * 解引用获取值          &#125;                // 提供默认值（如果没找到，返回 -1）          int id = idOpt.value_or(-1);  // 如果没有值，返回 -1，不会抛异常          std::cout &lt;&lt; &quot;用户ID（带默认值）: &quot; &lt;&lt; id &lt;&lt; std::endl;                return 0;      &#125;\n\n\n\n\n\n\n\n第三章（C5） · PointerFuncarray\n多维数组的表示\n\n最常见int a[1][2]\n\n使用类型别名：等价于上面的表示\nusing T = int[2];    T a[1];T* b; // 表示b是一个指向int[2]的指针，即int(*)[2]或int[][2]  \n\n等效于传统写法：\ntypedef int[2] T;  // 等效的 typedef 写法\n\n\n数组升维\n\nvoid main(){\n    int b[1];\n    \n    // 如何把b存给一个需要二维数组的函数呢\n    // 用类型别名\n    using T = int[2];\n    func2( (T*)b );\n}\n\nvoid fnc(int a[][2]){...}\n### 内存管理#### malloc1. 概述   1. `malloc`是 C 标准库（通常是 `&lt;stdlib.h&gt;`或 `&lt;cstdlib&gt;`）提供的一个函数，用于在 程序的**堆（heap）**内存区域上动态分配指定大小的内存块。   2. `malloc`通常会先从进程的堆内存中管理的一块“内存池”里分配，只有当剩余内存不足时，才会向操作系统申请更多的堆内存（通常通过 `brk`或 `mmap`系统调用）   3. `malloc`的返回值：只是地址，内存未初始化！2. 系统调用   `malloc`底层会依赖操作系统的系统调用来真正获取或释放内存，PPT 中提到了两种最常用的系统调用：   - **`brk`**：`brk`是一个比较基础的用于调整进程堆空间（heap）大小的系统调用。简单来说，它会移动进程的 “堆顶指针”（break pointer），从而扩大或缩小堆的空间范围。`malloc`在小内存分配场景下，经常通过调整 `brk`来获得连续的堆内存。   - **`mmap`/`munmap`**：**`mmap`（memory map）可以把一个文件或者其他设备映射到进程的地址空间，也可以直接用来申请一块匿名内存**（不对应任何文件的纯内存区域）。3. 设计原则   1. **减少系统调用**   2. **快速匹配**   3. **减少锁竞争**#### 设计模式RAII1. 概述：RAII（Resource Acquisition Is Initialization，资源获取即初始化）的设计模式，以及如何通过智能指针类来避免内存泄漏。   &gt; 理解：把资源和相关操作封装到对象中，这样就可以利用构造函数和析构函数管理资源，避免内存泄露风险。   &gt;   &gt; 比如智能指针、vector都是RAII设计模式。2. 核心思想：   1. **“谁申请，谁释放”**：资源的生命周期由其所有者（通常是封装资源的对象）管理。   2. **利用栈展开（Stack Unwinding）**：当函数退出（正常返回或异常抛出）时，C++ 会自动调用栈上对象的析构函数。   3. **异常安全**：即使发生异常，资源也能被正确释放，避免泄漏。   4. **零开销抽象**：运行时性能与手动管理相同（无额外动态分配或虚函数调用开销）。3. 理解   1. **传统方式（old_use）—— 存在内存泄漏风险**      ```c++      void old_use(Args a) &#123;          auto q = new Blob(a);  // 在堆上分配内存，返回指针          // ...          if (foo) throw Bad();  // 抛出异常 → 函数提前退出          if (bar) return;       // 正常返回 → 函数提前退出          // ...          delete q;  // 如果前面抛出异常或提前返回，此句不会执行 → 内存泄漏！      &#125;\n\n**问题**：\n\n- 手动管理内存（`new`/`delete`）需要严格匹配，若中途因异常或 `return`提前退出，会导致 `delete`被跳过，引发内存泄漏。\n- 代码复杂且易出错，尤其是多层嵌套的资源管理。\n\n**2. RAII 方式（newer_use）—— 自动管理内存**\n\nvoid newer_use(Args a) &#123;    auto p = int_ptr(new Blob(a));  // 使用智能指针包装资源    // ...    if (foo) throw Bad();  // 异常抛出 → 函数退出时 p 的析构函数自动调用    if (bar) return;       // 提前返回 → 函数退出时 p 的析构函数自动调用    // ...&#125;  // 函数结束时，p 被销毁 → 析构函数自动调用 delete 释放内存\n\n**优势**：\n\n- 无需手动调用 `delete`，资源随对象生命周期自动释放。\n- 即使发生异常或提前返回，析构函数也会被调用，保证内存安全。\n\n**3. 智能指针类 `int_ptr`的实现**\n\nclass int_ptr &#123;public:    // 构造函数：接收裸指针并接管资源    int_ptr(int* p = nullptr) : ptr(p) &#123;&#125;          // 析构函数：释放资源    ~int_ptr() &#123; delete ptr; &#125;          // 重载 -&gt; 操作符：让 int_ptr 对象像指针一样访问成员    int* operator-&gt;() const &#123; return ptr; &#125;          // 重载 * 操作符：让 int_ptr 对象像指针一样解引用    int&amp; operator*() const &#123; return *ptr; &#125;  private:    int* ptr;  // 存储裸指针&#125;;\n\n关键点解析\n\n1. **构造函数 `int_ptr(int\\* p)`**：接收裸指针 `p`并初始化成员变量 `ptr`，完成资源的“获取”。默认参数 `p = nullptr`允许空指针初始化（防止未初始化）。\n2. **析构函数 `~int_ptr()`**：释放 `ptr`指向的内存（`delete ptr`），完成资源的“释放”。当 `int_ptr`对象离开作用域（函数结束、异常抛出等）时，析构函数自动调用。\n3. **操作符重载 `operator-&gt;`和 `operator*`**：**`operator-&gt;`**：返回裸指针 `ptr`，使得 `int_ptr`对象可以通过 `-&gt;`访问指向对象的成员。示例：`p-&gt;someMethod()`等价于 `(p.operator-&gt;())-&gt;someMethod()`。**`operator*`**：返回裸指针解引用的结果（`*ptr`），使得 `int_ptr`对象可以通过 `*`直接访问指向的值。示例：`*p`等价于 `*(p.operator*())`。\n\n为什么需要操作符重载？\n\n- **语法兼容性**：让智能指针的使用方式与原生指针几乎一致，降低学习成本。\n- **封装安全性**：虽然内部持有裸指针，但外部无法直接访问（`ptr`是私有成员），只能通过受控的操作符（`-&gt;`和 `*`）访问资源，防止误操作（如悬垂指针、重复释放等）。\n\n\n\n\n\n智能指针\nauto_ptr\n\n概述\n在前面的介绍中，我们实现了int_ptr，那么为什么不能有其他的智能指针呢？所以有了auto_ptr\n\n\nauto_ptr有什么问题？\n反直觉的拷贝语义：当使用赋值操作符或拷贝构造函数对auto_ptr进行操作时，会发生所有权的转移。\n不适合STL容器：由于auto_ptr的这种非传统的拷贝语义，在STL容器中使用auto_ptr会导致未定义行为。例如，向vector&lt;auto_ptr&lt;int&gt;&gt;中插入元素时，可能会触发容器的重新分配内存，从而导致资源的所有权混乱。\n不支持数组：auto_ptr的析构函数使用delete来释放资源，而不是delete[]，因此不能用于管理动态分配的数组。\n\n\n\n\nunique_ptr\n\n为了改进auto_ptr，增加了以下特性：\n禁止拷贝构造和赋值：unique_ptr通过删除拷贝构造函数和赋值操作符，确保每个资源只有一个所有者，避免了auto_ptr的所有权转移问题。\n移动语义：unique_ptr支持移动构造函数和移动赋值操作符，允许资源所有权的转移，但需要显式使用std::move。\n支持自定义删除器：unique_ptr可以接受自定义的删除器，这使得它能够管理更复杂的资源，如文件句柄、网络连接等。\n\n\n\n\nshared_ptr\n\n核心特性：\n引用计数：shared_ptr内部维护一个“引用计数器”，记录有多少个 shared_ptr实例共同指向同一块资源。当最后一个 shared_ptr被销毁（或其引用计数减到 0）时，才会自动释放资源。\n共享所有权：允许多个 shared_ptr同时拥有对同一资源的控制权，适合多个对象&#x2F;模块需要协作管理同一块内存的场景。\n\n\n注意\n注意事项：\n循环引用：如果两个（或多个）shared_ptr彼此持有对方的指针，就会形成循环引用，导致引用计数永远无法归 0，资源泄漏。这时需要配合 weak_ptr来打破循环。\n\n\n\n\n\n\nweak_ptr\n\n核心特性：\n不增加强引用计数：weak_ptr不会增加 shared_ptr的引用计数，它只“观察”shared_ptr管理的资源，本身并不拥有资源。\n解决循环引用：常与 shared_ptr配合使用，用来打破 shared_ptr之间可能出现的循环引用，防止内存泄漏。\n临时获取资源：可以通过 lock()方法临时获取一个有效的 shared_ptr，如果资源还存在（即原 shared_ptr还没被销毁），则返回一个指向该资源的 shared_ptr；否则返回空。\n\n\n如何配合shared_ptr解决循环引用（以双链表为例）\nnext用shared_ptr，prev用weak_ptr\n\n\n\n\n\nFunction\nc++允许同名函数\n\n执行机制：\n\n函数的执行机制\n建立被调用函数的栈空间\n参数传递\n值传递 (call by value)\n引用传递 (call by reference)\n\n\n保存调用函数的运行状态\n将控制转交被调函数\n\n\n\n\nFunction Call\n\n\n\n\n\n第四章（C6） · Function函数调用\n调用流程\n\n\n\n调用约定\n\n_cdecl1. \n参数传递顺序：从右到左将参数压入堆栈。\n堆栈清理：由调用者（caller）负责清理堆栈。\n支持可变参数函数：比如 printf就是使用 cdecl，因为它需要支持可变数量的参数，只有调用者知道传了多少参数，所以必须由调用者来清理堆栈。\n\n\n_stdcall\n参数传递顺序：也是从右到左将参数压入堆栈。\n堆栈清理：由**被调用函数（callee）**负责清理堆栈。\n不支持可变参数函数：因为只有调用者知道传了几个参数，而被调用者负责清理堆栈，所以在参数数量不固定的情况下无法正确清理。因此，像 printf这样的函数就不能用 stdcall。\n\n\n_fastcall\n参数传递方式：部分或全部参数优先通过寄存器传递（通常是前两个或前三个），其余的仍然通过堆栈传递。\n堆栈清理：通常是 被调用者（callee） 负责清理堆栈（和 stdcall类似），但也有编译器实现不同。\n\n\n_thiscall\n\n\n混合编程\n\n由前面可知，C++允许同名函数，但是C不能，所以二者的符号表不同。如果C++程序想调用C的库函数，需要把函数写为extern &#39;C&#39; void func()\n\n\n内联函数inline\n\n由前面可知，函数调用需要额外的开销，包括参数、返回地址等等的空间，以及指针跳转的时间。对于一个小函数来说，没必要使用函数调用。\n\n优点\n\n减少函数调用的开销，提高程序运行效率\n适用于：\n\n函数体很小（比如只有一两行代码）；\n调用非常频繁（比如在循环中被多次调用）；\n追求极致性能的场景，如嵌入式系统、游戏引擎、高频交易等。\n\n\n\n\n实现方式：编译器把inline函数的代码逻辑复制到调用点。和宏类似，但是有区别。\n\n\n\n\n特性\n宏（Macro）\n内联函数（Inline Function）\n\n\n\n类型安全\n❌ 无类型检查\n✅ 有类型检查，是真正的函数\n\n\n调试支持\n❌ 难以调试\n✅ 可以调试\n\n\n防止副作用\n❌ 容易产生副作用\n✅ 参数只求值一次，更安全\n\n\n代码可读性\n❌ 差\n✅ 好\n\n\n编译器优化\n❌ 无智能优化\n✅ 编译器可以做更多优化\n\n\n🔒 结论：在 C++ 中，应该优先使用内联函数，而不是宏，来实现类似“代码展开”的功能。\n\ninline只能申请内联，最终决定权在编译器\n\n\n\n限制：\n\n不能递归\n没有函数指针\n\n\n\n\n\nFunctional Programming\n两种编程范式的比较\n\nImperative Programming\n把计算看做状态机，通过一系列语句改变状态\n\n\nFunctional Programming\n把计算看做数学函数的求值，避免状态和可变数据\n\n\n\n\n对比的例子\n\n// C++ 示例（命令式风格）\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int sum = 0;\n\n    for (int num : nums) {\n        int squared = num * num;  // 每个数平方\n        sum += squared;           // 累加到总和（修改状态）\n    }\n\n    std::cout &lt;&lt; &quot;Sum of squares: &quot; &lt;&lt; sum &lt;&lt; std::endl;\n    return 0;\n}\n\n   1. 用 **for 循环** 逐步遍历   2. 用 **变量（sum, squared）存储中间状态并不断修改**   3. 强调 **“如何一步步做”**2. ```python   # Python 示例（函数式风格）   nums = [1, 2, 3, 4]      # map: 每个元素平方   squared = map(lambda x: x ** 2, nums)      # reduce: 求和（这里用 sum() 更简单，但为了展示函数组合，可以用 reduce）   from functools import reduce   total = reduce(lambda x, y: x + y, squared)      print(&quot;Sum of squares:&quot;, total)\n\n1. 没有显式循环，通过 **map（映射）、reduce（归约）** 等高阶函数处理数据\n2. 没有中间变量被修改，强调 **数据变换的流水线**\n3. 更接近 **“做什么”** 而非 **“怎么做”**\n\n\n\n\n\n第五章（C7、C8） ·  封装面向对象编程OOP\n为什么要用OO（Non-OO有什么问题）\n非面向对象的实现方式虽然直观，但暴露了内部数据结构，缺乏封装，容易导致错误和安全问题，从而引出为什么要考虑更安全的面向对象方案。\n面向对象可以将数据和行为封装在一起，限制对内部状态的直接访问，提高代码的安全性、可维护性和模块化程度，这是对非OO方案问题的改进。\n封装为类之后，可以通过访问关键字控制权限，可以通过构造函数隐藏信息等等\n\n\n\n\nOO的基本概念\n内容要点：Concepts（概念）：\n程序是由多个对象组成的（Program &#x3D; Object1 + Object2 + …）\n对象包含数据与操作（Data + Operation）\n消息传递本质是函数调用\n类 是对象的模板或蓝图\n\n\nClassify（分类）：\n面向对象（Object-Oriented）：具备封装、继承、多态等完整特性。\n基于对象（Object-Based）：如Ada语言，有对象和封装，但没有继承等高级特性。\n\n\n小结：这张PPT从理论层面解释了什么是OOP，它的基本构建单元是对象与类，并对OOP的不同实现层次进行了分类，帮助理解OOP的范畴与特征。\n\n\n\n类\n类的声明和实现一般是分开的。声明在头文件，实现在源文件\n\n源文件中实现对象方法的例子\n\n// SetDate 的实现：把传入的 y/m/d 分别赋值给成员变量 year/month/day\nvoid TDate::SetDate(int y, int m, int d) {  \n    year = y;\n    month = m;\n    day = d;\n}\n\n// IsLeapYear 的实现：判断是否为闰年的逻辑\nint TDate::IsLeapYear() {  \n    return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);\n}\n   2. 但是有一些短小的函数可以在头文件中**内联**   1. ```c++      class TDate &#123;      public:          inline void SetDate(int y, int m, int d) &#123;                year = y; month = m; day = d;           &#125;          int IsLeapYear() &#123;                return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);           &#125;      private:          int year, month, day;      &#125;;\n\n\n\n\n\n\n类的创建于初始化\n\n在栈上创建:TDate g;这样的写法表示 g是一个值类型的对象，在栈上分配内存，生命周期随作用域结束自动销毁。\n\nDate g;\ng.SetDate(2000, 1, 1);    // 给对象 g 设置日期为 2000-1-1\n// \n2. 在堆上创建：与值对象相对的是指针/引用等方式管理的对象（比如堆上的 `p`）。   1. ```c++      TDate *p = new TDate;      p-&gt;SetDate(2015, 11, 17);  // 给指针 p 所指向的对象设置日期      // （注意：实际项目中要记得用 delete p; 释放内存，避免内存泄漏）\n\n\n\n\n\n\n\n\n模块\n\nfoo.cppm文件\n\nexport module M;import K;export int func(int x) &#123;    return 2 + square(x);&#125;\n\n此代码定义了一个名为 M的模块，导入了模块 K，并导出了一个函数 func，该函数调用 square函数并返回计算结果。\n\nClang 模块相关信息\n模块单元文件扩展名：在 Clang 中，模块单元文件使用 .cppm或 .ixx作为扩展名。\n编译后输出：可导入的 pcm（Precompiled Module）：模块经过预编译后生成的中间文件，便于后续快速导入和使用。可链接的对象文件：包含模块代码的机器码文件，可用于链接生成最终可执行文件。\n编译过程：首先使用 make编译模块 K，因为模块 M依赖于 K，所以需要先编译 K。接着使用 make编译模块 M，此时 K已经编译完成可供其导入。最后使用 make编译其他源文件，如 bar.cpp。\n这种模块化的编程方式有助于组织和管理大型项目的代码，减少编译依赖和重复编译等问题。\n\n\n\n构造函数\n是什么\n\n构造函数是 与类同名、无返回类型（连 void也没有）的特殊成员函数，用于 对象的初始化（如为成员变量赋初值、分配资源等）。它在 创建对象时自动调用，开发者无需显式调用，且 不可手动直接调用（如 obj.构造函数()是错误的）。\n\n\n关键特性\n\n可重载：一个类可以定义多个构造函数（参数列表不同），根据对象创建时的实参匹配对应的构造函数（例如支持无参初始化、带参初始化等场景）。\n\n默认构造函数：若类中 未显式定义任何构造函数，编译系统会自动生成一个 无参数的默认构造函数（即 类名() {}）；但 一旦自定义了任意构造函数（无论是否有参数），编译器就不再提供默认构造函数（需手动补全无参版本，否则 类名 obj;这种无参创建方式会报错）。\n\n访问控制：构造函数可以被定义为 public（默认，允许外部直接创建对象）或 private（限制外部直接创建，常用于 单例模式&#x2F;工厂模式 中接管对象创建逻辑，例如通过静态方法间接生成对象）。\n\n委托构造：允许一个构造函数调用同一个类中的 其他构造函数，从而 复用初始化代码，避免重复逻辑，提高代码可维护性。\n\nclass MyClass {\npublic:\n    // 目标构造函数（真正的初始化逻辑）\n    MyClass(int x, int y) : a(x), b(y) { /* ... */ }\n\n    // 委托构造函数（调用目标构造函数）\n    MyClass(int x) : MyClass(x, 0) {  // ✅ 委托调用\n        // ⬇️ 这里可以写额外的逻辑（函数体）\n        // 但是不允许再初始化成员变量了\n        std::cout &lt;&lt; &quot;委托构造，x = &quot; &lt;&lt; x &lt;&lt; std::endl;\n    }\n    \nprivate:\n    int a;\n    int b;\n};\n3. 构造函数的调用   1. **自动调用场景**      1. 构造函数会在 **对象定义时自动触发**，无需手动干预。第2张图通过 `class A`的三种构造函数（无参 `A()`、带 `int`参数 `A(int i)`、带 `char*`参数 `A(char* p)`）演示了不同对象定义方式对应的构造函数调用逻辑。   2. **典型调用示例与等价写法**      1. `A a1 = A(1);`⇔ `A a1(1);`⇔ `A a1 = 1;`→ 均调用 带 `int`参数的构造函数 `A(int i)`（前两种是显式调用，第三种是**隐式类型转换后调用**）。      2. `A a2 = A();`⇔ `A a2;`→ 调用 无参构造函数 `A()`；但 **`A a2();`是错误写法**！它会被编译器解析为 ****函数声明****（声明了一个返回 `A`类型、无参数的函数 `a2`），而非对象定义。      3. `A a3 = A(&quot;abcd&quot;);`⇔ `A a3(&quot;abcd&quot;);`⇔ `A a3 = &quot;abcd&quot;;`→ 调用 带 `char\\*`参数的构造函数 `A(char\\* p)`（同样存在隐式转换逻辑）。   3. **数组对象的构造**：`A a[4];`→ 定义包含4个 `A`对象的数组，每个元素会自动调用 **无参构造函数 `A()`**（依次初始化 `a[0]`到 `a[3]`）。`A b[5] = &#123; A(), A(1), A(&quot;abcd&quot;), 2, &quot;xyz&quot; &#125;;`→ 初始化5个元素的数组：前3个分别显式调用 `A()`、`A(int i)`、`A(char* p)`；后2个（`2`和 `&quot;xyz&quot;`）会尝试 **隐式转换为 `A`对象**（需类中存在对应的构造函数，例如 `A(int)`或 `A(const char*)`，否则编译报错）。### 成员初始化表1. 定义   1. 成员初始化表（Member Initializer List） 是 构造函数的一部分，位于 **构造函数参数列表之后、函数体之前**，以冒号 `:`开头，后面跟着一系列 **成员变量初始化项**，各初始化项之间用逗号分隔。   2. 语法格式：      ```c++      类名(参数列表) : 成员1(值1), 成员2(值2), ... &#123;          // 构造函数函数体（可选）      &#125;\n\n\n\n\n\n\n核心作用\n\n用于初始化类的数据成员（尤其是那些 不能或不应该在构造函数体内赋值 的成员）。是构造函数的补充（不是替代，但推荐优先使用）。\n\n\n执行顺序\n\n先于构造函数体执行（即成员初始化发生在进入构造函数 { ... }之前）。\n按类中数据成员的声明顺序初始化（不是按初始化表中的书写顺序！）。\n\n\n为什么能“减轻 Compiler 负担”？\n\n如果没有成员初始化表，某些成员（如 const成员、引用成员、没有默认构造函数的类对象成员）必须依赖构造函数体内的赋值语句，但这类成员 无法被赋值（只能初始化），编译器会报错。\n使用成员初始化表 可以 直接初始化这些成员，避免额外的默认构造 + 赋值操作，从而 提高效率并减少编译器的隐式处理负担。\n\n\n典型使用场景\n\n推荐在构造函数中尽量使用成员初始化表取代赋值动作\n\n必须使用成员初始化表的场景\n\n初始化 const成员\n\n\nconst成员变量 必须在声明时或构造函数初始化列表中初始化，不能在构造函数体内赋值（因为 const变量一旦初始化后就不能再修改）。\nclass A &#123;    const int y;public:    A() : y(1) &#123;&#125;  // ✅ 正确：必须在初始化列表中初始化    // A() &#123; y = 1; &#125;  // ❌ 错误：不能在构造函数体内赋值&#125;;\n\n\n初始化引用成员\n\n引用成员 必须在定义时绑定到一个对象，因此 只能在初始化列表中初始化，不能后期赋值。\nclass A &#123;    int&amp; z;  // 引用成员    int x;public:    A(int&amp; ref) : z(ref), x(0) &#123;&#125;  // ✅ 正确：引用必须在初始化列表中绑定    // A(int&amp; ref) &#123; z = ref; &#125;  // ❌ 错误：引用不能在构造函数体内赋值&#125;;\n\n\n初始化没有默认构造函数的对象成员\n\n如果类中包含 其他类的对象成员，且该对象 没有默认构造函数，则必须通过成员初始化表 显式调用其有参构造函数。\nclass B &#123;public:    B(int x) &#123;&#125;  // 没有默认构造函数&#125;;class A &#123;    B b;  // B 没有默认构造函数public:    A() : b(10) &#123;&#125;  // ✅ 必须通过初始化列表调用 B(int)    // A() &#123; b = B(10); &#125;  // ❌ 错误：先默认构造 B（不存在），再赋值（不允许）&#125;;\n\n\n\n\n\n\n\n析构函数\n基本定义\n语法格式：~类名()（例如 ~A()、~String()）。\n作用：在 对象生命周期结束时（消亡时）自动调用，主要用于 释放对象持有的非内存资源（因为内存资源即栈上资源是会自动回收的），如动态分配的内存、文件句柄、网络连接等。\n调用时机：当对象离开其作用域（如局部对象在函数结束时）、被 delete删除（动态对象）、或程序终止时，系统 自动调用析构函数。\n默认是 public（允许对象正常销毁）可显式定义为 private\n\n\n访问控制与特殊用法\n访问权限灵活性\n默认 public：允许对象正常销毁（如局部对象作用域结束、delete动态对象）。\n可定义为 private：\n用途：禁止外部直接调用 delete或对象离开作用域时自动销毁（例如实现单例模式、对象池等）。\n示例：若析构函数为 private，则必须通过类内部的特定方法（如 destroy()）手动控制销毁逻辑。\n\n\n\n\n强制自主控制对象存储分配\n通过将析构函数设为 private并提供自定义销毁方法（如 destroy()），可以实现强制自主控制对象的存储分配与释放（避免依赖自动析构）。\n\n\n\n\n使用场景\n析构函数默认是空实现\n如果在类中有动态分配的内存、文件句柄、网络连接等非内存资源，就必须手动写析构函数。\n\n\n\n拷贝构造函数\n是什么\n\n拷贝构造函数（Copy Constructor） 是一种 特殊的构造函数，用于 用一个已存在的同类对象来初始化一个新对象。\n语法形式：A(const A&amp; a)（参数是对同类对象的 常量引用）。\n\n\n核心特点\n\n自动调用：在特定场景下（如对象初始化、函数传参、返回对象等），编译器会自动调用拷贝构造函数。\n与普通构造函数区分：普通构造函数用于创建新对象，而拷贝构造函数用于 基于已有对象创建新对象。\n\n\n典型调用场景（拷贝构造函数在以下情况会被 自动调用）\n\n对象初始化时用另一个对象赋值：A a; A b = a;\n函数传参时传递对象（按值传递）：f(A a)，调用时传入对象会触发拷贝构造。\n函数返回对象（按值返回）：A f() { A a; return a; }，返回时会调用拷贝构造（可能被编译器优化）。\n\n\n定义拷贝构造\n\n默认拷贝构造函数\n\n如果类未显式定义拷贝构造函数，编译器会自动生成一个默认拷贝构造函数。\n默认行为：逐个成员初始化（member-wise initialization）\n对于 基本类型（如 int、float）：直接复制值。\n对于 对象成员：递归调用其自身的拷贝构造函数（即深层次地依次初始化每个成员对象）。\n\n\n\n\n何时需要自定义拷贝构造函数？\n\n当类中包含指针成员并管理动态内存时，默认拷贝构造函数会导致**“浅拷贝”**问题，进而可能引发 悬挂指针、双重释放等严重错误。\n\n浅拷贝问题示例：默认拷贝构造函数只会 简单复制指针的值（地址），而 不会复制指针指向的实际内存内容。导致多个对象共享同一块动态内存，当其中一个对象析构并释放内存后，其他对象的指针会变成 “悬挂指针”（指向已释放的内存），后续访问会导致程序崩溃。\n\n解决方案：深拷贝\n\n自定义拷贝构造函数，为指针成员分配新的内存，并复制原对象指针指向的内容，从而实现 深拷贝（deep copy）。\n\n示例代码：\nclass string &#123;    char* p;  // 动态分配的字符指针public:    // 自定义拷贝构造函数（深拷贝实现）    string(const string&amp; s) &#123;        p = new char[strlen(s.p) + 1];  // 为新对象分配新内存        strcpy(p, s.p);  // 复制原字符串内容到新内存    &#125;&#125;;\n\n\n效果：string s2 = s1;时，s2的指针 p会指向 新分配的内存，并复制 s1的字符串内容，避免与 s1共享内存，从而防止悬挂指针问题。\n\n\n\n\n\n\n自定义拷贝构造函数的风险\n\n默认拷贝构造函数会自动调用成员对象的拷贝构造函数，这是正确的。\n自定义拷贝构造函数，如果没有主动调用成员对象的拷贝构造函数，可能会触发成员对象的默认构造函数，导致没能复制成员对象。\n\n\n\n\n\n右值引用\n左值（LValue）\n\n定义：具有程序运行时可访问的存储地址的值，通常是变量或具有名称的对象。\n\n示例：\na = 1 + 2;\n\n\n变量 a → 有名字、有内存地址 → 是 左值（Lvalue）\n表达式 1 + 2 → 临时计算结果，没有名字、没有固定存储位置 → 是 右值（Rvalue）\n\n\n\n\n右值\n\n定义：通常是临时值、字面量、表达式结果或临时对象，没有持久的内存地址，一般不能被取地址，也不能出现在赋值语句左边。\n\n示例（第1张图右下角）：\n\nclass A &#123;&#125;;int main() &#123;    A a = A();  // A() 是一个临时对象（构造出的匿名对象）&#125;\n\n\nA() → 是一个临时构造出来的对象，没有变量名，无法直接访问 → 是 右值（Rvalue），图中已用箭头标出。\n\n\n核心特点：只能绑定到右值！ ，为移动语义（Move Semantics）和完美转发奠定基础。\n\n使用示例\n\n右值引用（A&amp;&amp;）绑定到右值（重点！）\nA &amp;&amp;aa = getA();  // ✅ 合法：A&amp;&amp; 是右值引用，getA() 返回临时对象（右值）aa.setVal(2);     // ✅ 可以通过右值引用修改该临时对象（前提是该对象非 const）\n\n\n主要用途（为什么要用右值引用）\n\n实现 移动语义（Move Semantics），通过移动构造函数&#x2F;移动赋值运算符，“窃取”临时对象的资源，避免深拷贝，极大提升程序运行效率。\n\nclass Buffer {\n...\n    // 移动构造函数（使用右值引用 T&amp;&amp;）\n    Buffer(Buffer&amp;&amp; other) noexcept {\n        data = other.data;  // 直接“窃取”资源\n        size = other.size;\n        other.data = nullptr;  // 避免原对象析构时 delete data\n        other.size = 0;\n        std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;\n    }\n...\n};\n\nBuffer createBuffer() {\n    Buffer temp(&quot;Hello from temp!&quot;);\n    return temp;  // 返回临时对象（右值），可触发移动构造\n}\n\nint main() {\n    Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！\n}\n   2. 2. 支持 **std::move**，将左值显式转化为右值，主动触发移动而非拷贝。   1. ```c++      int main() &#123;          BigData a(1000);         // 普通构造          BigData b(std::move(a)); // 显式转为右值，触发移动构造！      &#125;\n\n\n\n\n是 完美转发（Perfect Forwarding） 的基础，用于高效传递参数（尤其在模板和标准库中）。\n\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// 目标函数\nvoid process(int&amp; x) { std::cout &lt;&lt; &quot;处理左值: &quot; &lt;&lt; x &lt;&lt; std::endl; }\nvoid process(int&amp;&amp; x) { std::cout &lt;&lt; &quot;处理右值: &quot; &lt;&lt; x &lt;&lt; std::endl; }\n\n// 模板转发函数\ntemplate&lt;typename T&gt;\nvoid forwarder(T&amp;&amp; arg) {\n    process(std::forward&lt;T&gt;(arg));  // 完美转发：保持左值/右值性质\n}\n\nint main() {\n    int x = 42;\n    forwarder(x);            // 传左值 -&gt; 调用 process(int&amp;)\n    forwarder(123);          // 传右值 -&gt; 调用 process(int&amp;&amp;)\n}\n      4. 优化标准库容器（如 `std::vector`、`std::string`）在插入、扩容、返回值等场景下的性能表现。### 三种引用类型对比| 类型       | 绑定对象   | 是否可修改被引用对象 | 示例 / 说明           | 典型用途                                    || :--------- | :--------- | :------------------- | --------------------- | :------------------------------------------ || 非常量引用 | 左值       | ✅ 能                 | int &amp;ra = a;          | 函数内要修改传入的对象                      || 常量引用   | 左值、右值 | ❌ 不能               | const A &amp;ca = getA(); | 只读访问，避免拷贝（如传参时）              || 右值引用   | 右值       | ✅ 能（通常自己管理） | A &amp;&amp;aa = getA();      | 移动语义、高效资源管理、完美转发（C++11起） |### 移动构造函数| 特性           | 拷贝构造函数（Copy Constructor）           | 移动构造函数（Move Constructor）                     || :------------- | :----------------------------------------- | :--------------------------------------------------- || **语法**       | `A(const A&amp; a)`（常量左值引用）            | `B(B&amp;&amp; b)`（右值引用）                               || **资源操作**   | **复制资源**（如深拷贝动态内存、复制内容） | **转移资源所有权**（如指针指向的资源直接“接管”）     || **适用场景**   | 一般对象初始化、需要独立副本时             | **临时对象、大资源管理（避免深拷贝开销）**           || **性能影响**   | 可能较慢（如深拷贝大内存）                 | **更快（仅转移指针等轻量操作）**                     || **原对象状态** | 原对象保持有效，资源独立                   | **原对象资源被“掏空”（如指针置空），不再管理原资源** |1. 移动构造函数的实现   1. **接收一个右值引用参数（`T&amp;&amp;`）**，表示它只能绑定到临时对象（右值）。   2. **“窃取”源对象（右值）内部的资源（如动态内存指针、文件句柄等）**，而不是重新分配和深拷贝。   3. **将源对象的资源指针“置空”或置为有效但无害的状态**，防止原对象析构时误释放已转移的资源，或产生双重释放。2. 示例   1. ```c++      class Buffer &#123;      ...          // 移动构造函数（使用右值引用 T&amp;&amp;）          Buffer(Buffer&amp;&amp; other) noexcept &#123;              data = other.data;  // 直接“窃取”资源              size = other.size;              other.data = nullptr;  // 避免原对象析构时 delete data              other.size = 0;              std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;          &#125;      ...      &#125;;            Buffer createBuffer() &#123;          Buffer temp(&quot;Hello from temp!&quot;);          return temp;  // 返回临时对象（右值），可触发移动构造      &#125;            int main() &#123;          Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！      &#125;\n\n\n\n\n\n\n\n\n\n动态内存管理\n操作系统内的内存管理\n\n两种类型：栈和堆\n\nC &#x2F; C++对比\n\n\n\n\n操作\nC (malloc/free)\nC++ (new/delete)\n\n\n\n分配内存\nmalloc(sizeof(T))\nnew T\n\n\n释放内存\nfree(ptr)\ndelete ptr\n\n\n调用构造函数&#x2F;析构函数？\n❌ 不调用\n✅ 调用\n\n\n是否类型安全？\n❌ 不安全（返回 void*）\n✅ 类型安全操作\n\n\n\nC 语言：\n\nmalloc()：分配内存\nfree()：释放内存\n⚠️ 不会调用构造函数和析构函数\n\n\nC++ 语言：\n\nnew：分配内存 并调用构造函数\ndelete：释放内存 并调用析构函数\n\n\n\n\n\n\nC++ 动态对象（new&#x2F; delete）\n\n动态对象：在 堆（Heap） 上创建的对象，生命周期由程序员控制。\n\nnew的作用：\n\n分配内存 并调用构造函数（比 malloc更安全）。\n语法：\n\nT* ptr = new T;          // 无参构造T* ptr = new T(args...); // 带参构造\n\ndelete的作用：\n\n释放内存 并调用析构函数（比 free更安全）。\n语法：\n\ndelete ptr;       // 单个对象delete[] ptrArr;  // 对象数组\n\n注意事项：\n\nnew和 delete必须配对（new[]必须对应 delete[]）。\n\n释放后置空指针（ptr = nullptr），避免 悬空指针（Dangling Pointer）。\n\n不要混用 malloc/free和 new/delete（可能导致未定义行为）。\n\n\n\n\n\n动态数组\n\n一维动态数组创建与释放\n\n创建动态数组：\nT* arr = new T[100];  // 100 个 T 对象（调用默认构造函数）\n\n释放动态数组：\ndelete[] arr;  // 必须用 delete[]，否则行为未定义！\n\n关键点：\n\n类必须提供默认构造函数（否则 new T[100]编译失败）。\ndelete[]不能漏掉 []，否则可能只释放第一个对象，导致内存泄漏。\n\n\n\n\n二维动态数组创建与释放\n\n分配方式（分两步）：\n\n分配行指针数组（char**）\n为每一行分配列数组（char*）\n\nconst int ROWS = 3, COLS = 4;char** arr2D = new char*[ROWS];  // 分配行指针for (int i = 0; i &lt; ROWS; i++) &#123;    arr2D[i] = new char[COLS];   // 每行分配列&#125;\n\n释放方式（逆向释放）：\nfor (int i = 0; i &lt; ROWS; i++) &#123;    delete[] arr2D[i];  // 先释放每一行的列&#125;delete[] arr2D;  // 再释放行指针数组\n\n关键点：必须按分配顺序逆向释放（先释放“子数组”）。new[]和 delete[]必须配对，否则内存泄漏。\n\n\n\n\n\n\nconst成员\nconst成员变量\n\nconst成员变量 是类的成员变量，一旦初始化后 不能被修改。\n必须通过构造函数的成员初始化列表（Member Initializer List）进行初始化，不能在构造函数体内直接赋值。\n\nclass A &#123;private:    const int x;  // const 成员变量public:    // 必须通过成员初始化列表初始化 const 成员变量    A(int val) : x(val) &#123;&#125;  // ✅ 正确    // A(int val) &#123; x = val; &#125;  // ❌ 错误！不能在构造函数体内赋值&#125;;\n\nconst成员函数（常量成员函数）\n\n定义\n\nconst成员函数 是 不会修改对象状态 的成员函数，用 const修饰。\n承诺不会修改类的任何非 mutable成员变量。\n可以访问 const和非 const对象，但非 const成员函数只能访问非 const对象。\n\n\n示例\n\n\nclass TDate &#123;private:    int year;public:    int GetYear() const &#123;  // const 成员函数        return year;       // 只能读取，不能修改 year    &#125;    void SetYear(int y) &#123;  // 非 const 成员函数        year = y;          // 可以修改 year    &#125;&#125;;\n\n\n关键点\nconst成员函数不能修改成员变量（除非变量是 mutable）。\n\nconst对象只能调用 const成员函数，非 const对象可以调用所有成员函数。\n\n很好理解，如果const对象可以调用非const函数，就可能间接修改了对象状态。\n\n\nconst成员函数可以重载（例如，GetYear()和 GetYear() const可以同时存在）。\n\n\n\n\n\nmutable（可变成员变量）\n\n定义\n\nmutable 用于修饰 即使在 const成员函数中也可以被修改的成员变量。\n通常用于 缓存、日志、调试计数等不影响对象逻辑状态的变量。\n\n\n示例\n\n\nclass CacheExample &#123;private:    mutable int cacheHits;  // 即使在 const 函数中也可以修改    int data;public:    int GetData() const &#123;        cacheHits++;  // ✅ 允许，因为 cacheHits 是 mutable        return data;    &#125;&#125;;\n\n\n关键点\n\n\nmutable变量可以绕过 const限制，但应谨慎使用（通常用于内部优化）。\n\n\nconst参数（函数参数）\n\n定义\nconst参数 表示 函数内部不会修改该参数。\n可以用于 指针、引用，防止意外修改传入的数据。\n\n\n示例\n\nvoid Print(const std::string&amp; str) &#123;  // str 不会被修改    std::cout &lt;&lt; str &lt;&lt; std::endl;&#125;void Modify(int* const p) &#123;  // p 本身不能改（指针不能指向别的地址），但 *p 可以改    // p = nullptr;  // ❌ 错误！p 是 const 的    *p = 100;  // ✅ 可以修改 *p&#125;\n\n\n关键点\n\nconst T&amp;（常量引用）：避免拷贝，同时防止修改。\n\nconst T*（指向常量的指针）：指针可以改，但指向的数据不能改。\n\nT* const（常量指针）：指针不能改，但指向的数据可以改。\n\n\n\n\n\n\n常量表达式\n是什么\n\n常量表达式 是指 在编译期就能计算出结果的表达式（即不需要等到运行时才计算）。\n\n\n核心优势：更快：因为计算在编译期完成，运行时无需额外开销。更安全：错误（如非法计算、类型不匹配）能在编译期提前暴露，而不是等到运行时崩溃。\n\n两个关键字\n\n\n\n\n概念\n说明\n适用场景\n示例\n\n\n\nconstexpr\n可编译期或运行期求值\n数组大小、模板参数、查表、位运算\nconstexpr int sqr(int x) { return x * x; }\n\n\nconsteval(C++20)\n必须编译期求值，调用点必须为常量\n强制编译期计算\nconsteval int pow2(int n) { return 1 &lt;&lt; n; }\n\n\n\nconstexpr（C++11 起）\n\n定义\n\nconstexpr 表示 该函数或变量可以在编译期求值，但也允许在运行期使用（灵活性更高）。\n适用对象：变量：constexpr int x = 10;（编译期常量）函数：constexpr int sqr(int x) { return x * x; }（若参数是编译期常量，则结果也是编译期常量）\n\n\n特点\n\n可以在编译期或运行期求值（取决于调用时的参数是否为编译期常量）。\n适用于数组大小、模板参数、switch-case标签等需要编译期确定值的场景。\n提升运行时效率（因为很多计算提前到编译期完成）。\n\n\n示例\n\nstruct Point {\n    int x, y;\n    constexpr Point(int xx, int yy) : x(xx), y(yy) { }  // constexpr 构造函数\n};\n\nint main() {\n    constexpr Point origo(0, 0);  // 编译期对象\n    constexpr int z = origo.x;    // 编译期访问成员\n    constexpr Point a[] = {       // 编译期数组\n        Point(0, 0), Point(1, 1), Point(2, 2)\n    };\n    constexpr int x = a[1].x;     // 编译期计算，x = 1\n}\n      2. 3. **`consteval`（C++20 新增）**   1. 定义      - `consteval` 是 C++20 引入的关键字，比 `constexpr`更严格。      - 要求函数必须在编译期执行，并且 调用点必须传入编译期常量，否则 编译报错。      - 适用场景：当你 强制要求某个函数只能在编译期运行（不允许运行期调用）。   2. 特点      1. **只能在函数声明上使用。**      2. **函数调用必须在编译期完成（参数必须是编译期常量）。**      3. **如果调用时传入运行期变量（非编译期常量），则编译报错。**   3. 示例      1. ```c++         constexpr int sqr(int x) &#123; return x * x; &#125;  // 可编译期/运行期求值         constexpr int A = sqr(10);  // ✅ 编译期计算         int y = 3;         int B = sqr(y);  // ✅ 允许（运行期计算）                  consteval int pow2(int n) &#123; return 1 &lt;&lt; n; &#125;  // 必须编译期求值         constexpr int M = pow2(8);  // ✅ 编译期计算（合法）         // int r = pow2(y);  // ❌ 编译报错！y 不是编译期常量\n\n\n\n\n\n\n\n\n\n\n静态成员\n是什么\n\n静态成员属于类本身，而不是某个对象，是 类的所有对象共享的。\n\n\n静态成员变量（Static Member Variables）\n\n定义\n静态成员变量 是类的所有对象 共享的变量，只有一份拷贝，无论创建多少个对象。\n必须要在类外单独定义和初始化（C++17 前），C++17 开始可以用 inline在类内直接初始化。\n\n\n语法\n\nclass A &#123;public:    int x, y;                    // 普通成员变量（每个对象独立一份）    static int shared;           // 静态成员变量声明（类内声明）    &#123;    \t// C++17 支持：    inline static int shared = 0; （类内直接初始化）    &#125;&#125;;// 类外定义并初始化（C++17 前必须这样做）int A::shared = 0;  int main() &#123;    A a, b;  // a 和 b 共享同一个 shared 变量&#125;\n\n静态成员函数\n\n同Java静态函数\n\n特性\n1. \n\n\n\n\n特性\n说明\n\n\n\n只能访问静态成员\n不能直接访问 非静态成员变量&#x2F;函数\n\n\n没有 this指针\n因为它不依赖于某个具体对象\n\n\n可通过类名直接调用\n如 A::f()，无需创建对象\n\n\n遵循类访问控制\n可声明为 public&#x2F; private&#x2F; protected\n\n\n\n\n\n\n\n静态成员的应用\n1. **单例模式**\n\n1. 利用 **静态成员变量（保存唯一实例）** 和 **静态成员函数（获取实例）** 实现。\n\n2. ```c++\n   class Singleton {\n   protected:\n       Singleton() {}  // 构造函数保护，防止外部创建对象\n       Singleton(const Singleton&amp;) = delete;  // 禁止拷贝\n   \n   public:\n       // 获取唯一实例（静态函数）\n       static Singleton* instance() {\n           if (m_instance == nullptr)\n               m_instance = new Singleton();\n           return m_instance;\n       }\n   \n       // 销毁实例（静态函数）\n       static void destroy() {\n           delete m_instance;\n           m_instance = nullptr;\n       }\n   \n   private:\n       static Singleton* m_instance;  // 唯一实例指针\n   };\n   \n   // 类外初始化静态成员\n   Singleton* Singleton::m_instance = nullptr;\n   2. 对象计数1. ```c++           class A &#123;       static int obj_count;  // 静态成员变量，记录对象个数     public:       A() &#123; obj_count++; &#125;          // 构造时 +1       ~A() &#123; obj_count--; &#125;         // 析构时 -1         // 静态函数，返回当前对象数       static int get_num_of_obj() &#123;           return obj_count;       &#125;   &#125;;     // 类外定义静态成员变量   int A::obj_count = 0;     int main() &#123;       A a1, a2;       std::cout &lt;&lt; A::get_num_of_obj();  // 输出 2   &#125;\n    \n    2.\n\n\n\n友元\n是什么\n\nC++ 的封装性 要求类的 私有（private）和保护（protected）成员只能被本类的成员函数访问。\n但有时，某些外部函数或类也需要访问这些私有成员（比如运算符重载、矩阵运算、工具函数等）。\n友元机制 提供了一种 “特殊权限”，允许 指定的外部函数或类访问当前类的私有成员，突破封装限制，但仅限于被声明为友元的部分。\n\n\n使用场景\n\n\n\n\n类型\n说明\n示例（代码片段）\n\n\n\n友元函数（Friend Function）\n一个 普通函数（非成员函数），被声明为某个类的友元后，可以访问该类的 私有（private）和保护（protected）成员\nfriend void func();（在类内声明）\n\n\n友元类（Friend Class）\n一个 类（Class B） 被声明为另一个类（Class A）的友元后，该类的所有成员函数 都可以访问 Class A 的 私有成员\nfriend class B;\n\n\n友元类成员函数（Friend Class Member Function）\n某个特定类（如 Class C）的某个成员函数（如 void f()） 被声明为友元，只有这个函数 可以访问当前类的私有成员\nfriend void C::f();\n\n\n\n\n\n使用方法\n\nclass A {\nprivate:\n    int secret;\npublic:\n    friend void func();             // 友元函数\n    friend class B;                 // 友元类\n    friend void C::f();             // 友元类成员函数（需提前声明 C 和 f）\n};\n4. 重要特性   1. | 特性                 | 说明                                                         |      | :------------------- | :----------------------------------------------------------- |      | **友元不具有传递性** | 如果 A 是 B 的友元，B 是 C 的友元，**不代表 A 是 C 的友元**  |      | **友元不具有继承性** | 如果 B 是 A 的友元，B 的子类 **不自动成为 A 的友元**         |      | **友元关系是单向的** | 如果 A 声明 B 是友元，**不代表 B 也自动声明 A 是友元**       |      | **编译检查**         | 友元函数/类必须在类 **外部定义**，但必须在类 **内部声明为 friend** |## 第六章（C9） · 继承### 继承1. 概述   1. 定义：继承是面向对象程序设计中的核心机制，它允许新的类（派生类）基于已有的类（基类）来构建，从而实现**代码复用**和**层次化分类**。   2. 主要作用      1. **基于目标代码的复用**：避免重复编写相同功能的代码      2. **对事物进行分类**：通过层次结构清晰地描述现实世界的关系      3. **增量开发**：在现有类的基础上扩展新功能，实现渐进式开发2. 语法：   1. ```c++      // 以单继承为例      class 基类 &#123;          // 基类的成员（数据成员和成员函数）      &#125;;            class 派生类 : 访问控制 基类 &#123;          // 派生类的成员      &#125;;\n\n\n\n\n三种继承类别\n1. \n\n\n\n\n访问级别（基类的访问控制）\n说明\n\n\n\npublic\n成员可以被任何代码访问，包括类的使用者、派生类等\n\n\nprotected\n成员只能被该类自身及其派生类访问，外部代码不能直接访问\n\n\nprivate\n成员只能被该类自身访问，派生类和外部代码均不能直接访问\n\n\n\n\n\n\n继承方式（继承时指出）\n说明\n基类成员访问权限变化\n\n\n\npublic\n公有继承\n保持原有访问权限\n\n\nprotected\n保护继承\npublic→protected\n\n\nprivate\n私有继承\n所有成员→private\n\n\n\n\n\n常见问题：\n\n名覆盖：\n\n在派生类中定义了和基类中同名的函数或类，会导致基类中的对象不可见（被隐藏、被覆盖），调用时可能找不到而报错。如果要调用需要显示指明命名空间。\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base {\npublic:\n    void show() {\n        cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; endl;\n    }\n\n    void show(int x) {\n        cout &lt;&lt; &quot;Base::show(int): &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void show() {  // 派生类定义了一个同名的 show() 函数\n        cout &lt;&lt; &quot;Derived::show()&quot; &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Derived d;\n    d.show();        // OK，调用 Derived::show()\n    // d.show(10);   // 错误！Base::show(int) 被隐藏了，找不到这个函数\n    d.Base::show(10); // 正确：通过 Base:: 明确调用基类的版本\n    return 0;\n}\n   2. 对象切片      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。      2. 对象身份变化分析         - 派生类特有的成员被&quot;切掉&quot;         - 只保留基类部分的成员         - 对象身份从派生类变为基类类型   3. 私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数5. 构造与析构   1. 构造顺序      1. 第一，基类构造函数      2. 第二，派生类的成员类的构造函数（所依赖的类）      3. 第三，派生类构造函数   2. 析构顺序：和构造顺序相反   3. 如何调用基类的构造函数      1. 基类有默认构造函数（无参构造函数）         1. 如果你的基类有一个无参构造函数（默认构造函数），而你在派生类中没有显式调用基类构造函数，编译器会**自动调用基类的默认构造函数**。         2. ```c++            class Base &#123;            public:                Base() &#123;                    cout &lt;&lt; &quot;Base 默认构造函数&quot; &lt;&lt; endl;                &#125;            &#125;;                        class Derived : public Base &#123;            public:                Derived() &#123;                    cout &lt;&lt; &quot;Derived 默认构造函数&quot; &lt;&lt; endl;                &#125;            &#125;;                        int main() &#123;                Derived d;  // 先调用 Base()，再调用 Derived()                return 0;            &#125;\n\n3. \n\n\n基类没有默认构造函数，或你想调用指定的基类构造函数\n\n如果基类没有无参构造函数，或者你想要调用基类的某个有参构造函数，那么你必须在派生类的构造函数初始化列表中显式调用基类的构造函数\n\nclass Base {\npublic:\n    Base(int x) {\n        cout &lt;&lt; &quot;Base(int): &quot; &lt;&lt; x &lt;&lt; endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    Derived(int y) : Base(y) {  // 显式调用基类构造函数\n        cout &lt;&lt; &quot;Derived(int): &quot; &lt;&lt; y &lt;&lt; endl;\n    }\n};\n         3. ### 虚函数#### 虚函数的定义与特性1. 通过上面的介绍我们知道了：**虚函数就是多态函数**2. 重定义规则：   1. 如果基类函数声明为`virtual`，派生类中的重定义函数自动成为虚函数   2. 重定义函数必须与基类虚函数具有相同的签名   3. 使用`override`关键字（C++11）可以增强安全性3. 限制条件   1. | 函数类型     | 能否为虚函数 | 说明                       |      | :----------- | :----------- | :------------------------- |      | 普通成员函数 | ✅            | 主要的虚函数应用场景       |      | 静态成员函数 | ❌            | 与具体对象无关             |      | 内联成员函数 | ❌            | 编译时展开，与动态绑定冲突 |      | 构造函数     | ❌            | 对象构造期间虚表未完全建立 |      | 析构函数     | ✅            | 应该声明为虚函数           |   2. 在 C++ 的**继承与多态**场景中，**如果基类的析构函数不是虚函数（non-virtual destructor），而你通过基类指针删除派生类对象，就可能导致派生类部分的资源没有被正确释放，从而引发内存泄漏或其他未定义行为。**      1. 经典且推荐的实现：`virtual ~B() = default;`#### 类型相容与对象赋值机制1. 基础概念：   1. 类型相容是指不同数据类型之间能否进行赋值操作的兼容性规则。在继承体系中，派生类对象可以赋值给基类对象，但反之不成立。   2. 这里引出了**对象切片**的问题。      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。      2. 对象身份变化分析         - 派生类特有的成员被&quot;切掉&quot;         - 只保留基类部分的成员         - 对象身份从派生类变为基类类型2. 指针和引用的类型相容   1. 基类的指针或引用可以指向派生类对象，这是实现多态的基础：   2. ```c++      B* pb = new B();      A* pa = pb;     // 合法：基类指针指向派生类对象      A&amp; ra = *pb;    // 合法：基类引用绑定派生类对象\n\n\n\n\n\n\n\n\n对象身份发生变化，调用命名空间随之变化。\n\n\n虚函数的绑定机制\n引入\n\n\nfunc2()调用的是A还是B呢？这涉及到绑定机制。C++在默认情况下，是静态绑定，那么就会按照参数类型调用A::f()。如果需要动态绑定，则需要手动用virtual显式指出。\n\n\n静态绑定\n\n发生时机：编译时刻\n\n依据：对象的静态类型（声明类型）\n\n优点：执行效率高\n\n缺点：灵活性差\n\nclass Base {\npublic:\n    void nonVirtual() { cout &lt;&lt; &quot;Base::nonVirtual&quot;; }\n};\n\nBase* ptr = new Derived();\nptr-&gt;nonVirtual();  // 总是调用Base::nonVirtual（前期绑定）\n3. 动态绑定   1. 发生时机：运行时刻   2. 依据：对象的实际类型（动态类型）   3. 优点：灵活性高，支持多态   4. 缺点：效率相对较低   5. ```c++      class Base &#123;      public:          virtual void virtualFunc() &#123; cout &lt;&lt; &quot;Base::virtualFunc&quot;; &#125;      &#125;;            Base* ptr = new Derived();      ptr-&gt;virtualFunc();  // 根据实际对象类型调用（动态绑定）\n\n\n\n\n\n后期绑定的实现\n虚函数表的内存布局\n每个包含虚函数的类都有一个虚函数表（vtable），对象中包含指向该表的指针（vptr）。\nclass A &#123;    int x, y;public:    virtual void f();    virtual void g();    void h();&#125;;class B : public A &#123;    int z;public:    void f() override;  // 重写虚函数    void h();           // 重定义普通函数&#125;;\n\n虚函数调用过程\n\n通过对象的vptr找到虚函数表\n在虚函数表中查找函数地址\n根据实际对象类型调用正确的函数\n\nA a; B b;A* p = &amp;b;p-&gt;f();  // 调用B::f（通过虚函数表动态绑定）\n\n构造函数中的虚函数调用\n构造函数中的虚函数调用\n\n虚函数表是在构造函数中完成的，这就意味着构造到哪里，身份就到哪里。\n\n在构造函数执行期间，虚函数机制尚未完全建立：\n\n虚函数表指针（vptr）在构造函数中逐步设置\n在基类构造函数中调用虚函数，实际调用的是当前类的版本\n直到构造函数返回后，对象才能正常使用虚函数机制\n\n\nclass A {\npublic:\n    A() { f(); }  // 构造函数中调用虚函数\n    virtual void f() { cout &lt;&lt; &quot;A::f&quot;; }\n    void g() { cout &lt;&lt; &quot;A::g&quot;; }\n    void h() { f(); g(); }\n};\n\nclass B : public A {\npublic:\n    void f() override { g(); }  // 调用g()函数\n    void g() { cout &lt;&lt; &quot;B::g&quot;; }\n};\n\nB b;           // 输出：A::f（构造函数中调用A::f） *** 重点看这里 ***\nA* p = &amp;b;\np-&gt;f();        // 输出：B::g（通过虚函数表调用B::f，其中调用B::g）\np-&gt;g();        // 输出：A::g（非虚函数，静态绑定）\np-&gt;h();        // 输出：B::g A::g（h()中f()动态绑定，g()静态绑定） *** 重点看这里 ***\n#### 友元与protected1. 友元的友元不是友元2. 派生类的友元不是友元   1. ```c++      class Base &#123;      protected:          int prot_mem; // protected 成员      &#125;;            class Sneaky : public Base &#123;          friend void clobber(Sneaky&amp;);  // 能访问Sneaky::prot_mem          friend void clobber(Base&amp;);    // 不能访问Base::prot_mem          int j;                         // j 默认是private      &#125;;\n\n\nfriend void clobber(Base&amp;);：表示 clobber函数是 Base类的友元吗？不，这里是 Sneaky类把 clobber(Base&amp;)声明为友元。但 protected成员的访问权限有个关键限制：派生类只能让自己的友元访问自己继承来的 protected 成员，而不能直接让友元去访问基类的 protected 成员（除非友元是基类本身声明的，或者有其他特殊继承&#x2F;友元关系）。所以这个 clobber(Base&amp;)虽然是 Sneaky的友元，但它并不能访问 Base类里的 prot_mem。\n\n\n\n\n纯虚函数与抽象类\n纯虚函数\n是什么\n在 C++ 中，如果一个虚函数没有具体的实现，并且在声明时被赋值为 0，这样的函数就称为纯虚函数。\nvirtual 返回类型 函数名(参数列表) = 0;\n注意纯虚函数没有函数体（可以没有实现）。\n\n\n为什么要纯虚函数\n它定义了一个接口，要求派生类必须去实现它（除非派生类也是抽象类）。\n\n\n\n\n抽象类\n是什么\n如果一个类包含至少一个纯虚函数，那么这个类就称为抽象类。\n抽象类不能创建对象（不能实例化），它只能作为基类被继承。\n抽象类的目的是为了定义一个通用的接口或行为规范，强制派生类去实现这些行为。\n一般作为指针类型实现接口。\n\n\n\n\n\nfinal与override\nstruct B &#123;    virtual void f1(int) const;    virtual void f2();    void f3();    virtual void f5(int) final;&#125;;struct D : B &#123;    void f1(int) const override; // 正确: f1与基类中的f1 匹配    void f2(int) override;       // 错误: B没有形如f2(int) 的函数。int f2()?    void f3() override;          // 错误: f3不是虚函数    void f4() override;          // 错误: B没有名为f4的函数    void f5(int);                // 错误: B已经将f5声明成final&#125;;\n\n建议重写虚函数时要用上override关键字\n\n为什么要使用override\n\n编译时检查：确保重写的函数确实存在于基类\n代码可读性：明确标识这是重写函数\n维护性：当基类虚函数改变时，派生类中的override会报错\n\n\n为什么要使用final\n\n设计约束：明确某些类或函数不应该被进一步扩展\n性能优化：编译器可能对final函数进行去虚拟化优化\n安全性：防止意外的重写或继承\n\n\n\n访问控制\n访问控制检查在编译时期执行，因此只会检查静态类型\n\n如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。\n\n所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。\n\n\n\n设计原则\n确定共有继承是真正意义的 ‘is_a’ 关系\n\n在面向对象设计里，public继承表示 “是一种（is-a）” 关系。例如，如果写 class Dog : public Animal，就意味着 “狗是一种动物”——Dog 必须能替代 Animal 做所有 Animal 能做的事（里氏替换原则 Liskov Substitution Principle）。\n反过来，如果不是 “is-a” 关系，就不应该用 public继承；否则会导致语义混乱、代码难以维护甚至出现难以调试的错误。\n\n\n不要定义与继承而来的非虚成员函数同名的成员函数\n\n如果基类里有非虚成员函数，派生类里又定义了一个同名的成员函数，这在 C++ 里属于 “隐藏（Name Hiding）”，而非 “重写（Override）”。这很容易让程序员误以为是 “多态”，结果却出现和预期完全不同的行为（比如根据指针&#x2F;引用类型调用到不同函数，而不是根据实际对象类型）。\n更糟糕的是，一旦基类把那个函数改成 virtual，派生类里同名的函数就会自动变成 “重写”，行为可能瞬间改变，埋下隐患。\n\n\n保持派生类实现与基类虚函数的访问控制一致\n\n如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。\n所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。\n\n\n慎用私有继承\n\n私有继承常用于 “Implemented - in - term - of” 场景，也就是当派生类想要复用基类的实现（比如使用基类的 protected成员，或者重写基类的虚函数），但又不希望把基类暴露给外部客户端时，就可以使用私有继承。\n\n私有继承在 “设计层面” 并没有太多语义上的含义（不像公有继承那样表达 “is - a” 关系），它更多是在 “实现层面” 帮我们复用代码。\n\n私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数（就像示例中 eat(b)会报错那样）\n\nclass CHumanBeing { ... };\nclass CStudent: private CHumanBeing { ... };\nvoid eat(const CHumanBeing&amp; h) { ... }\nCHumanBeing a; CStudent b;\neat(a);\neat(b); // Error\n5. **绝对不要重新定义继承而来的缺省参数值**   1. 核心问题      1. **虚函数** 是实现**动态绑定（运行时多态）** 的关键。 虚函数的调用会根据对象的**实际类型** 来决定调用哪个类的虚函数版本。      2. **默认参数** 是在**编译时期** 就确定下来的，属于**静态绑定**。 默认参数的值由**指针或引用的声明类型** 决定，而不是对象的**实际类型** 决定。      3. 当你在派生类中重新定义了从基类继承而来的虚函数的默认参数值时，就会产生混淆和潜在的错误，因为：         - 函数调用是动态绑定的（决定调用哪个虚函数）。         - 默认参数值是静态绑定的（决定用什么默认值）。      4. 这会导致**函数的调用版本** 和 **默认参数的值** 可能不匹配， 从而出现不符合预期的行为。   2. 代码分析      1. ```c++         class A          &#123;          public:              virtual void f(int x=0) =0;          &#125;;                  class B: public A          &#123;          public:              virtual void f(int x=1)   // ❌ 错误示范：重新定义了继承来的默认参数！             &#123; cout &lt;&lt; x;&#125;          &#125;;                  class C: public A          &#123;          public:              virtual void f(int x) &#123; cout&lt;&lt; x;&#125;          &#125;;                  // 主逻辑：         A *p_a;          B b;          p_a = &amp;b;          p_a-&gt;f();                   A *p_a1;          C c;          p_a1 = &amp;c;          p_a1-&gt;f();\n\n2. 分析函数调用和默认参数\n\n   1. 调用 `p_a-&gt;f()`（p_a 指向 B 对象 b）\n\n      1. 虚函数调用（动态绑定）： 因为 `p_a`是指向 `A`的指针，而 `A`中的 `f`是虚函数，并且 `b`实际上是 `B`类型，所以会**动态绑定到 `B::f`**。\n\n      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a`的声明类型 `A\\*` 决定的，而不是由 `p_a`实际指向的对象类型 `B`决定的。所以，`B::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`**（而不是 `B`中错误定义的 `x=1`）**。因此，`p_a-&gt;f()`等价于 `B::f(0)`， 输出 `0`。\n\n   3. 调用 `p_a1-&gt;f()`（p_a1 指向 C 对象 c）\n\n      1. 虚函数调用（动态绑定）： `p_a1`是指向 `A`的指针，`A`中的 `f`是虚函数，并且 `c`实际上是 `C`类型，所以会**动态绑定到 `C::f`**。\n\n      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a1`的声明类型 `A\\*` 决定的，而不是由 `p_a1`实际指向的对象类型 `C`决定的。所以，`C::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`（因为 `C`中没有重新定义默认参数）。因此，`p_a1-&gt;f()`等价于 `C::f(0)`， 输出 `0`。\n\n\n\n\n\n多继承概述\n是什么\n\n定义：多继承是C++面向对象编程中的重要特性，它允许一个派生类同时从多个基类继承属性和方法。这种机制提供了更大的灵活性，但也带来了更复杂的语义和实现问题。\n\n基本语法：\n\nclass &lt;派生类名&gt; : [&lt;继承方式&gt;] &lt;基类名1&gt;, [&lt;继承方式&gt;] &lt;基类名2&gt;, ...\n{\n    &lt;成员表&gt;\n};\n      2. 2. 多继承中的名冲突问题   1. ```c++      class Base1 &#123;      public:          void display() &#123; cout &lt;&lt; &quot;Base1 display&quot; &lt;&lt; endl; &#125;          int value = 10;      &#125;;            class Base2 &#123;      public:          void display() &#123; cout &lt;&lt; &quot;Base2 display&quot; &lt;&lt; endl; &#125;          int value = 20;      &#125;;            class Derived : public Base1, public Base2 &#123;      public:          void show() &#123;              // display();     // 错误：名冲突，不知道调用哪个display              // cout &lt;&lt; value; // 错误：名冲突，不知道访问哪个value          &#125;      &#125;;\t      \n\n\n\n\n当多个基类包含同名成员时，会产生名冲突（Name Conflict）\n\n用使用作用域解析运算符明确指定要访问的成员\n\n\n\n菱形继承的数据冗余问题\n\n是什么：\n\n当B，C继承自A，而D多继承自B，C，那么D中就会出现B::x和C::x，然而x实际上都来自A::x，这就造成了冗余。\n\n\n造成的后果\n\n派生类D中将包含两份A的成员副本\n访问A的成员时会产生二义性\n内存布局复杂，存在冗余数据\n\n\n解决方案：虚继承\n\n\n\n\n虚继承\n虚继承是解决菱形继承问题的关键技术，它确保公共基类在派生类中只有一个副本：\n\n示例：\n\nclass A {\npublic:\n    int x;\n};\n\nclass B : virtual public A {  // 虚继承\n    // 虚继承A\n};\n\nclass C : public virtual A {  // 虚继承，两种写法等价\n    // 虚继承A\n};\n\nclass D : public B, public C {\n    // 现在D中只有一份A的成员x\n};\n2. 虚继承的工作原理   1. 虚继承通过引入**虚基类表指针**来实现：      1. 每个虚继承的类包含一个指向共享基类的指针      2. 最终派生类负责初始化虚基类      3. 所有中间类共享同一个基类实例   2. 内存模型      1. ```         D对象：         +-------------------+         | 虚基类表指针(B)   |         | B特有成员         |         +-------------------+         | 虚基类表指针(C)   |         | C特有成员         |         +-------------------+         | D特有成员         |         +-------------------+         | 共享的A部分       |  ← B和C通过指针共享         +-------------------+\n\n2.\n\n\n\n\n虚继承的特殊规则\n\n构造函数调用顺序\n虚基类的构造函数调用有特殊规则：\n\n虚基类的构造函数优先执行\n然后按声明顺序执行非虚基类的构造函数\n最后执行派生类自身的构造函数\n\nclass A &#123;public:    A() &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : virtual public A &#123;public:    B() &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125;&#125;;class C : virtual public A &#123;public:    C() &#123; cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; endl; &#125;&#125;;class D : public B, public C &#123;public:    D() &#123; cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl; &#125;&#125;;// 创建D对象时的输出顺序：// A constructor (虚基类优先)// B constructor// C constructor  // D constructor\n\n\n最新派生类责任\n在虚继承中，最底层派生类负责直接初始化所有虚基类\n\n\n\nclass A &#123;public:    A(int x) &#123; cout &lt;&lt; &quot;A(&quot; &lt;&lt; x &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;&#125;;class B : virtual public A &#123;public:    B() : A(1) &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125;&#125;;class C : virtual public A &#123;public:    C() : A(2) &#123; cout &lt;&lt; &quot;C()&quot; &lt;&lt; endl; &#125;&#125;;class D : public B, public C &#123;public:    // 必须直接初始化虚基类A    D() : A(100), B(), C() &#123;          cout &lt;&lt; &quot;D()&quot; &lt;&lt; endl;    &#125;&#125;;// 输出结果：// A(100)  - 虚基类由D直接初始化，B和C中的A初始化被忽略// B()// C()// D() \n\n\n虚基类表\n\n每个虚继承的类都包含一个虚基类表，记录：\n虚基类相对于当前对象的偏移量\n虚基类成员的访问信息\n\n\n\n\n\n常用库“algorithm”\n\n\n函数&#x2F;算法\n功能描述\n是否修改原数据\n适用对象\n备注 &#x2F; 示例关键词\n\n\n\nstd::sort***\n对范围进行排序（默认升序）\n✅ 是\n支持随机访问迭代器（如 vector, deque, 普通数组）\nstd::sort(v.begin(), v.end())\n\n\nstd::stable_sort\n稳定排序（相等元素相对顺序不变）\n✅ 是\n同上\n适合需要保持顺序的场景\n\n\nstd::reverse***\n反转范围内的元素顺序\n✅ 是\n双向迭代器（如 vector, list, deque）\nstd::reverse(v.begin(), v.end())\n\n\nstd::find\n查找某个值，返回第一个匹配的迭代器\n❌ 否\n输入迭代器\nfind(v.begin(), v.end(), 42)\n\n\nstd::find_if\n按条件查找（使用谓词 predicate）\n❌ 否\n输入迭代器\nfind_if(v.begin(), v.end(), [](int x){...})\n\n\nstd::count\n统计某个值出现的次数\n❌ 否\n输入迭代器\ncount(v.begin(), v.end(), 10)\n\n\nstd::count_if\n按条件统计个数\n❌ 否\n输入迭代器\ncount_if(v.begin(), v.end(), [](int x){...})\n\n\nstd::copy\n复制一个范围的元素到另一个位置\n❌ 否（目标被修改）\n输入 → 输出迭代器\ncopy(src.begin(), src.end(), dest.begin())\n\n\nstd::copy_if\n按条件复制元素\n❌ 否\n输入 → 输出迭代器\ncopy_if(v.begin(), v.end(), out, predicate)\n\n\nstd::transform\n对每个元素进行变换，生成新序列或原地修改\n✅ &#x2F; ❌ 取决于用法\n输入&#x2F;输出迭代器\n可用于 map-like 操作\n\n\nstd::for_each\n对每个元素执行某个操作（函数&#x2F;lambda）\n❌ 通常否\n输入迭代器\nfor_each(v.begin(), v.end(), func)\n\n\nstd::min&#x2F; std::max\n返回两个（或多个）值中的最小&#x2F;最大值\n❌ 否\n值\nmin(a, b), max(a, b)\n\n\nstd::min_element&#x2F; std::max_element\n返回范围内最小&#x2F;最大元素的迭代器\n❌ 否\n输入迭代器\nmin_element(v.begin(), v.end())\n\n\nstd::clamp（C++17）\n将值限制在 [low, high] 范围内\n❌ 否\n值\nclamp(x, low, high)\n\n\nstd::swap***\n交换两个对象的值\n✅ 是\n任意可交换类型\nswap(a, b)或 std::swap(a, b)\n\n\nstd::unique\n移除相邻的重复元素（需先排序）\n✅ 是（实际是移动到前面，需配合 erase）\n双向迭代器\n通常与 sort+ erase配合使用\n\n\nstd::fill\n用指定值填充某个范围\n✅ 是\n输出迭代器\nfill(v.begin(), v.end(), 0)\n\n\nstd::generate\n用生成器函数填充范围\n✅ 是\n输出迭代器\n常用于生成随机数等\n\n\nstd::accumulate（在 &lt;numeric&gt;）\n计算累计值（如求和、累积）\n❌ 否\n输入迭代器\n常与 lambda 配合做自定义累加\n\n\nstd::lower_bound\n返回第一个 不小于 指定值的迭代器（二分查找）\n❌ 否\n已排序的范围，随机访问迭代器\n用于有序容器\n\n\nstd::upper_bound\n返回第一个 大于 指定值的迭代器\n❌ 否\n已排序的范围\n与 lower_bound 一起可确定插入位置\n\n\nstd::binary_search\n判断某个值是否存在于已排序的范围中\n❌ 否\n已排序\n返回 true/false\n\n\nstd::equal\n判断两个范围是否相等\n❌ 否\n两个输入范围\n比较两段数据内容是否相同\n\n\nstd::all_of&#x2F; any_of&#x2F; none_of\n判断范围内是否全部&#x2F;任一&#x2F;无满足条件\n❌ 否\n输入迭代器 + 谓词\n常搭配 lambda 使用\n\n\n“fstream”\n\n\n类别\n方法&#x2F;对象\n调用示例\n返回值\n解释\n\n\n\n文件输出\nstd::ofstream\nstd::ofstream fout(&quot;file.txt&quot;);\nofstream对象\n输出文件流（写入文件）\n\n\n\nfout &lt;&lt; &quot;text&quot;;\nfout &lt;&lt; data;\nostream&amp;\n写入内容到文件\n\n\n\nfout.open(&quot;file.txt&quot;)\nfout.open(&quot;data.txt&quot;);\nvoid\n打开文件\n\n\n\nfout.close()\nfout.close();\nvoid\n关闭文件\n\n\n文件输入\nstd::ifstream\nstd::ifstream fin(&quot;file.txt&quot;);\nifstream对象\n输入文件流（读取文件）\n\n\n\nfin &gt;&gt; x;\nfin &gt;&gt; value;\nistream&amp;\n从文件读取变量\n\n\n\nstd::getline(fin, str)\nstd::getline(fin, line);\nistream&amp;\n读取文件中的一行文本\n\n\n\nfin.open(&quot;file.txt&quot;)\nfin.open(&quot;data.txt&quot;);\nvoid\n打开文件\n\n\n\nfin.close()\nfin.close();\nvoid\n关闭文件\n\n\n“memory”\n\n\n\n类别&#x2F;方法\n方法&#x2F;函数\n调用示例\n返回值\n解释说明\n\n\n\n智能指针类型\nstd::unique_ptr&lt;T&gt;\nstd::unique_ptr&lt;int&gt; p(new int(10)); 或更推荐：auto p = std::make_unique&lt;int&gt;(10);(C++14)\nstd::unique_ptr&lt;T&gt;对象\n独占所有权的智能指针，不能复制，只能移动，离开作用域时自动释放资源。\n\n\n\nstd::shared_ptr&lt;T&gt;\nstd::shared_ptr&lt;int&gt; p(new int(20)); 或推荐：auto p = std::make_shared&lt;int&gt;(20);\nstd::shared_ptr&lt;T&gt;对象\n共享所有权的智能指针，多个 shared_ptr可指向同一对象，通过引用计数管理生命周期。\n\n\n\nstd::weak_ptr&lt;T&gt;\nstd::weak_ptr&lt;int&gt; wp(sp);（sp 是 shared_ptr）\nstd::weak_ptr&lt;T&gt;对象\n弱引用指针，不增加引用计数，常用于解决 shared_ptr的循环引用问题，或安全访问可能已释放的资源。\n\n\n工厂函数（推荐）\nstd::make_unique&lt;T&gt;(args...)\nauto p = std::make_unique&lt;int&gt;(42); （C++14 起支持）\nstd::unique_ptr&lt;T&gt;\n安全、高效地创建 unique_ptr，避免显式使用 new，推荐首选方式。\n\n\n\nstd::make_shared&lt;T&gt;(args...)\nauto p = std::make_shared&lt;int&gt;(42); （C++11 起支持）\nstd::shared_ptr&lt;T&gt;\n安全、高效地创建 shared_ptr，通常比 new+ shared_ptr构造更高效（一次分配）。\n\n\n通用方法（适用于 shared_ptr &#x2F; unique_ptr）\n.get()\nint* raw = p.get();\nT*（原始指针）\n返回智能指针管理的原始指针，但不释放所有权，慎用，避免手动 delete。\n\n\n\n.reset()\np.reset();或 p.reset(new int(100));\nvoid\n释放当前管理的对象（如果有），并可选择指向一个新对象。如果无参数，则释放当前资源。\n\n\n\n.release()\nint* raw = p.release();\nT*\n释放所有权，返回原始指针，智能指针不再管理该内存，需手动管理（如 delete）。慎用！\n\n\nshared_ptr 独有方法\n.use_count()\nint count = sp.use_count();\nlong（或 size_t，取决于实现）\n返回当前有多少个 shared_ptr共享该对象（即引用计数），主要用于调试，不建议用于逻辑控制。\n\n\n\n.unique()\nbool is_unique = sp.unique();\nbool\n判断当前 shared_ptr是否是唯一拥有该对象的指针（即 use_count &#x3D;&#x3D; 1），C++17 起被标记为 deprecated，推荐用 use_count() == 1。\n\n\nweak_ptr 独有方法\n.lock()\nif (auto tmp = wp.lock()) { /* 使用 tmp */ }\nstd::shared_ptr&lt;T&gt;（如果资源还在） 或 nullptr（如果资源已释放）\n尝试将 weak_ptr提升为 shared_ptr，如果对象还存在则返回有效的 shared_ptr，否则返回空。用于安全访问可能被释放的资源。\n\n\n析构行为（隐式）\n析构函数 ~unique_ptr() ~shared_ptr() ~weak_ptr()\n无需显式调用，在对象离开作用域时自动调用\nvoid\n自动释放所管理的资源： - unique_ptr：直接 delete资源 - shared_ptr：引用计数减 1，归零时 delete - weak_ptr：不影响引用计数，仅观察\n\n\n\n\n“queue”\n\n\n方法\n用法示例\n说明\n\n\n\npush(x)\nq.push(10);\n元素入队（到队尾）\n\n\npop()\nq.pop();\n队首元素出队（无返回值）\n\n\nfront()\nint a = q.front();\n访问队首元素（不删除）\n\n\nback()\nint b = q.back();\n访问队尾元素（不删除）\n\n\nempty()\nif(q.empty()) ...\n判断队列是否为空\n\n\nsize()\nint n = q.size();\n返回元素个数\n\n\npriority_queue\n概述\n\nC++ 的 std::priority_queue 本质上是对 std::vector + 堆算法 (std::make_heap &#x2F; std::push_heap &#x2F; std::pop_heap) 的封装。\n默认实现是 大顶堆（堆顶是最大元素）。\n小顶堆或自定义顺序，其实是改比较器（greater&lt;T&gt; 或自定义 cmp）。\n\n\n构造\n1. \n\n\n\n\n用法\n示例代码\n说明\n\n\n\n默认大顶堆\npriority_queue&lt;int&gt; pq;\n取出最大元素\n\n\n小顶堆\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n取出最小元素\n\n\n自定义比较\npriority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;\n可定义结构体比较方式\n\n\n\n\n\n用法\n1. \n\n\n\n\n方法\n用法示例\n说明\n\n\n\npush(x)\npq.push(5);\n插入一个元素（自动调整堆）\n\n\npop()\npq.pop();\n删除当前最大元素（或最小，取决于堆类型）\n\n\ntop()\nint t = pq.top();\n返回堆顶元素（最大&#x2F;最小）\n\n\nempty()\nif(pq.empty()) ...\n判断是否为空\n\n\nsize()\nint n = pq.size();\n返回元素个数\n\n\n\n\n\n\n“string”\ngetline\n\nstd::getline(std::cin, str);  // 读取一行，包含空格\nstd::getline(std::cin, str, &#39;,&#39;);  // 读取直到逗号为止\n\n   2. 构造与初始化   | 方法                  | 说明                        | 示例                               |   | :-------------------- | :-------------------------- | :--------------------------------- |   | `string s;`           | 构造空字符串                | `string s;`→ `s = &quot;&quot;`              |   | `string s(&quot;hello&quot;);`  | 用 C 风格字符串初始化       | `string s(&quot;abc&quot;);`                 |   | `string s = &quot;world&quot;;` | 用字符串字面量初始化        | `string s = &quot;xyz&quot;;`                |   | `string s(5, &#x27;a&#x27;);`   | 构造 5 个 `&#x27;a&#x27;`组成的字符串 | `string s(3, &#x27;x&#x27;);`→ `&quot;xxx&quot;`       |   | `string s(other);`    | 拷贝构造                    | `string s1 = &quot;hi&quot;; string s2(s1);` |   ------   2️⃣ 容量相关   | 方法                      | 说明                                                  | 示例                      |   | :------------------------ | :---------------------------------------------------- | :------------------------ |   | `s.size()`或 `s.length()` | 返回字符串中字符的个数（不包括 `\\0`）                 | `s.size()`→ 如 `&quot;abc&quot;`→ 3 |   | `s.capacity()`            | 返回当前分配的存储空间（可能 ≥ size）                 | 一般用于优化，不常用      |   | `s.empty()`               | 判断字符串是否为空（size == 0）                       | `if (s.empty()) &#123;...&#125;`    |   | `s.resize(n)`             | 将字符串调整为 n 个字符（多出的补空字符，少则截断）   | `s.resize(5);`            |   | `s.resize(n, c)`          | 调整大小为 n，新增的字符为 `c`                        | `s.resize(5, &#x27;*&#x27;);`       |   | `s.reserve(n)`            | 预留至少能容纳 n 个字符的空间（优化用，避免多次扩容） | `s.reserve(100);`         |   &gt; ✅ `size()`和 `length()`是完全等价的，都返回字符数。   ------   3️⃣ 访问元素   | 方法      | 说明                                                    | 示例                |   | :-------- | :------------------------------------------------------ | :------------------ |   | `s[i]`    | 访问第 i 个字符（不检查越界）                           | `char c = s[0];`    |   | `s.at(i)` | 访问第 i 个字符（**越界会抛异常** `std::out_of_range`） | `char c = s.at(2);` |   &gt; ⚠️ 推荐在不确定索引是否合法时使用 `at()`，更安全。   ------   4️⃣ 修改字符串   | 方法                          | 说明                                   | 示例                      |   | :---------------------------- | :------------------------------------- | :------------------------ |   | `s.clear()`                   | 清空字符串                             | `s.clear();`→ `s == &quot;&quot;`   |   | `s.push_back(ch)`             | 在末尾添加一个字符                     | `s.push_back(&#x27;a&#x27;);`       |   | `s.pop_back()`                | 删除最后一个字符（字符串非空）         | `s.pop_back();`           |   | `s.append(str)`               | 在末尾追加字符串（或字符、C 字符串等） | `s.append(&quot;123&quot;);`        |   | `s += str`                    | 追加字符串（常用简洁写法）             | `s += &quot;abc&quot;;`             |   | `s.insert(pos, str)`          | 在 pos 位置插入字符串                  | `s.insert(2, &quot;XX&quot;);`      |   | `s.erase(pos, len)`           | 从 pos 开始删除 len 个字符             | `s.erase(1, 2);`          |   | `s.replace(pos, len, newStr)` | 替换从 pos 开始的 len 个字符为新字符串 | `s.replace(1, 2, &quot;123&quot;);` |   ------   5️⃣ 查找相关   | 方法                         | 说明                                                      | 示例                         |   | :--------------------------- | :-------------------------------------------------------- | :--------------------------- |   | `s.find(sub)`                | 查找子串 `sub`第一次出现的位置，找不到返回 `string::npos` | `size_t pos = s.find(&quot;lo&quot;);` |   | `s.find(ch)`                 | 查找字符第一次出现的位置                                  | `size_t pos = s.find(&#x27;a&#x27;);`  |   | `s.rfind(sub)`               | 查找子串最后一次出现的位置                                | `s.rfind(&quot;lo&quot;);`             |   | `s.find_first_of(&quot;abc&quot;)`     | 查找第一个出现在 `&quot;abc&quot;`中的字符                          |                              |   | `s.find_last_of(&quot;abc&quot;)`      | 查找最后一个出现在 `&quot;abc&quot;`中的字符                        |                              |   | `s.find_first_not_of(&quot;abc&quot;)` | 查找第一个 **不**在 `&quot;abc&quot;`中的字符                       |                              |   | `s.find_last_not_of(&quot;abc&quot;)`  | 查找最后一个 **不**在 `&quot;abc&quot;`中的字符                     |                              |   &gt; ⚠️ 找不到时返回 `string::npos`（一个很大的数，通常是 `size_t(-1)`），判断时要用：\n\n\n\nif (pos !&#x3D; string::npos) { &#x2F;* 找到了 *&#x2F; }\n   ------   6️⃣ 子串操作   | 方法                 | 说明                                                         | 示例                                                       |   | :------------------- | :----------------------------------------------------------- | :--------------------------------------------------------- |   | `s.substr(pos, len)` | 返回从 pos 开始，长度为 len 的子串 （len 可省略，表示到末尾） | `string sub = s.substr(2, 3);` `string sub = s.substr(1);` |   &gt; ⚠️ `pos`不能越界，否则未定义行为（最好先检查范围）。   ------   7️⃣ 比较操作   | 方法                                          | 说明                                                  | 示例                               |   | :-------------------------------------------- | :---------------------------------------------------- | :--------------------------------- |   | `s.compare(str)`                              | 比较两个字符串 返回 0 表示相等，&lt;0 或 &gt;0 表示大小关系 | `if (s.compare(&quot;abc&quot;) == 0) &#123;...&#125;` |   | 也可以直接用 `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=` | 更直观的比较方式                                      | `if (s == &quot;test&quot;) &#123;...&#125;`✅推荐      |   &gt; ✅ 推荐直接使用 `==`、`!=`等运算符，更简洁直观！   ------   8️⃣ 其他实用方法   | 方法                     | 说明                                                         | 示例                                             |   | :----------------------- | :----------------------------------------------------------- | :----------------------------------------------- |   | `s.c_str()`              | 返回 C 风格字符串（`const char*`），以 `\\0`结尾              | 常用于兼容 C 函数，如 `printf(&quot;%s&quot;, s.c_str());` |   | `s.data()`               | C++17 起也返回 `const char*`，但不保证以 `\\0`结尾（一般也可当 C 字符串用） | 类似 `c_str()`                                   |   | `s.copy(dest, len, pos)` | 将字符串的一部分拷贝到 dest 缓冲区（C 风格）                 | 较少使用                                         |   | `s.swap(other)`          | 交换两个字符串的内容                                         | `s.swap(s2);`                                    |   - 转换     -      - | 函数              | 说明                   | 转换目标类型  |       | :---------------- | :--------------------- | :------------ |       | `std::stoi(str)`  | 字符串 → `int`         | `int`         |       | `std::stol(str)`  | 字符串 → `long`        | `long`        |       | `std::stoll(str)` | 字符串 → `long long`   | `long long`   |       | `std::stof(str)`  | 字符串 → `float`       | `float`       |       | `std::stod(str)`  | 字符串 → `double`      | `double`      |       | `std::stold(str)` | 字符串 → `long double` | `long double` |     -      - | **`std::to_string(int)`** | `std::to_string(num)` | ✅ **最推荐** | C++11 及以上，简单直接的 int → string |       | ------------------------- | --------------------- | ------------ | ------------------------------------- |## &quot;vector&quot;1. 2. | 分类     | 方法/示例                                                   | 返回值（文字说明）           | 说明                     |   | -------- | ----------------------------------------------------------- | ---------------------------- | ------------------------ |   | **定义** | `vector&lt;int&gt; v1;`                                           | 空容器                       | 定义一个空 vector        |   |          | `vector&lt;int&gt; v2(5);`                                        | 含 5 个元素，值为 0          | 指定大小，默认初始化     |   |          | `vector&lt;int&gt; v3(5, 100);`                                   | 含 5 个元素，值全是 100      | 指定大小和值             |   |          | `vector&lt;int&gt; v4 = &#123;1,2,3&#125;;`                                 | 含 3 个元素：1,2,3           | 列表初始化               |   | **访问** | `v4[0]`                                                     | 元素引用（可能越界，不检查） | 下标访问                 |   |          | `v4.at(1)`                                                  | 元素引用（带越界检查）       | 越界会抛 `out_of_range`  |   |          | `v4.front()`                                                | 第一个元素引用               | 访问首元素               |   |          | `v4.back()`                                                 | 最后一个元素引用             | 访问尾元素               |   |          | `v4.begin()`                                                | 指向首元素的迭代器           | 迭代遍历起点             |   |          | `v4.end()`                                                  | 指向尾后元素的迭代器         | 遍历终点（左闭右开）     |   | **修改** | `ans.push_back(10);`                                        | 无返回值                     | 在尾部追加元素           |   |          | `ans.emplace_back(20);`                                     | 无返回值                     | 原地构造，效率更高       |   |          | `ans.pop_back();`                                           | 无返回值                     | 删除最后一个元素         |   |          | `ans.insert(ans.begin()+1, 99);`                            | 指向新元素的迭代器           | 在第 2 个位置插入 99     |   |          | `ans.insert(ans.end(), &#123;7,8,9&#125;);`                           | 指向第一个新元素的迭代器     | 在尾部插入多个元素       |   |          | `ans.erase(ans.begin());`                                   | 指向被删元素后的迭代器       | 删除第一个元素           |   |          | `ans.erase(ans.begin()+1, ans.begin()+3);`                  | 指向区间后的迭代器           | 删除区间 `[2,3)`         |   |          | `ans.clear();`                                              | 无返回值                     | 清空所有元素             |   |          | `ans.swap(other);`                                          | 无返回值                     | 与另一个 vector 交换内容 |   | **遍历** | `for (auto it=ans.begin(); it!=ans.end(); it++) cout&lt;&lt;*it;` | 无返回值                     | 迭代器遍历               |   |          | `for (auto &amp;x : ans) cout&lt;&lt;x;`                              | 无返回值                     | 范围 for 遍历            |   | **容量** | `ans.size();`                                               | 当前元素数量                 | O(1)                     |   |          | `ans.empty();`                                              | 布尔值                       | 是否为空                 |   |          | `ans.capacity();`                                           | 已分配的容量                 | 可能大于 size            |   |          | `ans.reserve(100);`                                         | 无返回值                     | 预留至少 100 个容量      |   |          | `ans.shrink_to_fit();`                                      | 无返回值                     | 收缩容量到 size          |   | **算法** | `sort(ans.begin(), ans.end());`                             | 无返回值                     | 升序排序                 |   |          | `sort(ans.rbegin(), ans.rend());`                           | 无返回值                     | 降序排序                 |   |          | `reverse(ans.begin(), ans.end());`                          | 无返回值                     | 反转元素顺序             |3. 注意，算法需要导入算法库：\\#include &lt;algorithm&gt;## 关联容器| 容器            | 底层   | 是否有序 | 是否允许重复 | 查找/插入/删除 || --------------- | ------ | -------- | ------------ | -------------- || `map`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       || `set`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       || `unordered_map` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      || `unordered_set` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      |### &quot;map&quot;1. 有序存放键值对2. 用法   1.    2. | 方法         | 用法                   | 返回值（文字说明）                                           |      | ------------ | ---------------------- | ------------------------------------------------------------ |      | `insert`     | `m.insert(&#123;1,&quot;one&quot;&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（表示是否插入成功） |      | `operator[]` | `m[2] = &quot;two&quot;;`        | 返回指定键对应的值的引用（如果键不存在会新建）               |      | `at`         | `m.at(2)`              | 返回指定键对应的值的引用（如果键不存在会抛异常）             |      | `find`       | `m.find(2)`            | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `m.erase(2)`           | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `m.erase(it)`          | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `m.count(2)`           | 返回匹配的元素个数（在 map 中永远是 0 或 1）                 |      | `size`       | `m.size()`             | 返回当前存储的元素数量                                       |      | `empty`      | `m.empty()`            | 返回是否为空（true/false）                                   |   3. ### &quot;set&quot;1. 有序存放键（没有值）2. 用法   1.    2. | 方法         | 用法            | 返回值（文字说明）                                           |      | ------------ | --------------- | ------------------------------------------------------------ |      | `insert`     | `s.insert(10);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |      | `find`       | `s.find(10)`    | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `s.erase(10)`   | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `s.erase(it)`   | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `s.count(10)`   | 返回匹配的元素个数（在 set 中永远是 0 或 1）                 |      | `size`       | `s.size()`      | 返回当前存储的元素数量                                       |      | `empty`      | `s.empty()`     | 返回是否为空（true/false）                                   |   3. ### &quot;unordered_map&quot;（哈希表）1. 无序存放键值对2. 用法   1.    2. | 方法         | 用法                      | 返回值（文字说明）                                           |      | ------------ | ------------------------- | ------------------------------------------------------------ |      | `insert`     | `um.insert(&#123;&quot;apple&quot;,3&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |      | `operator[]` | `um[&quot;banana&quot;]=5;`         | 返回指定键对应的值的引用（如果键不存在会新建）               |      | `at`         | `um.at(&quot;apple&quot;)`          | 返回指定键对应的值的引用（如果键不存在会抛异常）             |      | `find`       | `um.find(&quot;apple&quot;)`        | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |      | `erase(key)` | `um.erase(&quot;apple&quot;)`       | 返回删除的元素个数（0 或 1）                                 |      | `erase(it)`  | `um.erase(it)`            | 返回一个迭代器，指向下一个有效元素                           |      | `count(key)` | `um.count(&quot;apple&quot;)`       | 返回匹配的元素个数（在 unordered_map 中永远是 0 或 1）       |      | `size`       | `um.size()`               | 返回当前存储的元素数量                                       |      | `empty`      | `um.empty()`              | 返回是否为空（true/false）                                   |   3. 我想进行如下操作：如果表中已存在，则取出值并操作，否则新建并设置默认值：         1. ```c++         // 包含隐式创建默认对象         std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; graphMap;                  int node = 1;                  // 直接使用 operator[]，如果 node 不存在，会自动插入一个空的 vector&lt;int&gt;         std::vector&lt;int&gt;&amp; neighbors = graphMap[node]; // 如果不存在，会创建空vector\n\n\n如果希望显示创建，则使用find（）\n\n\n\n“unordered_set”（哈希表）\n无序存放键（没有值）\n\n用法\n1. \n\n\n\n\n方法\n用法\n返回值（文字说明）\n\n\n\ninsert\nus.insert(100);\n返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功）\n\n\nfind\nus.find(100)\n返回一个迭代器，指向找到的元素；如果没找到，返回 end()\n\n\nerase(key)\nus.erase(100)\n返回删除的元素个数（0 或 1）\n\n\nerase(it)\nus.erase(it)\n返回一个迭代器，指向下一个有效元素\n\n\ncount(key)\nus.count(100)\n返回匹配的元素个数（在 unordered_set 中永远是 0 或 1）\n\n\nsize\nus.size()\n返回当前存储的元素数量\n\n\nempty\nus.empty()\n返回是否为空（true&#x2F;false）\n\n\n\n\n\n\n其他Lambda匿名函数\n基本语法\n一个最基本的 Lambda 表达式的语法如下：\n[捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;\n\n其中：\n\n[捕获列表]：定义了 Lambda 表达式能访问的外部变量及其方式（值捕获、引用捕获等），可以为空。\n(参数列表)：和普通函数的参数列表一样，如果不需要参数，可以省略，但括号不能省略（除非使用特殊形式）。\n-&gt; 返回类型：可省略，编译器会自动推导返回类型（如果只有一条 return 语句，或者没有 return）。\n{ 函数体 }：函数的实现部分。\n\n\n注意：如果引用的变量在 Lambda 执行前已经被销毁（比如局部变量离开作用域），会导致未定义行为（悬空引用）。\n\n\n值传递和引用\nfor(T sth : sths)的逻辑是值传递，不能修改对象本身。而for(int i = 0 ...) {sths[i]} 是直接访问对象。\n\n如果希望简化写法直接修改对象，应该写作for(T&amp; sth : sths)\n\n\n&amp;引用：&amp;操作符用于别名时：\n\n作用：\n&amp;用于声明 引用（reference），引用是一个别名，是某个已存在变量的另一个名字，对引用的操作就是对被引用对象的操作。\n\n特点：\n\n必须初始化（不能先声明再赋值）。\n不能重新绑定到其他对象。\n引用本身不是对象，没有自己的内存地址（不像指针）。\n更安全，更直观，常用于函数参数传递和返回值优化。\n\n\n示例：\nint a = 10;int&amp; ref = a;  // ref 是 a 的引用（别名）ref = 20;      // 实际上是修改了 acout &lt;&lt; a;     // 输出 20\n\n引用 vs 指针（简要对比）\n\n\n\n特性\n引用 (&amp;)\n指针 (*)\n\n\n\n是否必须初始化\n✅ 必须初始化\n❌ 可以不初始化（但不推荐）\n\n\n是否可重新绑定\n❌ 不能重新绑定到其他对象\n✅ 可以修改指向的对象\n\n\n是否占用额外内存\n❌ 一般不占用（是别名）\n✅ 占用内存（存储地址）\n\n\n是否可以为空\n❌ 不能为空\n✅ 可以为 nullptr\n\n\n语法简洁性\n✅ 更简洁，更安全\n❌ 需要解引用，容易出错\n\n\n\n&amp;在C++中的主要用途\n1. \n\n\n\n\n号\n用法类别\n说明\n示例\n\n\n\n1\n引用声明\n声明一个变量的引用（别名）\nint&amp; ref = a;\n\n\n2\n取地址运算符\n获取变量的内存地址，用于指针\nint* p = &amp;a;\n\n\n3\n引用参数\n函数参数传引用，避免拷贝，可修改原值\nvoid func(int&amp; x)\n\n\n4\n引用返回值\n函数返回引用，可修改原对象或支持链式调用\nint&amp; getElement()\n\n\n5\n指针的引用\n引用指向指针，用于修改指针本身\nint*&amp; refPtr = ptr;\n\n\n\n\n\n\n\n\n输入输出操作\ngetline用法：\n\ngetline(cin, str)：把一行读到str中\ngetline(cin, str, delimiter)：读一行，知道遇见第一个隔断符\n\n\nstringstream用法\n\nstringsstream ss(str)：把字符串作为字符串流。这样可以搭配getline。\n\n示例\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::string str = &quot;apple,banana,orange&quot;;\n    char delimiter = &#39;,&#39;;  // 按逗号分割\n\n    std::vector&lt;std::string&gt; tokens;  // 存储分割后的子串\n    std::stringstream ss(str);        // 将字符串放入字符串流\n    std::string token;\n\n    // 按 delimiter 分割\n    while (std::getline(ss, token, delimiter)) {\n        tokens.push_back(token);\n    }\n\n    // 输出分割结果\n    for (const auto&amp; t : tokens) {\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n\n## 操作符重载1. 是什么：   1. 让你可以用内置操作符的方式来操作你自己定义的类型（比如类对象）2. 基本语法   1. 操作符重载本质上就是 **定义一个特殊的成员函数 或 友元函数**，函数名是 `operator`加上要重载的操作符符号。      1. 一般形式（成员函数）：      ```c++      返回类型 operator操作符(参数列表) &#123;          // 自定义操作符的实现      &#125;      // 参数个数 = 操作符需要的操作数个数 - 1（因为左操作数是 this)\n\n  2. 它可以是一个：\n       1. **成员函数**（常见，操作符左边的对象是当前对象，即 `this`）\n       2. **友元函数**（当左操作数不是当前类对象，或者需要访问私有成员但又不能是成员时）\n\n\n友元函数方式：\n\nfriend 返回类型 operator操作符(参数1, 参数2);\n\nfriend 返回类型 operator操作符(参数1, 参数2);\n// 参数个数 = 操作符总的操作数个数\n2. 举例   1. ```c++      #include &lt;iostream&gt;      using namespace std;            class MyArray &#123;      private:          int data[5];  // 假设我们只管理 5 个整数      public:          // 构造函数，初始化数组          MyArray() &#123;              for (int i = 0; i &lt; 5; ++i) &#123;                  data[i] = i * 10;  // 0, 10, 20, 30, 40              &#125;          &#125;                // 重载 [] 操作符 —— 用于访问元素（读写）          int&amp; operator[](int index) &#123;              return data[index];  // 返回第 index 个元素的引用          &#125;      &#125;;      \n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["技术"],"tags":["C++"]},{"title":"Linux系统基础","url":"/2024/12/04/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","content":"安装Linux虚拟机\n~$ sudo apt update\n~$ sudo apt upgrade\n~$ sudo apt install openssh-server\n\nubuntu终端知识点\n解释器为shell\n三种指令格式：\n“&#x2F;usr&#x2F;ubuntu&#x2F;date”：绝对路径下的命令\n“.&#x2F;date”：当前路径下的命令\n“date”：从环境变量中找命令\n\n\n家目录快捷：’~’可以代替家目录\nLinux指令是不可逆的，所以要养成备份的习惯，现在用git很方便\nr：可读，w：可写，x：可执行·\n对于一个文件，对其父目录可写，才可以删除这个文件\n想要打开一个文件，必须对其所有上级目录可执行\n重定向：e.g. echo hello &gt; file.txt，使得hello不输出到屏幕，而是写入file中去。e.g. cat &lt; hello.txt，使得cat不再等待键盘输入，而是读hello文件。e.g. echo &gt;&gt; file.txt，追加内容，而非覆盖\n管道：’ | ‘ 将一个程序的输出和另一个程序的输入连接起来。注意，有的指令不接受输入，而是接受参数，直接把它串起来是没有用的。\n对于一条程序指令，要搞清楚哪部分是命令去完成的，哪部分是由shell完成的。e.g. sudo echo 1 &gt; text.txt 其中sudo让echo指令以超级用户的身份运行，但是重定向&gt;是由shell完成的，所以如果身份权限不够，即使用了sudo也无法完成。\n缓存：就是打开的文件\nLinux 系统中，文件的格式并不是由文件名或文件扩展名决定的，而是由文件的内容和用来打开文件的程序决定的。后缀只是用来方便用户使用。\nshell只能做整数计算，用库bc做小数运算\n\n和windows的区别\n文件系统：Linux是从根目录开始的树状结构，而windows是先分区\n目录符号：Linux是正斜杠’&#x2F; ‘，Windows是反斜杠’\\ ‘\n\nLinux部分基础指令\necho：回显\nwhich：可以搜索到命令的位置（内置命令搜不到）\ntype：可以搜索到命令的位置和属性（包括内置命令）\npwd：打印目录（print working directory)\ncd：切换路径\nls：列出目录（白色是文件，蓝色是文件夹，灰色是其他）\nman：查手册（如：man ls）\n–help：查帮助\ntldr：快速查询（too long don’t read）\ncat：查看文件（全部输出）\nless：查看文件（一页一页看）\nmv：重命名或移动\ncp：复制\nrm：删除文件\nrmdir：删除空文件夹（-r：删除文件夹包括文件，-i 提示我是否删除）\nCtrl+l：清屏\n重定向：\ne.g. echo hello &gt; file.txt，使得hello不输出到屏幕，而是写入file中去。\ne.g. cat &lt; hello.txt，使得cat不再等待键盘输入，而是读hello文件。\ne.g. echo &gt;&gt; file.txt，追加内容，而非覆盖\n\n\nxargs：把输入参数化，传给后面的命令\ntail：展示最后的部分（默认是十行，-n1 改为一行）\nsudo -i：模拟超级用户登录过程，环境变量变了\nsudo su：切换为超级用户，但是你的环境变量没有变\ntee：接受一个文件作为参数，把输入写入文件（-a 表示追加）\ngrep：查找文件内容。\n递归搜索目录：grep -R test .\n获取匹配文本的上下文：grep -C 2 test *\n输出不匹配的结果：grep -v test file\n\n\nwc：统计输出内容数据（-l 行数）\nfind：查找。e.g. 删除当前目录下后缀为.tmp的所有文件：find . -name ‘*.tmp’ -exec rm {} ;  。\nhistory：列出历史记录（结合|，grep灵活应用）注：在命令前加一个空格，该命令就不会被记录。\n！：\n！！：执行上一条命令\n！cd：执行上一条cd命令\n\n\nCtrl+r：进入搜索模式。\nsed：文件内容的查找和替换。\n替换规则：sed -E ‘s&#x2F;查找的内容&#x2F;替换的内容&#x2F;‘（最后加个g表示持续替换）（-E表示让命令能够支持最新的正则表达式）\n（somethong）称为捕获组，可以用 \\1 表示第一捕获组的内容（如果有）。\n\n\nsort：\n不带参数：按字母顺序排序\n-nk1,1：按照数值排序，关键词为第一个字段\n\n\nuniq：唯一化（只会检测相邻行，所以一般和sort联用）\nawk：e.g. awk ‘{print $2}’ 打印第二个字段的内容\npaste：粘贴。（-s，变为单行输出，“d，”表示用逗号分隔）\ncut\ntr：\ne.g. tr “[:upper:]” “[:lower:]” 大写转小写\n\n\n改变权限：chmod\n数字授权：r w x 分别赋予数字4 2 1，权限就是他们的总和\n获权方：u拥有者，g同组成员（group），o其他组（other），a所有人（all）\n示例：有权限-rwxrw-r–，前三位是拥有者，中三位是同组员，后三位是其他组\n示例：chmod u&#x3D;rwx file,    chmod 764 file\n\n\nalias：取别名。e.g.  alias ll&#x3D;”ls -l”\ntime：得出命令运行的时间（为什么real &gt; user + sys ?因为还有其他程序在运行）\n\n文本编辑vim基础五大模式\n正常模式\n插入模式\n可视化模式\n命令模式\n替换模式\n\n语法命令模式\n用’ : ‘打开。\nw：保存\nq：退出\nsp：水平分屏\nvsp：上下分屏\nCtrl+w：切换窗口\ntabnew：新建标签\ntabnext &#x2F; tabn：下一个标签（或者快捷键gt）\n\n正常模式\n&#x2F; key :向后搜索\n? key：向前搜索\n[c+b]：向后翻页\n[c+f]：向前翻页\ne：单词末尾\nb：前一个单词\n（修饰语）i：内部 e.g.  ci( ：修改前方小括号内容\n（修饰语）a：周围 e.g. da’  ：删除周围的单引号\n\nshell脚本语法变量\n赋值时不要空格\n\n获取变量：$foo\n\n引号：单引号输出字面，双引号会取值。\n“$foo” &#x3D;&#x3D;&gt; value, ‘$foo’ &#x3D;&#x3D;&gt; $foo\n\n\n函数特殊变量\n$?：查看上一个程序的退出状态。（0为成功，1为失败）\n\n\n命令替换和进程替换\nfoo&#x3D;$(pwd)\necho $foo\ndiff &lt;(ls) &lt;(ls ..)\n\n通配数据处理指令见基础指令24~行\n正则表达式\n. ：除换行符之外的任意单个字符 \n*：匹配前面字符零次或多次 \n+：匹配前面字符一次或多次\n[abc]： 匹配 a、b、c 中的任意一个\n？：匹配零次或一次\n(RX1|RX2): 任何能够匹配RX1或RX2的结果\n^ 行首 $ 行尾\n{4}：重复4次\n\n注意：正则匹配都是“贪婪匹配”，即匹配的越多越好，所以会匹配到最后一个\n第三天的课堂练习一定要掌握\n通信机制signal信号\nSIGQUIT：终止程序执行并生成一个核心转储。Ctrl+\\。\nSIGINT：中断程序。Ctrl+c。（与SIGTERM的区别在于可以用键盘发出）\nSIGHUB：默认行为是Term行为，在退出时触发，终止所有程序。\nSIGSTOP：Stop行为，暂停程序。\nSIGCONT：Cont行为，继续程序。\nSIGKILL：Term行为，\nSIGTERM：通过kill命令发送，终止程序执行\n\n进程守护进程（服务进程）\n概念：在后台运行的程序。\n执行方法：\nCtrl+z。\n“cmd &amp;”。\njob：查看进程\n“bg %1”：让第一个进程开始\n“fg %1”：让第一个任务停止\n“kill -STOP %1”：暂停\n“kill -CONT %1”：继续\n“kill -HUB %1”：终止\n“nohub cmd”：让程序不接受HUB信号，退出终端时不会停止。\n“kill -KILL”：强制终止。\n\n\n\n终端和后台分离终端多路复用器：流行的是tmux\ntmux知识\n会话–&gt;窗口–&gt;面板\n会话：\n窗口：\n\n语法会话\ntmux new –s NAME 以指定名称开始一个新的会话\ntmux ls 列出当前所有会话 \n&lt;C+b&gt; d ：在tmux中按下该组合键，将当前会话分离\ntmux a 重新连接最后一个会话，可以通过-t参数指定具体的会话\n\n窗口\n&lt;C+b&gt; c： 创建一个新的窗口\n&lt;C+b&gt;  p： 切换到上一个窗口 \n&lt;C+b&gt;  n： 切换到下一个窗口 \n&lt;C+b&gt;  ,： 重命名当前窗口 \n&lt;C+b&gt;  w ：列出当前所有窗口\n\n面板\n&lt;C+b&gt; “ ：水平分割 \n&lt;C+b&gt;  % ：垂直分割 \n&lt;C+b&gt;  &lt;方向键&gt; ：切换到指定方向的面板 \n&lt;C+b&gt;  z ：切换当前面板的缩放 \n&lt;C+b&gt;  &lt;空格&gt; ：在不同的面板布局间切换\n\n","categories":["课业"]},{"title":"Java开发生态学习","url":"/2025/12/04/Java%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E5%AD%A6%E4%B9%A0/","content":"基础知识基础工具Linux\n目录结构：\n\n/bin\n\n存放常用的二进制可执行文件（命令），如 ls、cp、mv、cat。\n所有用户都可以使用。\n\n\n/sbin\n\n存放系统管理用的二进制程序，如 reboot、ifconfig。\n一般由 root 管理员使用。\n\n\n/boot\n\n启动相关文件，比如内核 vmlinuz、引导程序 grub 配置。\n系统开机时最先用到。\n\n\n/dev\n\n存放设备文件（不是实际的硬件，而是设备接口）。\n比如 /dev/sda（硬盘）、/dev/tty（终端）、/dev/null。\n\n\n/etc\n\n存放系统配置文件，例如：\n/etc/passwd 用户信息\n/etc/fstab 磁盘挂载\n/etc/apt/ apt 软件源配置\n\n\n里面通常没有二进制程序，主要是文本配置文件。\n\n\n/home\n\n普通用户的主目录。\n例如用户 hua 的主目录是 /home/hua，里面存放桌面、下载、配置等。\n\n\n/lib\n\n存放系统运行所需的共享库文件（类似 Windows 的 DLL）。\n比如 /lib/x86_64-linux-gnu/。\n\n\n/media\n\n挂载点目录，系统自动挂载 U 盘、光盘时会放在这里。\n如 /media/username/USB_DRIVE。\n\n\n/mnt\n\n传统的临时挂载点，管理员手动挂载磁盘时常用。\n\n\n/opt\n\n第三方应用软件目录。\n比如你单独安装的软件可能放在 /opt/google/chrome/。\n\n\n/proc\n\n虚拟文件系统，内核和进程信息接口。\n比如 /proc/cpuinfo 查看 CPU 信息，/proc/meminfo 查看内存信息。\n\n\n/root\n\nroot 管理员的主目录（类似 /home/root）。\n\n\n/run\n\n存放系统运行时数据（PID 文件、socket 等）。\n系统重启后会清空。\n\n\n/srv\n\n存放一些服务（service）运行需要的数据，如 FTP、HTTP 服务器数据。\n\n\n/sys\n\n内核接口虚拟文件系统，提供硬件信息和控制。\n比如 /sys/class/net/ 可以看到网卡信息。\n\n\n/tmp\n\n临时文件目录，任何用户都可使用。\n重启后一般会被清空。\n\n\n/usr\n\n最庞大的目录，存放用户软件与资源。\n细分为：\n/usr/bin：用户程序\n/usr/sbin：管理员程序\n/usr/lib：库文件\n/usr/share：共享数据、文档、图标\n/usr/local：用户本地安装的软件\n\n\n\n\n/var\n\n存放可变数据（log 日志、缓存、邮件、数据库等）。\n例如：\n/var/log：系统日志\n/var/tmp：临时文件\n/var/www：网站文件（如果装了 Apache&#x2F;Nginx）\n\n\n\n\n总结\n\n小总结：\n\n程序相关：/bin /sbin /lib /usr /opt\n\n配置相关：/etc\n\n用户相关：/home /root\n\n运行相关：/proc /sys /dev /run /tmp\n\n数据相关：/var /srv /media /mnt\n### git1. 是什么   1. Git 是一个**分布式版本控制系统**，用于跟踪文件的变化，协调多人协作开发，管理项目的历史版本。   2. 核心概念      1. **仓库（Repository / Repo）**一个 Git 仓库就是项目文件加上其版本历史记录的集合。可以是本地仓库（Local Repository），也可以是远程仓库（Remote Repository，如 GitHub、GitLab 等）。      2. **提交（Commit）**每次对文件的修改，当你觉得可以保存一个版本时，就可以做一个“提交”。每个提交都有一个唯一的 SHA-1 哈希值，记录了该版本的所有更改内容及提交信息。      3. **分支（Branch）**分支是独立开发线，允许你在不影响主线（通常是 `main`或 `master`）的情况下进行新功能开发或修复。默认分支通常是 `main`或 `master`。      4. **工作区、暂存区、版本库         1. **工作区（Working Directory）**：你直接编辑的文件区域。         2. **暂存区（Stage/Index）**：通过 `git add`将要提交的变更放入暂存区。         3. **版本库（Repository）**：通过 `git commit`将暂存区的变更保存到本地仓库中。      5. **远程仓库（Remote）**托管在网络上的仓库，比如 GitHub 上的项目，可以通过 `git remote`进行关联。2. 常用命令   1. 配置 Git\n\n\n\n\n\n   git config –global user.name “你的名字”   git config –global user.email “你的邮箱”   &gt; 设置全局用户信息，每次提交都会记录是谁提交的。查看配置：   git config –list      ------2. 创建仓库   初始化一个新的 Git 仓库：   git init   克隆一个远程仓库：   git clone &lt;远程仓库地址&gt;\n例如：git clone https://github.com/username/repo.git      ------3. 查看状态与日志   查看当前仓库的状态（哪些文件被修改、暂存等）：\n   git status   查看提交历史：   git log\n简洁版日志   git log –oneline      ------4. 添加与提交   将工作区的修改添加到暂存区：   git add &lt;文件名&gt;\n例如：git add index.html添加所有修改的文件   git add .   提交暂存区的修改到本地仓库：   git commit -m “提交说明”      ------5. 分支操作   查看当前分支：   git branch   创建新分支：   git branch &lt;分支名&gt;   切换分支：   git checkout &lt;分支名&gt;\n或者使用更现代的命令   git switch &lt;分支名&gt;   创建并切换到新分支：   git checkout -b &lt;新分支名&gt;\n或   git switch -c &lt;新分支名&gt;   合并分支（通常在主分支上合并其他分支）：   git merge &lt;要合并的分支名&gt;   删除分支：   git branch -d &lt;分支名&gt;\n强制删除未合并的分支   git branch -D &lt;分支名&gt;      ------6. 与远程仓库交互   查看远程仓库：   git remote -v   添加远程仓库：   git remote add origin &lt;远程仓库地址&gt;   推送本地分支到远程：   git push -u origin &lt;分支名&gt;\n第一次推送时使用 -u 设置上游分支之后可以直接使用 git push   从远程拉取更新（拉取并尝试合并）：\n   git pull   从远程获取更新（不自动合并）：   git fetch      ------7. 撤销与回退   撤销工作区的修改（未 add）：   git checkout – &lt;文件名&gt;   撤销暂存区的修改（已 add 但未 commit）：   git reset HEAD &lt;文件名&gt;   回退到某个提交（谨慎使用！会修改历史）：   git reset –hard    查看所有提交记录，找到想要的 commit-id：   git log –oneline      ------8. 其他实用命令   比较差异：   git diff\n比较工作区和暂存区   git diff –staged\n比较暂存区和最新提交   储藏当前修改（临时保存，用于切换分支等场景）：\n   git stash   git stash pop   查看远程分支：   git branch -r   查看所有分支（本地+远程）：   git branch -a   ### maven1. 是什么   1. **Apache Maven** 是一个 项目管理和构建自动化工具，主要用于 Java 项目，但也可以用于其他语言的项目。   2. 它基于 项目对象模型（POM, Project Object Model） 的概念，通过一个名为 `pom.xml`的配置文件来管理项目的 构建、依赖、文档、报告、发布 等各个方面。2. 主要功能   1.    2. | 功能                                  | 说明                                                       |      | :------------------------------------ | :--------------------------------------------------------- |      | **依赖管理（Dependency Management）** | 自动下载和管理项目所需的第三方库（jar 包），无需手动导入。 |      | **标准化的项目结构**                  | Maven 规定了统一的目录结构，便于团队协作和工具支持。       |      | **构建生命周期（Build Lifecycle）**   | 定义了清晰的构建过程，如编译、测试、打包、部署等。         |      | **插件机制（Plugins）**               | 支持各种插件来扩展功能，如编译插件、打包插件、测试插件等。 |      | **多模块项目管理（Multi-module）**    | 支持将一个大项目拆分为多个子模块，便于管理和复用。         |      | **一键构建与部署**                    | 通过简单的命令即可完成编译、测试、打包、发布等操作。       |3. 核心概念   1. **POM（Project Object Model）**      1. Maven 项目的核心配置文件，名称固定为：`pom.xml`      2. 定义了项目的基本信息、依赖、插件、构建配置等。      3. 所有的 Maven 项目都围绕 POM 文件来管理。   2. **坐标（Coordinates）**      1. 每个依赖库（第三方 jar 包）都通过一组唯一标识来定位，称为 **Maven 坐标**，包括：         - **groupId**：组织或公司名，如 `org.springframework`         - **artifactId**：项目或模块名称，如 `spring-core`         - **version**：版本号，如 `5.3.10`           - 示例：           - ```xml             &lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;                 &lt;artifactId&gt;spring-core&lt;/artifactId&gt;                 &lt;version&gt;5.3.10&lt;/version&gt;             &lt;/dependency&gt;\n\n仓库（Repositories）\nMaven 从仓库中下载依赖包，分为：\n\n本地仓库（Local Repository）：在你电脑上的一个目录（默认是 ~/.m2/repository），存放已下载的 jar 包。\n中央仓库（Central Repository）：Maven 官方维护的远程仓库，地址是 https://repo.maven.apache.org，包含绝大多数开源 Java 库。\n私服（Nexus、JFrog 等）：企业内部搭建的 Maven 仓库，用于管理内部共享的 jar 包。\n\n\n构建生命周期（Build Lifecycle）\nMaven 的构建过程分为几个标准的生命周期阶段（Phases），常用的有：\n\n\n\n阶段\n说明\n\n\n\nvalidate\n验证项目是否正确，所需信息是否完整\n\n\ncompile\n编译源代码（通常是我们写的 java 代码）\n\n\ntest\n运行单元测试（使用 JUnit 等）\n\n\npackage\n打包，如生成 jar、war 文件\n\n\ninstall\n将打包结果安装到本地仓库，供其他项目使用\n\n\ndeploy\n将最终包发布到远程仓库（如 Nexus）\n\n\n\n\n\n\n\n你运行某个阶段时，Maven 会自动执行它之前的所有阶段。\n例如运行 mvn install，会依次执行 validate → compile → test → package → install。\n\n\n常用命令\n\n\n\n\n命令\n说明\n\n\n\nmvn clean\n清理 target 目录，删除之前构建的文件\n\n\nmvn compile\n编译主代码（src&#x2F;main&#x2F;java）\n\n\nmvn test\n编译并运行测试代码（src&#x2F;test&#x2F;java）\n\n\nmvn package\n打包项目，生成 jar&#x2F;war 文件（在 target&#x2F; 目录下）\n\n\nmvn install\n打包并安装到本地仓库，供其他项目依赖\n\n\nmvn deploy\n打包并发布到远程仓库（一般用于发布正式版本）\n\n\nmvn dependency:tree\n查看项目的依赖树，排查依赖冲突\n\n\nmvn help:effective-pom\n查看生效的 POM 配置（包含继承与默认配置）\n\n\n\n\n\nmaven默认项目结构\n\n\n\n\n用途\n目录\n说明\n\n\n\n源代码\nsrc/main/java\n项目的 Java 源代码\n\n\n资源文件\nsrc/main/resources\n配置文件，如 .properties, .xml等\n\n\n测试代码\nsrc/test/java\n单元测试代码，如 JUnit\n\n\n测试资源\nsrc/test/resources\n测试用的配置文件\n\n\n构建输出\ntarget/\n编译后的 class 文件、打包的 jar&#x2F;war 等都放在这里（自动生成）\n\n\n\n\n\npom文件解析\n\n\n\n\n元素\n是否必需\n说明\n\n\n\n&lt;project&gt;\n✅ 必需\n整个 POM 文件的根元素。\n\n\n&lt;modelVersion&gt;\n✅ 必需\nPOM 模型的版本，目前固定为 4.0.0。\n\n\n&lt;groupId&gt;\n✅ 必需\n项目所属的组织或公司，通常是反转的域名，如：com.example、org.springframework。\n\n\n&lt;artifactId&gt;\n✅ 必需\n项目&#x2F;模块的名称，通常是项目名，如：my-app、user-service。\n\n\n&lt;version&gt;\n✅ 必需\n项目的版本号，如：1.0.0、1.0-SNAPSHOT（SNAPSHOT 表示开发中的快照版本）。\n\n\n&lt;packaging&gt;\n❌ 可选，默认为 jar\n项目的打包方式，常见有： • jar（默认）：普通 Java 应用 • war：Web 应用 • pom：父模块（用于多模块管理）\n\n\n&lt;name&gt;\n❌ 可选\n项目名称，用于展示，非必须。\n\n\n&lt;description&gt;\n❌ 可选\n项目描述信息。\n\n\n&lt;dependencies&gt;\n❌ 可选\n定义项目所依赖的第三方库（jar 包）。\n\n\n&lt;dependency&gt;\n在 &lt;dependencies&gt;中使用\n每一个依赖项，包括 groupId、artifactId、version。\n\n\n&lt;build&gt;\n❌ 可选\n定义项目的构建配置，比如编译器版本、插件配置等。\n\n\n&lt;plugins&gt;\n在 &lt;build&gt;中使用\n定义要使用的 Maven 插件及其配置，如编译插件、打包插件等。\n\n\n\n项目坐标（GAV）\nMaven 通过以下三个属性来唯一标识一个项目，称为 GAV 坐标：\n\n\n\n元素\n说明\n示例\n\n\n\ngroupId\n项目所属组织，通常是反转域名\ncom.example、org.apache\n\n\nartifactId\n项目&#x2F;模块名称\nmy-app、spring-core\n\n\nversion\n项目版本\n1.0.0、2.5.4-SNAPSHOT\n\n\n\n这三个属性合起来就像项目的身份证，Maven 通过它们去仓库中找到对应的 jar 包或项目。\n\n\n\n依赖管理 &lt;dependencies&gt;\n通过 &lt;dependencies&gt;声明项目所需的第三方库，Maven 会自动从本地仓库或远程仓库下载这些依赖。\n示例：引入 JUnit（测试框架）\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13.2&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 表示只在测试时使用 --&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\nscope（作用域） 可选值：compile（默认）：编译、测试、运行都有效provided：编译和测试时有效，运行时由容器提供（如 Servlet API）runtime：运行和测试时有效，编译时不需要test：仅在测试代码中有效（如 JUnit）\n\n\n构建配置 &lt;build&gt;\n\n用于配置项目的构建过程，比如指定 Java 版本、使用特定插件等。\n示例：配置 Java 编译版本为 11\n\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;version&gt;3.11.0&lt;/version&gt;            &lt;configuration&gt;                &lt;source&gt;11&lt;/source&gt;                &lt;target&gt;11&lt;/target&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n这会告诉 Maven：“请使用 JDK 11 来编译我的代码”。\n\n\n属性（Properties）\n可以定义一些变量，便于统一管理版本号等。\n&lt;properties&gt;    &lt;java.version&gt;11&lt;/java.version&gt;    &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;\n\n\n\n开发框架SpringBootMyBatis数据存储MySQLMongoDB\n是什么\n非关系型数据库\n数据结构灵活，没有了“列”概念\n存储的单元叫“文档”（Document）\n\n\n\nRedis\n数据库和服务之间的中间件，用以提高并发量。\n本地缓存\n工作逻辑类比cache，工作原理K-V\n\n\n远程缓存\n业务逻辑需要多个实例。但是如果一个商品的多个实例都有缓存的话就浪费空间了。于是需要一个远程缓存。\n并发问题：通过单线程避免。\n\n\n支持多种数据结构：不只是string&lt;&#x3D;&gt;string，允许先进先出的List，去重的Set，排序的ZSet\n内存过期、内存淘汰：参考cache的淘汰策略\n持久化：\n需要避免当缓存重启后没有内存数据，让所有业务全部交给数据库导致崩溃。\n定期将缓存数据转储到磁盘文件中。\n\n\n简化网络协议\n\n中间件TomcatKafkaZooKeeperElasticSearch\n倒排索引（inverted index）\nterm index\n\n\n\nStored Fields\n存放文本本身的地方\n行式存储\n\n\nDoc Values\n将散落在文档中的某个字段集中存放（比如你要排序啥的）\n列式存储\n\n\nSegment\n对上面的信息的封装\n是能够实现搜索的最小单元\nsegment只读，不可修改。如果要修改，则生成新的segment。这样做避免了并发写带来的低效。\n\n\nLucene：\n一个开源基础搜索库，单机文本搜索库\n\n\nElastic Search\n对Lucene扩展之后，得到了高并发高可用持久化的分布式搜索引擎\n\n\n\n部署运维Docker\nDocker是什么？\n\n是一个 容器化平台（一个客户端和服务端的中间件），可以把你的应用程序和它所依赖的环境（运行时、库、配置）打包成一个 镜像（image），然后运行在一个轻量级的 容器（container） 里。\n和虚拟机不同，Docker 容器不需要完整的操作系统，而是共享宿主机的内核。\n\n\n镜像是什么？\n\n程序的运行依赖于环境，而操作系统是环境的重要部分。操作系统分为用户空间和内核空间，运行程序只需要关注用户空间。\n为了能运行程序，docker把程序所依赖的环境一起打包，“压缩”成一个“压缩文件”，称为镜像。\n\n\n容器是什么？\n\n镜像通过docker run把镜像“解压缩”之后的一个独立的环境和程序。\n一个操作系统内核可以运行多个容器\n\n\nDockerfile是什么？\n\n从安装镜像到程序运行中间还有一些准备工作要做，就像制定镜像、创建文件夹之类的。而Linux中所有任务都可以通过命令行实现，所以用Dockerfile把准备工作列出来，像一个ToDoList，然后交给程序运行。\n\n\nregistry是什么？\n\n管理镜像仓库推拉能力的服务。\n\n\ndocker的架构原理：client-server架构\n\nclient：docker-cli（我们在命令行输入的命令就是docker-cli）\n常见命令：\ndocker build：docker会根据Dockerfile指令一层层构建容器镜像文件\ndocker push &#x2F; pull：docker会通过外部registry交互推拉镜像文件\ndocker run：会调用Containerd组件来驱使runC组件来创建和运行容器\n\n\n\n\nserver：docker daemon（守护进程）\n核心职责：解析命令，创建和管理各个容器。\ndocker daemon可以分为docker server（就是一个HTTP服务器），Engine（用于指派Job），Job（实际执行各种工作）\n\n\n\n\ndocker compose是什么\n\n如果说docker是管理一个容器，则docker compose是管理多个容器\n需要部署一套多个容器时，一个个docker run很不方便。\n可以通过yaml文件写清楚要部署的文件有哪些，部署顺序，占多少cpu等等。\n最后通过docker-compose up命令自动化部署\n\n\ndocker swarm是什么\n\n如果说docker compose是管理一套服务多个容器，docker swarm就是管理多套服务和多个服务器。\n如果某台服务器炸了，那么就把上面的服务迁移到另外一套服务器上。\n也可以根据需要对服务扩缩容。\n\n\ndocker和k8s的关系\n\nk8s原来是docker swarm的竞品（）功能很像。\ndocker compose &lt;&#x3D; 类比 &#x3D;&gt; Pod\ndocker swarm &lt;&#x3D; 类比 &#x3D;&gt; k8s\n\n\n常用命令\n\n镜像（Image）管理\n***docker pull ubuntu:22.04         # 拉取镜像***docker images                    # 列出本地镜像***docker rmi &lt;image_id&gt;            # 删除镜像*docker tag &lt;image_id&gt; myapp:v1   # 给镜像打标签*docker build -t myapp:v1 .       # 用 Dockerfile 构建镜像docker save -o &lt;image_id&gt; filename.tar         # 保存镜像为.tar文件docker load -i &lt;image_id&gt; filename.tar\n\n\n容器（Container）管理\ndocker run -it ubuntu:22.04 bash   # 运行交互式容器并进入 bash***docker run --name=my_nginx_01 --restart=always -d -p 8080:80 nginx     # 后台运行 nginx，映射端口***docker ps                          # 查看正在运行的容器**docker ps -a                       # 查看所有容器（包括已退出）***docker stop &lt;container_id&gt;         # 停止容器***docker start &lt;container_id&gt;        # 启动已停止的容器***docker restart &lt;container_id&gt;      # 重启容器***docker rm &lt;container_id&gt;           # 删除容器**docker exec -it &lt;id&gt; bash          # 进入正在运行的容器docker logs -f &lt;container_id&gt;      # 查看容器日志（实时跟随）docker cp &lt;id&gt;:/path /path    # 把容器内的内容复制出来。也可以交换路径顺序，表示复制进去。\n\n\n 日常组合示例\n# 拉取 Nginx 并运行docker run -d --name web -p 8080:80 nginx# 构建并运行本地项目docker build -t myapp:v1 .docker run -d -p 5000:5000 myapp:v1\n\n\n\nJenkinsNginx\n是一个高性能 Web 服务器和反向代理服务器（一个客户端和服务端的中间件）。\nnginx 的主要功能\nWeb 服务器\n可以直接提供静态资源（HTML、CSS、JS、图片等）。\n\n\n反向代理 &#x2F; 负载均衡\n接收用户请求，然后把请求转发给后端（如 Node.js、Java、Python 应用）。\n可以把流量分配给多台后端服务器，实现负载均衡。\n\n\n缓存功能\n静态资源缓存，减少后端压力。\n\n\n模块化网管能力\nSSL&#x2F;TLS\n可以做 HTTPS 加密终端，统一管理证书。\n\n\n高并发\n基于事件驱动（epoll&#x2F;kqueue），能轻松支撑上万并发连接。\n多进程（Worker），每个进程单线程。\n\n\nMaster进程\n\n\n\nk8s\nk8s是什么\n\nKubernetes（简称 K8s）是一个容器编排系统，主要用来自动管理大量的 Docker 容器\n介于应用服务和服务器之间\n通过yaml文件配置定义应用的部署顺序等信息，自动部署各个应用到服务器上\n能自动扩缩容\n能够在服务器炸了之后自动把应用部署到其他服务器\n\n\nk8s的架构原理\n\nk8s会把服务器分为两部分：控制平面和Node。前者控制后者，后者执行具体应用\n\n控制平面：\n\nAPI Server：通过接口操作服务器资源，而不需要具体登录到各个服务器。\nScheduler：自动化决策服务器的cpu和内存是否能够部署应用\nController Mgt：自动化创建、关闭服务\nETCD：存储层。上面过程中产生的数据存到这里。\n\n\nNode：\n\n可以是真机服务器，也可以是虚拟机\n\n多个应用服务共享一台Node的内存和CPU。\n\n不用手动上传代码，而是把代码打包为容器镜像，然后通过简单的命令部署。\n\nKubelet：用于接受控制命令，管理Pod。\n\nKube Proxy：用于网络通讯，可以联系Node内外的应用\n\nContainer runtime：用于下载和部署镜像\n\nPod：应用容器、日志容器、监控容器组成一个Pod。pod运行在Node上。k8s可以调度Pod。\n\nPod是k8s的最小调度单位\n\n\n\n\n工作负载：\n\nCluster（集群）\n\n控制平面和Node组成了Cluster\n一般在公司中会有多个集群，比如开发集群、测试集群。\n通过Ingress控制器把器群的服务暴露给外部\n\n\nkubectl\n\n是命令行工具，封装好了控制k8s控制平面的命令\n如何使用kubectl\n编写yaml文件，定义Pod里用了哪些镜像，占用多少内存和cpu等信息\n通过kubectl apply -f XXX.yaml命令应用配置。\n剩下的交给k8s就好了。至此就完成了一个Pod的部署。\n\n\n\n\nConfigMap：配置集\n\nSecret：用来存储敏感信息的\n\n如何调用服务呢\n\n以前不用k8s，一个HTTP请求会到达nginx，然后到达服务器，然后返回响应\n现在用k8s，请求会先到Ingress控制器，然后到Kube Proxy，找到对应的Pod服务，然后转发到对应的容器服务，并返回响应。\n\n\n\n\nk8s指令\n\n# 创建pod\nkubectl run my-nginx --image=nginx:1.25.2 --port=80\n\n\n# 查看集群所有节点\nkubectl get nodes\n\n# 应用配置文件，创建资源\nkubectl apply -f xxxx.yaml\n\n# 查看集群中部署了哪些应用\nkubectl get pods -A\n\n# 修改镜像\nkubectl set image &lt;资源类型&gt;/&lt;资源名&gt; &lt;容器名&gt;=&lt;镜像地址:tag&gt; -n &lt;命名空间&gt;\n\n# 创建、删除命名空间\nkubectl create\\delete ns &lt;namespace&gt;\n\n# 查看状态\nkubectl describe pod &lt;pod_name&gt;\n\n# 每个pod都会分配一个IP，使用pod的ip+port即可访问\nkubectl get pod -owide\n\n# \n\n4. 四个组件的关系   1. ```          +----------------+          |   Deployment   |          |  (nginx-app)   |          +----------------+                   |                   |  创建 &amp; 管理                   v          +----------------+          |   ReplicaSet   |          | (nginx-rs-xxx) |          +----------------+                   |             ---------------------------------             |                               |             v                               v         +----------------+             +----------------+         |      Pod       |             |      Pod       |         | (nginx-xxx-1)  |             | (nginx-xxx-2)  |         |  Container:    |             |  Container:    |         |  nginx         |             |  nginx         |         +----------------+             +----------------+                 ^                               ^                 |                               |                 |  Selector: app=my-nginx-03    |                 |                               |                 +-------------+-----------------+                               |                               v                      +----------------+                      |    Service     |                      | (NodePort 30080)|                      +----------------+                               |                     外部访问：http://&lt;NodeIP&gt;:30080\n\n\n\n\n\n分布架构SpringCloudDubbo详解Spring详见其他笔记\nRedis概述\n是什么\nRedis（Remote Dictionary Server）是一个基于内存的键值存储系统，支持多种数据结构，可以用作：\n缓存（最常见用途）\n数据库（持久化场景）\n消息中间件（如消息队列、事件发布订阅）\n\n\nRedis 的特点回顾（简要）\n内存存储，读写速度极快（微秒级响应）\n单线程模型（Redis 6.0 前完全单线程，之后部分模块如网络 IO 支持多线程）\n支持丰富的数据结构：String、Hash、List、Set、Sorted Set（ZSet）\n支持数据持久化（RDB、AOF）\n支持主从复制、哨兵、集群等高可用方案\n命令原子性，支持事务与 Lua 脚本\n\n\n\n\n\n数据结构\nString（字符串）\n\n概述\n\n最基本的数据类型，一个 key 对应一个 value。\nValue 可以是字符串、数字或二进制数据（如图片、序列化对象）。\n最大支持 512MB。\n\n\n常用命令：\n\n\nSET key valueGET keyINCR key          # 数字自增，常用于计数器DECRINCRBYAPPENDMSET / MGET       # 批量设置/获取EXPIRE key seconds  # 设置过期时间\n\n\n应用场景：\n\n缓存数据（如用户信息 JSON）\n\n计数器（如文章阅读量、点赞数）\n\n分布式锁（SETNX）\n\n\n\n\n\n\nHash（哈希表）\n\n概述\n\n类似于 Map 结构，一个 key 对应一个字段-值对的集合。\n适合存储对象，比如用户信息、商品详情等。\n\n\n常用命令：\n\n\nHSET user:1 name &quot;Tom&quot; age 25HGET user:1 nameHGETALL user:1HKEYS / HVALSHINCRBY\n\n\n优点：\n\n相比将整个对象序列化为 String，Hash 可以只修改部分字段，更高效。\n\n节省内存（Redis 对小 Hash 有特殊优化）。\n\n\n\n\n\n\nList（列表）\n\n概述\n\n一个 key 对应一个双向链表，支持从头部或尾部插入&#x2F;删除元素。\n适合实现：最新消息、消息队列、文章评论列表等。\n既可以当做栈来用，也可以按照队列来用\n\n\n常用命令：\n\n\nLPUSH myList &quot;a&quot;  # 头部插入RPUSH myList &quot;b&quot;  # 尾部插入LPOP / RPOP       # 头/尾弹出LRANGE myList 0 -1  # 获取全部元素LLEN\n\n\n应用场景：\n\n消息队列（结合 LPOP&#x2F;RPOP 或 BRPOP）\n\n最新 N 条记录（如最新评论、动态）\n\n\n\n\n\n\nSet（集合）\n\n概述\n\n无序、唯一的字符串集合。\n支持交集、并集、差集等操作，适合标签、共同关注等场景。\n\n\n常用命令：\n\n\nSADD tags &quot;redis&quot; &quot;db&quot;SMEMBERS tagsSISMEMBER tags &quot;redis&quot;SINTER set1 set2  # 交集SUNIONSDIFF\n\n\n应用场景：\n\n标签系统\n\n好友共同关注\n\n去重统计（结合客户端）\n\n\n\n\n\n\nSorted Set（ZSet，有序集合）\n\n概述\n\n集合的升级版，每个元素都关联一个 score（分数），根据 score 排序。\n元素唯一，但 score 可重复。\n\n\n常用命令：\n\n\nZADD leaderboard 100 &quot;Alice&quot; 200 &quot;Bob&quot;ZRANGE leaderboard 0 -1          # 按 score 升序获取ZREVRANGE leaderboard 0 -1       # 降序ZSCORE leaderboard &quot;Alice&quot;ZINCRBY leaderboard 10 &quot;Alice&quot;\n\n\n应用场景：\n\n排行榜（游戏、热搜榜）\n\n优先级队列\n\n延迟队列（结合 score 为时间戳）\n\n\n\n\n\n\n线程模型\nRedis 6.0 之前：完全单线程（主线程处理所有客户端请求、命令执行、持久化等）\nRedis 6.0 之后：引入多线程 I&#x2F;O（处理网络读写），但命令执行仍然是单线程目的是提高网络吞吐，缓解高并发下的网络瓶颈，但核心数据操作依旧保持原子性。\n\n\n✅ 所以，Redis 依然可以认为是单线程模型（命令执行层面），无需考虑锁竞争，执行效率高。\n\n持久机制Redis 默认是内存数据库，但支持将数据保存到磁盘，避免重启后数据丢失。\n\nRDB（Redis DataBase）\n\nRDB 触发方式\n\n手动触发（主动保存）\n\n命令：SAVE或 BGSAVE``SAVE：同步执行，会阻塞 Redis 主线程，不推荐生产使用\nBGSAVE：异步执行，Redis 会 fork 一个子进程在后台生成 RDB 文件，主线程不受影响（推荐）\n\n\n自动触发（通过配置规则）\n\n\nRedis 允许通过配置文件设置自动快照规则，例如：\nsave 900 1       # 900秒内至少有1个key被修改，就触发一次 RDBsave 300 10      # 300秒内至少10个key被修改save 60 10000    # 60秒内至少10000个key被修改\n\n\n只要满足其中任意一条规则，Redis 就会在后台通过 BGSAVE自动保存一次 RDB 快照。\n\n\n\nRDB 的优点\n\n\n\n优点\n说明\n\n\n\n✅ 恢复速度快\nRDB 是数据快照，文件小，Redis 启动时加载 RDB 比 AOF 快很多\n\n\n✅ 文件体积小\n只保存某一时刻的数据，而非所有操作命令\n\n\n✅ 适合备份与灾难恢复\n可以定期将 RDB 文件拷贝到其他服务器或云存储，用于容灾\n\n\n\n\nRDB 的缺点\n\n\n\n缺点\n说明\n\n\n\n❌ 可能丢失数据\nRDB 是定时快照，如果 Redis 在两次快照之间宕机，这段时间的数据会丢失\n\n\n❌ fork 子进程开销\nBGSAVE 会 fork 一个子进程，如果数据量很大，fork 可能会阻塞主线程（特别是大内存实例）\n\n\n❌ 不适合实时性要求极高的场景\n不如 AOF 安全\n\n\n\n\n\nAOF（Append Only File）\n\nAOF 工作流程\n\n客户端执行一个写命令（如 SET key value）\n\nRedis 不仅将数据写入内存，还会将该命令追加到 AOF 缓冲区\n\n根据配置的同步策略，将缓冲区内容写入磁盘的 AOF 文件\n\nRedis 重启时，会重新加载并执行 AOF 文件中的命令，恢复数据\n\nAOF 配置选项（同步频率）\n在 redis.conf 中，可以通过以下参数控制 AOF 的写入磁盘策略（即命令同步到磁盘的时机）：\n\n\n\n配置项\n说明\n安全性\n性能\n\n\n\nappendfsync always\n每个写命令都同步到磁盘\n✅ 最安全，几乎不丢数据\n❌ 性能最差\n\n\nappendfsync everysec（默认）\n每秒同步一次\n⚠️ 最多丢失 1 秒的数据\n✅ 性能较好，推荐\n\n\nappendfsync no\n由操作系统决定何时同步\n❌ 可能丢失较多数据\n✅ 性能最好\n\n\n\n✅ 生产环境推荐使用：appendfsync everysec（折中方案，安全且性能较好）\n\n\nAOF 的优点\n\n\n\n优点\n说明\n\n\n\n✅ 数据安全性更高\n记录了所有写操作，最多只丢失 1 秒的数据（取决于配置）\n\n\n✅ 可修复\nAOF 文件损坏时，Redis 提供 redis-check-aof工具可以尝试修复\n\n\n✅ 更适合数据重要性高的场景\n比 RDB 更可靠\n\n\n\nAOF 的缺点\n\n\n\n缺点\n说明\n\n\n\n❌ 文件体积大\n记录了所有写命令，尤其是数据量大或频繁更新时，AOF 文件会膨胀\n\n\n❌ 恢复速度慢\n启动时要重新执行所有命令，比加载 RDB 慢\n\n\n❌ 写放大\n同一个数据多次修改会产生多条命令\n\n\n\n\nAOF 重写（AOF Rewrite）\n随着时间推移，AOF 文件会越来越大。为了解决这个问题，Redis 提供了 AOF 重写机制：\n\n作用： 对 AOF 文件进行“瘦身”，去掉冗余命令，用最终的数据状态重写一个新的、更小的 AOF 文件\n\n命令： BGREWRITEAOF（后台异步执行）\n\n触发方式： 可配置自动触发策略，如：\nauto-aof-rewrite-percentage 100  # 当前 AOF 文件比上次重写后增长了 100%auto-aof-rewrite-min-size 64mb   # AOF 文件至少达到 64MB 才触发\n\n\n\n\n\n高可用与扩展（集群策略）\n主从复制（Master-Slave Replication）\n\n核心思想：\n\n允许一个 Master（主节点） 可以有多个 Slave（从节点），从节点会异步复制主节点上的数据，实现数据的备份、读写分离、负载均衡。\n\n\n架构与原理\n\nMaster：负责写操作（也可读），数据变更后异步同步给 Slave。\nSlave：只读（也可配置为可写，但不推荐），从 Master 拉取数据，保持同步。\n\n\n数据同步方式：\n\n全量同步（初次同步）：Slave 第一次连接 Master 时，Master 会生成 RDB 快照并发送给 Slave，然后同步增量命令。\n\n增量同步：后续 Master 的写操作会以命令的方式发送给 Slave，保持数据一致。\n\n\n\n特点与作用\n\n\n\n\n\n特点\n说明\n\n\n\n✅ 读写分离\nMaster 写，Slave 读，分担读压力\n\n\n✅ 数据备份\nSlave 是 Master 的数据副本，可用于容灾\n\n\n❌ 无自动故障转移\n如果 Master 宕机，需要手动切换 Slave 为 Master\n\n\n❌ 无自动负载均衡\n需要客户端或代理层实现读请求分发\n\n\n\n优点\n\n简单易用，配置方便\n\n数据冗余，提高可用性\n\n支持读扩展（多个 Slave 分担读负载）\n\n\n\n缺点\n\n不具备高可用性：Master 宕机后，整个集群不可写，需人工干预\n\n数据一致性是最终一致（异步复制，Slave 数据可能有延迟）\n\n无自动 Failover（故障切换）能力\n\n\n\n\n\n哨兵模式（Sentinel）\n\n核心思想：\n\n在 主从复制的基础上，引入 Sentinel（哨兵）进程，用于 监控 Redis 主从节点的健康状态，并在 Master 宕机时自动进行故障转移（Failover），选举新的 Master，实现高可用性。\n\n\n架构组成\n\nMaster：主节点，负责写操作\nSlave：从节点，复制 Master 数据\nSentinel（哨兵）：独立的 Redis 进程（或线程），不存储数据，用于监控 + 故障转移\n\n\n\n\n通常部署 至少 3 个 Sentinel 节点（避免脑裂），它们共同监控 Redis 节点并协作决策。\n\n\nSentinel 做了什么？\n\n\n\n\n功能\n说明\n\n\n\n✅ 监控\n持续检查 Master 和 Slave 是否正常运行\n\n\n✅ 自动故障转移\n当 Master 宕机，Sentinel 会选举出一个 Slave 作为新 Master，并通知其他 Slave 复制新 Master\n\n\n✅ 通知\n通过 API 或消息告知客户端 Master 发生了变更\n\n\n✅ 配置提供者\n客户端可以从 Sentinel 获取最新的 Master 地址\n\n\n\n\n\n\n优点：\n\n  - **自动故障转移**（High Availability）\n\n  - **自动发现与通知**（客户端可感知新 Master）\n\n  - 仍然支持 **读写分离 &amp; 读扩展**\n\n\n缺点：\n\n不支持自动扩容 &#x2F; 数据分片：数据仍然全部存在一个 Master 上，无法解决大数据量存储问题\n\nSentinel 本身不存储数据，只是协调者\n\n客户端需要支持 Sentinel 感知机制，或使用支持 Sentinel 的 Redis 客户端 SDK\n\n\n\n集群模式（Redis Cluster）\n\n核心思想：\nRedis 官方推出的分布式集群解决方案，支持 数据自动分片（Sharding）、高可用、多主多从、横向扩展，是生产环境 大规模数据 + 高并发 + 高可用 场景下的首选架构。\n\n\n核心特性\n\n\n\n\n\n\n特性\n说明\n\n\n\n✅ 数据分片（Sharding）\n数据按哈希槽（16384 个 slot）分片，分散存储在多个主节点上\n\n\n✅ 多主多从\n每个分片是一个 主从结构，主节点负责写，从节点负责备份与故障切换\n\n\n✅ 高可用\n如果某个主节点宕机，其从节点会被 自动提升为主节点\n\n\n✅ 客户端直连\n客户端可以直接连接集群节点，支持智能路由\n\n\n✅ 横向扩展\n可通过增加节点来扩展存储容量与并发能力\n\n\n\n数据分片原理（16384 个 Slot）\n\nRedis Cluster 将所有的数据分成 16384 个哈希槽（hash slot）\n\n每个 Key 通过 CRC16(key) % 16384 计算出所属的 Slot\n\n每个 主节点负责一部分 Slot（比如节点 A 负责 05000，节点 B 负责 500110000…）\n\n客户端访问时，Redis 会告诉客户端应该去哪个节点操作\n\n\n\n高可用实现\n\n每个主节点可以有 1 个或多个从节点\n\n如果某个主节点宕机，其对应的 从节点会通过选举成为新的主节点（类似哨兵的故障转移，但是集群内置）\n\n如果某个节点完全宕机且无从节点，则对应的 Slot 不可用\n\n\n\n优点\n\n支持海量数据存储（通过分片）\n支持高并发（多节点共同承担）\n自动故障转移（内置，无需 Sentinel）\n横向可扩展（可动态增加节点）\n官方原生支持，无需第三方组件\n\n\n缺点\n\n架构复杂，部署和运维成本较高\n不支持多 Key 操作（除非这些 Key 在同一个 Slot，可使用 Hash Tag\n事务操作受限（跨节点事务不支持）\n需要客户端支持 Cluster 协议（或使用代理）\n\n\n\n三种集群策略 对比总结\n\n\n\n对比维度\n主从复制\n哨兵模式\nRedis Cluster（集群）\n\n\n\n数据复制\n✅ Master → Slave\n✅ Master → Slave\n✅ 每个主节点有从节点，支持复制\n\n\n读写分离\n✅ 支持\n✅ 支持\n✅ 支持（主写从读）\n\n\n高可用（自动 Failover）\n❌ 不支持\n✅ 支持（Sentinel）\n✅ 支持（内置）\n\n\n数据分片 &#x2F; 扩展性\n❌ 不支持\n❌ 不支持\n✅ 支持（16384 slots，多主多从）\n\n\n数据存储能力\n❌ 单机限制\n❌ 单机限制\n✅ 海量数据，可扩展\n\n\n复杂度\n低\n中等\n高（需理解分片、路由等）\n\n\n适用场景\n读多写少、简单备份\n中小应用、要求高可用\n大数据、高并发、生产级集群\n\n\n\n事务\n事务（Transaction）\n\n使用 MULTI、EXEC、DISCARD、WATCH实现。\n\n将多个命令打包，按顺序执行，但不保证原子性（中间可能被其他客户端打断）\nWATCH 可以实现乐观锁。\n\n\n实现原理\n\nRedis 的事务提供了一种将多个命令打包，然后一次性、按顺序执行的机制。它的实现主要依赖三个核心命令：MULTI、EXEC 和 DISCARD。\n\n启动事务：MULTI\n\n当客户端发送 MULTI 命令时，Redis 会将该客户端的状态从非事务模式切换到事务模式。\n在此之后，客户端发送的任何命令（除了 EXEC、DISCARD、WATCH 等少数几个命令）都不会立即执行。\n相反，这些命令会被放入一个命令队列中，等待后续执行。\nRedis 只是简单地回复 QUEUED，表示命令已成功入队。\n\n\n执行事务：EXEC\n\n当客户端发送 EXEC 命令时，Redis 事务正式开始执行。\nRedis 会将命令队列中的所有命令按顺序、原子性地一次性执行完毕。\n执行完后，Redis 会将每个命令的执行结果按顺序打包成一个列表（Array）返回给客户端。\n客户端退出事务模式。\n\n\n取消事务：DISCARD\n\n如果客户端在 MULTI 之后，但在 EXEC 之前发送 DISCARD 命令，Redis 会清空命令队列。\n客户端退出事务模式，所有已入队的命令都不会被执行。\n\n\n监控键值：WATCH \n\n命令用于监视（Watch）一个或多个键。它的核心机制可以概括为一句话：\n如果在 WATCH 之后，到 EXEC 执行之前，任何被监视的键发生了修改，那么整个事务将被取消（EXEC 返回空）。\n当 EXEC 失败（返回空响应）时，客户端程序就知道事务执行失败了，因为它依赖的底层数据已经被修改，必须：\n清除监视： 自动或手动（通过 UNWATCH 命令）清除当前的监视状态。\n重试： 从第 1 步重新开始整个操作流程（重新 WATCH，重新读取数据，重新计算，重新 EXEC）。\n\n\n\n\n\n\n\n\n错误处理\n\n入队时发现的错误（Syntax Error）\n如果在 MULTI 和 EXEC 之间，客户端发送了一个格式错误（如拼写错误、参数数量错误等）的命令，Redis 会在入队时就发现这个错误。\n在这种情况下，Redis 会拒绝执行整个事务队列，当执行 EXEC 时，所有命令都不会被执行。\n\n\n执行时发现的错误（Runtime Error）***\n如果在 EXEC 执行过程中，某个命令因为操作了错误的数据类型等原因而执行失败（Runtime Error），Redis 不会回滚（Rollback） 已经执行成功的命令。\n事务中其他执行成功的命令仍然会生效，只有失败的命令返回错误信息。\n这是 Redis 事务与关系型数据库事务最大的区别之一。 Redis 强调的是简单和高性能，它不会为了支持回滚而引入额外的复杂性。\n\n\n\n\n并发控制\n\n为了解决事务过程中数据被其他客户端修改的问题，Redis 引入了 WATCH 命令，实现了乐观锁（Optimistic Locking）：\nWATCH key [key ...]: 客户端在 MULTI 之前使用 WATCH 监视一个或多个键。\n执行事务: 客户端执行 MULTI，然后发送命令入队。\n检查: 当客户端执行 EXEC 时，Redis 会检查所有被 WATCH 监视的键。\n失败: 如果在 WATCH 之后到 EXEC 之前，任何一个被监视的键被其他客户端修改了，那么整个事务将被中断和取消，EXEC 命令会返回一个空结果（Null Reply）。\n重试: 客户端需要重新 WATCH 键，并重新执行整个事务流程。\n\n\n\n\nACID\n\n原子性如何实现？Redis没有回滚机制，是否破坏了原子性？\n\n我们说原子性是在事物进行过程中不会进行CPU调度，导致事务被打断\n在Redis事务中，如果遇到运行时错误，Redis仍然会继续执行后面的命令，那么事务并没有被打断，仍然可以认为保证了原子性\n虽说不满足传统意义的原子性，但是确实保证了事务不会被打断。\n并且运行时错误多为编程错误，可以避免。\n\n\n一致性如何实现？\n\n内部一致性： Redis 保证其内部数据结构的操作是正确的，并且其单线程模型确保了数据结构本身不会出现损坏。\n事务隔离性： I 的保证间接支撑了 C，因为事务在执行过程中不会被其他客户端操作干扰，确保事务完成时，系统从一个有效状态转移到另一个有效状态。\n\n\n隔离性如何实现？\n\nRedis 对隔离性的保证是非常强大的，因为它基于单线程模型。\n保证方式： Redis 使用 单线程 模型处理所有客户端请求（除了后台的持久化操作）。\n结果： MULTI&#x2F;EXEC 事务在执行过程中，不会被其他客户端的命令打断。事务队列中的所有命令都会被原子性地连续执行。\n总结： Redis 实现了最高级别的事务隔离性，即串行化（Serializability）——在事务执行期间，其他操作完全隔离。\n\n\n持久性如何实现？\n\nRedis 提供了多种机制来实现持久性，但需要用户根据需求进行配置，默认情况下持久性是有风险的。\n\nRedis 主要通过两种方式实现持久性：\n\nAOF (Append Only File) 模式：\n将所有写命令以日志形式追加到文件中。\n如果配置了 always 模式（每条命令都同步到磁盘），则可以实现接近于 RDBMS 的持久性。\n但为了性能，通常配置为 everysec（每秒同步一次），这意味着最近一秒内的数据可能会丢失。\n\n\nRDB (Redis Database) 快照模式：\n定期将内存中的数据生成一个二进制快照文件。\n由于是定期快照，最近一次快照之后的所有数据都可能在系统崩溃时丢失。\n\n\n\n\n总结： Redis 的持久性是可配置的。只有在启用 AOF 并设置为 always 同步时，才能最大限度地保证 Durability，但这样做会牺牲写入性能。\n\n\n\n\n\n\n\n\n\nLua 脚本\n是什么\nLua 是一种轻量级、高效、可嵌入的脚本语言，可作为编程语言的扩展语言，被广泛的运用到Redis脚本中\n\n\n在Redis中的应用\n原子性操作\nRedis 执行 单个命令是原子性的，但多个命令组合在一起 默认不是原子性 的（中间可能被其他客户端的命令插入）。\n把多个命令封装进一个 Lua 脚本，Redis 会一次性、按顺序执行脚本里的所有命令，不会被其他操作打断，保证原子性。\n\n\n减少网络开销\n如果你要执行多个 Redis 命令，通常需要多次网络往返。\n使用 Lua 脚本，可以把多个命令一次性发送到 Redis 服务端执行，只需一次网络通信，提高效率。\n\n\n复杂业务逻辑\n有些业务逻辑比较复杂，比如“先判断再修改”、“循环操作”、“带条件的多键操作”等，用 Lua 脚本可以在服务端高效完成。\n\n\n实现分布式锁、计数器、限流等高级功能\n像 Redis 分布式锁的正确释放（判断 value 一致再 DEL）\n限流算法（如令牌桶、漏桶）\n排行榜加分、扣分逻辑都可以用 Lua 脚本优雅地实现。\n\n\n\n\n\n过期策略与内存淘汰机制\n过期策略\n可以给 Key 设置过期时间：EXPIRE key seconds\n\nRedis 采用以下两种方式清理过期 Key：\n\n定期删除：每隔一段时间随机抽取一些 key 检查是否过期\n惰性删除：当访问某个 key 时，检查是否过期，如果过期则删除\n\n\n\n\n\n\n⚠️ 过期不会立即释放内存，而是惰性或定期清理。\n\n\n内存淘汰机制（maxmemory-policy）\n\n当 Redis 内存达到上限时，根据策略删除部分 key，常见策略包括：\n\nnoeviction（默认）：不删除，写入报错\nallkeys-lru：从所有 key 中淘汰最近最少使用的\nvolatile-lru：只从设置了过期时间的 key 中淘汰\nallkeys-random &#x2F; volatile-random：随机淘汰\nallkeys-ttl：优先淘汰快过期的\n\n\n生产环境推荐使用：allkeys-lru 或 volatile-lru\n\nRedis实现分布式锁\n概述\n\n在分布式系统中，多个进程或服务（可能运行在不同的服务器上）可能会同时尝试访问共享资源（如数据库、文件、缓存等），为了保证数据一致性，我们需要一种跨进程&#x2F;服务的互斥机制，这就是 分布式锁（Distributed Lock）。\n在分布式系统中，传统的线程锁（如 Java 的 synchronized、ReentrantLock）只能在单个 JVM 内起作用，无法跨进程、跨服务器工作。而 Redis 是一个高性能的、支持网络访问的、内存数据库，天生适合用来实现跨服务的锁机制。\n注意是用Redis实现一个分布式锁，而不是Redis内部机制（毕竟Redis是单线程的，不用考虑分布式锁）\n\n\n工作原理\n\n使用 Redis 的 SET key value NX PX timeout命令，来实现：\n\n互斥性（Mutual Exclusion）：同一时刻只有一个客户端能成功设置锁\n避免死锁：锁必须要有过期时间，防止客户端崩溃后锁永远不释放\n锁的释放必须是原子的且只能由加锁者释放：通过 value（唯一标识，如 UUID）来判断，避免误删别人的锁\n\n\n释放锁（必须验证锁是自己的！！）\n\n不能直接用 DEL lockKey，因为：\n如果 A 加了锁，但锁过期了，B 获取到了锁\n此时 A 的业务还没执行完，但锁已经失效，A 还去执行 DEL，就会把 B 的锁删掉 ❌\n\n\n正确做法：使用 Lua 脚本保证原子性，校验 value 一致才删除\nLua 脚本如下：\n\n\n\nif redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then    return redis.call(&quot;del&quot;, KEYS[1])else    return 0end\n\n\nKEYS[1]是锁的 key，比如 order_lock_123\nARGV[1]是加锁时设置的唯一标识（requestId &#x2F; UUID）\n\n\n\n\n实现方式\n\n命令格式：\nSET lock_key unique_value NX PX 30000\n\n参数解释：\n\n\n\n参数\n含义\n\n\n\nlock_key\n锁的名称，比如 order_lock_123\n\n\nunique_value\n唯一标识，通常是 UUID 或 客户端生成的随机字符串，用于标识锁的持有者\n\n\nNX\n仅当 key 不存在时才设置成功（保证互斥）\n\n\nPX 30000\n设置锁的过期时间，单位毫秒（这里是 30 秒），防止死锁\n\n\n\n\n\n\n常见问题与优化建议\n\n\n问题\n本质\n原因\n解决方案关键词\n\n\n\n缓存穿透\n查询了不存在的数据，每次都访问 DB\n恶意&#x2F;错误查询、缓存没有拦截\n布隆过滤器、缓存空对象\n\n\n缓存击穿\n热点 key 突然失效，大量请求直达 DB\n单个热点 key 过期，高并发访问\n永不过期（逻辑过期）、互斥锁\n\n\n缓存雪崩\n大量 key 同时失效 &#x2F; Redis 宕机，DB 崩溃\n过期时间集中、Redis 故障\n随机过期、多级缓存、高可用、熔断\n\n\n\n缓存穿透\n\n查询一个不存在的数据，导致每次都访问数据库。\n\n解决方案：\n\n布隆过滤器\n\n布隆过滤器是一种空间效率极高、用于判断某个元素是否可能存在于集合中的数据结构。\n\n在缓存层或应用启动时，将所有合法的数据 key 提前加载到布隆过滤器中\n当用户查询某个 key 时，先经过布隆过滤器判断：这个 key 是否可能存在如果布隆过滤器判断 “不存在” → 直接返回，不去查缓存和数据库如果判断 “可能存在” → 再去查缓存&#x2F;数据库\n\n\n优点：\n\n对于大量不存在的 key 请求，在第一层就拦截掉\n\n占用内存极小，效率高\n\n\n\n适用场景：\n\n适合ID类查询、提前已知所有合法 key 的业务（如商品 ID、用户 ID）\n\n常用于防止恶意或错误查询穿透到数据库\n\n\n\n\n\n缓存空对象\n\n即使数据库查询结果为空（比如 ID 为 999 的用户不存在），也把这个 空结果进行缓存，并设置一个较短的过期时间（如 30~60 秒）。\n下次同样查询时，缓存中能命中这个“空值”，就不再查数据库。\n\n\n\n\n\n\n缓存击穿\n\n某个热点 key 突然失效，大量请求直接打到数据库。\n\n解决方案：\n\n设置热点 key 永不过期（逻辑过期）\n\n对于特别热点的 key，不设置真正的过期时间（或者设置一个非常长的时间）\n\n但数据本身可以设置一个 “逻辑过期时间”（比如在 value 中保存一个过期时间戳）\n\n后台启动一个 定时任务或异步线程，在数据即将过期时，异步更新缓存\n\n优点： 避免大量请求同时击穿缓存\n\n缺点： 数据更新可能有一定延迟，需要维护逻辑过期时间\n\n\n\n使用互斥锁（Mutex Lock） &#x2F; 分布式锁重建缓存\n\n当缓存未命中时，不是所有请求都去查数据库，而是：\n\n第一个请求去查库，并重建缓存，同时对其他请求加锁（互斥）\n其它请求发现锁存在，就 等待或短暂休眠后重试，或者直接返回旧数据 &#x2F; 默认值\n锁释放后，其它请求再尝试从缓存获取\n\n\n实现方式：\n\n使用 Redis 的 SETNX或 RedLock等实现分布式锁\n\n或者使用本地锁（单机情况下）\n\n\n\n关键点： 只让 一个请求去查库并重建缓存，其他请求等待或重试\n\n\n\n\n\n\n\n缓存雪崩\n\n大量 key 在同一时间过期，导致请求全部压到数据库。\n\n解决方案：\n\n设置不同的过期时间（随机过期）\n\n为每个缓存 key 的过期时间添加一个 随机值，比如：\n基础过期时间：3600 秒（1小时）随机值：± 300 秒（5分钟）=&gt; 最终过期时间在 3300 ~ 3900 秒之间\n\n避免大量 key 同时失效，错开缓存刷新时间\n\n\n\n使用多级缓存\n\n不止依赖 Redis，还可以引入本地缓存（如 Caffeine、Guava Cache）作为一级缓存\n\nRedis 作为二级缓存\n\n即使 Redis 缓存失效，本地缓存还能挡一波请求\n 优点： 多层防护，即使某一层失效，也有兜底\n\n\n\nRedis 高可用（主从 + 哨兵 &#x2F; 集群）\n\n避免因为 Redis 宕机 导致所有缓存不可用\n通过 Redis Sentinel 或 Cluster 提高 Redis 自身的可用性\n\n\n熔断降级 &amp; 请求限流\n\n当数据库压力过大时，可使用 熔断机制（如 Hystrix、Sentinel、Resilience4j）\n或对请求进行 限流（如令牌桶、漏桶算法），保护数据库\n\n\n\n\n\n\n性能优化建议\n\n避免大 Key（如大 Hash、大 List）、热 Key\n\n合理使用 Pipeline 批量操作，减少网络往返\n\n根据业务选择合适的数据结构\n\n监控慢查询、内存使用、命中率等指标\n\n\n\n\n订阅与发布\n是什么\n\nRedis 的 Pub&#x2F;Sub（发布&#x2F;订阅） 是一种消息通信模式，它允许：\n发送者（Publisher） 向 指定的频道（Channel）发送消息；\n接收者（Subscriber） 可以订阅一个或多个频道，从而接收发送到这些频道的消息；\n\n\n关键点：\n发布者和订阅者之间没有直接的连接或耦合；\n消息传递是实时的、广播式的；\nRedis Pub&#x2F;Sub 是基于内存的、即发即弃（fire-and-forget）的消息系统，不提供消息持久化。\n\n\n\n\n工作原理\n\n订阅者（Subscriber） 通过命令订阅一个或多个频道；\n发布者（Publisher） 向某个频道发送消息；\nRedis 服务器 将该消息实时推送给所有订阅了该频道的订阅者；\n如果某个客户端没有订阅该频道，则不会收到任何消息。\n\n\n命令\n\n订阅频道（Subscribe）\nSUBSCRIBE channel1 [channel2 ...]\n\n示例：\nSUBSCRIBE news sports\n\n订阅者会进入监听模式，等待消息。此时 Redis CLI 会阻塞，等待发布消息。\n\n发布消息（Publish）\nPUBLISH channel message\n\n示例：\nPUBLISH news &quot;Hello, this is a news update!&quot;\n\n这条消息会被推送给所有订阅了 news频道的客户端。\n\n取消订阅（Unsubscribe）\nUNSUBSCRIBE [channel1 channel2 ...]\n\n如果不指定频道，则取消所有订阅。\n\n查看活跃的频道（可选，用于监控）\nPUBSUB CHANNELS [pattern]\n\n示例：\nPUBSUB CHANNELS news *\n\n可以查看当前有哪些频道正被订阅（支持通配符）。\n\n\n\n\ndocker实战安装docker\n卸载旧版本：sudo apt-get remove docker docker-engine docker.io containerd runc\n\n安装依赖：\n\nsudo apt-get update sudo apt-get install -y ca-certificates curl gnupg lsb-release\n\n\n添加 Docker 官方 GPG key\n\nsudo mkdir -p /etc/apt/keyrings\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg \\\n  | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n4. 设置软件源   1. ```      echo \\        &quot;deb [arch=$(dpkg --print-architecture) \\        signed-by=/etc/apt/keyrings/docker.gpg] \\        https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\        $(lsb_release -cs) stable&quot; \\        | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null      \n\n\n\n\n安装docker：\n\nsudo apt-get update sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n\n配置加速\n\nsudo mkdir -p /etc/docker\nsudo nano /etc/docker/daemon.json\n\n写入以下内容：\n{\n  &quot;registry-mirrors&quot;: [\n    &quot;https://registry.docker-cn.com&quot;,\n    &quot;https://docker.m.daocloud.io&quot;,\n    &quot;https://mirror.ccs.tencentyun.com&quot;,\n    &quot;https://hub-mirror.c.163.com&quot;\n  ]\n}\n\n### 容器1. 如何进入docker容器内部修改内容：`docker exec -it &lt;id&gt; bash  # 进入正在运行的容器 `2. 挂载：进入容器修改页面太麻烦，我们把它挂在到服务器的目录中。修改服务器目录就能够修改容器中的内容。注意是index.html文件### 如何把java上传到服务器1. 把写好的代码用maven打包为.jar，在target目录下2. 编写Dockerfile。一定会有FROM指明需要从DockerHub上下载的java镜像和作者3. 上传到服务器，建好工作目录。4. docker build, docker run## k8s实战### 创建集群1. 预备环境   1. 需要多台服务器，分为控制服务器master和服务节点nide   2. 创建以后把他们放在一个VPC中   3. 每台都要安装docker   4. 改主机名   5. 确保组内互信   6. 确保永久禁止交换分区（free -m 的结果中 Swap 一项全是 0）   7. 允许流量桥接（iptables）   8. 下载所需依赖2. 下载“三大件”   1. kubelet   2. kubeadm   3. kubectl### 引导启动集群1. 启动kubelet。注意，kubelet此时会反复重启，属正常现象2. 设置域名映射3. 启用CRI   1. ```      检查 containerd 是否安装并运行      systemctl status containerd                  如果没安装：            apt-get update &amp;&amp; apt-get install -y containerd            2. 生成并修改配置文件            生成默认配置：            containerd config default &gt; /etc/containerd/config.toml                  修改关键配置：            CRI 插件必须启用：确认 [plugins.&quot;io.containerd.grpc.v1.cri&quot;] 没被注释掉。            sandbox 镜像（pause 镜像）要改成国内可拉取的地址，例如：            [plugins.&quot;io.containerd.grpc.v1.cri&quot;]        sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;            3. 重启 containerd      systemctl daemon-reexec      systemctl restart containerd            4. 验证 CRI socket 是否可用      crictl info                  能输出 JSON 就说明 OK（如果 crictl 没装，可以 apt-get install -y cri-tools）。            5. 重新加入集群            在 node 上重新执行 master 给的 join 命令：            kubeadm join 172.23.159.16:6443 --token txnlw2.j83802umcetcr3mo \\        --discovery-token-ca-cert-hash sha256:46251037d5a972db8d96635b4c1244c00c9d17f6e90963a2e6da5d42106724ab      \n\n\n改完的&#x2F;etc&#x2F;container&#x2F;conf.toml\n\ndisabled_plugins = []\nimports = []\noom_score = 0\nplugin_dir = &quot;&quot;\nrequired_plugins = []\nroot = &quot;/var/lib/containerd&quot;\nstate = &quot;/run/containerd&quot;\ntemp = &quot;&quot;\nversion = 2\n\n[cgroup]\n  path = &quot;&quot;\n\n[debug]\n  address = &quot;&quot;\n  format = &quot;&quot;\n  gid = 0\n  level = &quot;&quot;\n  uid = 0\n\n[grpc]\n  address = &quot;/run/containerd/containerd.sock&quot;\n  gid = 0\n  max_recv_message_size = 16777216\n  max_send_message_size = 16777216\n  tcp_address = &quot;&quot;\n  tcp_tls_ca = &quot;&quot;\n  tcp_tls_cert = &quot;&quot;\n  tcp_tls_key = &quot;&quot;\n  uid = 0\n\n[metrics]\n  address = &quot;&quot;\n  grpc_histogram = false\n\n[plugins]\n\n  [plugins.&quot;io.containerd.gc.v1.scheduler&quot;]\n    deletion_threshold = 0\n    mutation_threshold = 100\n    pause_threshold = 0.02\n    schedule_delay = &quot;0s&quot;\n    startup_delay = &quot;100ms&quot;\n\n  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]\n    cdi_spec_dirs = [&quot;/etc/cdi&quot;, &quot;/var/run/cdi&quot;]\n    device_ownership_from_security_context = false\n    disable_apparmor = false\n    disable_cgroup = false\n    disable_hugetlb_controller = true\n    disable_proc_mount = false\n    disable_tcp_service = true\n    drain_exec_sync_io_timeout = &quot;0s&quot;\n    enable_cdi = false\n    enable_selinux = false\n    enable_tls_streaming = false\n    enable_unprivileged_icmp = false\n    enable_unprivileged_ports = false\n    ignore_deprecation_warnings = []\n    ignore_image_defined_volumes = false\n    image_pull_progress_timeout = &quot;5m0s&quot;\n    image_pull_with_sync_fs = false\n    max_concurrent_downloads = 3\n    max_container_log_line_size = 16384\n    netns_mounts_under_state_dir = false\n    restrict_oom_score_adj = false\n    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;\n    selinux_category_range = 1024\n    stats_collect_period = 10\n    stream_idle_timeout = &quot;4h0m0s&quot;\n    stream_server_address = &quot;127.0.0.1&quot;\n    stream_server_port = &quot;0&quot;\n    systemd_cgroup = false\n    tolerate_missing_hugetlb_controller = true\n    unset_seccomp_profile = &quot;&quot;\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]\n      bin_dir = &quot;/opt/cni/bin&quot;\n      conf_dir = &quot;/etc/cni/net.d&quot;\n      conf_template = &quot;&quot;\n      ip_pref = &quot;&quot;\n      max_conf_num = 1\n      setup_serially = false\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]\n      default_runtime_name = &quot;runc&quot;\n      disable_snapshot_annotations = true\n      discard_unpacked_layers = false\n      ignore_blockio_not_enabled_errors = false\n      ignore_rdt_not_enabled_errors = false\n      no_pivot = false\n      snapshotter = &quot;overlayfs&quot;\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]\n        base_runtime_spec = &quot;&quot;\n        cni_conf_dir = &quot;&quot;\n        cni_max_conf_num = 0\n        container_annotations = []\n        pod_annotations = []\n        privileged_without_host_devices = false\n        privileged_without_host_devices_all_devices_allowed = false\n        runtime_engine = &quot;&quot;\n        runtime_path = &quot;&quot;\n        runtime_root = &quot;&quot;\n        runtime_type = &quot;&quot;\n        sandbox_mode = &quot;&quot;\n        snapshotter = &quot;&quot;\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]\n          base_runtime_spec = &quot;&quot;\n          cni_conf_dir = &quot;&quot;\n          cni_max_conf_num = 0\n          container_annotations = []\n          pod_annotations = []\n          privileged_without_host_devices = false\n          privileged_without_host_devices_all_devices_allowed = false\n          runtime_engine = &quot;&quot;\n          runtime_path = &quot;&quot;\n          runtime_root = &quot;&quot;\n          runtime_type = &quot;io.containerd.runc.v2&quot;\n          sandbox_mode = &quot;podsandbox&quot;\n          snapshotter = &quot;&quot;\n\n          [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]\n            BinaryName = &quot;&quot;\n            CriuImagePath = &quot;&quot;\n            CriuPath = &quot;&quot;\n            CriuWorkPath = &quot;&quot;\n            IoGid = 0\n            IoUid = 0\n            NoNewKeyring = false\n            NoPivotRoot = false\n            Root = &quot;&quot;\n            ShimCgroup = &quot;&quot;\n            SystemdCgroup = true\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]\n        base_runtime_spec = &quot;&quot;\n        cni_conf_dir = &quot;&quot;\n        cni_max_conf_num = 0\n        container_annotations = []\n        pod_annotations = []\n        privileged_without_host_devices = false\n        privileged_without_host_devices_all_devices_allowed = false\n        runtime_engine = &quot;&quot;\n        runtime_path = &quot;&quot;\n        runtime_root = &quot;&quot;\n        runtime_type = &quot;&quot;\n        sandbox_mode = &quot;&quot;\n        snapshotter = &quot;&quot;\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]\n      key_model = &quot;node&quot;\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]\n      config_path = &quot;&quot;\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]  \n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]\n      tls_cert_file = &quot;&quot;\n      tls_key_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.opt&quot;]\n    path = &quot;/opt/containerd&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.restart&quot;]\n    interval = &quot;10s&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.tracing&quot;]\n\n  [plugins.&quot;io.containerd.metadata.v1.bolt&quot;]\n    content_sharing_policy = &quot;shared&quot;\n\n  [plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]\n    no_prometheus = false\n\n  [plugins.&quot;io.containerd.nri.v1.nri&quot;]\n    disable = true\n    disable_connections = false\n    plugin_config_path = &quot;/etc/nri/conf.d&quot;\n    plugin_path = &quot;/opt/nri/plugins&quot;\n    plugin_registration_timeout = &quot;5s&quot;\n    plugin_request_timeout = &quot;2s&quot;\n    socket_path = &quot;/var/run/nri/nri.sock&quot;\n\n  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]\n    no_shim = false\n    runtime = &quot;runc&quot;\n    runtime_root = &quot;&quot;\n    shim = &quot;containerd-shim&quot;\n    shim_debug = false\n\n  [plugins.&quot;io.containerd.runtime.v2.task&quot;]\n    platforms = [&quot;linux/amd64&quot;]\n    sched_core = false\n\n  [plugins.&quot;io.containerd.service.v1.diff-service&quot;]\n    default = [&quot;walking&quot;]\n    sync_fs = false\n\n  [plugins.&quot;io.containerd.service.v1.tasks-service&quot;]\n    blockio_config_file = &quot;&quot;\n    rdt_config_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.blockfile&quot;]\n    fs_type = &quot;&quot;\n    mount_options = []\n    root_path = &quot;&quot;\n    scratch_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]\n    async_remove = false\n    base_image_size = &quot;&quot;\n    discard_blocks = false\n    fs_options = &quot;&quot;\n    fs_type = &quot;&quot;\n    pool_name = &quot;&quot;\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.native&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]\n    mount_options = []\n    root_path = &quot;&quot;\n    sync_remove = false\n    upperdir_label = false\n\n  [plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.tracing.processor.v1.otlp&quot;]\n\n  [plugins.&quot;io.containerd.transfer.v1.local&quot;]\n    config_path = &quot;&quot;\n    max_concurrent_downloads = 3\n    max_concurrent_uploaded_layers = 3\n\n    [[plugins.&quot;io.containerd.transfer.v1.local&quot;.unpack_config]]\n      differ = &quot;&quot;\n      platform = &quot;linux/amd64&quot;\n      snapshotter = &quot;overlayfs&quot;\n\n[proxy_plugins]\n\n[stream_processors]\n\n  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]\n    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;]\n    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]\n    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]\n    path = &quot;ctd-decoder&quot;\n    returns = &quot;application/vnd.oci.image.layer.v1.tar&quot;\n\n  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]\n    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;]\n    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]\n    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]\n    path = &quot;ctd-decoder&quot;\n    returns = &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;\n\n[timeouts]\n  &quot;io.containerd.timeout.bolt.open&quot; = &quot;0s&quot;\n  &quot;io.containerd.timeout.metrics.shimstats&quot; = &quot;2s&quot;\n  &quot;io.containerd.timeout.shim.cleanup&quot; = &quot;5s&quot;\n  &quot;io.containerd.timeout.shim.load&quot; = &quot;5s&quot;\n  &quot;io.containerd.timeout.shim.shutdown&quot; = &quot;3s&quot;\n  &quot;io.containerd.timeout.task.state&quot; = &quot;2s&quot;\n\n[ttrpc]\n  address = &quot;&quot;\n  gid = 0\n  uid = 0\nroot@k8s-master:~# vim /etc/containerd/config.toml\nroot@k8s-master:~# cat /etc/containerd/config.toml\ndisabled_plugins = []\nimports = []\noom_score = 0\nplugin_dir = &quot;&quot;\nrequired_plugins = []\nroot = &quot;/var/lib/containerd&quot;\nstate = &quot;/run/containerd&quot;\ntemp = &quot;&quot;\nversion = 2\n\n[cgroup]\n  path = &quot;&quot;\n\n[debug]\n  address = &quot;&quot;\n  format = &quot;&quot;\n  gid = 0\n  level = &quot;&quot;\n  uid = 0\n\n[grpc]\n  address = &quot;/run/containerd/containerd.sock&quot;\n  gid = 0\n  max_recv_message_size = 16777216\n  max_send_message_size = 16777216\n  tcp_address = &quot;&quot;\n  tcp_tls_ca = &quot;&quot;\n  tcp_tls_cert = &quot;&quot;\n  tcp_tls_key = &quot;&quot;\n  uid = 0\n\n[metrics]\n  address = &quot;&quot;\n  grpc_histogram = false\n\n[plugins]\n\n  [plugins.&quot;io.containerd.gc.v1.scheduler&quot;]\n    deletion_threshold = 0\n    mutation_threshold = 100\n    pause_threshold = 0.02\n    schedule_delay = &quot;0s&quot;\n    startup_delay = &quot;100ms&quot;\n\n  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]\n    cdi_spec_dirs = [&quot;/etc/cdi&quot;, &quot;/var/run/cdi&quot;]\n    device_ownership_from_security_context = false\n    disable_apparmor = false\n    disable_cgroup = false\n    disable_hugetlb_controller = true\n    disable_proc_mount = false\n    disable_tcp_service = true\n    drain_exec_sync_io_timeout = &quot;0s&quot;\n    enable_cdi = false\n    enable_selinux = false\n    enable_tls_streaming = false\n    enable_unprivileged_icmp = false\n    enable_unprivileged_ports = false\n    ignore_deprecation_warnings = []\n    ignore_image_defined_volumes = false\n    image_pull_progress_timeout = &quot;5m0s&quot;\n    image_pull_with_sync_fs = false\n    max_concurrent_downloads = 3\n    max_container_log_line_size = 16384\n    netns_mounts_under_state_dir = false\n    restrict_oom_score_adj = false\n    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;\n    selinux_category_range = 1024\n    stats_collect_period = 10\n    stream_idle_timeout = &quot;4h0m0s&quot;\n    stream_server_address = &quot;127.0.0.1&quot;\n    stream_server_port = &quot;0&quot;\n    systemd_cgroup = false\n    tolerate_missing_hugetlb_controller = true\n    unset_seccomp_profile = &quot;&quot;\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.cni]\n      bin_dir = &quot;/opt/cni/bin&quot;\n      conf_dir = &quot;/etc/cni/net.d&quot;\n      conf_template = &quot;&quot;\n      ip_pref = &quot;&quot;\n      max_conf_num = 1\n      setup_serially = false\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]\n      default_runtime_name = &quot;runc&quot;\n      disable_snapshot_annotations = true\n      discard_unpacked_layers = false\n      ignore_blockio_not_enabled_errors = false\n      ignore_rdt_not_enabled_errors = false\n      no_pivot = false\n      snapshotter = &quot;overlayfs&quot;\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime]\n        base_runtime_spec = &quot;&quot;\n        cni_conf_dir = &quot;&quot;\n        cni_max_conf_num = 0\n        container_annotations = []\n        pod_annotations = []\n        privileged_without_host_devices = false\n        privileged_without_host_devices_all_devices_allowed = false\n        runtime_engine = &quot;&quot;\n        runtime_path = &quot;&quot;\n        runtime_root = &quot;&quot;\n        runtime_type = &quot;&quot;\n        sandbox_mode = &quot;&quot;\n        snapshotter = &quot;&quot;\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.default_runtime.options]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]\n          base_runtime_spec = &quot;&quot;\n          cni_conf_dir = &quot;&quot;\n          cni_max_conf_num = 0\n          container_annotations = []\n          pod_annotations = []\n          privileged_without_host_devices = false\n          privileged_without_host_devices_all_devices_allowed = false\n          runtime_engine = &quot;&quot;\n          runtime_path = &quot;&quot;\n          runtime_root = &quot;&quot;\n          runtime_type = &quot;io.containerd.runc.v2&quot;\n          sandbox_mode = &quot;podsandbox&quot;\n          snapshotter = &quot;&quot;\n\n          [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]\n            BinaryName = &quot;&quot;\n            CriuImagePath = &quot;&quot;\n            CriuPath = &quot;&quot;\n            CriuWorkPath = &quot;&quot;\n            IoGid = 0\n            IoUid = 0\n            NoNewKeyring = false\n            NoPivotRoot = false\n            Root = &quot;&quot;\n            ShimCgroup = &quot;&quot;\n            SystemdCgroup = true\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime]\n        base_runtime_spec = &quot;&quot;\n        cni_conf_dir = &quot;&quot;\n        cni_max_conf_num = 0\n        container_annotations = []\n        pod_annotations = []\n        privileged_without_host_devices = false\n        privileged_without_host_devices_all_devices_allowed = false\n        runtime_engine = &quot;&quot;\n        runtime_path = &quot;&quot;\n        runtime_root = &quot;&quot;\n        runtime_type = &quot;&quot;\n        sandbox_mode = &quot;&quot;\n        snapshotter = &quot;&quot;\n\n        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.untrusted_workload_runtime.options]\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.image_decryption]\n      key_model = &quot;node&quot;\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]\n      config_path = &quot;&quot;\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.auths]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.headers]\n\n      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]\n\n    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.x509_key_pair_streaming]\n      tls_cert_file = &quot;&quot;\n      tls_key_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.opt&quot;]\n    path = &quot;/opt/containerd&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.restart&quot;]\n    interval = &quot;10s&quot;\n\n  [plugins.&quot;io.containerd.internal.v1.tracing&quot;]\n\n  [plugins.&quot;io.containerd.metadata.v1.bolt&quot;]\n    content_sharing_policy = &quot;shared&quot;\n\n  [plugins.&quot;io.containerd.monitor.v1.cgroups&quot;]\n    no_prometheus = false\n\n  [plugins.&quot;io.containerd.nri.v1.nri&quot;]\n    disable = true\n    disable_connections = false\n    plugin_config_path = &quot;/etc/nri/conf.d&quot;\n    plugin_path = &quot;/opt/nri/plugins&quot;\n    plugin_registration_timeout = &quot;5s&quot;\n    plugin_request_timeout = &quot;2s&quot;\n    socket_path = &quot;/var/run/nri/nri.sock&quot;\n\n  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]\n    no_shim = false\n    runtime = &quot;runc&quot;\n    runtime_root = &quot;&quot;\n    shim = &quot;containerd-shim&quot;\n    shim_debug = false\n\n  [plugins.&quot;io.containerd.runtime.v2.task&quot;]\n    platforms = [&quot;linux/amd64&quot;]\n    sched_core = false\n\n  [plugins.&quot;io.containerd.service.v1.diff-service&quot;]\n    default = [&quot;walking&quot;]\n    sync_fs = false\n\n  [plugins.&quot;io.containerd.service.v1.tasks-service&quot;]\n    blockio_config_file = &quot;&quot;\n    rdt_config_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.aufs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.blockfile&quot;]\n    fs_type = &quot;&quot;\n    mount_options = []\n    root_path = &quot;&quot;\n    scratch_file = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.btrfs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.devmapper&quot;]\n    async_remove = false\n    base_image_size = &quot;&quot;\n    discard_blocks = false\n    fs_options = &quot;&quot;\n    fs_type = &quot;&quot;\n    pool_name = &quot;&quot;\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.native&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.snapshotter.v1.overlayfs&quot;]\n    mount_options = []\n    root_path = &quot;&quot;\n    sync_remove = false\n    upperdir_label = false\n\n  [plugins.&quot;io.containerd.snapshotter.v1.zfs&quot;]\n    root_path = &quot;&quot;\n\n  [plugins.&quot;io.containerd.tracing.processor.v1.otlp&quot;]\n\n  [plugins.&quot;io.containerd.transfer.v1.local&quot;]\n    config_path = &quot;&quot;\n    max_concurrent_downloads = 3\n    max_concurrent_uploaded_layers = 3\n\n    [[plugins.&quot;io.containerd.transfer.v1.local&quot;.unpack_config]]\n      differ = &quot;&quot;\n      platform = &quot;linux/amd64&quot;\n      snapshotter = &quot;overlayfs&quot;\n\n[proxy_plugins]\n\n[stream_processors]\n\n  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar&quot;]\n    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+encrypted&quot;]\n    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]\n    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]\n    path = &quot;ctd-decoder&quot;\n    returns = &quot;application/vnd.oci.image.layer.v1.tar&quot;\n\n  [stream_processors.&quot;io.containerd.ocicrypt.decoder.v1.tar.gzip&quot;]\n    accepts = [&quot;application/vnd.oci.image.layer.v1.tar+gzip+encrypted&quot;]\n    args = [&quot;--decryption-keys-path&quot;, &quot;/etc/containerd/ocicrypt/keys&quot;]\n    env = [&quot;OCICRYPT_KEYPROVIDER_CONFIG=/etc/containerd/ocicrypt/ocicrypt_keyprovider.conf&quot;]\n    path = &quot;ctd-decoder&quot;\n    returns = &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;\n\n[timeouts]\n  &quot;io.containerd.timeout.bolt.open&quot; = &quot;0s&quot;\n  &quot;io.containerd.timeout.metrics.shimstats&quot; = &quot;2s&quot;\n  &quot;io.containerd.timeout.shim.cleanup&quot; = &quot;5s&quot;\n  &quot;io.containerd.timeout.shim.load&quot; = &quot;5s&quot;\n  &quot;io.containerd.timeout.shim.shutdown&quot; = &quot;3s&quot;\n  &quot;io.containerd.timeout.task.state&quot; = &quot;2s&quot;\n\n[ttrpc]\n  address = &quot;&quot;\n  gid = 0\n  uid = 0\n3. 配置crictl使用containerd   1. ```      sudo tee /etc/crictl.yaml &lt;&lt;EOF      runtime-endpoint: unix:///run/containerd/containerd.sock      image-endpoint: unix:///run/containerd/containerd.sock      timeout: 10      debug: false      EOF      \n\n\n\n\n\n\n\n初始化master\n\nsudo kubeadm init \\\n  --apiserver-advertise-address=172.23.159.13 \\\n  --apiserver-cert-extra-sans=120.55.74.89,k8s-master \\\n  --image-repository registry.aliyuncs.com/google_containers \\\n  --kubernetes-version $(kubeadm version -o short) \\\n  --pod-network-cidr=10.244.0.0/16\n\n2. 结果:3. ```   Your Kubernetes control-plane has initialized successfully!      To start using your cluster, you need to run the following as a regular user:        mkdir -p $HOME/.kube     sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config     sudo chown $(id -u):$(id -g) $HOME/.kube/config      Alternatively, if you are the root user, you can run:        export KUBECONFIG=/etc/kubernetes/admin.conf      You should now deploy a pod network to the cluster.   Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:     https://kubernetes.io/docs/concepts/cluster-administration/addons/      Then you can join any number of worker nodes by running the following on each as root:      kubeadm join 172.23.159.16:6443 --token 3hhxla.q0vggulqf855w9qj \\           --discovery-token-ca-cert-hash sha256:46251037d5a972db8d96635b4c1244c00c9d17f6e90963a2e6da5d42106724ab \n\n\n\n\n配置kubectl\n\n安装网络插件\n\ncalico\n\nCalico 镜像拉取失败（国内环境）解决步骤\n1. 部署 Calico（官方 YAML）\nkubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.3/manifests/calico.yaml\n\n2. 替换镜像源（解决国内拉取失败问题）\n\n👉 把 docker.io 换成 DaoCloud 镜像加速地址：\n\n# 替换 calico-node DaemonSet 主容器和 cni 容器\nkubectl -n kube-system set image daemonset/calico-node \\\n  calico-node=quay.m.daocloud.io/calico/node:v3.27.3 \\\n  install-cni=quay.m.daocloud.io/calico/cni:v3.27.3 \\\n  upgrade-ipam=quay.m.daocloud.io/calico/cni:v3.27.3\n\n3. 额外修复 init 容器 mount-bpffs\nkubectl -n kube-system set image daemonset/calico-node \\\n  mount-bpffs=quay.m.daocloud.io/calico/node:v3.27.3\n\n4. 替换 calico-kube-controllers 镜像\nkubectl -n kube-system set image deployment/calico-kube-controllers \\\n  calico-kube-controllers=quay.m.daocloud.io/calico/kube-controllers:v3.27.3\n\n5. 删除旧的 Pod，让 DaemonSet/Deployment 重建\nkubectl delete pod -n kube-system -l k8s-app=calico-node\nkubectl delete pod -n kube-system -l k8s-app=calico-kube-controllers\n\n6. 验证状态\nkubectl get pods -n kube-system\n\n\n期望结果：\n\ncalico-node → Running\n\ncalico-kube-controllers → Running\n\n其他系统组件 → Running\n      2. 7. 导入nodes   1. 让master生成加入命令：`kubeadm token create --print-join-command`   2. 把上面的命令运行到nodes上8. （可选）可视化组件dashboard   1. 安装：`kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml`   2. 改镜像      1. ```         # Dashboard         kubectl -n kubernetes-dashboard set image deploy/kubernetes-dashboard \\           kubernetes-dashboard=registry.cn-hangzhou.aliyuncs.com/google_containers/dashboard:v2.7.0                  # Metrics Scraper         kubectl -n kubernetes-dashboard set image deploy/dashboard-metrics-scraper \\           dashboard-metrics-scraper=registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper:v1.0.8         \n\n\n\n\n改设置：\n\nkubectl edit svc kubernetes-dashboard -n kubernetes-dashboard把里面的type: ClassIp 改为NodePort\nkubectl get svc -A | grep kubernetes-dashboard得到控制台端口，在安全组中开放之\n就可以通过浏览器，任意集群服务公网加端口，访问控制。https://115.29.194.182:32100\n\n\n生成token\n\n创建角色\n\n# 创建一个 ServiceAccount\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: admin-user\n  namespace: kubernetes-dashboard\n---\n# 将 ServiceAccount 绑定到 cluster-admin 角色\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: admin-user\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n- kind: ServiceAccount\n  name: admin-user\n  namespace: kubernetes-dashboard\n---\n# 为 ServiceAccount 创建一个 Secret（长期有效的 token）\napiVersion: v1\nkind: Secret\nmetadata:\n  name: admin-user-token\n  namespace: kubernetes-dashboard\n  annotations:\n    kubernetes.io/service-account.name: &quot;admin-user&quot;\ntype: kubernetes.io/service-account-token\n\n      2. 应用配置      3. 获取token: `kubectl -n kubernetes-dashboard describe secret admin-user-token`长期有效#### token1. ```   eyJhbGciOiJSUzI1NiIsImtpZCI6IjRwMG9ycHJOTkNUbXFiQ0VtaHZFcWN4Z1c5SE5FSndoeXczblhqOGE3V1UifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJhMGJhYzk4Ny1iZmJkLTRiYzItOTU0My1mZjA3YmIwOGU5MWMiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.olewgwArPXj57FGM5Kmo99yeVRVl7tEnfbLorPzzQxP97nuACkO1aWCVakFMKkjT3UeVTSUyKvzpEO7qTF_T2xC556sKt_qJ-uxtFmooix3ix1gUIrrAYOKjaiFcajNFlSuZ5XscMlNoJkmqr8cpJkXWO_B0qXSm0o4KKWSBtU4up9Mus10Mu_wlJpBxPEpQ0O-95lA1jBvR9A7WkfhDXYJ-IzKFDqS30mizQUO8Lc-iZLftLdhj9aabbmSm3xScCpemo_rFP1RtH0Yr0WZCVoBq1xZSI7tC0rbRro1uhc15skCO5Y7Epr5xftorP1KVYi11ux7kFTcMFttjDGt_BQ\n\n\n\n\n\n\n\n\n\n核心实战Deployment\n通过Deployment启用Pod，负责控制Pod，使之有多个副本，有自愈、扩缩容等能力\n\napiVersion: apps/v1kind: Deploymentmetadata:  name: my-nginx-03  namespace: defaultspec:  replicas: 2  selector:    matchLabels:      app: my-nginx-03  template:    metadata:      labels:        app: my-nginx-03    spec:      containers:      - name: nginx        image: ghcr.io/nginxinc/nginx-unprivileged:1.25        ports:        - containerPort: 8080---apiVersion: v1kind: Servicemetadata:  name: my-nginx-03-svc  namespace: defaultspec:  selector:    app: my-nginx-03  ports:  - protocol: TCP    port: 80    targetPort: 8080    nodePort: 30080  type: NodePort\n\n\n创建了一个deployment，设置replicas&#x3D;2，创建两个pod和一个service。\n两个pod的ip不一样。但一个pod中的不同container的ip一样的，端口不一样。\n\n\n命令：\n\n# 创建deployment\nkubectl create deployment my-nginx --image=nginx:1.25.2 --replicas=2\n   2. 4. 体验deployment的功能   1. 扩缩容`kubectl scale deploy/&lt;pod&gt; --replicas=&lt;n&gt; `   2. 自愈 &amp; 故障转移：如果感知到pod故障，就重启pod。如果pod无法重启，比如服务器断电，则在其他服务器部署   3. 滚动更新：pod要更新时，不停机更新，一个一个更新。      1. `kubectl set image deploy/&lt;deploy&gt; &lt;image&gt;=xxxx --record`   4. 版本控制：`kubectl rollout undo deploy/&lt;dep&gt; --to-revision=xxx`#### Service1. 将一组Pods公开为网络服务的抽象方法。负责Pod服务的发现与负载均衡。2. 命令   1. ```      # kubectl expose &lt;name&gt; \n\n\n–port：暴露端口（集群内部port）\n\n–target-port：映射端口\n\n–type&#x3D;NodePort：把所有pod的IP映射到同一个Service的IP，以实现负载均衡。可公网访问\n\n–type&#x3D;ClusterIP：把所有pod的IP映射到同一个Service的IP，以实现负载均衡。但是只能在集群内部访问（也是默认情况）\n\n\n\n\nIngress\nk8s希望Ingress是流量唯一入口（网关）\n\n安装Ingress\n\n添加官方部署yaml文件（⚠️ 这一步可能失败（因为默认拉取的是 k8s.gcr.io &#x2F; registry.k8s.io 的国外镜像）。）：kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controllerv-1.9.6/deploy/static/provider/baremetal/deploy.yaml\n\n修改为国内镜像\n\n# 找到pod\nkubectl get pods -n ingress-nginx\n\n# 修改镜像。用DaoCloud 提供的一个中国代理镜像仓库\n# 替换 Ingress Controller 镜像\nkubectl -n ingress-nginx set image deployment ingress-nginx-controller \\\n  controller=k8s-gcr.m.daocloud.io/ingress-nginx/controller:v1.9.6\n\n\n# 替换 Admission Webhook Job 镜像\n# 因为一直调不通，就不用admiss了\nkubectl -n ingress-nginx set image job/ingress-nginx-admission-create \\\n  create=k8s-gcr.m.daocloud.io/ingress-nginx/kube-webhook-certgen:v1.4.1\n\nkubectl -n ingress-nginx set image job/ingress-nginx-admission-patch \\\n  patch=k8s-gcr.m.daocloud.io/ingress-nginx/kube-webhook-certgen:v1.4.1\n\n\n\n# 验证安装\nkubectl get pods -n ingress-nginx -w\n\n   3. 一系列授权（改动的原理我就不知道了）#### nfs1. 为了同步各个服务器的存储信息，用nfs2. 服务端安装nfs-server（存储）   1. ```bash      sudo apt install -y nfs-kernel-server            sudo mkdir -p /nfs/data      sudo chown nobody:nogroup /nfs/data      sudo chmod 777 /nfs/data            # 编辑导出配置      echo &quot;/nfs/data *(rw,sync,no_subtree_check,no_root_squash,insecure)&quot; | sudo tee -a /etc/exports            # 启动服务      sudo systemctl enable rpcbind --now      sudo systemctl enable nfs-kernel-server --now            # 生效导出      sudo exportfs -rav      \n\n\n\n\n\n\n所有节点安装nfs-client（挂载）\n\nsudo apt update\nsudo apt install -y nfs-common\n\n\n# 查看服务端导出目录\nshowmount -e 172.23.159.16\n\n# 本地挂载目录\nsudo mkdir -p /nfs/data\nsudo mount -t nfs 172.23.159.16:/nfs/data /nfs/data\n\n4. PV：持久卷。就是真实存储内容的位置。5. PVC：持久卷声明。申请存储空间#### 小结![image-20250920164917122](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250920164917122.png)1. **基础集群环境**   - 已经搭建好一个 **Kubernetes 集群 (v1.28.2)**，包含：     - 控制平面组件：`etcd`、`kube-apiserver`、`kube-controller-manager`、`kube-scheduler` ✅     - 网络插件：**Calico**（`calico-node`、`calico-kube-controllers`） ✅     - 集群 DNS：`coredns` ✅     - 代理：`kube-proxy`（iptables 模式） ✅     - 辅助：部署了 **kubernetes-dashboard** ✅   集群核心服务状态良好，全部 Running。   ------2. **业务工作负载**   - 在 `default` 命名空间部署了一个 **nginx 应用**：     - Deployment `my-nginx-03`，有 2 个 Pod Running ✅     - 用于后续测试 Service 和 Ingress 转发。   ------3. **Ingress 部署**   - 尝试部署了 **ingress-nginx-controller (v1.9.6)**，过程中遇到几个问题：     1. **镜像拉取失败** → 解决方法：换用 `k8s-gcr.m.daocloud.io/ingress-nginx/controller:v1.9.6` ✅     2. **Admission Jobs CrashLoopBackOff** → 你决定跳过 admission，不再使用 webhook ✅     3. **Controller Pod 启动失败** →        - 原因：`ServiceAccount` RBAC 权限不足        - 修复：补齐了对 `services`、`endpointslices`、`leases` 的访问权限 ✅     4. **最终 ingress-nginx-controller 正常 Running**，日志显示 Nginx 已经启动，并完成 Leader Election ✅   ------4. **验证 Ingress**   - 访问 `http://172.23.159.15:31080`（NodePort 方式） → 成功命中 ingress-nginx，但返回 **404**（因为还没有配置 Ingress 规则）。   - 这一步证明 **Ingress Controller + NodePort 已经完全打通**，只差创建路由规则。5. **有两个可对外访问的 NodePort 服务**：   1. **`my-nginx-03-svc`**      - 类型：`NodePort`      - ClusterIP: `10.97.118.5`      - 端口：`80:30080/TCP`         👉 直接访问 `http://&lt;NodeIP&gt;:30080` 就能看到 **nginx welcome page**。   2. **`ingress-nginx-controller`**      - 类型：`NodePort`      - ClusterIP: `10.101.33.201`      - 端口：`80:31080/TCP, 443:31443/TCP`         👉 这是 Ingress Controller 的入口，当前访问会返回 **404**，因为还没有配置任何 Ingress 规则。6. 示例demo1. ```yaml   # ---------------------------   # hello-server Deployment   # ---------------------------   apiVersion: apps/v1   kind: Deployment   metadata:     name: hello-server     namespace: default   spec:     replicas: 2     selector:       matchLabels:         app: hello-server     template:       metadata:         labels:           app: hello-server       spec:         containers:         - name: hello-server           image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server           ports:           - containerPort: 9000   ---   # hello-server Service   apiVersion: v1   kind: Service   metadata:     name: hello-server     namespace: default   spec:     selector:       app: hello-server     ports:     - port: 8000       targetPort: 9000       protocol: TCP   ---   # ---------------------------   # nginx-demo Deployment   # ---------------------------   apiVersion: apps/v1   kind: Deployment   metadata:     name: nginx-demo     namespace: default   spec:     replicas: 2     selector:       matchLabels:         app: nginx-demo     template:       metadata:         labels:           app: nginx-demo       spec:         containers:         - name: nginx-demo           image: ghcr.io/nginxinc/nginx-unprivileged:1.25           ports:           - containerPort: 80   ---   # nginx-demo Service   apiVersion: v1   kind: Service   metadata:     name: nginx-demo     namespace: default   spec:     selector:       app: nginx-demo     ports:     - port: 8000       targetPort: 80       protocol: TCP   ---   # ---------------------------   # Ingress 配置   # ---------------------------   apiVersion: networking.k8s.io/v1   kind: Ingress   metadata:     name: demo-ingress     namespace: default   spec:     ingressClassName: nginx     rules:     - host: hello.mukongshan.com       http:         paths:         - path: /           pathType: Prefix           backend:             service:               name: hello-server               port:                 number: 8000     - host: demo.mukongshan.com       http:         paths:         - path: /           pathType: Prefix           backend:             service:               name: nginx-demo               port:                 number: 8000\n\n\n\n\n\n高级\ningress\n路径重写\n限流\n\n\n\nKubesphere安装\n裸机安装（很方便，几条指令就好了）\n如果遇到镜像联不通，试试export KKZONE=cn\n\n删除已有应用：\n\n# 停止并卸载 kubeadm/kubelet/kubectl\nsudo systemctl stop kubelet\nsudo apt-get purge -y kubeadm kubectl kubelet kubernetes-cni kube*\nsudo apt-get autoremove -y\nsudo rm -rf ~/.kube /etc/kubernetes /var/lib/etcd /var/etcd /var/lib/kubelet\n\n# 卸载 Docker（如果不打算用 KK 自带的 Docker）\nsudo systemctl stop docker docker.socket\nsudo apt-get purge -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\nsudo apt-get autoremove -y\nsudo rm -rf /var/lib/docker /var/lib/containerd\n\n# 卸载containerd\nsudo systemctl stop containerd\nsudo apt-get purge -y containerd containerd.io\nsudo apt-get autoremove -y\nsudo rm -rf /etc/containerd /var/lib/containerd\n\n\n\n\n\n\n\n在已有的k8s集群上安装\n先安装Helm Chart\n\n\n\n\n多租户\nadmin是最高权限\n划分多个角色，权限不同，对企业、项目、角色的访问能力不同\n\n部署应用概述\n\n考虑工作负载\n部署（无状态）\n有状态副本集\n守护进程集\n\n\n考虑数据挂载和配置\n考虑访问控制\n\n安装MySQL\n凡拉取镜像都应该先上DockerHub上看拉取方式\n\n考虑配置文件\n根据dockerhub上的mysql官方文档描述，以.cnf结尾的文件会被默认为配置文件。\n在Kubesphere的可视化平台中，找到配置，其中key就是原来的文件名，value就是你的配置\n\n\n考虑卷挂载声明\n\n安装redis安装ElasticSearch\n注意，如果挂载配置文件时，文件夹下有多个配置文件，但我们只想挂载某些时，需要把挂载路径精确到文件\n\n","categories":["技术"]},{"title":"python核心库学习笔记","url":"/2025/12/04/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"numpyNumPy（Numerical Python）是 Python 中一个强大的科学计算库，提供了高性能的多维数组对象（ndarray）以及大量的数学函数和操作工具，是许多其他科学计算库（如 SciPy、Pandas、Matplotlib 等）的基础。\n下面是 NumPy 库的一些基本用法：\n\n一、安装 NumPy如果尚未安装 NumPy，可以使用 pip 安装：\npip install numpy\n\n\n二、导入 NumPy通常我们这样导入 NumPy，并给它起一个别名 np：\nimport numpy as np\n\n\n三、NumPy 的核心：ndarray（多维数组）NumPy 最核心的数据结构是 ndarray（N-dimensional array），即 N 维数组。它是一个高效、固定类型的多维数组对象。\n1. 创建 ndarray从 Python 列表创建：# 一维数组a = np.array([1, 2, 3, 4])print(a)  # 输出: [1 2 3 4]# 二维数组b = np.array([[1, 2], [3, 4]])print(b)# 输出:# [[1 2]#  [3 4]]\n\n使用内置函数快速创建数组：\n\n\n函数\n说明\n示例\n\n\n\nnp.zeros(shape)\n全零数组\nnp.zeros((2, 3))→ 2行3列的全0数组\n\n\nnp.ones(shape)\n全1数组\nnp.ones((3,))→ 一维的3个1\n\n\nnp.empty(shape)\n未初始化的数组（值随机）\nnp.empty((2,2))\n\n\nnp.arange(start, stop, step)\n类似 range，生成一维数组\nnp.arange(0, 10, 2)→ [0 2 4 6 8]\n\n\nnp.linspace(start, stop, num)\n指定范围内的等间隔 num 个数\nnp.linspace(0, 1, 5)→ [0.   0.25 0.5  0.75 1.  ]\n\n\nnp.random.rand(d0, d1, ...)\n生成 [0,1) 区间的随机数数组\nnp.random.rand(2, 3)\n\n\n示例：\nzeros_arr = np.zeros((2, 3))ones_arr = np.ones(4)rand_arr = np.random.rand(3)print(zeros_arr)print(ones_arr)print(rand_arr)\n\n\n四、数组的基本属性a = np.array([[1, 2, 3], [4, 5, 6]])print(a.shape)    # 数组的维度，输出 (2, 3)print(a.ndim)     # 数组的轴数（维度数），输出 2print(a.size)     # 数组元素的总数，输出 6print(a.dtype)    # 数组元素的数据类型，如 int64, float64\n\n\n五、数组的索引与切片1. 一维数组a = np.array([10, 20, 30, 40, 50])print(a[0])    # 10print(a[1:4])  # [20 30 40] （左闭右开）\n\n2. 二维数组b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print(b[0, 1])   # 第0行第1列 → 2print(b[1:, :2]) # 第1行及之后，前两列 → [[4 5], [7 8]]\n\n\n六、数组的运算NumPy 支持**逐元素（element-wise）**的数学运算，无需写循环，非常高效！\na = np.array([1, 2, 3])b = np.array([4, 5, 6])print(a + b)  # [5 7 9]print(a - b)  # [-3 -3 -3]print(a * b)  # [ 4 10 18]print(a / b)  # [0.25 0.4  0.5 ]print(a ** 2) # [1 4 9]  平方\n\n也可以与标量进行运算：\nprint(a + 10)  # [11 12 13]\n\n\n七、常用函数1. 数学函数a = np.array([1, 4, 9])print(np.sqrt(a))   # 平方根 → [1. 2. 3.]print(np.sum(a))    # 求和 → 14print(np.mean(a))   # 均值 → 4.666...print(np.max(a))    # 最大值 → 9print(np.min(a))    # 最小值 → 1print(np.std(a))    # 标准差\n\n2. 聚合函数可以指定 axis对于二维数组，可以按行或列聚合：\nb = np.array([[1, 2, 3], [4, 5, 6]])print(np.sum(b, axis=0))  # 按列求和 → [5 7 9]print(np.sum(b, axis=1))  # 按行求和 → [ 6 15]\n\n\n八、形状操作1. 改变数组形状：reshapea = np.arange(6)  # [0 1 2 3 4 5]b = a.reshape(2, 3)  # 变成 2行3列print(b)# 输出:# [[0 1 2]#  [3 4 5]]\n\n\n注意：reshape 不改变原数组，而是返回新视图（如果可能）。\n\n2. 展平数组：ravel 或 flattenprint(b.ravel())   # 展平为一维 [0 1 2 3 4 5]print(b.flatten()) # 同上，也是展平\n\n\n九、数组拼接与分割1. 拼接数组a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]])# 垂直拼接（按行）→ 上下堆叠c = np.vstack((a, b))print(c)# 输出:# [[1 2]#  [3 4]#  [5 6]#  [7 8]]# 水平拼接（按列）→ 左右合并d = np.hstack((a, b))print(d)# 输出:# [[1 2 5 6]#  [3 4 7 8]]\n\n2. 分割数组a = np.arange(12).reshape(3, 4)# 按行切分upper, lower = np.vsplit(a, [2])print(upper)print(lower)# 按列切分left, right = np.hsplit(a, [2])print(left)print(right)\n\n\n十、广播机制（Broadcasting）NumPy 允许不同形状的数组进行运算，系统会自动扩展较小数组的形状，这个机制叫广播（Broadcasting）。\na = np.array([1, 2, 3])b = 2  # 标量print(a + b)  # [3 4 5] → 相当于 a + [2, 2, 2]# 另一个例子c = np.array([[1], [2], [3]])  # 3x1d = np.array([10, 20, 30])     # 1x3print(c + d)# 输出一个 3x3 的数组，每个元素是对应位置相加\n\n\n广播规则较为复杂，但基本原则是：从尾部维度开始对齐，维度相同或其中一个为1时可广播。\n\n\n总结：NumPy 常用功能一览\n\n\n功能类别\n常用函数&#x2F;操作\n\n\n\n创建数组\nnp.array(), np.zeros(), np.ones(), np.arange(), np.random.rand()\n\n\n数组属性\n.shape, .ndim, .size, .dtype\n\n\n索引与切片\na[0], a[:, 1:3], a[1:, :]\n\n\n数学运算\n+, -, *, /, **, np.sqrt(), np.sin(), …\n\n\n统计函数\nnp.sum(), np.mean(), np.max(), np.min(), np.std()\n\n\n形状操作\nreshape(), ravel(), flatten()\n\n\n拼接与分割\nnp.vstack(), np.hstack(), np.vsplit(), np.hsplit()\n\n\n广播机制\n自动扩展维度进行运算\n\n\n\n如果你有具体想了解的 NumPy 功能（比如线性代数、随机数生成、文件读写等），欢迎继续提问！我可以为你深入讲解。\npandaspandas是 Python 中最流行、功能最强大的数据分析库之一，特别适合处理和分析结构化数据（比如表格数据）。它是建立在 NumPy 基础之上的，提供了高效的数据结构和丰富的数据操作功能，是数据清洗、处理、分析、探索性分析（EDA）中不可或缺的工具。\n\n一、什么是 pandas？pandas（Python Data Analysis Library） 是一个开源的、提供高性能、易用的数据结构与数据分析工具的库。\n它的两个核心数据结构是：\n\n1.Series（一维数据，类似带标签的一维数组）\n2.DataFrame（二维数据，类似带标签的电子表格或 SQL 表）\n\n\n二、安装 pandas如果你的环境中还没有安装 pandas，可以通过 pip 安装：\npip install pandas\n\n通常也会一并安装依赖库，如 NumPy。\n\n三、导入 pandas一般习惯这样导入：\nimport pandas as pd\n\n（pd是社区广泛接受的别名）\n\n四、pandas 的两个核心数据结构1. Series（一维数据）Series 是一个带标签的一维数组，可以保存任意数据类型（整数、字符串、浮点数、Python 对象等）。\n创建 Series：import pandas as pd# 从列表创建s = pd.Series([10, 20, 30, 40])print(s)\n\n输出类似：\n0    101    202    303    40dtype: int64\n\n\n•左边是索引（index），右边是值（value）\n•可以指定索引：\n\ns = pd.Series([10, 20, 30], index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])print(s)\n\n输出：\na    10b    20c    30dtype: int64\n\n你可以通过索引访问数据，如 s[&#39;a&#39;]→ 10\n\n2. DataFrame（二维数据，最常用）DataFrame 是一个带标签的二维表格数据结构，类似于 Excel 表格或者 SQL 表，由多个 Series 组成（每列是一个 Series），每一列可以是不同的数据类型。\n创建 DataFrame 的常见方式：从字典创建（最常见）：data = &#123;    &#x27;姓名&#x27;: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Charlie&#x27;],    &#x27;年龄&#x27;: [25, 30, 35],    &#x27;城市&#x27;: [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;广州&#x27;]&#125;df = pd.DataFrame(data)print(df)\n\n输出：\n姓名  年龄  城市0   Alice  25  北京1     Bob  30  上海2  Charlie  35  广州\n\n\n•每一列是一个 Series\n•默认索引是 0, 1, 2, …\n•可以自定义索引：\n\ndf = pd.DataFrame(data, index=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])\n\n\n五、查看和访问数据查看 DataFrame 的基本信息：df.info()        # 数据类型、非空数量、内存使用等df.describe()    # 数值列的统计摘要（如均值、标准差、最小最大值等）df.shape         # 返回 (行数, 列数)df.columns       # 查看列名df.index         # 查看索引\n\n查看部分数据：df.head(2)   # 查看前 2 行df.tail(2)   # 查看后 2 行\n\n选择列：print(df[&#x27;姓名&#x27;])       # 选择单列，返回一个 Seriesprint(df[[&#x27;姓名&#x27;, &#x27;年龄&#x27;]])  # 选择多列，返回一个 DataFrame\n\n选择行：print(df.loc[&#x27;a&#x27;])      # 按标签选择某一行（loc = location）print(df.iloc[0])       # 按位置（索引号）选择某一行（iloc = integer location）\n\n选择多行：\nprint(df.loc[[&#x27;a&#x27;, &#x27;b&#x27;]])print(df.iloc[0:2])     # 前两行（左闭右开）\n\n选择某行某列的值：\nprint(df.loc[&#x27;a&#x27;, &#x27;年龄&#x27;])   # 获取 a 行，年龄列 → 25print(df.iloc[0, 1])         # 第0行，第1列 → 25\n\n\n六、常用数据处理操作1. 增加&#x2F;删除列# 增加列df[&#x27;性别&#x27;] = [&#x27;女&#x27;, &#x27;男&#x27;, &#x27;男&#x27;]print(df)# 删除列df = df.drop(&#x27;性别&#x27;, axis=1)  # axis=1 表示列\n\n2. 增加&#x2F;删除行# 增加行（一般通过 concat 或 append，但 append 已不推荐）new_row = pd.DataFrame(&#123;&#x27;姓名&#x27;: [&#x27;David&#x27;], &#x27;年龄&#x27;: [40], &#x27;城市&#x27;: [&#x27;深圳&#x27;]&#125;)df = pd.concat([df, new_row], ignore_index=True)# 删除行df = df.drop(index=0)  # 删除第0行\n\n\n七、数据筛选（条件过滤）# 筛选年龄大于28的行filtered = df[df[&#x27;年龄&#x27;] &gt; 28]print(filtered)# 多条件：年龄&gt;25 且 城市 == &#x27;北京&#x27;filtered = df[(df[&#x27;年龄&#x27;] &gt; 25) &amp; (df[&#x27;城市&#x27;] == &#x27;北京&#x27;)]\n\n\n八、常用统计函数df[&#x27;年龄&#x27;].mean()    # 平均年龄df[&#x27;年龄&#x27;].sum()     # 年龄总和df[&#x27;年龄&#x27;].max()     # 最大年龄df[&#x27;年龄&#x27;].min()     # 最小年龄df[&#x27;年龄&#x27;].std()     # 标准差df.describe()        # 数值列统计汇总\n\n\n九、排序# 按年龄升序df_sorted = df.sort_values(by=&#x27;年龄&#x27;)# 按年龄降序df_sorted = df.sort_values(by=&#x27;年龄&#x27;, ascending=False)\n\n\n十、处理缺失值在实际数据中，经常会遇到缺失值（NaN）。\n检查缺失值：df.isnull()      # 每个值是否为缺失值df.isnull().sum()  # 每列缺失值的数量\n\n删除缺失值：df.dropna()      # 删除含有缺失值的行\n\n填充缺失值：df.fillna(0)          # 用 0 填充df[&#x27;年龄&#x27;].fillna(df[&#x27;年龄&#x27;].mean(), inplace=True)  # 用均值填充年龄列的缺失值\n\n\n十一、读取和保存数据pandas 支持多种格式的数据读写，如 CSV、Excel、JSON 等。\n读取 CSV 文件：df = pd.read_csv(&#x27;data.csv&#x27;)  # 从当前目录读取 data.csv 文件print(df.head())\n\n保存为 CSV：df.to_csv(&#x27;output.csv&#x27;, index=False)  # 不保存行索引\n\n其他格式：\n\n•Excel: pd.read_excel(), df.to_excel()\n•JSON: pd.read_json(), df.to_json()\n•SQL: 结合 SQLAlchemy 使用\n\n\n十二、数据合并与连接类似于 SQL 的 join 操作：\n# 假设有 df1 和 df2result = pd.concat([df1, df2])           # 简单堆叠result = pd.merge(df1, df2, on=&#x27;key&#x27;)    # 按某个键合并，类似 SQL join\n\n\n总结：pandas 常用功能速查\n\n\n功能\n方法&#x2F;操作\n\n\n\n创建数据\npd.Series(), pd.DataFrame()\n\n\n查看数据\ndf.head(), df.tail(), df.info(), df.describe()\n\n\n选择数据\ndf[&#39;列名&#39;], df[[&#39;列1&#39;,&#39;列2&#39;]], df.loc[], df.iloc[]\n\n\n筛选数据\ndf[df[&#39;列&#39;] &gt; 值], 多条件用 &amp;, &#96;\n\n\n排序\ndf.sort_values(by=&#39;列名&#39;, ascending=True/False)\n\n\n处理缺失值\ndf.isnull(), df.dropna(), df.fillna(value)\n\n\n统计计算\ndf.mean(), df.sum(), df.max(), df.min()\n\n\n增删行列\n增加列：df[&#39;新列&#39;] = ...；删除：df.drop()\n\n\n读写文件\npd.read_csv(), df.to_csv(), pd.read_excel(), df.to_excel()\n\n\n合并数据\npd.concat(), pd.merge()\n\n\n\n推荐学习路径（如果你是新手）：\n1.掌握 Series 和 DataFrame 的创建与基本操作\n2.学会查看和选择数据（列、行）\n3.学会数据筛选、排序、统计\n4.学会处理缺失值\n5.学会读取&#x2F;保存 CSV、Excel 文件\n6.尝试实际的数据分析小项目（比如分析销售数据、学生成绩等）\n\n\n🔥 如果你有具体的需求，比如：\n\n•如何用 pandas 处理某个 csv 文件？\n•如何筛选&#x2F;分组&#x2F;聚合数据？\n•如何画图（结合 matplotlib&#x2F;seaborn）？\n•如何做数据清洗？\n\n欢迎继续提问，我可以给你出详细代码示例！ 😊\n","categories":["技术"]},{"title":"Java与JVM","url":"/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","content":"基础Java生命周期\n编码阶段（Writing Code）\n\n\n开发者编写源代码，文件后缀为 .java。比如：HelloWorld.java。\n源代码中包含类（class）、方法（method）等，使用 Java 语法。\n\n\n\n编译阶段（Compiling）\n\n\n使用 Java 编译器 javac 将 .java 文件编译成 字节码文件（.class）。\njavac HelloWorld.java\n\n编译后生成 HelloWorld.class 文件。\n\n注意：字节码不是机器码，而是一种中间形式，跨平台。\n\n\n\n\n类加载阶段（Class Loading）\n\n\n当运行程序时（java HelloWorld），类加载器（ClassLoader） 会把需要的 .class 文件加载进内存。\n类加载过程分为三个小步骤：\n加载（Loading）：把字节码读到内存。\n连接（Linking）：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。\n初始化（Initialization）：执行静态代码块、给静态变量赋初值。\n\n\n\n\n\n字节码执行阶段（Execution）\n\n\nJava 虚拟机（JVM）解释执行字节码，也可能使用 JIT（即时编译器） 把热点代码编译成本地机器码，以提高运行效率。\n\n执行的起点是程序入口：\npublic static void main(String[] args) &#123; ... &#125;\n\n\n\n程序运行时（Runtime）\n\n\nJVM 在运行时会：\n内存管理：使用 堆、栈、方法区、运行时常量池 等。\n垃圾回收（GC）：回收不再使用的对象内存。\n异常处理：执行过程中出现异常时，JVM 按照异常机制处理。\n\n\n\n\n\n程序终止（Termination）\n\n\n当 main 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。\n在退出前，可能会执行 finally 块、shutdown hook（关闭钩子）。\n\n\n程序生命\n\n$$.java(源码) \\underset{\\text{decompile}}{\\overset{\\text{compile}}{\\longleftrightarrow}} .class(字节码)\\xrightarrow{\\text{load}}class类\\xrightarrow{\\text{execution}}机器码\\xrightarrow{\\text{run}}结果$$\n\nJVM, JRE, JDK的关系\n\n\n\n名称\n全称\n作用\n是否包含编译器\n是否必需开发 Java 程序\n说明\n\n\n\nJVM\nJava Virtual Machine（Java 虚拟机）\n运行 Java 字节码的虚拟计算机，负责加载字节码并执行\n❌ 不包含\n❌ 不单独用于开发\n是运行 Java 程序的“引擎”\n\n\nJRE\nJava Runtime Environment（Java 运行时环境）\n运行 Java 程序所需的环境，包含 JVM + 核心类库\n❌ 不包含\n❌ 仅能运行，不能开发\n如果你只需要运行 Java 程序（比如别人的软件），安装 JRE 就够了\n\n\nJDK\nJava Development Kit（Java 开发工具包）\n开发 Java 程序所需的完整工具包，包含 JRE + 编译器（javac） + 调试工具等\n✅ 包含（javac）\n✅ 必需\n开发 Java 程序必须安装 JDK\n\n\n编译字节码（.class文件）\n.class文件是 Java 源代码（.java）经过 javac编译后生成的字节码文件，它是 平台无关的中间代码，不能直接被操作系统执行，但可以被 Java 虚拟机（JVM）加载和执行。\n\n文件结构ClassFile &#123;    u4             magic; // 魔数CAFEBABY，仅代表这个文件是java文件，没有其他作用    u2             minor_version; // 副版本号    u2             major_version; // 主版本号    u2             constant_pool_count;         // 常量池大小    cp_info        constant_pool[constant_pool_count-1]; // 常量池    u2             access_flags;                // 访问标志(public, private)    u2             this_class; // 指向当前类，是cp_info的下标    u2             super_class; // 指向父类    u2             interfaces_count;     u2             interfaces[interfaces_count]; // 接口信息    u2             fields_count;                     field_info     fields[fields_count]; // 字段信息    u2             methods_count;                   method_info    methods[methods_count]; // 方法信息    u2             attributes_count;                attribute_info attributes[attributes_count]; // 属性信息&#125;\n\ncp_infocp_info&#123;\tu1 tag;\tu1 info[]; // 大小是可变的。例如Integer就是u4 byte, String就是u2 length, u1 byte[length]。&#125;\n\n\ntag的取值表：\nthis_class指向CONSTANT_Class_Info，后者又指向一个字符串(name)。\n\nfield_infofield_info &#123;    u2             access_flags;    u2             name_index; // 本质是个下标，指向常量池    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n\naccess_flag的取值：字段可以叠加，Value取或\n\nmethod_infomethod_info &#123;    u2             access_flags;    u2             name_index;    u2             descriptor_index;    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;\n\n描述符\n规范：前缀+类完整名（包含分号）（如果不是以下的基本类型）\n\n前缀：\n1. \n\n\n\n\nJava 类型\n描述符\n说明\n\n\n\nbyte\nB\n8-bit 整数\n\n\nchar\nC\n16-bit Unicode 字符\n\n\ndouble\nD\n64-bit 双精度浮点数\n\n\nfloat\nF\n32-bit 单精度浮点数\n\n\nint\nI\n32-bit 整数\n\n\nlong\nJ\n64-bit 整数\n\n\nshort\nS\n16-bit 整数\n\n\nboolean\nZ\n布尔类型（true&#x2F;false）\n\n\nvoid\nV\n仅用于返回类型，表示无返回\n\n\narray\n[\n表示返回数组\n\n\n\n\n\n入参的表示：用小括号包裹。\n\n例\nint func(String s) --&gt; &lt;(Ljava/lang/String;)I&gt;,   void func() --&gt; &lt;()V&gt;,  float func(double[] d ) --&gt; &lt;([D)F&gt;\n\nattributes\n属性太多了，这里仅介绍几个常见的\n\n\nConstantValue：只针对常量static final的基础类型或字符串的属性，在编译器赋值，而不是运行时，提高效率。\nCode：函数体的内容，这个是非常重要的，尤其是后面学习ASM指令，一个类主要承载的功能，都反应在了method的code里。\nException：函数中声明的抛出的异常，可以有多个。注意这里是声明的抛出的异常，不包含一些运行时的异常。\n区分Code异常表和Exception属性：通过try-catch的异常会出现在code异常表。\n\n\nLineNumberTable\nLocalVariableTable\nSignature：与泛型密切相关\n\n函数code中的指令\nload &#x2F; push\n\nload的形式有很多种，比如我们可以把本地变量load到栈顶\niload_{y}按照int或byte或char或boolean或short类型，加载第y个变量。\nlload_{y}按照long类型加载第y个变量。\nfload_{y}按照float类型加载第y个变量。\ndload_{y}按照double类型加载第y个变量。\naload_{y}按照对象类型加载第y个变量，aload_0加载this，默认第0个位置是this或者常量load到栈顶\n\n\nbipush针对byte范围的int值的load\nsipush针对short范围的int值的load\n\n\nstore：理同load\n\nreturn：\n\nreturn之后需要保证栈是空的，不然编译会验证不通过。\n\nreturn等于代码return，不消耗栈顶\nireturn消耗栈顶一帧，返回一个int或byte或char或boolean或short类型\nfreturn消耗栈顶一帧返回一个float\nlreturn消耗栈顶2帧返回一个long\ndreturn消耗栈顶2帧返回一个double\nareturn消耗栈顶一帧返回一个地址，即返回一个对象类型的内存地址\n\n注意：return不一定是代码结束的地方，可能有判断分支有多个return语句，而且还有可能是athrow抛出异常。\n\n\n\npop &#x2F; dup &#x2F; new\n\npop：如果一个栈上的操作数，想要直接消耗掉，则直接用pop指令消耗一个栈帧，比如运行了一个函数操作后，直接忽略函数的返回值就可以pop消耗掉，如果返回值是long/double可以pop两次，或者pop2指令消耗。\ndup：复制栈顶栈帧。用法同pop。这经常用于new一个对象。\nnew的过程：对应字节码，如下new指令作用是，创建一个对象会在堆上分配内存，并将内存的地址放到操作数栈上；注意这里有个dup把地址复制了一份，这是new对象的一个固定操作，因为invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;这个构造方法与普通非静态方法一样，会消耗掉一个操作数作为this。所以需要提前把地址备份一下，不然new完地址就丢了，下面会说invoke相关指令。\n\n\ninvoke\n\ninvoke是函数调用的指令，他主要有5种，\ninvokevirtual普通的可访问的方法，需要依次把对象，参数从左到右放到栈顶。\ninvokestatic静态方法，需要依次把参数从左到右放到栈顶。\ninvokespecial特殊方法，构造方法，私有方法，父类中的方法，接口的default实现等，根据情况参考上面的操作数顺序。\ninvokeinterface接口方法，栈顶操作数顺序参考上面。\ninvokedynamic动态方法，一般是lambda表达式，栈顶操作数顺序参考上面。\n\n\n\n\n跳转\n\n注意，long &#x2F; double占两个局部变量\n其实try-catch是专门记录到code的异常表中的，上面提到过异常表和异常属性的区别。\n\n\n\n常量池概述\n常量池（Constant Pool）是 Java .class文件中的一个重要组成部分，它是一个结构化的、预定义的常量表，用于存储：字面量（如字符串、数字等），符号引用（如类名、方法名、字段名、方法描述符等），其他在程序运行时或类加载时可能需要引用的常量信息。\n它不是程序运行时动态生成的，也不是只在编译期间临时存在的东西。\n字面量（Literal）如 int a = 1; 里的 1，或者 &quot;Hello&quot; 这样的字符串。\n符号引用（Symbolic Reference）\n类和接口的全限定名（例如 java/lang/String）\n字段名和描述符\n方法名和描述符\n\n\n\n分类\n静态常量池（Class File Constant Pool）\n\n位置：位于 .class 文件中。\n生成时机：编译阶段由编译器写入。\n内容：\n字面量（Literal）\n基本类型常量（如 1.2f, 100）\n字符串字面量（如 &quot;Hello&quot;）\nfinal 常量（编译期可确定的值）\n\n\n符号引用（Symbolic Reference）\n类和接口的全限定名（如 java/lang/String）\n字段名和描述符\n方法名和方法描述符\n\n\n\n\n作用：为类加载时提供原始数据。\n\n注意：静态常量池是“死”的，只存在于 .class 文件里，不会变化。\n\n\n运行时常量池（Runtime Constant Pool）\n\n\n位置：方法区的一部分（JDK 8 之后是元空间 Metaspace 中）。\n\n生成时机：类加载的 加载 → 链接 过程中，JVM 会把 .class 文件中的静态常量池信息拷贝到运行时常量池。\n\n内容：\n\n解析后的字面量（真正的 int、float、String 对象引用）。\n符号引用在 解析（Resolution）阶段 转换为 直接引用（比如指向方法区中某个方法的指针）。\n\n\n特点：\n\n是动态的，可以在运行时产生新的常量，比如 String.intern() 会把字符串放到运行时常量池。\n不仅包含编译期的常量，还包含运行期解析出来的引用。\n\n\n字符串常量池（String Constant Pool）\n\n属于运行时常量池的一部分。但是在堆区中。即逻辑上属于运行时常量池，但是物理上不在一个区。\n专门存放字符串字面量的池子。\n早期（JDK 6 及之前）在方法区，JDK 7 后移到了堆中。\n\n\n\n\n\n字符串常量池\n字符串常量池在堆中，可能存在在E区、S区、O区。在讲解时默认在E区\n\n如果通过字面量赋值，则字符串对象直接出现在常量池中。\n\nString s &#x3D; “lizhi”;\n\n\nString s &#x3D; new String(“lizhi”);\n\n\nString a = &quot;lizhi&quot;;\nString b = new String(&quot;lizhi&quot;);\nString c = &quot;li&quot; + new String(&quot;zhi&quot;);\n      ![image-20250902205758484](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205758484.png)3. intern（）方法   1. 从注释中可以比较清楚地看到，当调用intern()方法时，会判断字符串常量池中是否有该对象的引用，通过equal()方法判断，如果存在就返回字符串常量池中的对象引用。如果不存在，就把当前字符串对象直接添加到字符串常量池中，**注意这里说的把该字符串对象添加到常量池池，是指把堆中对象的引用添加到常量池，并不是在常量池中再创建一个该字符串的对象**，然后返回该对象的引用。![image-20250902205439336](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902205439336.png)# 类加载## 类加载过程### 加载1. 将类的字节码载入**方法区**，并创建.class对象。   1. JVM 找到并加载类的二进制字节流。   2. 常见来源：class 文件、JAR 包、网络、甚至动态生成（如 `ASM`、`CGLIB`）。   3. JVM 为这个类生成一个 `Class` 对象，作为方法区/元空间中该类的访问入口。   4. 如果此类的父类没有加载，先加载父类   5. 加载是懒惰执行      1. 懒惰执行：需要用到的时候才执行### 链接1. 验证：验证类是否符合class规范，做合法性、安全性检查2. 准备：为**静态变量**分配空间，设置**默认值**   &gt; *可以理解为，为了安全性必须赋初始值*3. 解析：将常量池的符号引用解析为直接引用。例如方法调用时，编译期只知道方法的符号引用（静态常量池），解析阶段才会绑定到真正的方法地址。   &gt; *这里很形象，原本只是符号引用，但是解析之后就用指针把调用链串起来了。很有“链接”的意思*### 初始化1. **执行静态代码块**与**非final静态变量的赋值**   1. 执行类构造器 `&lt;clinit&gt;()` 方法（编译器自动生成），对静态变量赋值、执行静态代码块。   2. 初始化是类加载的 最后一步，也是程序员能控制的阶段。      `&lt;clinit&gt;()` 方法由编译器收集：      - 所有 **静态变量的显式赋值**      - 所有 **静态代码块**按照源码中的顺序合并。2. 初始化时懒惰执行## 触发时机1. 只会加载 / 链接，不会初始化的情况：   1. 引用一个 `static final`       &gt; 常量会在编译期被放入调用类的常量池，也就是说，运行时根本没有去访问类，只是直接用常量池里的值。   2. 获取类的 `Class` 对象（如 `String.class`）。      &gt; JVM 只需要返回一个指向 **类元信息的引用**2. 必须初始化的情况   1. `new` 一个对象。      &gt; 在创建对象前，需要保证该类的 **静态变量、静态方法、父类状态** 都处于可用的、已知的状态。   2. 访问类的静态变量或调用静态方法（非常量）。   3. 反射调用 `Class.forName()`。   4. 初始化一个类时，若其父类还没初始化，会先初始化父类。   5. JVM 启动时，执行 `main` 方法所在的类。\n\n\n\n\n\n例子：class A {    static {        System.out.println(“A init”);    }    public static final int X &#x3D; 100;   &#x2F;&#x2F; 编译期常量    public static final int Y &#x3D; new java.util.Random().nextInt(10); &#x2F;&#x2F; 运行期常量}\npublic class Test {    public static void main(String[] args) {        System.out.println(A.X); &#x2F;&#x2F; 访问 X        System.out.println(A.Y); &#x2F;&#x2F; 访问 Y    }\n}输出结果：100A init123Q1：为什么访问 X 不会触发初始化？A1：\tX &#x3D; 100 是 编译期可确定的常量（字面量）。\tJava 编译器在编译 Test 类的时候，就把 A.X 直接替换为字面量 100，并存到 Test 的常量池 中。\t也就是说，运行时根本没有去访问 A 类，只是直接用常量池里的值。\t所以不会触发 A 的初始化。\t这就是所谓的 常量传播&#x2F;常量折叠优化。\nQ2：为什么访问 Y 会触发初始化？A2：\tY 的值依赖于 new Random().nextInt(10)，这是运行时才能确定的。\t编译器无法在编译期把它折叠进常量池。\t所以，运行时访问 A.Y 时，必须先执行类的 () 方法来初始化 Y。\t这就会触发 A 的初始化。\n## 类加载器### 分类在 JVM 中，类的加载是由类加载器完成的。常见的三层体系：1. 启动类加载器（Bootstrap ClassLoader）   - C++ 实现，JVM 自带，不是 Java 类。   - 负责加载核心类库（`rt.jar`，Java 9 之后是 `java.base` 模块），即`%JAVA_HOME%/lib`2. 扩展类加载器（Extension ClassLoader / Platform ClassLoader）   - 负责加载 `JAVA_HOME/jre/lib/ext` 或 `java.ext.dirs` 下的类库，即即`%JAVA_HOME%/lib/etc`   - Java 9 之后改为 Platform ClassLoader。3. 应用类加载器（AppClassLoader）   - 负责加载 classpath 下的类（我们写的应用代码）。另外，还可以有 自定义类加载器，一般继承 `ClassLoader`。### 特性1. 用来确定类的唯一性   1. 一个类在 JVM 内存中只能有一个唯一的定义，由**类加载器 + 类的全限定名**唯一确定。二元组&lt;N（全限定名）, L（类加载器）&gt;。   1. **一个类由哪个类加载器真正加载了，那么它的 `getClassLoader()`方法返回的就是那个类加载器。**2. 传递性   ![image-20250902154447055](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154447055.png)   1. 如果类A是由L0加载的，那么A所依赖的类也要通过L0加载。   2. 即使是核心类库中的类，也要通过L0加载，但是会被委派到Bootstrap ClassLoader加载3. 可见性   ![image-20250902154812128](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902154812128.png)   1. 我们说类B对于类A可见，含义是：加载A的加载器L，也可以直接或委派间接加载B   1. 在 Java 中，一个类加载器只能看到它自身以及它的 父类加载器（Parent ClassLoader）所加载的类，但看不到它的 子类加载器（Child ClassLoader） 所加载的类。## 双亲委派机制### 概述1. 为什么要双亲委派？   1. 避免重复加载（保证类的唯一性）：**如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。**   2. 保证核心类库的安全性（比如 `java.lang.String` 不会被随便篡改）。2. 什么时候打破？   1. 一般出现在一些 **特殊场景** 下，尤其是框架 / 容器需要加载用户自定义类、插件类，或者隔离不同模块时：      1. 自定义类加载器加载应用类/插件类         - 典型例子：**Tomcat、Jetty 等 Web 容器**         - 它们需要加载不同 Web 应用的类，避免不同应用之间互相干扰（类隔离）。         - Tomcat 会自己实现类加载器，不完全遵循双亲委派。      2. 实现热加载（Hot Deployment）         - 开发工具（如 IDEA、Eclipse）、Spring Boot DevTools 热部署功能，需要在运行时重新加载类。         - 如果走双亲委派，父加载器一旦加载过，就无法替换，需要自己写类加载器打破机制。      3. SPI（Service Provider Interface）机制：**顶层加载器需要调用应用类加载器**。顶层提供接口，底层实现         - Java 自带的 `ServiceLoader` 需要加载厂商提供的实现类（通常在 `META-INF/services` 里）。         - 这些实现类不能放在 JDK 的核心类加载器里，只能由 **线程上下文类加载器（Thread Context ClassLoader）** 去加载，突破双亲委派。      4. 模块/插件化系统         - 比如 OSGi、各种插件化框架，需要动态加载第三方 jar 包，并且允许卸载/升级插件。         - 通常需要定制自己的类加载逻辑，不完全依赖父加载器。      5. 字节码增强 / 动态代理         - 一些框架（Spring、MyBatis、JVM Agent、字节码增强工具 ASM/CGLIB）在运行时生成代理类。         - 这些类需要在运行时被加载进 JVM，往往会使用自定义类加载器绕过双亲委派。### 机制内容![image-20250902153715595](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153715595.png)![image-20250902153959633](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902153959633.png)1. 工作过程   1. 当应用类加载器要加载一个类时，比如 `java.lang.String`。   2. 它不会自己去尝试加载，而是先 **委托给父加载器（Platform ClassLoader）**。   3. Platform ClassLoader 又委托给 Bootstrap ClassLoader   4. Bootstrap ClassLoader 如果能加载（发现 String 在核心库里），就直接返回。   5. 如果父加载器都没找到，才由子加载器自己去加载。2. 作用核心目的就是 **安全性和一致性**：   1. **保证核心类库不会被篡改**      1. 假设你写了一个自定义的 `java.lang.String` 类，如果没有双亲委派，你的 `String` 可能会被应用类加载器加载并替代系统的核心类，这是极其危险的。      2. 但因为双亲委派，加载 `java.lang.String` 的请求会交给 Bootstrap ClassLoader，它会优先加载 JDK 自带的版本，从而保证安全。   2. **保证类的唯一性**      1. 一个类在 JVM 内存中只能有一个唯一的定义（由 **类加载器 + 类的全限定名** 唯一确定）。      2. 如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。### 依赖冲突- 有一个典型的题目：有一个项目P，依赖于包B、C，这两个包又分别依赖A1.0、A2.0，且如果B用A2.0或者C用A1.0都会出错。此时如何让项目正常运行。  1. 一个类在JVM中的定义是由**&lt;类加载器+全限定名&gt;**决定的，如果在项目中用同一个类加载器加载了同一个路径下的A，就会导致冲突  2. 核心思路是让B、C分别依赖不同版本的包A，所以就要让他们依赖的A的类加载器或全限定名不一样。- 由此提出以下解决方案：  - 重构包名  - 打破双亲委派模型，使用自定义类加载器来实现类隔离  - 在Maven中显式指定依赖  - 使用兼容包### 打破双亲委派1. 重写ClassLoader中的loadClass方法2. 使用线程上下文加载器3. 为什么要打破双清委派？   1. **类隔离需求**：不同的框架、应用或模块可能需要加载 **同名但不同版本的类**，例如两个 Web 应用都用了不同版本的同一个库（如 Log4j）。如果都遵循双亲委派，所有类都由同一个类加载器加载，就会导致版本冲突。   2. **热部署 / 热加载**：在服务器环境中，我们可能希望在不重启整个 JVM 的情况下重新加载某个应用或模块，这就要求该模块的类能被独立加载和卸载，而双亲委派模型不利于这种灵活的类生命周期管理。   3. **框架/容器需要加载用户代码**：比如在 Web 容器中，容器本身和用户部署的 Web 应用可能都会用到一些公共的类（如 Servlet 相关类），但容器希望 **对这些类有统一的控制权**，同时又能让每个 Web 应用自己的类库相互隔离，避免互相干扰。## 数组类1. 所有数组实例都属于Object，每个数组实例都有自己的class2. 数组类本身不通过类加载器创建，而是通过JVM直接创建3. 数组类的元素需要类加载器创建4. 数组类也需要通过&lt;N, L&gt;唯一确定# 运行## 垃圾回收![image-20250902111808844](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902111808844.png)1. GC（Garbage Collection）发生在堆区2. 过程：   1. new对象出生在E区。当E区快满了，触发youngGC。扫描young区所有类，如果某个对象没有引用了，就打个标记，最后删除。幸存的对象复制到S区   2. S0和S1交替使用   3. 每幸存一轮，对象age加一   4. 如果某个对象达到一定年龄（可以是6岁），则转移到O区。   5. O区存放**老年对象**或**大对象**。   6. 如果O区快满了，则触发oldGC，暂停程序，全力垃圾回收。3. E区比S0区为8:14. 老年代比年轻代为2:1### 标记算法1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。   2. 有多个根对象，但是只会选用一个。      1. 栈中引用的对象      2. 常量引用的对象      3. 类静态属性引用的对象      4. Native方法引用的对象### 回收算法1. **标记清除算法**   1. 基本思想      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。   2. 优点      1. 不需要移动对象，实现相对简单   3. 缺点      1. 内存碎片化严重      2. 效率问题2. **复制算法**   1. 基本思想      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）      2. 每次只使用其中一块（如 From 区）来分配对象      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）      4. 交换角色：原来的 To 区成为新的 From 区，继续使用   2. 优点      1. 没有内存碎片！      2. 分配效率高      3. 适合对象存活率低的场景   3. 缺点      1. 浪费了一半的内存空间      2. 不适合存活对象多的场景3. **标记压缩算法**   1. 基本思想      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间   2. 优点      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）      2. 内存利用率高，适合大对象和长期存活对象分配   3. 缺点      1. 移动对象成本高！### 垃圾回收器不是所有垃圾回收的阶段都会触发 STW，但 **很多关键阶段必须 STW**，以下是一些常见 GC 算法的 STW 情况：1. **Serial GC / Serial Old GC（单线程 GC）**- **特点：** 单线程，适合客户端应用或小内存环境- STW：标记阶段（标记存活对象）清除/整理阶段都是 STW 的！整个过程都会暂停所有应用线程&gt; ✅ 用户线程完全停止，卡顿感明显，不适合高并发服务端应用2. **Parallel GC（多线程版本的 Serial，也叫吞吐量优先 GC）**- **特点：** 多线程并行执行 GC，适合后台计算型任务- STW：标记、清除、压缩等阶段大多是 STW 的同样会暂停所有应用线程&gt; ✅ 吞吐量高，但停顿时间仍然较长3. **CMS（Concurrent Mark-Sweep，老年代 GC，并发标记清除）**- **特点：** 目的是 **减少 STW 时间**，适合对延迟敏感的应用- **STW 阶段：**  - 初始标记（Initial Mark）**：**STW，只标记 GC Roots **直接**关联的对象（很快）  - 并发标记（Concurrent Mark）**：**与应用线程并发执行，不 STW。存在错标、漏标。  - 重新标记（Remark）**：**STW**，修正并发标记期间用户线程修改的引用关系（关键！）**  - 并发清除（Concurrent Sweep）**：**不 STW&gt; ✅ **CMS 通过并发标记减少了 STW 时间，但仍有 2 次较短的 STW（初始标记和重新标记）**4. **G1 GC（Garbage First，JDK 9+ 默认 GC）**- **特点：** 面向服务端，将堆划分为多个 Region，目标是控制停顿时间- STW 阶段：  - 初始标记（Initial Mark）**：**STW并发标记  - 最终标记（Remark）**：**STW  - 筛选回收（Cleanup / Evacuation）：部分阶段 STW&gt; ✅ G1 通过分 Region 和并发/并行结合，进一步优化了 STW 时间，是 JDK 9 后的默认 GC- | 设计点                                                       | 说明                                                         |  | :----------------------------------------------------------- | :----------------------------------------------------------- |  | **1. 堆的逻辑结构改变：不再分“年轻代”“老年代”物理隔离**      | 而是将整个 Java 堆划分为多个大小相等的 **Region（区域）**，每个 Region 可以是 Eden、Survivor 或 Old 区，**动态分配角色** |  | **2. 可预测的停顿时间模型（Pause Prediction Model）**        | 你可以设置一个目标停顿时间（比如 200ms），G1 会尽量在每次 GC 时控制在这个范围内 |  | **3. 分 Region 回收，优先回收垃圾最多的 Region（Garbage First）** | G1 会优先选择 **垃圾比例最高（存活对象最少）的 Region** 进行回收，从而提高回收效率，这就是名字中 **“Garbage First”** 的来源 |  | **4. 并发与并行结合**                                        | - 并发标记（和应用线程一起运行） - 并行回收（STW，多线程加速） |5. **ZGC（Z Garbage Collector，JDK 11+ 实验性，JDK 17+ 生产可用） &amp; Shenandoah**- **特点：** **超低延迟 GC，目标 STW 时间不超过 10ms，甚至 1ms**- STW：极短，大部分阶段都是并发执行的只会在极少数关键阶段有非常短暂的 STW&gt; ✅ ZGC 是目前最先进的低延迟 GC，适合超大堆、超低延迟场景（如金融、游戏、实时系统）# 编程## JVM详解## 内存区![image-20250902110508883](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250902110508883.png)### 堆1. 是 JVM 中 最大的一块内存区域，用于存放**所有**对象实例和数组（即通过 `new`创建的对象）。2. 是 垃圾回收器（Garbage Collector, GC）主要管理的区域。### 栈（虚拟机栈）1. 每个线程运行时都会创建一个 **虚拟机栈**，用于存储 **栈帧（Stack Frame）**，每个栈帧对应一个方法调用。2. 栈帧中包含：   1. 局部变量表（Local Variables）：存储方法参数和局部变量   2. 操作数栈（Operand Stack）：用于计算   3. 动态链接（Dynamic Linking）   4. 方法返回地址（Return Address）### 方法区1. 作用：   - 用于存储 已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。   - 是 Java 类的“元数据”存储区域。2. 特点：   - 线程共享   - 存放内容：类的结构信息（如类名、方法、字段、父类、接口等）**静态变量（static 变量）常量池（运行时常量池）**JIT 编译后的代码   - 在 HotSpot 虚拟机中，方法区的实现叫 “永久代（PermGen，Java 7 及之前）” 或 “元空间（Metaspace，Java 8 及之后）”   &gt; ⚠️ 注意：方法区是 JVM 规范中定义的逻辑区域，而永久代 / 元空间 是 HotSpot 的具体实现。3. **运行时常量池（Runtime Constant Pool）【线程共享，属于方法区的一部分】**   - 是方法区的一部分，用于存放 **编译期间生成的各种字面量和符号引用**，如：字符串常量（如 `&quot;Hello&quot;`）final 常量类/方法/字段的符号引用### 本地方法栈1. 作用   - 为 JVM 调用的 **Native 方法（如 C/C++ 写的方法，通过 JNI 调用）** 服务   - 类似于 Java 虚拟机栈，但是服务于本地（非 Java）方法### 程序计数器1. 作用：   - 是一块较小的内存空间，是 **当前线程执行的字节码的行号指示器**   - 用于记录当前线程正在执行的字节码指令地址，线程切换时能恢复执行位置2. 特点：   - **线程私有**   - **唯一一个在 JVM 规范中没有任何 OutOfMemoryError 情况的区域**   - 如果线程执行的是 Java 方法，计数器记录的是正在执行的字节码指令地址；   - 如果执行的是 Native 方法，则计数器值为空（Undefined）## 数据结构### List#### ArrayList1. 概述   1. 是一种集合，底层基于 **可扩容数组**。   2. 底层通过数组实现，初始大小为10；   3. 扩容以1.5倍放大2. 用法   1.    2. | 分类      | 方法                    | 说明                 |      | --------- | ----------------------- | -------------------- |      | 增加      | `add(E e)`              | 在末尾添加           |      |           | `add(int index, E e)`   | 在指定位置插入       |      | 删除      | `remove(int index)`     | 删除指定下标的元素   |      |           | `remove(Object o)`      | 删除匹配的第一个元素 |      |           | `clear()`               | 清空列表             |      | 修改/获取 | `get(int index)`        | 获取指定下标元素     |      |           | `set(int index, E e)`   | 修改指定下标元素     |      |           | `size()`                | 返回大小             |      |           | `isEmpty()`             | 是否为空             |      | 查找      | `contains(Object o)`    | 是否包含元素         |      |           | `indexOf(Object o)`     | 返回第一个匹配下标   |      |           | `lastIndexOf(Object o)` | 返回最后一个匹配下标 |#### LinkeList1. 概述2. 用法   1.    2. | 分类 | 方法                         | 说明                          |      | ---- | ---------------------------- | ----------------------------- |      | 增加 | `add(E e)`                   | 在末尾添加                    |      |      | `addFirst(E e)`              | 在头部添加                    |      |      | `addLast(E e)`               | 在尾部添加                    |      |      | `push(E e)`                  | 入栈（= addFirst）            |      | 删除 | `remove()` / `removeFirst()` | 删除并返回头部元素            |      |      | `removeLast()`               | 删除并返回尾部元素            |      |      | `remove(Object o)`           | 删除指定对象                  |      |      | `pop()`                      | 出栈（= removeFirst）         |      |      | `clear()`                    | 清空                          |      | 获取 | `get(int index)`             | 获取指定下标元素              |      |      | `getFirst()`                 | 获取头部元素（不删除）        |      |      | `getLast()`                  | 获取尾部元素（不删除）        |      |      | `peek()` / `peekFirst()`     | 查看头部元素，空时返回 `null` |      |      | `peekLast()`                 | 查看尾部元素，空时返回 `null` |      | 其他 | `size()`                     | 返回大小                      |      |      | `isEmpty()`                  | 是否为空                      |### CopyOnWriteArrayList1. CopyOnWriteArrayList 的核心原理 —— **写时复制（Copy-On-Write）**   什么是写时复制？   1. “写时复制” 的意思就是：当你要修改这个 List（比如 add / remove / set）时，不直接在原数组上修改，而是先复制一份新的数组，在新数组上进行修改，改完后再让内部的数组引用指向这个新数组。   2. 而对于读操作（如 get、iterator），始终是从原数组（可能是旧数组）上读取，不需要加锁，也不关心是否有写操作正在进行。2. `CopyOnWriteArrayList`是一个线程安全的 List，采用 “写时复制（Copy-On-Write）” 机制实现并发安全，适合读多写少的并发场景。### Map#### HashMap1. 概述   1. 底层是数组实现，大小必须是2的幂次   2. 哈希冲突会在对应位置生成链表（桶）   3. JDK8之后，链表达到一定长度后会变成红黑树2. 用法   1.    2. | 分类      | 方法                                       | 说明                         |      | --------- | ------------------------------------------ | ---------------------------- |      | 增加/修改 | `put(K key, V value)`                      | 插入键值对（若键存在则替换） |      |           | `putAll(Map m)`                            | 批量插入                     |      |           | `putIfAbsent(K key, V value)`              | 键不存在时才插入             |      | 删除      | `remove(Object key)`                       | 删除键并返回对应的值         |      |           | `remove(Object key, Object value)`         | 键和值都匹配时才删除         |      |           | `clear()`                                  | 清空                         |      | 获取      | `get(Object key)`                          | 获取值，不存在返回 `null`    |      |           | `getOrDefault(Object key, V defaultValue)` | 不存在时返回默认值           |      |           | `containsKey(Object key)`                  | 是否包含某个键               |      |           | `containsValue(Object value)`              | 是否包含某个值               |      | 遍历      | `keySet()`                                 | 返回所有键                   |      |           | `values()`                                 | 返回所有值                   |      |           | `entrySet()`                               | 返回键值对集合               |      | 其他      | `size()`                                   | 返回大小                     |      |           | `isEmpty()`                                | 是否为空                     |      |           | `replace(K key, V value)`                  | 替换指定键的值               |      |           | `replace(K key, V oldValue, V newValue)`   | 旧值匹配时才替换             |#### LinkedHashMap1. 底层实现几乎和HashMap一样2. 在每个元素中添加了一个链表，指向下一个插入的数据#### TreeMap1. 底层用红黑树实现2. 特点是按照Key进行排序#### HashTable1. 是线程安全的（并发安全）2. 进行写操作时会对整个HashTable上锁#### ConcurrentHashTable1. 和HashTable的区别就是只对桶上锁### Set1. 本身是通过Map实现的2. 把Value设置为null，只用Key| 方法签名                     | 说明                                                         | 示例                                        || :--------------------------- | :----------------------------------------------------------- | :------------------------------------------ || `boolean add(E e)`           | 添加元素到集合，如果集合中 **已存在该元素则不会重复添加，并返回 false** | `set.add(&quot;apple&quot;)`                          || `boolean remove(Object o)`   | 移除指定元素，成功返回 true，否则返回 false                  | `set.remove(&quot;banana&quot;)`                      || `boolean contains(Object o)` | 判断集合中是否包含某个元素                                   | `set.contains(&quot;apple&quot;)`→ true/false         || `int size()`                 | 返回集合中元素的个数                                         | `set.size()`                                || `boolean isEmpty()`          | 判断集合是否为空                                             | `set.isEmpty()`                             || `void clear()`               | 清空集合中的所有元素                                         | `set.clear()`                               || `Iterator&lt;E&gt; iterator()`     | 返回集合中元素的迭代器，用于遍历                             | `for (String s : set) &#123; ... &#125;`              || `Object[] toArray()`         | 将集合转换为 Object 数组                                     | `Object[] arr = set.toArray()`              || `&lt;T&gt; T[] toArray(T[] a)`     | 将集合转换为指定类型的数组                                   | `String[] arr = set.toArray(new String[0])` |### Queue| 分类         | 方法                 | 功能                   | 队列为空/满时的表现                     || ------------ | -------------------- | ---------------------- | --------------------------------------- || **插入**     | `add(E e)`           | 插入一个元素           | 队列满时抛异常 `IllegalStateException`  ||              | `offer(E e)`         | 插入一个元素           | 队列满时返回 `false`                    || **查看队头** | `element()`          | 获取队头元素，但不删除 | 队列空时抛异常 `NoSuchElementException` ||              | `peek()`             | 获取队头元素，但不删除 | 队列空时返回 `null`                     || **移除队头** | `remove()`           | 删除并返回队头元素     | 队列空时抛异常 `NoSuchElementException` ||              | `poll()`             | 删除并返回队头元素     | 队列空时返回 `null`                     || **其他**     | `size()`             | 返回队列元素个数       | 0（如果队列空）                         ||              | `isEmpty()`          | 判断队列是否为空       | true/false                              ||              | `clear()`            | 清空队列               | 队列变空                                ||              | `contains(Object o)` | 判断是否包含某元素     | true/false                              |#### PriorityQueue1. 概述   1. `PriorityQueue&lt;E&gt;` 是 Java 提供的 **基于堆 (Heap)** 的优先队列实现类。      1. 插入元素：`O(log n)`      2. 删除堆顶：`O(log n)`      3. 获取堆顶：`O(1)`      4. 遍历 `PriorityQueue` 得到的结果 **不是排序好的**      5. **允许重复元素**，不允许 `null`。   2. 默认大小是11.      1. 当元素个数超过当前容量时，会 **自动扩容**。         扩容规则：         1. 如果旧容量 &lt; 64 → 新容量 = `(旧容量 * 2) + 2`            （比如 11 → 24 → 50 …）         2. 如果旧容量 ≥ 64 → 新容量 = `旧容量 + (旧容量 &gt;&gt; 1)`            （相当于 1.5 倍扩容，比如 64 → 96 → 144 …）   3. 默认是 **最小堆**：堆顶元素是“最小值”。   4. 如果要最大堆，需要自定义 **比较器 (Comparator)**。   5. 常见应用：**Top K 问题、任务调度、最短路径算法 (Dijkstra)、Huffman 编码** 等。2. 用法   1. 构造方法      1. ```java         PriorityQueue&lt;Integer&gt; pq1 = new PriorityQueue&lt;&gt;();           // 默认最小堆                  PriorityQueue&lt;Integer&gt; pq2 = new PriorityQueue&lt;&gt;(Collections.reverseOrder());           // 最大堆                  PriorityQueue&lt;String&gt; pq3 = new PriorityQueue&lt;&gt;(Comparator.comparingInt(String::length));           // 自定义比较规则：字符串长度         \n\n\n调用方法参考普通队列\n\n双端队列\n构造：Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();。从中可以看出，其本质就是一个链表。只不过为了面向接口编程，这样定义不会误用其他方法。\n用法：\nofferFirst、offerLast等等\n\n\n\n红黑树\n也是对树结构的平衡，但是和AVL树有区别\nAVL 树（严格平衡，查找快）\n红黑树（相对平衡，插入&#x2F;删除更快，综合性能更好）\n\n\n\n\n五大原则\n每个节点要么是红色，要么是黑色。​​\n根节点必须是黑色。\n叶子节点（NIL &#x2F; 空节点）视为黑色。\n红色节点的两个子节点都必须是黑色（即不能有两个连续的红色节点）。\n从任意一个节点到其所有后代叶子节点的路径上，黑色节点的数量相同（称为黑高相同）。\n\n\n\n\n口诀：左根右（二叉搜索树），根叶黑，不红红，黑路同\n\n\n插入\n\n默认插入点（cur）节点是红色的\n破坏了根叶黑：若插入节点是根节点，直接变黑\n破坏了不红红：\n若插入节点的“叔叔”节点（父节点的兄弟节点）是红色，则叔父爷变色，cur指向爷爷，然后递归判定原则\n若插入节点的叔叔节点是黑色，则进行旋转（同AVL树），然后旋转中心点和旋转点变色\n\n\n\n\n删除：\n\n\n理念：\n对于一般的二叉搜索树，删除都有三种情况：叶节点，有一个子树，有两个子树。但是有两个子树的情况最终是转换成前两种情况。所以针对红黑树，我们只需要研究前两种就好了\n针对红黑树，只有一个子树时，子树一定只有一个节点。否则要么违反不红红，要么违反黑路同\n\n\n删除叶节点：\n红色：直接删除\n黑色：我们把要调整的节点成为“双黑节点”，代表经过它的路径都少一个黑节点\n兄弟节点是黑色：\n兄弟节点至少有一个红色孩子：\n变色：兄弟节点、其红孩子和父节点都要集成对应的上级节点的颜色\n旋转\n\n\n兄弟节点只有黑孩子：\n把兄弟节点变为红色，那么就恢复了局部的黑路同，双黑节点交给父节点\n递归处理\n\n\n\n\n兄弟是红节点：兄父变色，朝双黑旋转\n\n\n\n\n\n\n\nB+树\n和B树的区别\n\n很像。当我们要遍历树中元素时，对于B树，需要中序遍历，这要求指针来回跳跃，非常耗时。\n\n而B+数则要求在叶节点上保存所有的元素，并且从小到大链接起来\n\n对于非叶子结点，每个元素代表对应子节点的最大值。\n\n非叶子节点相当于只是索引\n\n\n\n\n异常处理异常体系\n所有异常都来自于顶级父类Throwable\nThrowable下有两个子类：Exception, Error\nError：表示非常严重的错误（JVM或系统级），程序无法解决。\n比如，OutOfMemoryError（内存不足，堆内存溢出），StackOverflowError，（栈溢出，比如无限递归）\n\n\nException：表示程序可以解决的异常。Exception一般又可以分为RuntimeException和Checked Exception（受检异常 &#x2F; 必检异常）。\nRuntimeException：运行时异常，一般为逻辑错误。\nChecked Exception：检查异常，由编译器要求必须处理\n\n\n\n\n\n异常处理\ntry-catch-finally\n用于 捕获并处理异常：\ntry &#123;    // 可能抛出异常的代码&#125; catch (IOException e) &#123;    // 捕获并处理 IOException    e.printStackTrace();&#125; catch (Exception e) &#123;    // 捕获其他异常&#125; finally &#123;    // 无论是否异常都会执行的代码（如关闭资源）&#125;\n\n\n\nthrows（声明抛出）\n\n如果当前方法 不想处理某个受检异常，可以将其抛给调用者处理：\npublic void readFile() throws IOException &#123;    // 可能抛出 IOException 的代码&#125;\n\n调用者必须继续处理这个异常（catch 或继续 throws）。\n\n\n自定义异常\n你可以根据业务需求定义自己的异常类，通常继承自：\n\nException（受检异常）\nRuntimeException（运行时异常）\n\n示例：自定义受检异常\npublic class MyCheckedException extends Exception &#123;    public MyCheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n示例：自定义运行时异常\npublic class MyUncheckedException extends RuntimeException &#123;    public MyUncheckedException(String message) &#123;        super(message);    &#125;&#125;\n\n泛型和多态\n泛型的实现\n\n泛型（Generics）是如何实现的？ → 核心机制：类型擦除（Type Erasure）\n\n✅ 1. 泛型的本质：编译期的类型检查，运行时类型擦除\n\nJava 的泛型是通过 “类型擦除（Type Erasure）” 实现的，这意味着泛型信息只在编译阶段存在，用于类型检查，而在编译成字节码后，类型参数会被擦除，替换为默认类型（通常是 Object 或指定的边界类型）。\n\n\n✅ 2. 举个例子 👇\n你写这样的泛型代码：List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);String s = list.get(0); // 不需要强转\n\n但在编译后（字节码层面），它实际上变成了：List list = new ArrayList(); // 类型参数 &lt;String&gt; 被擦除了list.add(&quot;Hello&quot;);String s = (String) list.get(0); // 编译器自动插入了强制类型转换\n\n\n✅ 编译器在编译时保证了你只能放入 String，取出时也自动帮你转回 String，但运行时 JVM 看到的只是原始类型 List。\n\n\n✅ 3. 类型擦除的规则\n\n\n\n情况\n擦除后变成什么\n\n\n\nList&lt;T&gt;\n擦除为 List&lt;Object&gt;（JDK 1.5 早期）或更准确地说是 List（原始类型）\n\n\nList&lt;String&gt;\n擦除为 List，但编译器会做类型检查并插入强制转换\n\n\nT extends Number（比如 List&lt;Integer&gt;）\n擦除为 Number，即上限类型\n\n\nT没有指定边界\n擦除为 Object\n\n\n\n✅ 4. 为什么用类型擦除实现泛型？\n\n历史原因：为了兼容 Java 5 之前的代码（非泛型代码），保证泛型引入后 旧代码依然能运行，不破坏二进制兼容性。\nJVM 层面没有泛型支持：Java 的虚拟机（JVM）本身并不直接认识泛型类型，它是基于原始类型运作的。\n\n\n✅ 总结：泛型是 Java 编译器层面的语法糖，它通过类型擦除在编译时提供类型安全，运行时则“擦除”掉具体类型信息。\n\n\n\n\n\n线程创建\n\n\n方式\n说明\n是否推荐\n适用场景\n\n\n\n1️⃣ 继承 Thread类\n自定义类继承 Thread，重写 run()方法\n⭐ 不推荐\n简单示例、学习线程基础\n\n\n2️⃣ 实现 Runnable接口\n实现 Runnable接口，实现 run()方法，传给 Thread 对象\n⭐⭐⭐⭐ 推荐\n大多数场景，灵活、面向接口\n\n\n3️⃣ 实现 Callable&lt;V&gt;接口 + FutureTask\n类似 Runnable，但可以有返回值，能抛异常\n⭐⭐⭐ 推荐（需要返回值时）\n需要获取线程执行结果的场景\n\n\n4️⃣ 使用线程池（Executor 框架）\n通过线程池（如 Executors）管理线程的创建和执行\n⭐⭐⭐⭐⭐ 强烈推荐\n生产环境、高并发、线程复用\n\n\n\n创建线程池参数\n\npublic ThreadPoolExecutor(\n    int corePoolSize,                  // 核心线程数\n    int maximumPoolSize,               // 最大线程数\n    long keepAliveTime,                // 空闲线程存活时间\n    TimeUnit unit,                     // 时间单位\n    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列\n    ThreadFactory threadFactory,       // 线程工厂\n    RejectedExecutionHandler handler   // 拒绝策略\n)\n\n### 线程池1. 工作原理   1. 步骤 1：如果当前线程数 &lt; 核心线程数（corePoolSize）      - 线程池会 立即创建一个新线程 来执行这个任务      - 该线程执行完任务后 不会被销毁，而是进入线程池中 等待下一个任务   2. 步骤 2：如果线程数 ≥ 核心线程数，但任务队列未满      - 线程池 不会创建新线程      - 而是把任务放入 任务队列（workQueue）中等待      - 空闲的核心线程会 从队列中取出任务执行   3. 步骤 3：如果任务队列已满，但线程数 &lt; 最大线程数（maximumPoolSize）      - 线程池会 创建新的线程（非核心线程） 来执行这个任务      - 这些线程在完成任务后，如果 空闲时间超过 keepAliveTime，就会被销毁   4. 步骤 4：如果线程数已达最大线程数，且任务队列已满      - 线程池会触发 拒绝策略（RejectedExecutionHandler）比如抛出异常、丢弃任务、由调用线程自己执行等2. 注意，是等待队列满了之后才会创建新线程。### ThreadLocal1. 是什么？   1. `ThreadLocal`是 Java 中一个非常有特色的线程绑定机制，它提供了一种**线程本地存储**（Thread-local Storage）的方式，即 每个线程都有自己独立的变量副本，线程之间互不干扰，从而避免了多线程环境下的共享变量同步问题。   2. **ThreadLocal 本身是用来存储单个线程的单一变量（一个 ThreadLocal 对应一个值）**2. 应用场景   1. 线程上下文信息传递（如用户登录信息、请求上下文）      在 Web 应用或服务端程序中，一个请求往往由一个线程处理，我们经常需要在处理过程中传递一些上下文信息，比如：      - 当前登录用户信息（User）      - 请求 ID（traceId / requestId）      - 数据源信息      - 事务上下文      如果通过方法参数一层层传递，代码会非常冗余。使用 `ThreadLocal`可以优雅地解决这个问题，让这些信息**在当前线程中“全局可见”**   2. 数据库连接、Session 等线程隔离资源管理      1. 为了保证每个线程使用独立的数据库连接，避免多线程并发问题，会使用 `ThreadLocal`来保存当前线程的 Connection 或 Session。3. 底层原理   1. 每个 Thread 对象内部都有一个 ThreadLocalMap   2. 数据结构：ThreadLocalMap（类似简易的 HashMap）      - `ThreadLocalMap`是 ThreadLocal 的静态内部类      - 它的 **key 是 ThreadLocal 对象本身（弱引用）**      - value 是线程本地存储的实际值      - 它是一个 定制化的哈希表，专门为 ThreadLocal 服务   3. ```java      Thread      └── threadLocals: ThreadLocalMap             ├── key: ThreadLocal 对象1（弱引用） → value: 线程1的变量值1             ├── key: ThreadLocal 对象2（弱引用） → value: 线程1的变量值2             └── ...                   （每个线程都有自己的 threadLocals，彼此独立）\n\n\n\n\n内存泄露问题\n\nEntry 的 key 是 ThreadLocal 对象的弱引用，但 value 是强引用\n当你不再引用这个ThreadLocal，但是线程长期存活时，当遇到GC，key就会被回收（因为是弱引用），但是value没法回收。造成泄露。\n一定要用threadLocal.remove()手动回收\n\n\n\n同步乐观锁和悲观锁\n\n\n对比维度\n悲观锁（Pessimistic Locking）\n乐观锁（Optimistic Locking）\n\n\n\n核心思想\n“总会有人抢，先加锁，防止冲突”\n“大家不一定会冲突，先尝试，冲突了再处理”\n\n\n锁的获取\n操作数据前先加锁，阻止其他人修改\n操作数据前不加锁，提交时检查是否被修改过\n\n\n并发性能\n并发度低，线程会阻塞，上下文切换开销大\n并发度高，无阻塞，靠重试或版本控制解决冲突\n\n\n适用场景\n冲突频繁，写多读少（如银行转账）\n冲突较少，读多写少（如计数器、浏览量）\n\n\n实现方式\nsynchronized、ReentrantLock、数据库行锁&#x2F;表锁等\nCAS、版本号（version）、时间戳等\n\n\n典型实现\nsynchronized、Lock 接口、数据库的 SELECT ... FOR UPDATE\nCAS（Compare-And-Swap）、version字段、AtomicXXX\n\n\n是否阻塞\n是（线程会等待锁）\n否（线程不会阻塞，冲突时重试或失败）\n\n\nAQS\n\n\n项目\n说明\n\n\n\nAQS 是什么\nJava 并发包中实现锁和同步器的底层核心框架（如 ReentrantLock、Semaphore 的基础）\n\n\n核心功能\n管理同步状态（state）、线程排队（CLH 队列）、阻塞与唤醒\n\n\n核心变量\nvolatile int state：表示同步状态（比如锁是否被占用、剩余许可数等）\n\n\n核心机制\n线程获取资源失败时进入队列等待，资源可用时被唤醒\n\n\n两种模式\n独占模式（如锁）、共享模式（如信号量、读锁）\n\n\n子类实现\n开发者通过重写 tryAcquire&#x2F; tryRelease等方法，定义资源获取与释放逻辑\n\n\n应用广泛\n是 Java 中大部分同步工具（如 Lock、Semaphore、CountDownLatch）的底层实现基础\n\n\n\nAQS（AbstractQueuedSynchronizer，抽象队列同步器） 是 Java 并发包（java.util.concurrent）中 最核心、最基础的同步框架，它是 构建锁和同步器（如 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）的基石。\n\n作用\n\n同步状态的管理（比如锁是否被占用、资源数是否足够）\n线程的排队与阻塞（当资源不可用时，线程进入等待队列）\n线程的唤醒与通知（当资源可用时，唤醒等待线程）\n\n它主要用于构建 锁（Lock）和同步器（Synchronizer），是 实现线程安全与并发控制的重要基础框架。\n\n工作原理\n\n同步状态（State）\nAQS 内部维护了一个 volatile int 类型的 state 变量，表示 同步状态，这个状态的意义取决于具体的同步器实现\n\n线程的排队（CLH 队列）\n当某个线程尝试获取资源（比如锁、许可）但 失败时（比如锁被占用、许可不足），AQS 会将该线程封装成一个 Node 节点，并加入到一个 FIFO（先进先出）的等待队列中，这个队列叫做 CLH 队列（Craig, Landin, and Hagersten 队列）。\n\n阻塞与唤醒\n\n当线程获取资源失败时，AQS 会通过 LockSupport.park() 将线程阻塞（挂起）\n当资源可用时（比如其他线程释放了锁或许可），AQS 会通过 LockSupport.unpark() 唤醒队列中的线程\n\n\n\n\nAQS 底层数据结构 —— CLH 队列（简化理解）\n\n当线程获取资源失败时，AQS 会将线程封装成 Node 节点，并加入到一个 FIFO 队列（CLH 队列） 中等待。\n每个 Node 代表一个等待的线程\n队列是 双向链表结构\n头节点一般是占用资源的线程，后续节点是排队等待的线程\n\n\n\n\n\nsynchronized\n在 Java 中，当多个线程同时访问共享资源（比如一个变量、对象、集合等）时，如果没有合理的同步措施，就可能导致数据不一致、线程安全问题。\n\n\n同步关键字 synchonized\n\nsynchronized是 Java 提供的最基本的线程同步机制，它基于 对象监视器（monitor），可以修饰 方法 或 代码块，保证同一时刻 只有一个线程能进入被 synchronized 保护的代码区域。\n\n使用方法（只展示如何锁住代码块）：\n\npublic class Counter {\n    private int count = 0;\n    private final Object lock = new Object(); // 任意对象，作为锁对象\n\n    public void increment() {\n        synchronized (lock) {  // 只锁定需要同步的代码块，不是整个方法\n            count++;\n        }\n    }\n}\n2. 锁升级：   1. 根据线程竞争的情况，synchronized 锁会从 偏向锁 → 轻量级锁 → 重量级锁 逐步升级，尽量以最小的性能代价实现线程同步。   2. 三层锁状态      1.       2. | 锁状态                              | 说明                                                         | 适用场景                                        | 底层实现                                                  |         | :---------------------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------------- |         | **1. 偏向锁（Biased Lock）**        | 假设锁只会被 **一个线程访问**，不存在竞争，**加锁时几乎没有额外开销** | 单线程访问同步代码块的场景                      | 通过对象头 Mark Word 中记录偏向线程ID                     |         | **2. 轻量级锁（Lightweight Lock）** | 假设锁 **只有少量线程交替访问，竞争不激烈**，采用 **CAS 自旋方式获取锁，线程不阻塞** | 多线程交替执行，但 **没有或很少真正的并发争抢** | 通过 CAS 操作和栈帧中的 **Lock Record** 实现              |         | **3. 重量级锁（Heavyweight Lock）** | 当多个线程 **真正并发竞争锁时**，轻量级锁升级为重量级锁，线程会进入 **阻塞状态，由操作系统管理** | 高并发、多线程同时争抢锁                        | 基于操作系统 **Mutex Lock（互斥锁）**，涉及线程挂起与唤醒 |   3. 锁升级流程      1. ```java         无锁状态            ↓ （第一次被线程访问，且没有竞争）         偏向锁（Biased Lock）            ↓ （当有第二个线程尝试获取锁，发现不是自己）         轻量级锁（Lightweight Lock，通过 CAS 自旋）            ↓ （如果自旋超过阈值，或等待线程较多，竞争激烈）         重量级锁（Heavyweight Lock，线程进入阻塞，由 OS 管理）\n\n\n线程1第一次获取锁\n       ↓\n     偏向锁（记录线程1的ID，几乎无开销）\n       ↓\n线程2来尝试获取锁（不是线程1）\n       ↓\n   偏向锁撤销，升级为轻量级锁\n       ↓\n线程1释放，线程2通过 CAS 获取锁（自旋）\n       ↓\n如果自旋多次仍失败，或竞争激烈\n       ↓\n     升级为重量级锁（线程阻塞，OS 管理）\n   4. 自旋：      1. 当一个线程尝试获取某个资源（比如锁）失败时，它不会立即被阻塞（挂起）、让出 CPU，而是通过循环（忙等 / busy-waiting）的方式，不停地尝试重新获取锁，直到成功为止。      2. 简单来说就是：线程不放弃 CPU，而是“原地打转”，反复尝试，直到成功获取所需资源。#### ReentrantLock1. 用法   1. 创建：`private final Lock lock = new ReentrantLock();`   2. 在访问共享资源之前，调用 `lock.lock()`加锁。这个方法会阻塞线程，直到加到锁。   3. 执行你的临界区代码（操作共享资源）   4. **在 finally 块中调用 `lock.unlock()`释放锁**（⚠️ 必须做，防止遇到**异常**导致无法解锁）   5. `trylock()`会尝试枷锁，不会阻塞线程。加到锁返回true，否则返回false。   6. 例子   ```java    // 加锁保证线程安全    public void add() &#123;        lock.lock();      // 1. 加锁        try &#123;            count++;      // 2. 临界区代码（操作共享资源）        &#125; finally &#123;            lock.unlock(); // 3. 一定要在 finally 中解锁        &#125;    &#125;\n\n\n\n\n作用范围是从lock到unlock的中间代码块\n\n\n\n公平锁和非公平锁\n1. \n\n\n\n\n特性\n公平锁（Fair Lock）\n非公平锁（Nonfair Lock）\n\n\n\n定义\n按照线程请求锁的 先后顺序 获取锁，先到先得\n线程获取锁时，不排队，直接尝试抢锁，谁抢到算谁的\n\n\n是否排队\n✅ 按 FIFO（先进先出）顺序获取锁\n❌ 不保证顺序，允许插队\n\n\n可能导致饥饿\n❌ 不会，所有线程最终都能获得锁\n✅ 可能，某些线程可能一直抢不到锁\n\n\n吞吐量（性能）\n⬇️ 较低，因为要维护顺序\n⬆️ 较高，减少线程切换和等待\n\n\n实现方式\n加锁前先检查是否有线程在排队\n直接尝试 CAS 抢锁，抢不到再排队\n\n\n创建方式\nnew ReentrantLock(true)\nnew ReentrantLock(false)或默认\n\n\n\n底层原理\n\nReentrantLock的公平与非公平实现，核心都依赖于 AQS（AbstractQueuedSynchronizer，抽象队列同步器）。\n\nAQS 的核心机制\nAQS 内部维护了一个 FIFO 等待队列（CLH 队列），以及一个 volatile 状态变量 state 表示锁的状态：\n\nstate &#x3D; 0：表示锁未被占用\nstate &gt; 0：表示锁被占用，数值代表重入次数\n\n当线程尝试获取锁时：\n\n如果锁是空闲的（state &#x3D;&#x3D; 0），尝试通过 CAS（Compare And Swap） 抢锁\n如果锁被占用，线程进入等待队列中排队\n\n\n非公平锁（Nonfair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n直接尝试 CAS 抢锁（不排队！）使用 CAS 将 state 从 0 改为 1，如果成功，当前线程获得锁\n如果 CAS 失败（锁被占用），才进入 AQS 队列等待\n唤醒后继续尝试抢锁\n\n\n优点：吞吐量高，减少线程挂起和切换，性能更好\n缺点：可能导致某些线程一直抢不到锁（饥饿）\n\n\n公平锁（Fair Lock）的实现原理\n\n获取锁时的逻辑（简化）：\n先检查是否有线程在排队（hasQueuedPredecessors()）如果队列中 已经有其它线程在等待，那么当前线程 不去抢锁，直接进入队列排队\n如果队列为空，才尝试 CAS 抢锁\n如果 CAS 成功，获得锁；失败则进入队列\n\n\n优点：避免饥饿，每个线程最终都能获得锁，公平性好\n缺点：性能较差，增加了线程切换和排队时间\n\n\n\n\n\n\n\nCountDownLatch\n倒计时门闩：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待，直到其他线程完成一组操作。你可以把它想象成一个“倒计时器”：主线程等待 N 个子线程完成各自任务后，再继续执行。\n工作原理\nCountDownLatch内部基于 AQS 实现\n初始化时设置一个 state &#x3D; count（计数值）\n每调用一次 countDown()，state 减 1（通过 CAS 操作）\n调用 await()的线程会阻塞，直到 state &#x3D;&#x3D; 0\nCountDownLatch 只能用一次，计数归零后不能重置！\n\n\n\nSemaphore\nSemaphore 是一个计数信号量，用于控制同时访问某个资源的线程数量，常用于限流、资源池管理。\n工作原理\nSemaphore也基于 AQS 实现\n内部维护了一组 可用的许可（permits），也就是 state 值\n调用 acquire()时：如果还有许可（state &gt; 0），则 state 减 1，线程继续执行如果没有许可，则线程进入 AQS 队列等待\n调用 release()时：state 加 1，唤醒等待队列中的一个线程\nSemaphore 可以重复使用，许可可以动态获取和释放\n\n\n\n网络编程基本的通信架构\nCS架构（Client客户端 &#x2F; Server服务端）\nBS架构（Browser浏览器 &#x2F; Server服务端）\n\nIPInetAddress\n是JAVA中的一个类，用于表示 IP 地址（可以是 IPv4 或 IPv6），并提供了与 IP 地址相关的一些常用操作，比如解析主机名、获取本机地址等\n\n常用方法\n\n\n\n\n\n方法\n说明\n\n\n\nstatic InetAddress getByName(String host)\n根据主机名（如 &quot;www.baidu.com&quot;）或 IP 地址字符串（如 &quot;14.215.177.39&quot;）返回对应的 InetAddress实例。\n\n\nstatic InetAddress[] getAllByName(String host)\n返回与给定主机名关联的所有 IP 地址（因为一个域名可能对应多个 IP）。返回的是一个数组。\n\n\nstatic InetAddress getLocalHost()\n获取本机（localhost）的 InetAddress对象。\n\n\nString getHostName()\n获取此 IP 地址对应的主机名。\n\n\nString getHostAddress()\n获取该对象的 IP 地址字符串表示（如 &quot;192.168.1.100&quot;）。\n\n\nboolean isReachable(int timeout)\n测试该地址是否可达（通过网络 ping），timeout 是超时时间（毫秒）。注意：这个方法不一定在所有环境下都有效，比如受防火墙限制。\n\n\nPort\n周知窗口：0-1023\n注册端口：1024-49151\n动态端口：49152-65535\n\n通信协议UDP协议\n特点：无连接，不可靠\n不事先建立连接。发出去就不管了\n每次把数据封装在包内（lim 64KB）\n\nTCP协议\n面向连接，可靠通信\n三次握手，四次挥手\n\nUDP通信DatagramSocket 、DatagramPacket\nDatagramSocket用于收发数据报\n\nDatagramPacket表示一个实际的数据包包括数据内容，目标IP和端口，来源IP和端口。\n\n常用方法\n\n\n\n\nDatagramSocket()\n创建一个 UDP 套接字，系统自动分配端口（常用于客户端）\n\n\n\nDatagramSocket(int port)\n创建并绑定到指定端口（常用于服务端）\n\n\nvoid send(DatagramPacket p)\n发送一个数据报包\n\n\nvoid receive(DatagramPacket p)\n接收一个数据报包（阻塞）\n\n\nvoid close()\n关闭套接字，释放资源\n\n\nvoid setSoTimeout(int timeout)\n设置接收超时时间（毫秒）\n\n\nint getLocalPort()\n获取本地绑定的端口号\n\n\nboolean isBound()\n是否已绑定端口\n\n\nboolean isClosed()\n是否已关闭\n\n\n\n\n\n\njava.net.Socket\n常用方法\n1. \n\n\n\n\nSocket(String host, int port)\n创建 Socket 并连接到指定主机和端口\n\n\n\nInputStream getInputStream()\n获取输入流，用于读取服务器数据\n\n\nOutputStream getOutputStream()\n获取输出流，用于向服务器发送数据\n\n\nvoid close()\n关闭 Socket 和相关资源\n\n\nvoid setSoTimeout(int timeout)\n设置读取超时（毫秒）\n\n\nInetAddress getInetAddress()\n获取远程服务器 IP\n\n\nint getPort()\n获取远程服务器端口\n\n\nboolean isConnected()\n判断是否已连接\n\n\nboolean isClosed()\n判断是否已关闭\n\n\n\n\n\n\njava.net.ServerSocket","categories":["技术"],"tags":["Java","后端"]},{"title":"SSM学习笔记","url":"/2025/12/04/SSM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"学习路线\n不需要完整学习 Spring（特别是 XML 配置那一套）。\n只需要补齐一些 Spring 的核心概念：\nIoC&#x2F;DI（控制反转 &#x2F; 依赖注入）\nBean 生命周期与作用域\nAOP（切面编程，事务、日志、权限）\nSpring MVC 的基本原理（DispatcherServlet、HandlerMapping、Controller） 👉 这些都是 Spring Boot 底层依然在用的，你必须理解，不然看不懂它的自动装配。\n\n\n\n\nSpring Boot\n核心容器IoC（Inversion of Control）控制反转\n核心思想：使用对象时，不要显示的new创建对象，而是由“外部”提供对象。这个过程中对象创建权由程序移交到外部，称为控制反转。\n被创建和管理的对象在IoC容器中，称为Bean\n\nDI（Dependency Injection）依赖注入\n在容器中建立Bean与Bean之间依赖关系的过程，称为依赖注入\n\nBean\n什么是bean\n\nBean &#x3D; 被 Spring 容器（IoC 容器）管理的对象\n在普通 Java 程序里，我们需要手动 new 一个对象：\n\nUserService userService = new UserService();\n\n\n在 Spring 里，不用自己 new，交给 Spring 来管理，它会创建、装配、销毁对象。\n\n\nBean 的来源\n\n注解声明\n@Component：通用组件\n@Service：业务逻辑层\n@Repository：数据访问层（DAO）\n@Controller &#x2F; @RestController：控制层（Web）\n@Configuration + @Bean：在配置类里手动声明 Bean\n\n\n自动装配\nSpring Boot 通过 自动配置（AutoConfiguration） 和 @EnableAutoConfiguration，会自动往容器里注册很多 Bean（例如 DataSource、EntityManager）。\n\n\n\n\n生命周期\n\n实例化：Spring 创建对象（相当于 new）\n属性赋值 &#x2F; 依赖注入：给 Bean 注入依赖（DI, Dependency Injection）\n初始化：执行初始化方法（@PostConstruct &#x2F; InitializingBean.afterPropertiesSet()）\n使用：在应用中被调用\n销毁：应用关闭时销毁 Bean（@PreDestroy &#x2F; DisposableBean.destroy()）\n\n\n作用域：\n\n\n\n作用域\n说明\n\n\n\nsingleton（默认）\n每个 Spring 容器中只有一个实例（共享）\n\n\nprototype\n每次获取 Bean 都创建一个新实例\n\n\nrequest\n每个 HTTP 请求创建一个 Bean（Web 环境）\n\n\nsession\n每个用户会话一个 Bean\n\n\napplication\n整个 ServletContext 生命周期内一个 Bean\n\n\n\n\nAOP概述\n什么是 AOP？\n\nOOP（面向对象编程）：我们通过类和对象来组织代码。\nAOP（面向切面编程）：我们把 横切关注点（cross-cutting concerns） 从业务逻辑中抽离出来。\n\n\n简单说： 在不改动原有业务代码的情况下，动态地在某些方法的前后“插入”额外逻辑。\n\n常见的横切关注点有：\n\n日志记录（打印方法调用情况）\n\n性能监控（统计方法耗时）\n\n权限校验（检查用户是否有权限访问）\n\n事务管理（方法执行失败时回滚）\n\n\n\n\n\nAOP 的几个核心概念\n\nAspect（切面） 横切逻辑的模块化单元，比如“日志切面”、“事务切面”。\nJoin Point（连接点） 程序运行的某个点，可以是方法调用、异常抛出等。 Spring AOP 支持的连接点是 方法级别。\nPointcut（切点） 定义哪些连接点要被拦截，比如 execution(* com.example.service.*.*(..)) 表示拦截 service 包下所有方法。\nAdvice（通知） 切面在切点处要执行的操作，有几种类型：\n@Before：方法执行前\n@After：方法执行后\n@AfterReturning：方法成功返回后\n@AfterThrowing：方法抛出异常时\n@Around：方法执行前后都能操作（最强大，可以手动控制目标方法是否执行）\n\n\nWeaving（织入） 把切面逻辑“织入”到目标对象的过程。Spring AOP 用 动态代理 实现：\n如果目标类实现了接口 → JDK 动态代理\n如果没有接口 → CGLIB 字节码生成\n\n\n\n\n\nAOP代理\nAOP 代理是 Spring AOP 实现“横切逻辑织入”的核心机制，它是 Spring 在运行时为目标对象生成的一个代理对象，用来在调用目标方法前后，插入额外的增强逻辑（Advice），从而实现 AOP 的功能。\n\n运行流程\n\n你定义一个切面（Aspect），包含：切点（Pointcut）：描述哪些方法需要被增强（比如 execution(* com.example.service.*.*(..))）通知（Advice）：描述在目标方法执行 前&#x2F;后&#x2F;异常&#x2F;最终 要执行的逻辑（比如日志、事务）\nSpring 容器启动时，会扫描这些切面，并为目标 Bean 创建代理对象如果有接口 → JDK 动态代理如果无接口 → CGLIB 代理\n当你从 Spring 容器中获取 Bean 时，实际上拿到的是代理对象，不是原始对象！\n当你调用代理对象的方法时，代理会先执行横切逻辑（Advice），再调用真正目标方法（或根据通知类型决定顺序）\n\n\n示例\n\n启用AOP\n\n@SpringBootApplication\n@EnableAspectJAutoProxy  // 启用 Spring AOP\npublic class MyApp {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApp.class, args);\n    }\n}\n2. 定义切片类   1. ```java      import org.aspectj.lang.annotation.*;      import org.springframework.stereotype.Component;            @Aspect      @Component      public class LoggingAspect &#123;                // 定义切点：拦截 com.example.service 包下的所有方法          @Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)          public void serviceMethods() &#123;&#125;                // 前置通知：在目标方法执行前执行          @Before(&quot;serviceMethods()&quot;)          public void logBefore() &#123;              System.out.println(&quot;[AOP] 方法即将执行...&quot;);          &#125;                // 后置通知：在目标方法执行后执行          @After(&quot;serviceMethods()&quot;)          public void logAfter() &#123;              System.out.println(&quot;[AOP] 方法执行完成！&quot;);          &#125;      &#125;\n\n\n\n\n\n\n\n\nSpring MVC\n解释：\n\nM：Model。由Controller准备，包含要展示的数据\nV：View。由Thymeleaf模版担任，负责如何展示数据\nC：Controller。\n\n\n核心组件：\n\n\n\n组件\n作用\n\n\n\nDispatcherServlet（前端控制器）\n核心入口，接收所有 HTTP 请求，负责调度\n\n\nHandlerMapping\n根据请求 URL 找到对应的 Controller 方法\n\n\nController\n处理具体业务逻辑，返回 Model 和 View 或数据（如 JSON）\n\n\nViewResolver\n将逻辑视图名解析为实际页面（如 JSP、Thymeleaf）\n\n\nModelAndView &#x2F; @ResponseBody\n用于返回数据或视图\n\n\n\n基本流程：\n\n用户发起请求 → DispatcherServlet 接收\nHandlerMapping 找到匹配的 Controller 方法\nController 处理请求，返回ModelAndView\n视图解析并渲染返回给用户\n\n\n🎯 一句话： Spring MVC 通过 DispatcherServlet 统一调度，把请求交给对应的 Controller 处理，最终返回结果，是 Web 开发的核心框架。\n\n\n\nSpring事务概念\n在 Spring 的事务管理中，事务传播机制（Transaction Propagation Behavior） 是指：当一个事务方法被另一个事务方法调用时，这个事务该如何传播？是加入已有的事务，还是开启一个新的事务，还是以非事务方式运行？\n换句话说：事务传播机制定义了多个事务方法相互调用时，事务边界应该如何传播、如何管理，是 Spring 事务管理中非常核心的一个概念。\n\n事务传播机制\n\n\n传播机制\n枚举常量\n说明\n适用场景\n\n\n\n1. REQUIRED（默认）\nPropagation.REQUIRED\n如果当前存在事务，就加入该事务；如果当前没有事务，就新建一个事务\n✅ 最常用，适用于大多数业务方法\n\n\n2. REQUIRES_NEW\nPropagation.REQUIRES_NEW\n无论当前是否存在事务，都新建一个事务，并挂起当前事务（如果有）\n适用于独立事务场景，比如日志记录、审计等不应与主事务同生共死\n\n\n3. SUPPORTS\nPropagation.SUPPORTS\n如果当前有事务，就加入事务；如果当前没有事务，就以非事务方式运行\n适用于可选事务的场景\n\n\n4. NOT_SUPPORTED\nPropagation.NOT_SUPPORTED\n以非事务方式运行，如果当前有事务，就把当前事务挂起\n适用于不想参与事务的方法，比如只读查询\n\n\n5. MANDATORY\nPropagation.MANDATORY\n必须在一个已有的事务中运行，如果当前没有事务，就抛出异常\n适用于必须被事务方法调用的方法，防止误调用\n\n\n6. NEVER\nPropagation.NEVER\n必须以非事务方式运行，如果当前存在事务，就抛出异常\n适用于禁止事务的方法，比如某些严格只读操作\n\n\n7. NESTED\nPropagation.NESTED\n如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则新建一个事务 （嵌套事务是保存点机制，可部分回滚）\n适用于需要部分回滚的场景\n\n\n事务的两种实现方式\n声明式事务（Declarative Transaction）【推荐】\n\n使用 注解（如 @Transactional） 或 XML 配置，将事务管理代码与业务逻辑分离，让事务管理变得非常简单。\n\n\n编程式事务（Programmatic Transaction）\n\n通过 代码手动控制事务的开启、提交、回滚，更灵活但代码更繁琐，一般适用于需要 精细化控制事务边界 的场景。\n\n\n\n事务什么时候会失效\nSpring 的事务管理（特别是 声明式事务，即 @Transactional）是通过 Spring **AOP（动态代理）**实现的。\n\n也就是说：只有通过 Spring 代理对象调用的方法，事务才会生效；如果绕过代理直接调用，或者配置&#x2F;使用不当，事务就不会生效（即事务失效）。\n\nSpring 事务生效的条件总结（牢记）\n\n\n\n条件\n是否必须\n说明\n\n\n\n方法必须是 public\n✅ 是\nSpring AOP 只能代理 public 方法\n\n\n调用方式必须通过 Spring 代理对象（不能是 this.方法() 内部调用）\n✅ 是\n内部调用不会走代理，事务失效\n\n\n异常必须是 RuntimeException 或 Error，或者配置了 rollbackFor\n✅ 是\n默认只对未捕获的 RuntimeException 回滚\n\n\n方法不能是 final &#x2F; static\n✅ 是\n无法被代理增强\n\n\n必须启用事务管理（@EnableTransactionManagement 或 Spring Boot 自动配置）\n✅ 是\n否则事务注解不生效\n\n\n数据库与表引擎要支持事务（如 InnoDB）\n✅ 是\n如 MyISAM 不支持事务\n\n\n\nSpring 事务在以下情况会失效\n\n\n\n失效场景\n原因简述\n\n\n\nthis.方法() 内部调用\n没走 Spring 代理，事务不生效\n\n\n非 public 方法（private &#x2F; protected）\nAOP 代理不拦截\n\n\n异常被捕获未抛出 或 抛出非 RuntimeException\n默认不触发回滚\n\n\n方法被 final &#x2F; static 修饰\n无法被代理增强\n\n\n没有启用事务管理 或 事务管理器配置错误\n注解不生效\n\n\n数据库引擎不支持事务（如 MyISAM）\n表不支持事务机制\n\n\n\n\n事务的实现方式\nSpring 中的事务是通过 AOP（面向切面编程） + 事务管理器（如 DataSourceTransactionManager） 实现的，底层依托于数据库的事务机制，通过 声明式事务（@Transactional）或编程式事务（TransactionTemplate） 提供灵活的事务管理能力，让开发者可以轻松控制事务的提交、回滚与传播。\n\nSpring 的事务管理，本质上是对 数据库事务（如 MySQL 的事务）的封装和增强。一般都是在数据库的场景下使用事务。\n\n实现方式\n\nAOP（面向切面编程）—— 事务的底层实现方式\n\nSpring 的 声明式事务（@Transactional） 是通过 Spring AOP（动态代理） 实现的。也就是说：Spring 并没有直接操作事务，而是通过 AOP 在方法调用前后，添加了事务的开启、提交、回滚等逻辑。\n原理流程（简化）：\n当你使用 @Transactional 注解时，Spring 会为这个方法生成一个代理对象（JDK 动态代理 或 CGLIB）\n当你调用这个方法时，实际上是调用了代理对象的方法\n代理对象在方法执行前：根据配置开启事务（比如调用 beginTransaction()）\n代理对象在方法执行后：如果方法正常执行完毕 → 提交事务（commit()）如果方法抛出了异常（且符合回滚规则）→ 回滚事务（rollback()）\n\n\n\n\n事务管理器（PlatformTransactionManager）—— 事务执行的核心组件\n\nSpring 并不直接操作数据库事务，而是通过 事务管理器（PlatformTransactionManager） 与底层数据库交互，真正控制事务的开启、提交和回滚。\n\n\n\n\n\n\n\nSpring用了哪些设计模式\n\n\n设计模式\n应用场景\n说明\n\n\n\n工厂模式\nBeanFactory &#x2F; ApplicationContext\n管理 Bean 的创建\n\n\n单例模式\n默认的 Bean Scope\n一个 Bean 只有一个实例\n\n\n代理模式\nSpring AOP\n实现方法拦截与增强\n\n\n模板方法模式\nJdbcTemplate、RestTemplate\n封装固定流程\n\n\n观察者模式\nApplicationEvent &#x2F; Listener\n事件发布与订阅\n\n\n适配器模式\nHandlerAdapter、AdvisorAdapter\n接口转换与兼容\n\n\n装饰器模式\nBeanPostProcessor\n增强 Bean 功能\n\n\n策略模式\n事务管理器、视图解析器\n多种实现动态选择\n\n\n责任链模式\n过滤器链、拦截器链\n多个处理器依次处理请求\n\n\n原型模式\nBean Scope 为 prototype\n每次获取新实例\n\n\n组合模式\n树形结构数据（非核心）\n组合对象与叶子对象统一处理\n\n\n外观模式\n高级封装（如 JdbcTemplate）\n简化复杂 API\n\n\n建造者模式\nSpringApplicationBuilder\n分步骤构建复杂对象\n\n\nSpring常用的注解及其底层实现Bean定义相关\n@Component\n\n作用： 标识一个类为 Spring 管理的 Bean（即交给 IoC 容器管理）\n**底层实现：**Spring 在启动时通过 ClassPathScanningCandidateComponentProvider 扫描带有 @Component（以及衍生注解）的类将这些类解析成 BeanDefinition（Bean 的定义信息），并注册到 BeanDefinitionRegistry（通常是 DefaultListableBeanFactory）最终由容器实例化、管理这些 Bean\n\n@Component 是以下注解的“父注解”或“通用注解”\n\n@Service、@Repository、@Controller\n\n底层实现： 它们主要用于代码语义分层，底层实现与 @Component 完全一样\n\n\n\n依赖注入相关\n@Autowired\n作用： 自动注入一个 Bean（默认按 类型（byType） 匹配，如果有多个相同类型，再按 名称（byName &#x2F; @Qualifier））\n**底层实现：**Spring 通过 AutowiredAnnotationBeanPostProcessor（一个 Bean 后置处理器） 扫描带有 @Autowired 的字段 &#x2F; 方法 &#x2F; 构造器在 Bean 初始化过程中，自动解析匹配的 Bean 并注入如果找不到匹配的 Bean，默认会抛出 NoSuchBeanDefinitionException（可配置 required&#x3D;false）\n\n\n\n事务管理相关\n@Transactional\n作用： 声明一个方法或类是事务性的，方法执行时会由 Spring 自动管理事务（开启、提交、回滚）\n**底层实现：**基于 AOP（动态代理） + PlatformTransactionManager 事务管理器Spring 会为标注了 @Transactional 的方法生成一个 代理对象在方法调用前后，通过事务管理器控制事务的开启、提交、异常回滚支持配置传播机制（Propagation）、隔离级别（Isolation）、回滚异常类型等\n\n\n\n其他\n@SpringBootApplication\n作用： Spring Boot 应用的主启动注解，组合了以下三个注解：@Configuration@EnableAutoConfiguration@ComponentScan\n底层实现：@EnableAutoConfiguration 通过 SpringFactoriesLoader 加载 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 中的自动配置类，实现“约定优于配置”@ComponentScan 扫描当前包及子包，注册 Bean@Configuration 表明这是一个配置类\n\n\n\nSpring Security概述\n核心功能：它解决了什么问题？\n\n认证 (Authentication) —— “你是谁？”\n\n验证用户的身份。\n\n方式： 用户名&#x2F;密码、指纹、手机验证码、API Key、OAuth2（微信&#x2F;Google登录）等。\n\n结果： 告诉系统当前用户是 “张三”。\n\n\n\n\n\n授权 (Authorization) —— “你能做什么？”\n\n判断已认证的用户是否有权限执行某个操作。\n\n方式： URL 访问控制（如 &#x2F;admin 只有管理员能进）、方法级安全（如 deleteUser() 方法只有经理能调）。\n\n结果： 允许或拒绝请求（403 Forbidden）。\n\n\n\n\n\n\n\n底层原理\n\nSpring Security 的底层是基于 Servlet 过滤器链 (Filter Chain) 实现的。\n拦截请求： 当一个请求到达应用时，会先经过一系列的 Security 过滤器。\n处理安全逻辑： 每个过滤器负责不同的任务（例如：解析 Token、校验登录表单、检查 URL 权限、处理异常等）。\nSecurityContext： 认证成功后，用户信息会被存放在 SecurityContextHolder 中（通常基于 ThreadLocal），在整个请求处理过程中，你可以随时获取当前用户信息。\n\n\n\n\n核心组件：\n\nUserDetailsService (接口)\n作用： 加载用户数据的核心接口。你需要实现它，告诉 Spring Security 如何从你的数据库（MySQL, Redis 等）中查找用户。\n方法： loadUserByUsername(String username)\n\n\nUserDetails (接口)\n作用： 代表一个标准的用户对象。你的数据库 User 实体类通常需要实现这个接口，或者转换为这个接口的实现类。它包含密码、用户名、权限列表、账户是否过期等信息。\n\n\nPasswordEncoder (接口)\n作用： 处理密码加密。永远不要存储明文密码！\n常用实现： BCryptPasswordEncoder (目前最推荐)。\n\n\nSecurityFilterChain\n作用： 定义安全规则（哪些接口公开，哪些需要登录，使用什么登录方式等）。\n\n\n\n\n配置示例\n\n@Configuration\n@EnableWebSecurity // 开启 Spring Security\npublic class SecurityConfig {\n\n    // 1. 定义安全过滤器链 (核心配置)\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // 禁用 CSRF (通常在前后端分离/使用 JWT 时禁用，传统 Web 开发建议开启)\n            .csrf(csrf -&gt; csrf.disable())\n            \n            // 配置请求拦截规则\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(&quot;/public/**&quot;, &quot;/auth/login&quot;).permitAll() // 允许匿名访问\n                .requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)            // 只有 ADMIN 角色能访问\n                .anyRequest().authenticated()                             // 其他所有请求都需要登录\n            )\n            \n            // 配置表单登录 (如果不配置，默认会弹出一个浏览器自带的登录框)\n            .formLogin(form -&gt; form\n                .loginPage(&quot;/login&quot;)        // 自定义登录页面 URL\n                .loginProcessingUrl(&quot;/perform_login&quot;) // 提交表单的接口\n                .defaultSuccessUrl(&quot;/home&quot;, true)\n                .permitAll()\n            );\n\n        return http.build();\n    }\n\n    // 2. 配置密码加密器\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n\n\n\n\n常见应用场景\n\n传统 Web 应用 (Monolith)\n机制： Session + Cookie。\n流程： 用户登录 -&gt; 服务器创建 Session -&gt; 返回 Cookie -&gt; 后续请求带 Cookie -&gt; 服务器验证 Session。\nSpring Security 原生支持极好。\n\n\n前后端分离 &#x2F; 微服务 (Modern)\n机制： Token (如 JWT)。\n流程： 用户登录 -&gt; 服务器签发 JWT -&gt; 前端存储 JWT -&gt; 后续请求 Header 带 Authorization: Bearer  -&gt; 服务器解析 Token 验证身份。\n配置： 需要自定义 Filter 来拦截请求并解析 Token，且通常需要将 Session 策略设置为 STATELESS (无状态)。\n\n\n第三方登录 (OAuth2 &#x2F; OIDC)\n机制： 微信登录、GitHub 登录、SSO (单点登录)。\nSpring Security 提供了 spring-security-oauth2-client 和 spring-security-oauth2-resource-server 模块，极大简化了集成难度。\n\n\n\n\n必做功能\n1. \n\n\n\n\n序号\n必做工作\n说明\n备注\n\n\n\n1\n配置用户认证的数据来源（核心）\n必须告诉 Spring Security：用户信息从哪里来（数据库？内存？LDAP？）\n通常通过实现 UserDetailsService接口来完成\n\n\n2\n实现 UserDetailsService 接口\n根据用户名加载用户信息，返回 UserDetails对象（包含用户名、密码、权限等）\n是认证流程中连接数据与 Security 的桥梁\n\n\n3\n密码加密存储与匹配（核心安全）\n用户密码必须加密存储（如 BCrypt），并在认证时用 PasswordEncoder进行匹配\n严禁明文存储密码！推荐使用 BCryptPasswordEncoder\n\n\n4\n配置 HttpSecurity（权限控制）\n定义哪些 URL 需要登录、哪些角色能访问哪些接口、是否允许匿名访问等\n通过 authorizeHttpRequests()或旧版 antMatchers()配置\n\n\n\n\n\n\n过滤器链\nSecurityContextHolderFilter：检查你的 Session 或 Token。\n情况A（已登录）： 发现你是 “User: ZhangSan, Role: ADMIN”，放入上下文。\n情况B（未登录）： 上下文是空的（Anonymous）。\n\n\nUsernamePasswordAuthenticationFilter：检查 URL。\n发现 URL 是 &#x2F;admin&#x2F;users 而不是 &#x2F;login，直接放行，不做任何事。\n\n\n…中间经过一堆其他 Filter…\nAuthorizationFilter（最终守门员）：\n检查配置：&#x2F;admin&#x2F;** 需要 ADMIN 权限。\n情况A： 上下文里有 ZhangSan 且是 ADMIN -&gt; 放行 -&gt; 进入 Controller。\n情况B： 上下文是空的 -&gt; 抛出 AccessDeniedException。\n\n\nExceptionTranslationFilter（捕获异常）：\n捕获到异常，发现你根本没登录，于是重定向到 &#x2F;login 页面。\n\n\n\n相关接口\nAuthentication接口概念：\n它的实现类表示当前访问系统的用户，封装了用户相关信息。例如，用户名、密码以及其他可能的用户属性（如角色等）。\n使用时机：在身份验证过程中，当用户尝试登录系统时，会创建一个Authentication对象的实例来代表用户的认证请求。在认证成功后，也会得到一个包含用户完整信息的Authentication对象。\n使用方法：通常不需要直接实例化，而是通过Spring Security框架中的认证机制来创建和管理。例如，在自定义的认证逻辑中，可以获取已有的Authentication对象来检查用户是否已经通过认证，或者获取用户的相关信息。\n\n\nAuthenticationManager接口概念：\n定义了认证Authentication的方法。它是整个认证流程的核心管理接口，负责接收Authentication对象并进行认证操作。\n使用时机：在用户提交登录信息后，系统会将用户的登录信息封装成Authentication对象，然后交给AuthenticationManager进行认证。例如，当用户在前端输入用户名和密码并点击登录按钮后，后端代码会将这些信息构建成Authentication对象，调用AuthenticationManager的方法来进行认证。\n使用方法：一般通过配置来注入一个具体的AuthenticationManager实现（如DaoAuthenticationProvider等），然后在需要进行认证的地方调用其authenticate(Authentication authentication)方法，传入待认证的Authentication对象。如果认证成功，该方法会返回一个完全认证的Authentication对象；如果认证失败，则会抛出相应的异常。\n\n\nUserDetailsService接口概念：\n加载用户特定数据的核心接口。它里面定义了一个根据用户名查询用户信息的方法。\n使用时机：在认证过程中，当需要获取用户的详细信息时（例如，根据用户输入的用户名查找对应的用户记录），就会用到UserDetailsService。比如，在基于数据库的用户认证场景中，会根据用户名从数据库中查询用户的密码、角色等信息。\n使用方法：实现该接口并重写loadUserByUsername(String username)方法。在这个方法中，编写逻辑从数据源（如数据库、LDAP等）中根据给定的用户名获取用户信息，并将其封装成UserDetails对象返回。例如，在一个使用JDBC从数据库获取用户信息的实现中，会在这个方法中执行SQL查询，将查询结果转换为UserDetails对象。\n\n\nUserDetails接口概念：\n提供核心用户信息。通过UserDetailsService根据用户名从数据库获取处理的用户信息后，封装成UserDetails对象返回，然后将这些信息封装到Authentication对象中。\n使用时机：在整个认证和授权过程中都需要用到，用于传递和处理用户的基本信息和权限信息。例如，在认证时检查用户密码是否正确，在授权时确定用户具有的角色和权限。\n使用方法：通常会有多个实现类（如org.springframework.security.core.userdetails.User等），可以直接使用这些实现类来封装用户信息。也可以自定义实现类，根据具体需求添加或修改用户信息的字段和获取方式。在认证和授权相关的代码中，可以通过UserDetails对象来访问用户的基本属性和权限信息。\n\n\n\n服务端开发课程Thymeleaf\n定义：\n\nThymeleaf 是一个现代化的、用于 Java 的 服务器端模板引擎（Template Engine），主要用于在 Web 应用中生成动态 HTML 页面，支持 自然模板（Natural Templates），可以直接在浏览器中预览静态效果。\n它特别适合与 Spring Boot &#x2F; Spring MVC 一起使用，是它们的默认推荐模板引擎之一（另一个常见的是 JSP，但 Thymeleaf 更现代）。\n\n\n特性\n\nThymeleaf 的核心特点（重点！）\n\n\n\n特点\n说明\n优势\n\n\n\n1. 基于 HTML 的模板\n模板文件就是普通的 .html文件，不需要特殊扩展名\n易于编写、直观，前端开发者友好\n\n\n2. 支持自然模板（Natural Templates）\n模板可以直接在浏览器中打开并显示静态内容，便于设计和调试\n前后端分离开发更顺畅\n\n\n3. 与 Spring 深度集成\n是 Spring Boot &#x2F; Spring MVC 的官方推荐模板引擎，配置简单，使用方便\n适合 Spring 全家桶项目\n\n\n4. 表达式语言（Thymeleaf Expression）\n使用类似 th:text=&quot;${name}&quot;的标签来动态渲染数据\n清晰、简洁、功能强大\n\n\n5. 支持逻辑控制\n比如条件判断 th:if、循环 th:each、变量定义 th:with等\n可以灵活控制页面渲染逻辑\n\n\n6. 不依赖 Servlet 容器运行（可静态预览）\n模板可以在没有服务器的情况下直接用浏览器打开查看静态效果\n便于 UI 设计与原型开发\n\n\n\n\n\n用法\n\nThymeleaf 常用语法\n在 hello.html中，我们只用了最基本的 th:text，其实 Thymeleaf 还支持很多强大的功能：\n\n\n\n功能\n语法\n说明\n\n\n\n显示文本\nth:text=&quot;${var}&quot;\n设置元素的文本\n\n\n显示 HTML（谨慎使用）\nth:utext=&quot;${htmlContent}&quot;\n渲染 HTML 内容（有 XSS 风险，慎用）\n\n\n循环遍历\nth:each=&quot;item : ${list}&quot;\n类似 for循环，遍历集合\n\n\n条件判断\nth:if=&quot;${condition}&quot;\n条件为 true 时显示该元素\n\n\n变量定义\nth:with=&quot;name=${value}&quot;\n定义局部变量\n\n\n表单绑定\nth:field=&quot;*{fieldName}&quot;\n用于 Spring 表单绑定（配合 @ModelAttribute）\n\n\n链接生成\nth:href=&quot;@{/path}&quot;\n生成上下文相关的 URL\n\n\n引入模板 &#x2F; 布局\nth:replace=&quot;~{fragments/header :: header}&quot;\n用于模板复用和布局（高级用法）\n\n\n\n\n\n\n表单提交\n注意提交后一定要重定向一次，否则不安全，会出错。\n\n期中作业\n用Thymeleaf写一个网页小游戏\n\n","categories":["技术"]},{"title":"PA小记","url":"/2024/12/04/PA%E5%B0%8F%E8%AE%B0/","content":"思考题\n在cmd_c()函数中, 调用cpu_exec()的时候传入了参数-1, 你知道这是什么意思吗?\n在 NEMU 项目中的 cmd_c() 函数调用 cpu_exec(-1) 时，传入的 -1 参数表示让模拟器持续执行指令，直到某种停止条件（如断点或异常）发生。\n\n\n\n笔记\n用gdb调试NEMU：\n\n在nemu下执行make gdb\n在一个高度较高的窗口中运行GDB后, 输入layout split就可以切换到TUI, 这样你就可以同时从源代码和指令的角度来观察程序的行为了.\n\n\ncore文件：放在了&#x2F;tmp里面\n\n用gdb分析：格式gdb &lt;可执行程序&gt; &lt;核心转储文件&gt;\n\n\nRISC-32的指令格式\n![截图 2024-10-22 12-00-03](&#x2F;home&#x2F;mukongshan&#x2F;图片&#x2F;截图&#x2F;截图 2024-10-22 12-00-03.png)\n完整opcode编码表\n\n\n\nNEMU结构关键结构体全局设置\nword_t：表示与ISA字长等长的无符号类型, 在32位的ISA中为uint32_t, 在64位的ISA中为uint64_t.\nsword_t：表示与ISA字长等长的有符号类型, 在32位的ISA中为int32_t, 在64位的ISA中为int64_t\nchar *FMT_WORD：word_t类型对应的十六进制格式化说明符, 在32位的ISA中为“0x%08x”, 在64位的ISA中为“0x%016lx”\nCPU_state cpu：寄存器结构的全局定义.\n\nPA2\n涉及到了很多宏，详见手册RTFSC（2）\n\n\nstruct &#123;  // ...&#125; ISADecodeInfo;用于存放ISA相关的译码信息, 会嵌入在译码信息结构体Decode的定义中.\n\nINSTPAT：(意思是instruction pattern)是一个宏(在nemu/include/cpu/decode.h中定义), 它用于定义一条模式匹配规则. 其格式如下:\nINSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);\n\nDecode：\n\ntypedef struct Decode &#123;                                      vaddr_t pc;                                   vaddr_t snpc; // static next pc   vaddr_t dnpc; // dynamic next pc   ISADecodeInfo isa;           IFDEF(CONFIG_ITRACE, char logbuf[128]);&#125; Decode;\n\n\n\n关键函数PA1\nengin\n\ncpu_exec: 模拟cpu执行命令。包括检查nemu_state。参数n表示要执行的代码量。若n&#x3D;-1，则意思是让cpu一直执行下去，直到某种停止条件。\n\nexec_once: 执行一次命令。\n\n\nsdb_loop：负责调试机的运行，包括读取指令\n\nrl_gets：读取字符串\n\ncmd_c: 继续（continue）的意思。\n\n\n\n\n\ngetopt_long: getopt_long 是一个 C 语言标准库函数，用于解析命令行参数。与 getopt 不同的是，它支持 长选项（如 --option）以及短选项（如 -o）。长选项非常适合复杂的命令行工具，使选项的含义更具可读性。\n\n参数\n\nargc: 参数个数（通常来自 main 函数的 argc）。\n\nargv: 参数列表（通常来自 main 函数的 argv）。\n\noptstring: 短选项的字符串定义，每个字符表示一个选项。如果某个选项需要参数，在其后加上 :（如 -f filename）。\n\nlongopts: 长选项的定义，是一个 struct option 类型的数组，每个选项有四个字段：\n\n返回值：\n\n\n如果解析到短选项或长选项，则返回选项对应的字符（短选项）或 val（长选项）。\n如果遇到非选项参数，返回 1。\n当所有参数解析完毕时，返回 -1。\n\n\n\n\n\n\npaddr.c：内存相关的函数\n\npaddr_read：接受一个起始地址和长度，读取内存\npaddr_write\nguest_to_host：地址映射\n\n\n\nPA2\nisa_exec_once(Decode *s);int isa_exec_once(Decode *s);取出s-&gt;pc指向的指令并译码执行, 同时更新s-&gt;snpc.\n\n\n\ngdb用法\n启动GDB\n\n用-g：gcc -g -o myprogram myprogram.c\n\n用-ggdb：gcc -ggdb -o myprogram myprogram.c\n\n\n\n启动GDB：\ngdb .&#x2F;myprogram\n\n常用命令:\n\n运行程序：run 或 r：启动程序。run ：带参数启动程序，例如 run arg1 arg2。\n设置断点：break ：在指定行设置断点，例如 break 10。break ：在指定函数设置断点，例如 break main。break :：在指定文件的指定行设置断点，例如 break main.c:10。\n查看断点：info breakpoints：列出所有断点。\n删除断点：delete ：删除指定编号的断点。delete：删除所有断点。\n单步执行：next 或 n：执行下一行（不会进入函数）。step 或 s：执行下一行（会进入函数）。continue 或 c：继续执行程序直到下一个断点。\n查看代码：list 或 l：显示当前代码段。list ：显示指定行附近的代码。list ：显示指定函数的代码。\n打印变量：print  或 p ：打印变量的值。print&#x2F;x ：以十六进制显示变量值。\n查看栈信息：backtrace 或 bt：查看当前函数调用栈。frame ：切换到指定的栈帧，例如 frame 2。info frame：查看当前栈帧的信息。\n查看变量：info locals：查看当前栈帧中的局部变量。info variables：查看所有变量。\n修改变量：set variable &#x3D;：修改变量值，例如 set variable x&#x3D;10。\n退出GDB： quit 或 q：退出GDB。\n其他技巧  条件断点：使用 condition  ，例如 condition 1 x&#x3D;&#x3D;5。  断点命令：使用 commands  在指定断点触发时执行命令。\n\n\n\ngcc用法\n基本编译命令\n编译一个 C 源文件生成可执行文件:gcc -o program main.c\n编译多个源文件并生成一个可执行文件：gcc -o program main.c utils.c\n将源文件编译为目标文件（.o 文件），而不是直接生成可执行文件：gcc -c main.cgcc -c utils.c\n将多个目标文件链接成一个可执行文件：gcc -o program main.o utils.o\n\n\n\n","categories":["课业"]},{"title":"数据管理基础","url":"/2024/05/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/","content":"第一章\n举出适合用文件系统而不是数据库系统的例子；再举出适合用数据库系统的应用例子。\n\n解析：读者可以根据自己所使用的或了解到的实际应用来回答。例如：\n\n\n目前，许多手机上的小型应用都把数据存放在手机操作系统的文件中，如照片、短信和微信等数据。一般来说，功能比较简单、比较固定的应用系统适合用文件系统。\n目前，几乎所有企业或部门的信息系统都以数据库系统为基础，都使用数据库系统。例如，一个工厂的信息系统会包括多个子系统，如库存管理系统、物资采购系统、作业调度系统、设备管理系统和人事管理系统等；再如学校的学生管理系统、人事管理系统、图书管理系统等都适合用数据库系统。因此，数据库系统已经成为信息系统的基础和核心。\n\n\n试述数据库系统三级模式结构，并说明这种结构的优点是什么？答：\n\n数据库系统的三级模式结构由外模式、模式和内模式组成（参考《概论》图1.16)。\n外模式，亦称子模式或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。\n模式，亦称逻辑模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式通常是模式的子集。\n内模式，亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。\n为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式／模式映像和模式／内模式映像。正是这两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。\n\n\n\n第二章\n定义并理解下列术语，说明它们之间的联系与区别\n(1）域，笛卡儿积，关系，元组，属性答：\n域：域是一组具有相同数据类型的值的集合。\n笛卡儿积：给定一组域D,D2,….D，允许其中某些域是有相同的。这组域的笛卡儿积为D,XD,x.xD,&#x3D;|(d,.d2,.d.)ld,eD,,i&#x3D;1.2.….n|\n关系：在域D,D2,…,D上笛卡儿积D,xD2x…xD，的子集称为关系，表示为R(D1,D2,….D.)。注意，这里是用较为形式化的方法来定义关系。在第1章中则是用通俗的语言来说明什么是关系，是一种不严格的定义。\n元组：关系中的每个元素是关系中的元组。\n属性：关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute)。\n\n\n(2）候选码，主码，外码答：\n候选码：若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（candidate key)。\n主码：若一个关系有多个候选码，则选定其中一个为主码（primary key)。\n外码：设F是基本关系R的一个或一组属性，但不是关系R的码，如果F与基本关系S 的主码K，相对应，则称F是基本关系R的外部码（foreign key)，简称外码。\n\n\n(3）关系模式，关系，关系数据库\n关系模式：关系的描述称为关系模式（relation schema)。它可以形式化地表示为R(U,D,DOM,F)其中R为关系名，U为组成该关系的属性名集合，D为属性组U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。\n关系：见（1)，关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。27&#x2F;292\n关系数据库：关系数据库也有型和值之分。关系数据库的型称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。\n\n\n\n\n\n第五章\n数据库的完整性概念与数据库的安全性概念有什么区别和联系？\n\n答：\n\n区别：防范对象的不同。完整性防范的是不正确的、不完整的数据，安全性防范的是恶意用户或非法用户所执行的各种操作。\n联系：完整性和安全性都旨在保护数据，确保数据的准确性和可用性。完整性确保数据符合业务规则，而安全性确保数据不被非法篡改或泄露。\n\n\n\n\n","categories":["课业"]},{"title":"操作系统","url":"/2024/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"第一讲 · 操作系统概述概述\n内核，进程和线程：\n内核：控制多道程序执行的系统超级程序\n进程：即内核控制下的多道程序实例(一个独立执行的程序指令流)\n线程：是进程的基本执行单位，通常被称为轻量级进程。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源（如内存、打开的文件等）。\n\n\nOS是中断驱动的\n总览![屏幕截图 2025-02-24 113426](E:\\Pictures\\Screenshots\\屏幕截图 2025-02-24 113426.png)\n\n第二章 · 处理器管理文件中断处理器模式\n计算机通过设置处理器模式实现特权指令管理\n计算器一般设置0、1、2、3等四种运行模式(保护级别)\n0:内核级，操作系统内核，可以执行全部指令，包括中断处理、处理I&#x2F;O操作等命令\n1:系统调用级，执行系统调用，获得特定的和受保护的程序服务\n2:共享库级，可以多个运行进程共享，允许调用库函数，读取但不修改相关数据。\n3:用户程序，只能执行非特权指令，收到的保护最少\n\n\n0模式可以执行全部指令；3模式只能执行非特权指令；其他每种运行模式可以规定执行的指令子集\n一般来说，现代操作系统只使用0和3两种模式，对应于内核模式和用户模式\n处理器模式是由处理器模式位决定的。\n\n处理器模式切换\n$用户态\\to内核态$：中断、异常或系统异常等事件导致用户程序向OS内核切换。有以下三种：\n程序请求操作系统服务，执行系统调用\n程序运行时发生异常(如发生程序性中断，或者目态执行特权指令)\n程序运行时发生并响应中断(一般是I&#x2F;O中断)\n\n\n$内核态\\to用户态$：OS内核处理完成后，调用中断返回指令(如Intel的iret)触发\n\n栈空间\n用户栈：就是平常说的栈\n\n核心栈：\n\n核心栈也叫系统栈或内核栈，是内存中属于操作系统空间的一块区域，其用途包含以下两种:\n\n保存中断现场，嵌套中断\n\n保存操作系统程序(函数)间相互调用的参数、返回值、返回点以及程序局部变量。\n\n\n\n每个进程有一个核心栈:可读可写不可执行，大小有限\n\n硬件栈指针只有一个\n\n\n\n\n中断系统处理流程\n进程概述\n概念：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。\n具有一定独立功能的程序：进程是相对独立的\n关于某个数据集合：对于不同数据集合的操作不是同一个进程。\n一次运行活动：有生命周期\n\n\n进程是操作系统进行资源分配和调度的一个独立单位:这只限于单线程单进程的情况下\n属性：\n动态性:进程是程序在数据结合上的一次执行过程，是动态概念\n共享性:同一程序同时运行于不同数据集合上时都是不同的进程，即不同的进程可以运行相同的程序。\n独立性:每个进程是操作系统中的一个独立实体。有自己的虚存空间、程序计数器和内部状态.\n制约性:进程因共享资源或协同工作产生相互制约关系，造成进程执行速度的不可预测性，必须对进程的执行次序或相对执行速度予以协调。\n并发性:多个进程的执行在时间上可以重叠。\n\n\n组成：一个进程包括五个实体部分，分别是：\n(OS管理运行程序的)数据结构P\n(运行程序的)内存代码C\n(运行程序的)内存数据D\n(运行程序的)通用寄存器信息R\n(OS控制程序执行的)程序状态字信息PSW\n\n\n\n转态和转换\n进程三态模型\n\n只要操作系统支持多道程序设计，就必须要设计进程转换模型来管理，必须实现三个进程状态和四个跳转关系\n进程状态转换一定有内核的参与。\n四个状态转换，一个不能少，一个也不能多，其他的转换不存在的原因如下：\n没有就绪态到等待态:到等待态需要内核参与。\n没有等待态到运行态:等待的资源还没有就绪，无法进入运行态。\n\n\n\n\n挂起\n\n概念\n\nOS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况。，现为性能低和死锁两种情况。\n解决办法：剥夺某些进程的内存及其他资源，调入OS管理的对换区（对换区在磁盘上，是外存），不参加进程调度，待适当时候再调入内存、恢复资源、参与运行，这就是进程挂起\n挂起态与等待态有着本质区别\n进程挂起:没有任何资源\n进程等待:占有已申请到的资源处于等待\n\n\n结束挂起状态的命令只能由操作系统和父进程发出。\n\n\n挂起的选择和恢复\n\n挂起的选择：\n一般选择等待态进程进入挂起等待态\n也可选择就绪态进程进入挂起就绪态\n运行态进程还可以挂起自己\n\n\n挂起的恢复\n等待事件结束后，挂起等待态进入挂起就绪态\n一般选择挂起就绪态进程予以恢复\n操作系统极其空闲才会选择调入挂起等待态的进程\n\n\n\n\n\n\n\n描述和组成进程映像\n某一时刻进程的内容及其执行状态集合：\n进程控制块: 每个进程捆绑一个，保存进程的标识信息、现场信息和控制信息。进程创建时创建进程控制块，进程撤销时回收进程控制块，与进程一一对应，是进程存在的唯一标识。\n进程程序块: 进程执行的程序空间，规定进程一次运行所应完成的功能。\n进程数据块: 进程处理的数据空间，是进程的私有地址空间，包括各类私有数据、处理函数的用户栈和可修改的程序\n进程核心栈: 每个进程捆绑一个，进程在内核模式下运行时使用的堆栈，中断或系统过程使用，保存函数调用的参数、局部变量和返回地址等。\n\n\n进程运行时如果遇到要执行操作系统内核函数，此时则保存应用程序的全部现场信息及其用户栈，使其不被内核程序破坏。而内核函数运行时使用进程的核心栈来放置工作信息。\n进程映像是内存级的物理实体，又称为进程的内存映像\n进程的内存映像示意图\n\n进程控制块&#x2F;描述符（Process Control Block，PCB）\n\n进程控制块PCB是OS用于记录和刻画进程状态及环境信息的数据结构，是进程存在的唯一标识，是操作系统掌握进程的唯一资料结构和进程调度的主要依据\n包括标识信息、现场信息和控制信息。\n\n进程上下文\n进程的执行需要环境支持，进程上下文刻画了进程的执行情况.\n\n进程队列\n进程队列分类\n运行队列：通常只有一个进程\n等待(阻塞)队列:也是有机会被调入，他等待的资源或事件完成后，调入就绪队列。\n就绪队列:从就绪队列中挑选进程调入运行，按照优先级或FCFS的原则排队\n\n\n\n\n\n进程队列组织方式\n链接方式：采用单向链接或双向链接。\n索引方式：利用索引表记录不同状态进程的PCB地址或在PCB表中的编号\n核心是完成入队和出队操作\n进程与资源调度围绕进程队列展开\n\n\n\n\n进程管理\n原语\n\n原语是由若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性(保证对核心资源的访问是正确的，原语涉及到的资源都是共享核心资源，只能是唯一的)。原语的执行可以通过关中断实现\n进程控制使用的原语被称为进程控制原语，另一类常用原语是进程通信原语\n\n\n进程切换和模式切换\n\n进程切换与模式切换(状态转换)\n一些中断&#x2F;异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程，处理流程是：\n(中断&#x2F;异常触发)正向模式切换压入PSW&#x2F;PC\n保存被中断进程的现场信息\n处理中断&#x2F;异常\n恢复被中断进程的现场信息\n(中断返回指令触发)逆向模式转换弹出PSW&#x2F;PC\n\n\n比如计时中断，中断处理完成后直接恢复\n模式切换是进程仍在自己的上下文进行处理，仅仅是处理器状态发生了变化，内核仍然被中断进程的上下文中进行处理。\n\n\n\n\n\n\n线程概述\n把进程的两项功能分离开来\n\n独立分配资源(进程概念上)，进程作为系统资源分配和保护的独立单位，不需要频繁地切换\n被调度分派执行(线程概念上)，线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换\n\n\n多线程结构\n\n概念\n\n线程是进程能够并发执行的实体，是进程的组成单位，也是处理器调度和分派的基本单位。\n进程是一条执行路径，有独立的程序计数器，未运行时保护线程上下文。\n同一个进程中的所有线程共享进程获得的主存空间和资源。\n\n\n多线程策略\n\n\n内核级线程（ KLT, Kernel-Level Threads）\n\n特点\n优点：\n在多处理器上内核可以同时调度统一进程的多个线程运行。\n进程中的某一线程被阻塞了，内核能调度同一进程的其它线程占有处理器运行，也可以运行其他进程。\n由于内核比较小，内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率。\n\n\n缺陷：\n应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大。\n线程调度开销大，线程通信开销小。\n\n\n\n\n\n用户级线程（ULT, User-Level Threads）\n\n特点\n优点：\n节省开销和内核资源:所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源。\n允许进程按应用特定需要选择调度算法，甚至根据应用需求裁剪调度算法。\n可移植性好:能运行在任何OS上，内核在支持ULT方面不需要做任何工作。\nULT可以解决逻辑并行性问题。\n\n\n缺点：\n不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行。\n一个ULT的阻塞，将引起整个进程的阻塞:不能完成切换线程，因为内核感知不到进程中的线程的存在。\n\n\nULT可以解决逻辑并行性问题。\n\n\n\n混合式策略\n\n特点：\n合并了用户级线程&#x2F;内核级线程设施\n线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行\n一个应用中的多个用户级线程被映射到一些(小于等于用户级线程数目)内核级线程上\n程序员可以针对特定应用和机器调节内核级线程的数目，以达到整体最佳结果\n该方法将会结合纯粹用户级线程方法和内核级线程方法的优点，同时减少它们的缺点\n\n\n线程混合式策略下的线程状态\nKLT的三态模型，由系统调度负责\nULT的三态模型，由用户调度负责\n活跃态的ULT代表绑定KLT的三态\n活跃态的ULT运行时可激活用户调度，非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT\n\n\n\n\n\n为什么是活跃态绑定KLT的三态？\n因为ULT 依赖于 KLT 执行，而 KLT 受操作系统的调度机制控制。用户级线程（ULT）需要绑定到内核级线程（KLT）上才能真正执行\n只有ULT为活跃态且KLT为运行态，ULT才处于运行态。\n\n\n\n调度处理器调度层次\n高级调度：又称长程调度、作业调度，决定能否加入到执行的进程池中，管理从创建进程到调度运行再到结束阶段后的善后部分的全过程。\n中级调度，又称平衡调度、中程调度，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作。\n低级调度：又称短程调度、进程调度&#x2F;线程调度，根据某种原则决定就绪队列中哪个进程&#x2F;线程获得处理器，并将处理器让出给它使用。\n\n\n调度算法概述\n考虑因素\n\n资源利用率：使得CPU或其他资源的使用率尽可能高且能够并行工作$$CPU利用率&#x3D;\\frac{CPU有效工作时间}{CPU总运行时间}$$\n\n吞吐量：单位事假内CPU处理作业的个数，服务器的TPS，例如12306或淘宝\n\n公平性：确保每个用户每个进程获得合理的CPU份额或其他资源份额\n\n响应时间：\n\n使交互式用户的响应时间尽可能小，或尽快处理实时任务\n细分包含输入的程序命令传送到CPU时间、CPU处理请求命令的时间、处理所形成的响应回送到终端显示器的时间。\n\n\n周转时间：从提交给系统开始到执行完成获得结果为止的这段时间间隔称周转时间，应该使周转时间或平均周转时间尽可能短。\n\n\n\n调度模式\n\n抢占式(剥夺式)调度：当前正在运行的进程可能被操作系统中断，并转移到就绪态。处理器剥夺原则：\n高优先级进程&#x2F;线程可剥夺低优先级进程&#x2F;线程。\n运行进程&#x2F;线程时间片用完后被剥夺。\n\n\n非抢占式(非剥夺式)调度：一个进程一旦处于运行态，它就不断执行直到终止，或者为等待I&#x2F;O或请求某些操作系统服务而阻塞自己。\n与非抢占式调度相比，抢占式调度可能会导致较大的开销，但是可能对所有进程提供更好的服务，可以避免任何一个进程独占处理器太长时间\n\n\n\n先来先服务（FCFS）\n非抢占式\n弊端太大，性能会非常差，不被现在的操作系统使用\n\n最短进程优先（SPN）\n非抢占式\n缺点：\n需要预知作业所需的CPU运行时间\n忽略了作业的等待时间：只要持续不断地提供更短的进程，长进程就有可能饿死，同样也会服务不到。\n分时、实时处理仍然不理想。\n\n\n\n最短剩余时间优先（SRTF）\n抢占式\n\n最高响应比优先（HRRN）\n非抢占式\n\n\n每当需要调度时，计算出所有的响应比，选择最高的。\n\n$$响应比&#x3D;\\frac{等待时间+期待服务时间}{期待服务时间}&#x3D;1+\\frac{等待时间}{期待服务时间}$$\n\n\n优先级调度\n调度器总是选择优先级较高的进程，提供多个就绪队列(一组就绪队列)，代表各个级别的优先级。\n低优先级的进程可能很难被执行到？一个进程的优先级应该随着它的时间或执行的历史而变化。\n如果就绪队列中出现优先级高的进程&#x2F;线程，系统可以预先规定策略为非剥夺式和剥夺式策略。\n优先级的确定\n用户给出优先级\n系统综合考虑各因素，包括打开文件数、资源申请情况等等\n\n\n优先级确定方式\n静态：生命周期内不改变，容易造成饥饿问题。\n动态：生命周期内可能会发生改变，正在运行的进程逐渐降低优先级，正在等待的进程逐渐提高优先级。\n\n\n\n时间片轮转调度***（RR）\n本质也是先来先服务，但是要按照时间片来进行调度。\n根据各个进程进入就绪队列的时间先后轮流占有CPU一个时间片，基于时钟做抢占式调度。\n时间片中断：以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列队尾，然后基于FCFS策略选择下一个就绪进程运行\n时间片的确定：选择长短合适的时间片，一般为10ms到200ms\n过长则退化为先来先服务算法\n过短则调度开销显著增大\n\n\n时间片分为单时间片、多时间片和动态时间片三种\n使用时间片轮转调度算法，在给一个进程分配处理器的时候，不需要知道进程需要多长时间\n很多的调度都会结合时间片轮转调度算法来实现\n如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。\n\n\n多级反馈调度***(Multi-level Feedback Queue，MLFQ)，又称分级调度\n基本思想\n建立多个不同优先级的就绪进程队列\n多个就绪进程队列之间按照优先数调度\n高优先级的就绪进程, 分配的时间片短\n单个就绪进程队列中的进程的优先数和时间片相同,按照先来先服务算法调度\n\n\n如果没做完会惩罚降级，做题目要至少画一下前几个RQ。如果进程掉出去的同时，有新的进程进入，那么新的进程优先进入就绪队列\n对以计算为主的长进程不友好，就绪队列越深获得调度的机会越小\n不同的进程可以设置不同的时间片长度：q&#x3D;2^i^(可选)，i是第几次处理的意思\n多级队列更能够发现先到达的，时间片比较短的处理完。\n除了极少数的硬实时操作系统使用抢占式调度算法，绝大多数操作系统有效地组合时间片调度算法和优先数调度算法，采用分级调度算法的策略加以实现\n如果没有竞争不掉下去，时刻1(根据考试具体情况决定)\n\n彩票调度\n基本思想：为进程发放针对系统各种资源(如CPU时间)的彩票；当调度程序需要做出决策时，随机选择一张彩票，持有该彩票的进程将获得系统资源\n\n第三章 · 存储管理基础\n逻辑地址\n逻辑地址：又称相对地址，即用户编程所使用的地址空间\n逻辑地址从零开始编号，有两种形式：\n一维逻辑地址(地址)\n二维逻辑地址(段号:段内地址)\n\n\n\n\n物理地址\n又称绝对地址，从处理器角度看到的物理内存单元。\n处理器执行指令时按照物理地址进行\n\n\n\n连续存储管理单连续分区存储管理概述\n每个进程占用一个物理上完全连续的存储空间(区域)\n单连续分区存储管理细分:\n单用户连续存储管理\n固定分区存储管理\n可变分区存储管理\n\n\n分区方式不能实现虚拟存储。\n内部碎片和外部碎片\n内部碎片：比如在固定分区中，某一块被使用的分区中还有空闲\n外部碎片：比如在固定分区中，有空闲的小分区\n\n\n\n单用户连续分区\n适用于单用户单任务操作系统，如DOS\n\n主存区域(内存空间)划分为系统区与用户区\n\n系统区用于存放操作系统内核程序和数据结构等\n用户区用于存放应用程序和数据\n\n\n设置一个栅栏寄存器界分两个区域，硬件用它在执行时进行存储保护\n\n一般采用静态重定位进行地址转换\n\n硬件实现代价低\n\n单用户连续分区存储管理示意\n\n静态重定位：在装入一个作业时，把该作业中程序的指令地址和数据地址全部转换成绝对地址\n界限地址:放置软件访问到操作系统的部分\n\n\n\n固定分区\n又称静态分区模式\n\n基本思想：\n\n内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们都可以并发执行。\n可用静态&#x2F;动态重定位、硬件实现代价低、被早期OS采用\n\n\n主存分配\n\n主存分配表：包含内容：起始地址、长度、占用标志\n内存分配方法很简单，其任务有何时吧内存空间划分成分区：由系统管理员和操作系统初始化模块协同完成。\n\n\n\n作业进入分区的排队策略：\n每个分区有自己的作业等待队列，作业等待能装下自身的最小分区。\n所有等待处理作业排成等待队列，每当有空闲，找到队列中能进入的最大的一个。\n\n\n\n\n地址转换：\n\n缺点：\n\n由于预先规定了分区的大小，使得大作业无法装入，而不得不采用覆盖技术，带来负担。\n内存空间利用率不高，作业很少填满分区：固定分区存储管理不够灵活，既不适应大尺寸程序，又存在内存内零头，有浪费，内存内零头是因为在分区内部有零头。\n如果作业在运行中要求动态扩展内存空间是困难的。\n分区数目是操作系统初启动时确定的，会限制多道运行程序的道数。\n\n\n\n可变分区\n概述\n可变分区存储管理又称动态分区模式，按照作业大小划分分区，但划分的时间、大小和位置都是动态的。\n创建一个进程时，根据进程所需主存量查看主存中是否有足够的连续空闲空间\n若有，则按需要量分割一个分区\n若无，则令该进程等待主存资源\n\n\n由于分区大小按照进程实际需要量来确定，因此分区个数是随机变化的\n\n\n示例\n主存分配表\n管理的数据结构：已分配区表与未分配区表，采用链表实现\n找一个最大的空闲的位置进行分配\n\n\n内存回收\n可变分区方式的内存回收会导致内存空间的转换\n作业X撤离后有且仅有如上4种情况\n\n\n地址转换\n硬件实现机制与动态重定位\n进程的程序和数据的地址由硬件完成\n基址寄存器：分配进程的起始地址\n限长寄存器：进程占用的连续存储空间的长度\n\n\n\n\n\n动态分区分配算法最先适应优先使用低地址空闲分区\n最佳适应优先使用更小的空闲分区\n最坏适应优先使用更大的空闲分区\n临近适应（循环首次适应法）每次都从上次查找结束的位置开始查找空闲分区链\n分区方式的内存零头\n固定分区方式会产生内存内零头\n可变分区方式也会随着进程的内存分配产生一些小的不可用的内存分区，称为内存外零头，内存外零头是指分区内部是没有零头的，而是在外面的零头。\n最优适配算法最容易产生外零头\n任何适配算法都不能避免产生外零头\n\n交换与覆盖\n移动技术（程序浮动）\n\n碎片：内存中的小空闲区，移动分区来解决内存外零头问题。\n需要动态重定位支撑:静态重定位无法解决内存外零头\n问题：移动技术有极大的系统开销。\n\n\n对换技术：\n\n如果当前一个或多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用；同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为对换。\n被对换出去的进程的状态会调整为就绪态，并且通知存储管理程序，一旦内存可用，立即将该进程对换回内存。\n对换技术关键点\n被对换进程：通常系统选择时间片耗尽或优先级较低的进程对换出去。\n对换的进程信息：将数据区和堆栈通过文件系统转换为特殊文件保存。\n被对换的时机：\n批处理系统中：进程需要扩充内存空间但不能被满足时\n分时系统：\n时间片结束时\n执行I&#x2F;O操作时\n\n\n\n\n\n\n\n\n覆盖技术\n\n移动和对换技术解决因多个程序存在而导致内存区不足问题。\n\n但是如果程序长度超过物理内存的总和，或者超出固定分区大小，则会出现内存永久性短缺，大程序无法运行，解决方案是覆盖技术。\n\n程序分段： 将一个大程序划分为多个独立的部分（通常是功能模块），这些部分通常称为”覆盖块”（Overlay Blocks）。\n内存交换： 在程序执行过程中，操作系统将某些覆盖块从磁盘加载到内存中运行，当这些块不再需要时，操作系统可以将它们从内存中卸载，释放空间给其他块。\n\n\n\n\n段式存储概述\n高级语言采用模块化程序设计方法。应用程序由若干程序段(模块)组成，如由主程序段(M)、子程序段(X)、数据段(D)和工作区段(W)组成，每一段都从0开始编制，各有各自名字和长度且实现不同功能。\n\n\n\n编译后段间地址是不连续的，段内地址是连续的。\n\n地址转换\n分段存储器的逻辑地址由两部分组成:段号+段内偏移\n页式存储管理中页的划分对程序员不可见。\n段式存储管理中段的划分对程序员可见。\n\n页式存储概述\n基本原理\n\n页面：金层逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始编号。比如出版一本书，出版受到页大小影响，最后由若干页组成，一般大小为4KB\n\n页框：又称页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区都是一个页框(物理块)，块号从0开始。\n\n逻辑地址：分页存储器的逻辑地址由页号 + 页面偏移组成(地址总线32位)\n\n页号：32-12 &#x3D; 20位，则包含页220220位\n页面偏移：页面大小为4KB，则需要12位\n\n\n内存页框表：该表长度取决于内存划分的物理块数，表项中给出物理块使用情况，0为空闲，1为占用，有的系统还会添加保护位、脏位等等。\n\n页表：将页装入到内存中，\n页未必连续\n，我们需要为每一个页面设立一个重定向寄存器，这个寄存器的集合就是页表。\n\n数学角度：页面号→页框号页面号→页框号\n系统设置页表基址寄存器，存放当前运行进程的页表起始地址。\n物理地址&#x3D;页框号∗块长+页内偏移物理地址&#x3D;页框号∗块长+页内偏移，实际转换时，我们将页内偏移作为低地址，根据页号从页表中查找到页框号并作为高地址即可。\n页表不存储页号，只存储页框号和相应标志位\n\n\n页式存储产生的碎片是内部碎片\n\n可以类比固定分区\n比如19KB的程序，加载到页大小为4KB中，会产生1KB的内存内零头。\n\n\n\n\n地址：\n\n页式存储管理的逻辑地址由两部分组成，页号和单元号(页内偏移)，逻辑地址形式：\n\n\n\n页式存储管理的物理地址也有两部分组成：页架号(页框号)和单元号(页内偏移)，物理地址形式：\n\n\n\n多道程序环境下的进程表\n\n进程表中登记了每个进程的页表\n进程占有处理器运行时，其页表起始地址和长度送入页表控制寄存器\n\n\n多道程序环境下的地址转换\n\n\n页表控制寄存器存储了当前的页表的地址和长度\n页表控制寄存器和进程表是有关联的，所有进程在进程表中都有一项，当这个进程占据CPU时，这个进程就占据页表控制寄存器。\n不使用快表:首先从逻辑地址中，提取出页号，比较页号是否出现越界中断，如果没有越界，则根据页表向下偏移到对应的块号，提取出页表信息和页框号，页框号结合单元号，得到物理地址\n快表:不是从页表中查找，而是优先从快表中查询块号。\n\n\n\n调度算法最佳算法OPT（Belady算法）\n算法描述：当要调入新页面时，首先淘汰以后不再访问的页，然后选择距现在最长时间后再访问的页。\n该方法由Belady提出，称为BeLady算法，又称最佳算法(OPT)\nOPT只可以模拟，不可以实现，因为永远无法预知之后的事情。\n这种算法可以用作衡量其他各种算法的标准。\n图示。（这个图应该斜着看，左下的栈和右上的数字搭配，更新后得到右下的栈）\n\nFIFO先进先出\nFIFO算法的Belady异常：更多的页框导致了更高的缺页率，页框为3和4的时候。注意，Belady异常和Beladey算法没关系。\n\nLRU，最近最少用LFU，最不常用CLOCK算法\nCLOCK就是SCR结合FIFO形成循环，使用页引用标志位。\n流程\n页面调入主存时，其引用标志位置为1\n访问主存页面时，其引用标志位置为1\n淘汰页面时，从指针当前指向的页面开始扫描循环队列\n把所遇到的引用标志位是1的页面的引用标志位清0并跳过\n把所遇到的引用标志位是0的页面淘汰，指针推进一步\n\n\n\n\n\n局部最佳页面替换算法(MIN)（一般不考）\n实现思想：进程在时刻t访问某页面，如果该页面不在主存中，导致一次缺页，把该页面装入一个空闲页框.\n不论发生缺页与否，算法在每一步要考虑引用串，如果该页面在时间间隔(t, t+τ)内未被再次引用，那么就移出；否则，该页被保留在进程驻留集中\nt为一个系统常量，间隔(t, t+τ)称作滑动窗口 。例子中τ&#x3D;3，双闭区间\n\n\n工作集模型和工作集置换算法(WS)\n进程工作集指”在某一段时间间隔内进程运行所需访问的页面集合”\n实现思想：工作集模型用来对局部最佳页面替换算法进行模拟实现，不向前查看页面引用串，而是基于程序局部性原理向后看\n任何给定时刻，进程不久的将来所需主存页框数，可通过考查其过去最近的时间内的主存需求做出估计\n双闭区间\n\n\n多级页表\n页表是面向进程的，每个进程都要有页表，标记为页号\n反置页表是面向内存的，标记为页框号\n\n\n为每个进程创建完整的页表开销很大\n既然页表也是数据，我们就为页表再创建一个页表，每一页称为页表页，新页表叫页目录表\n做法：把整个页表分割成许多小页表，每个称为页表页，它的大小与页框长度相同，于是每个页表页含有若干页表表项。\n页表项从0开始编号，允许放到不连续的页框中，为了找到页表页，建立地质索引，称为页目录表。\n系统为每一个进程建立一张页目录表，他的每一个表项指出一个页表页，而页表页的每个表项给出页面和页框的对应关系。\n\n\n逻辑地址结构有三部分组成：页目录、页表页和位移\n\n页目录项是页表页的索引，而页表页项是进程程序的页面索引。\n\n反置页表(IPT)\n正向页表(名单)、反置页表(现场坐的是谁)\n\n正向页表:以页号为索引(隐含)，完整连续排列，页表项中不含页号，每个进程单独一个页表\n反置页表:以页框号为索引(隐含)，完整连续排列，每个页框填入的是哪个进程的哪个页号，索引进程共用一个反置页表。其页表项不包含页框号\n\n\n基本设计思想：\n\n针对内存中的每个页架建立一个页表，按照块号(页架号)排序\n表项包含：正在访问该页框的进程标识、页号及特征位，和哈希链指针等\n用来完成内存页架到访问进程页号的对应，即物理地址到逻辑地址的转换\n\n\n反置页表的页表项\n\n页号：虚拟地址页号\n进程标志符：使用该页的进程号(页号和进程标志符结合起来标志一个特定进程的虚拟地址空间的一页)\n标志位：有效、引用、修改、保护和锁定等标志信息\n链指针：哈希链，如果某个项没有链项，则该域为空(允许用一个单独的位来表示)。\n\n\n反置页表的逻辑地址\n\n进程标识符：使用该页的进程。\n页号：虚拟地址页号部分，页号和进程标志符结合起来标志一个特定的进程的虚拟地址空间的一页。\n页内位移\n\n\n地址转换\n\n反置页表地址转换过程如下:\n需要访问内存地址时，地址转换机制用进程标识符与页号作为输入，由哈希函数先映射到哈希表，哈希表项存放的是指向IPT表项的指针\n此指针可能就是指向匹配的IPT表项\n如果不是则遍历哈希链直至找到进程标识符与页号均匹配的IPT表项：因为多个页号通过哈希函数可能得到了相同的哈希值，所以我们选择使用哈希链。\n\n\n而此表项的**序号(索引)**就是页框号，通过拼接页内位移便可生成物理地址。\n若在反置页表中未能找到匹配的IPT页表项，说明此页不在内存，触发缺页异常，请求操作系统通过页表调入：发生缺页中断时需要多访问一次磁盘，速度会比较慢。\n\n\n页框号是根据公式换算出来的：$x_i&#x3D;x_0+4*i$，其中$x_i$ 表示第 i 个表项的物理地址，$x_0$ 表示反置页表的起始物理地址，4 表示每个表项的大小（以字节为单位）\n\n\n\n段页式存储\n基本原理\n\n一言以蔽之：先分段，再分页\n逻辑地址由段号s、段内页号p和页内偏移d组成\n对用户，虚拟地址由段号s和段内位移d’组成\n系统内部将d’分解为p和d，d’ &#x3D; p * 块长 + d\n\n\n请求段页式虚拟存储管理的数据结构比较复杂，包含作业表、段表和页表三部分。\n作业表：进入系统的作业和作业段表的起始地址\n段表：是否在内存、段页表起始地址\n页表：是否在内存、对应内存块号\n\n\n\n\n地址转换\n\n\n\n\n\n\n第四章 · 设备管理概述\n知道三种控制方式：轮询，中断，DMA（直接存储器访问）\nIO通道\n描述：\n设备控制器包含自身专用的处理器和通道程序，自成体系，使得CPU与通道高度并行，实现通道和CPU并行操作，通道之间并行操作，设备之间并行操作。\n\n\n工作流程（就是中断那一套）\nCPU在执行主程序时遇到I&#x2F;O任务，启动指定通道(通过通道程序地址字CAW)上选址的设备。\n启动成功，通道开始控制设备进行操作，此时CPU继续执行其他任务，直到I&#x2F;O操作完成。\n通道发出I&#x2F;O操作结束中断，处理器相应并停止当前工作，转向处理I&#x2F;O操作结束事件。\n\n\n\n\n\nIO软件的实现IO软件的层次结构\n\n\nIO中断程序\nI&#x2F;O中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系\n进程请求I&#x2F;O操作时，通常被挂起，直到数据传输结束后并产生I&#x2F;O中断时，操作系统接管CPU后转向中断处理程序\n当设备向CPU提出中断请求时，CPU响应请求并转入中断处理程序\nI&#x2F;O中断处理程序的功能\n检查设备状态寄存器内容，判断产生中断的原因，根据I&#x2F;O操作的完成情况进行相应的处理\n如果数据传输有错，向上层软件报告设备的出错信息，实施重新执行\n如果正常结束，唤醒等待传输的进程，使其转换为就绪态\n如果有等待传输的I&#x2F;O命令，通知相关软件启动下一个I&#x2F;O请求\n\n\n\nIO驱动程序\n概念：\nI&#x2F;O设备驱动程序是操作系统与I&#x2F;O设备之间的接口软件。它是一组软件代码，用于控制和管理I&#x2F;O设备的运行。驱动程序为操作系统提供了一种与硬件设备进行通信的方式，使得操作系统能够通过标准的接口来操作各种不同的硬件设备。\n\n\n任务\n把用户提交的逻辑I&#x2F;O请求转化为物理I&#x2F;O操作的启动和执行，如设备名转换为端口等\n监督设备是否正确执行，管理数据缓冲区，进行必要的纠错处理\n\n\n功能\n设备初始化:在系统初次启动或设备传输数据时，预置设备和控制器以及通道状态\n执行设备驱动例程\n负责启动设备，进行数据传输\n对于具有通道方式，还负责生成通道指令和通道程序，启动通道工作\n\n\n调用和执行中断处理程序:负责处理设备和控制器及通道所发出的各种中断\n\n\n\n独立于设备的IO软件\n基本功能：执行适用于所有设备的常用I&#x2F;O功能，并向用户层软件提供一致性接口\n设备命名：通过路径名寻址设备\n设备保护：检查用户是否有权访问所申请设备\n资源分配方式\n静态分配：进程运行前申请。实现简单，能够防止死锁，但会降低设备利用率\n动态分配：进程随用随申请。考虑互锁管理，需要结合信号量与PV操作\n\n\n缓冲技术：\n通过缓冲消除填满速率和清空速率的影响\n网络上数据需要分析检查才知道去哪里。\n有些设备有严格时间约束，比如数字音频设备。\n\n\n块设备和字符设备都需要缓冲技术\n块设备：磁盘读写以块为单位，应用程序以任意大小单元处理设备，如果应用程序读写长度和位置不是完整扇区，则需要使用缓冲区来缓冲。\n字符设备：字符设备提供数据速度快于或慢于应用程序消耗数据的速度。\n\n\n缓冲设计大量复制操作，对I&#x2F;O性能有较大开销\n\n\n\n用户空间的IO软件\n库函数\n一小部分I&#x2F;O软件不在操作系统中，是与应用程序链接在一起的库函数，甚至完全由运行于用户态的程序组成\n系统调用通常由库函数封装后供用户使用，封装函数只是将系统调用所用的参数放在合适位置，然后执行访管指令来陷入内核，再由内核函数实现真正的I&#x2F;O操作\n\n\nSPOOLing软件\n在内核外运行的系统I&#x2F;O软件，采用预输入、缓输出和井管理技术，是多道程序设计系统中处理独占型设备的一种方法，通过创建守护进程和特殊目录解决独占型设备的空占问题\n\n\n\n缓冲技术\n概述\n\n缓冲区:在内存中开辟的存储区，专门用于临时存放I&#x2F;O操作的数据\n目的：\n解决CPU与设备之间速度不匹配的矛盾，协调逻辑记录大小和物理记录大小不一致的问题\n减少I&#x2F;O操作对CPU的中断次数\n放宽对CPU中断响应时间的要求\n提高CPU和设备的并行性\n\n\n\n\n单缓冲\n\n每当应用程序发出I&#x2F;O操作时，操作系统在主存(内存)的系统区中开设一个缓冲区\n\n\n\n\n\n如果希望输入的数据被加工后再输出，则需要双缓冲。\n\n工作机制：\n\n输入：将数据读至缓冲区，系统将缓冲区数据送至用户区，应用程序对数据进行处理；如此往复，系统读入后续的数据\n输出：把数据从用户区复制到缓冲区，再将数据输出后，应用程序继续请求输出\n\n\n双缓冲\n\n操作系统在主存的系统区中开设两个缓冲区\n\n\n\n\n\n工作机制\n\n输入：\n设备首先将数据输入缓冲区1，系统再从缓冲区1把数据传到用户区，供应用程序处理，同时从设备数据传送到缓冲区2\n当缓冲区1为空，则再次从设备读出数据到缓冲区1，将缓冲区2的数据传送到用户区，供应用程序处理，同时从设备数据传送到缓冲区1\n仅当两个缓冲区全为空，并且进程还要提取数据时等待。\n\n\n输出：\n第一张卡片读入缓冲区1，在打印缓冲区1中数据的同时，又把第二张卡片读入缓冲区2。\n缓冲区1打印完毕时，缓冲区2也刚好输入完毕，让读卡机和打印机交换缓冲区。这样，I&#x2F;O设备就能够处于并行工作状态。\n\n\n\n\n多缓冲\n\n\n\n多缓冲的缓冲区是系统的公共资源，可供进程共享并由系统统一分配和管理\n\n\n驱动调度技术磁盘结构\n组成\n术语\n盘面号也被叫做磁头号\n磁道号也被叫做柱面号\n区别:”0面0道1扇区”中的”面”是指磁头，不是柱面\n面和道都是0开始\n扇区是从1开始\n\n\n\n\n\n调度\n调度耗时：磁盘完成数据读写所需要的时间:是寻道时间、旋转延迟、传送时间的总和\n调度策略包括旋转调度和移臂调度\n\n移臂调度\n目的：使移动臂的移动时间最短，从而减少寻道总时间\n\n先来先服务算法 FCFS\n移臂距离大，性能不好，移动臂是随机移动，寻道性能较差\n按顺序处理请求，对所有进程公平\n\n最短查找时间优先(最小短距离法) SSTF\n先执行查找时间最短的请求，具有较好的寻道性能，存在”饥饿”现象：距离比较远的被满足\n选择使磁头臂从当前位置开始移动最少的磁盘I&#x2F;O请求，因此SSTF策略总是选择导致最小寻道时间的请求，总是选择最小寻道时间并不能保证平均寻道时间最小，但是，它的性能比FCFS更好\n\n扫描算法 SCAN算法\n移动臂每次向一个方向移动，遇到最近的I&#x2F;O请求便进行处理，到达最后一个柱面后再向相反方向移动\n对最近扫描所跨越区域的请求响应较慢\n和电梯调度算法的不同：碰壁才会折返\n\n循环扫描算法 C-SCAN算法\n单向移动的扫描算法\n\n分布扫描算法 N-step-SCAN\n进程\n重复请求同一磁道会垄断整个设备造成磁头臂的粘性，采用分步扫描可避免这类问题\n\n把磁盘I&#x2F;O请求队列分成长度为N的子队列，按照FIFO处理每一个子队列，每个子队列内部使用扫描算法\n在处理一个队列时，新请求必须添加到其他某个队列中\n处理完一个子队列后再服务下一个队列\n\n\n如果在扫描的最后剩下的请求数小于N，则它们全部将在下一次扫描时处理\n\n当N→∞时，N-step-SCAN的性能接近SCAN\n当N&#x3D;1时，实际上是FIFO\n\n\n\n电梯调度(LOOK 算法)\n无请求时移动臂停止不动，有请求时按电梯规律移动\n每次选择沿移动臂的移动方向最近的柱面\n如果当前移动方向上没有但相反方向有请求时，改变移动方向\n\n旋转调度\n目的：使得旋转延迟的总时间最少\n循环排序：通过优化I&#x2F;O请求排序，在最少旋转圈数内完成位于同一柱面的访问请求 \n旋转位置测定硬件和多磁头同时读写 技术有利于提高旋转调度的效率\n优化分布如下\n\n\n\n优化分布\n通过信息在存储空间的排列方式来减少旋转延迟\n交替排序：由于磁盘匀速运转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，如交叉因子为n:1表示相邻编号间会间隔n-1个扇区\n把相邻扇区集中成簇读写\n按柱面集中存储数据（另一种集簇方式），可以减少数据读写时的移臂操作\n\n磁盘循环冗余阵列\nSPOOLing（外部设备联机并行操作）系统概述\n实质：让独享型设备变为共享设备\n\n\n相关概念：\n独占性设备：指在一段时间内只能被一个进程独占使用的设备\n输入井，输出井：类似于缓冲区。但是缓冲区在内存，输入输出井在磁盘\n虚拟设备：使用一类物理设备模拟另一类物理设备的技术，让独享型设备变为共享设备\n示例\n内存卡模拟磁盘\n块设备模拟字符设备\n输入输出重定向\n\n\n\n\n\n\n作用：\n\n组成部分\n软件组成：\n预输入程序**：**预先把数据从输入设备传送到磁盘输入井\n缓输出程序：把数据从磁盘输出井传送到输出设备\n井管理程序：控制作进程和井之间的数据交换（事实上是I&#x2F;O重定向）\n目标：预输入，缓输出\n\n\n\n\n数据结构：\n系统有一张作业表来登记进入系统的所有作业的JCB，包括作业名、作业状态等信息。\n预输入表用来登记作业的各个输入文件的情况。\n缓输出表用来登记作业的各个输出文件的情况。\n\n\n\n作业调度\n是指从后备状态作业中选择进入运行状态\n\n\n\n第五章 · 文件管理\n文件的组织存储\n卷和块\n卷：卷是存储介质的物理单位，对应于一盘磁带、 一块软盘、一个光盘片、一个硬盘分区\n块是存储介质上连续信息所组成的一个区域， 也叫做物理记录\n块是主存储器和辅助存储器进行信息交换的 物理单位，每次总是交换一块或整数块信息\n\n\n\n\n顺序存取存储设备：\n顺序存取设备是严格依赖信息的物理位置次 序进行定位和读写的存储设备\n磁带机是最常用的一种顺序存取存储设备， 它具有存储容量大、稳定可靠、卷可装卸和便于保存等优点，广泛用作存档。现在也有在用\n\n\n直接存取存储设备\n磁盘是一种直接存取存储设备，又叫 随机存取存储设备\n\n\n\n逻辑结构\n流式文件\n流式文件指文件内的数据不再组成记 录，只是由一串依次的字节组成的信 息流序列 \n这种文件常常按长度来读取所需信息， 也可以用插入的特殊字符作为分界\n\n\n记录式文件\n记录式文件是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件\n逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位\n每个职工的工资信息是一个逻辑记录；\n整个单位职工的工资信息便组成了该单位工资信息的记录式文件\n\n\n逻辑记录是文件内独立的最小信息单位，记录位置代替字节位置。\n记录是文件常用的记录组织和使用方法\n记录式顺序文件：文件的记录顺序生成并被顺序访问。\n记录式索引文件：文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引文件便指向相应记录。\n\n\n\n\n\n成组与分解\n记录式文件才有成组与分解\n\n\n基本概念\n一些定义：\n逻辑记录：是按信息在逻辑上的独立含义由用户所划分的单位。\n块：是系统划分的存储介质上连续信息所组成的区域。\n一条逻辑记录被存放到文件存储器的存储介质上时可能占用一个或多块，或者一个物理块包含多条逻辑记录。\n扇区也叫做物理块，或者物理记录\n\n\n组：若干逻辑记录的组合。\n块因子：每块中逻辑记录的个数。比如物理块800K，卡片80K，此时的块因子数就是10。\n对于流式文件，一个物理记录可以存放很多个连续字节。\n\n\n记录的成组操作在输出缓冲区内进行， 凑满一块后才将缓冲区内的信息写到 存储介质上\n当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离 出来的操作叫记录的分解操作\n\n\n特点：\n优点：记录成组与分解不仅节省存储空间，还能减少输入输出操作次数，提高系统效率\n记录成组与分解处理带来的新特征：\n提前读：用户读请求，导致包含该逻辑记录的物理块读入输入缓冲区；这一操作可能读入了多个逻辑记录，可以更快的访问附近的记录。\n推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出。\n\n\n副作用(推迟写操作)：因为优先写到输出缓冲区，等到缓冲区满，才会写到磁盘，可能会造成数据不一致(写到缓冲区，但是因为停电等原因没有办法同步到磁盘)\n\n\n\n物理结构\n文件分类：\n\n顺序文件\n连接文件，又称串联文件\n直接文件，又称散列文件\n索引文件\n\n\nFCB：文件控制块\n\n在Linux系统中，FCB中的管理信息单独组成一个数据结构，称为inode\n\n\n目录项（Directory Entry）：\n目录项是目录文件中的一个条目，用于存储文件或子目录的名称和对应的 inode 号。目录本身也是一个文件，它包含多个目录项。每个目录项包含以下信息：\n\n文件或子目录的名称\n对应的 inode 号\n\n\n\n\n目录项，inode和数据块的关系\n\n物理结构：\n引导块\n超级块：\n存放文件系统结构和管理信息，如记录inode表所占盘块数\n可见超级块既有盘位示图的功能，又记录整个文件卷的控制数据。\n\n\n磁盘inode：\n有K块，K待定\n每个文件都有各种属性，它们被记录在称为索引节点inode的结构中\n所有inode都有相同大小，且inode表是inode结构的列表，文件系统中的每个文件在该表中都有一个inode。\n\n\n数据区\n索引文件详细\n访问方式：\n索引文件在文件存储器上分两个区：索引区和数据区\n访问索引文件需两步操作\n第一步查找索引表\n第二步获得记录物理地址\n\n\n\n\n\n\n\n\n目录项与 inode 的关系\n目录项指向 inode：目录项中的 inode 号是关键。通过目录项中的 inode 号，文件系统可以找到对应的 inode。\ninode 与文件名分离：inode 本身不存储文件名，文件名存储在目录项中。这种分离使得硬链接成为可能，多个目录项可以指向同一个 inode。\n\n\ninode 与数据块的关系\ninode 指向数据块：inode 中的块号字段存储了文件内容所在的磁盘块号。通过这些块号，文件系统可以找到文件的实际存储位置。\n数据块存储文件内容：数据块中存储了文件的实际内容。\n\n\n\n索引的组织（重要）\n注意，这里索引文件的组织是指一个文件内部的数据的组织方式，而不是多个文件之间的组织\n\n\n\n一级索引：存放的是物理地址\n两级索引：若干索引本身也是一种记录。\n多级索引：以三级索引为例，一个地址指引12831283个地址，但是全部使用三级索引也不行，性能会比较差，所以我们往往选择使用混编的方式。\n动态扩容：放不下就扩容\ninode规定了15个索引项，每项4KB\n直接索引：前12项存放文件信息的磁盘块号\n一次间接索引：第13项指向一个物理块\n二次间接索引：第14项指向一个物理块\n三次间接索引：第15项指向一个物理块\next2中，每个物理块存放1KB，所以下面右图最多存放12KB+256KB+2562KB+2563KB\n\n\n\n文件系统功能及实现目录结构\n一级目录结构：顾名思义\n二级目录结构：\n第一级为主文件目录，它用于管理所有用户文件目录\n第二级为用户的文件目录，它为该用户的每个文件保存一个登记栏，其内容与一级目录的目录项相同\n\n\n\n树形目录结构\n是一种层次目录结构\n一个硬盘分区可以组织成一颗子树\n每棵子树可以对应于一个逻辑盘符（Win）\n也可以把众多子树嫁接成一颗大树（UNIX）\n\n\n\n\n\n目录管理\n文件的定位\n\n目录项的查找\n\n活动文件表\n\n文件系统向应用程序提供了一组系统调用，包括建立、打开、关闭、撤销、读&#x2F;写和控制，通过这些系统调用，用户能够获得文件系统的各种服务。\n系统会为每一个用户进程建立一张打开文件表\n用户使用文件之前先通过打开操作，将文件FCB拷贝到指定内存位置\n当不在使用时，通过关闭操作切断和文件的联系，释放文件的FCB。\n\n\n接下来以Linux系统为例，介绍其文件系统调用的种类、功能和实现。内核将磁盘作为主要文件存储器，磁盘按扇区编号，扇区序列分成三个部分。\n文件系统内部结构如下图所示：不是三级坐标，是经过转化后的结构\n\n\n\n\n文件操作\n见spricoder\n\n文件空间管理\n位示图\n磁盘空间通常使用固定大小的块，可方便地用位示图管理，用若干字节构成一张位示图，其中每一字位对应一个物理块，字位的次序与块的相对次序一致，字位为‘1’表示相应块已占用，字位为‘0’表示该块空闲。\n\n\n空闲块的管理：成组连接法\n第一行指出有多少个空闲块\n第二行指向下一级\n从第三行起指向空闲块\n\n\n管理的算法\n\n文件的共享\n文件共享指不同进程共同使用同一个文件，文件共享为不同进程完成共同任务所需。\n节省大量外存空间，减少因文件复制而增加的I&#x2F;O操作次数。\n\n\n静态共享\n\n允许一个文件同时属于多个目录，但是实际上文件仅有一处物理存储。\n\n文件链接：从多个目录可到达文件的链接。\n\n无论进程是否运行，文件链接关系都存在，所以称为静态共享。\n\n链接的文件的存在形式：\n\n同一父目录下的不同文件名出现\n不同父目录下的相同或不同文件名出现\n\n\n链接实际上是共享已存在文件的索引节点inode，完成链接的系统调用：\nlink(“&#x2F;home&#x2F;fei1&#x2F;myfile.c” , ”&#x2F;home&#x2F;fei2&#x2F;myfile.c”)；硬链接\n\n\n\n动态链接：\n\n使用同一位移指针的文件共享：先打开文件，再fork()\n\n同一用户父、子进程协同完成任务，使用同一读&#x2F;写位移，同步地对文件进行操作。\n该位移指针宜放在相应文件的活动inode中。当用系统调用fork()建立子进程时，父进程的PCB结构被复制到子进程的PCB结构中，使两个进程的打开文件表指向同一活动的索引节点，达到共享同一位移指针的目的。\n\n\n使用不同位移指针的文件共享：先fork()，再打开文件\n\n多用户进程共享文件，每个希望独立地读、写文件，这时不能只设置一个读写位移指针，须为每个用户进程分别设置一个读、写位移指针。\n位移指针应放在每个进程用户打开文件表的表目中。\n这样，当一个进程读、写文件，并修改位移指针时，另一个进程的位移指针不会随之改变，从而，使两个进程能独立地访问同一文件，会新建系统打开文件表(包含f_offset)\n\n\n\n\n\n第六章 · 并发程序设计并发程序\n顺序程序设计\n特点：\n程序执行的顺序性：程序指令执行是严格按序的，每个操作必须在下一个操作开始前结束。\n计算环境的封闭性：程序运行时如同独占受操作系统保护的资源，资源状态只能由程序本身决定和改变，不受外界因素改变。\n计算结果的确定性：程序执行结果与执行速度和执行时段无关\n计算过程的可再见性：程序对相同数据集的执行轨迹是确定的\n\n\n\n\n并发程序设计：\n无关与交往：\n无关的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关\nBernstein条件：\n\n这样的无关性使得进程之间互不影响\n\n\n\n\n交往的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果\n\n\n两个视角：\n宏观上，并发性反应了一个时间段内有几个程序都处于运行但运行尚未结束的状态。\n微观上，任一时刻都只有一个程序在运行。\n\n\n特点：\n不再满足顺序程序设计的四个特点\n并行性：多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行，提高了计算效率\n共享性：多个进程共享软件资源\n交往性：多个进程并发执行时存在制约，增加了程序设计的难度\n\n\n与时间有关的错误\n结果不唯一\n永久等待\n\n\n\n\n\n竞争（互斥）与协作（同步）\n$竞争\\to互斥\\to等待$\n$协作\\to同步\\to等待$\n\n\n竞争：\n：并发进程之间因相互争夺独占性资源而产生的竞争制约关系\n竞争带来的问题：\n死锁(Deadlock)问题: 一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。\n饥饿(Starvation)问题: 一个进程由于其他进程总是优先于它而被无限期拖延，可以使用FCFS来解决饥饿问题\n\n\n操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题\n\n\n\n协作：\n概念：某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行\n进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调\n\n\n\n临界区\n临界区：是指包含对共享资源进行访问的代码段。\n临界区管理的三个要求(Dijkstra, 1965)\n一次至多一个进程能够进入临界区内执行：在某些特殊情况下可能会突破\n如果已有进程在临界区，其他试图进入的进程应等待\n进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入\n\n\n进程互斥的软件实现方法：\n单标志法\n\n双标志先检查法\n\n可能两个都进\n\n\n双标志后检查法\n\n可能两个都不进\n\n\nPeterson算法\n\n原理：结合了双标志法和一个额外的“进入”标志turn。每个进程在进入临界区前，先设置自己的标志为true，然后检查对方的标志和turn标志。如果对方标志为true且turn指向对方，则等待。\n\n优点：完全避免了死锁和忙等问题，且满足互斥条件。\n\n缺点：实现较为复杂，且仅适用于两个进程的情况。\n\n\n\n\n\n\n信号量和PV操作\n\n信号量：\n\n是一个数据结构，由两部分组成：\n信号量的值：为正数是代表空闲资源数量，为负数代表等待进程数量\n信号量队列指针：指向等待队列\n\n\n\n\nPV操作：\n\nP(s)：\n\n将信号量s减去1，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态\n负数的绝对值就是等待的进程的个数\n\n\nV(s)：将信号量s加1，若结果不大于0，则释放(唤醒)一个等待信号量s的进程，使其转换为就绪态\n\n原语：CPU处于内核态，在关中断环境下执行的一段指令序列\n\n强调：对于信号量，只允许使用P和V原语操作访问信号量，不能直接对信号量的整型值做读写操作，也不能直接对信号量的队列做任何其他操作\n\n伪代码：\n// 基本数据结构定义typedef struct semaphore &#123;   int value;           /*信号量值，正值表示资源可复用次数，0值表示无资源且无进程等待，负数的绝对*/   struct pcb* list;    /*信号量队列指针，等待队列*/&#125;;// P操作原语void P(semahore s) &#123;   s.value--;           /* 信号量值减1 */   if(s.value &lt; 0)      sleep(s.list);   /* 若信号量值小于0,执行P操作的进程调用sleep(s.list)阻塞自己，被置成等待信号量s状态并移人s信号量队列,转向进程调度程序*/&#125;// V操作原语void V ( semaphore s) &#123;   s.value++;           /* 信号量值加 1*/   if(s.value &lt;=0)      wakeup(s.list) ;   /*若信号量值小于等于0,则调用wakeup(s. list) 从信号量s队列中释放一-个等待信号量s的进程并转换成就绪态,进程则继续执行*/  &#125;// PV操作解决进程互斥问题框架semaphore s;s = 1;cobegin   process Pi &#123;      ……      P(s);      临界区;      V(s);      ……   &#125;coend;\n\n\n信号量与状态：\n\n\n\n\n\n\n哲学家就餐问题\n问题：\n\n五个哲学家，五把叉子，必须拿到左右两把叉子才能吃上饭。\n即使使用了PV操作，还是可能死锁。\n\n\n解决方案\n\n霍尔方案：控制人数，至多有四个人可以拿叉子\n\n这里声明了两个信号量。fork表示叉子，每个叉子值为1，表示互斥关系。room表示可以同时拿叉子的人数。\n每次都是先控制人数，然后再去叉子，这样就不会死锁\n\n\n编号方案：奇数号先取左手边的叉子，偶数号先取右手边的叉子\n\n\n\n\n生产者-消费者问题\n问题描述：\n互斥访问：缓冲区同一时间只能被一个生产者或消费者访问。\n同步：生产者不能在缓冲区满时继续生产，消费者不能在缓冲区空时尝试消费。\n\n\n解决方案：\n设计两个信号量sput和sget，分别表示可以生产的量和可以消耗的量。\n注意，每段代码的P操作和V操作不是同一个信号量\n设计两个信号量S1,S2，若有多个消费者和生产者，他们要互斥的访问缓冲区.\n\n\n\n苹果-桔子问题\n问题描述：\n\n\n解决方案：\n\n\n\n前驱关系\n读写问题\n睡眠的理发师\n\n这里的mutex是必要的。访问共享的变量时，需要互斥！\n\n农夫猎人问题\n和苹果-桔子问题本质上是一样的\n\n银行服务问题\n这个例子对理解PV操作有帮助\n信号量就像是一个通讯方式（实际上就是IPC对象），PV就是等待信号和发送信号\n\n\n缓冲区问题\n售票问题\n吸烟者问题\n独木桥问题 ***\n问题一：东西向汽车过独木桥，为了保证安全，只要桥上无车，则允许一方的汽车过桥，待一方的车全部过完后，另一方的车才允许过桥。请用信号量和PV操作写出过独木桥问题的同步算法。\n\n确保同一时间只有一个方向的行人过桥：\n通过 wait 信号量，确保同一时间只有一个方向的行人可以过桥。如果一个方向的行人已经占用桥，另一个方向的行人必须等待。\n\n\n\n\n问题二：在独木桥问题1中，限制桥面上最多可以有k辆汽车通过。试用信号量和P，V操作写出过独木桥问题的同步算法\n\n问题三：在独木桥问题1中，以3辆汽车为一组，要求保证东方和西方以组为单位交替通过汽车。试用信号量和P，V操作写出汽车过独木桥问题的同步算法\n\n问题四：在独木桥问题1中，要求各方向的汽车串行过桥，但当另一方提出过桥时，应能阻止对方未上桥的后继车辆，待桥面上的汽车过完桥后，另一方的汽车开始过桥。试用信号量和P，V操作写出过独木桥问题的同步算法\n\n\n管程概述\n概念：它是一种封装了共享数据和操作这些数据的过程（或函数）的模块。\n\n功能：管程不仅提供互斥功能，还提供条件变量（condition variables）用于线程或进程之间的同步。它通常包含：\n\n共享数据：封装的共享数据，只能通过管程提供的过程访问。\n过程（或函数）：操作共享数据的过程。\n互斥锁：内部的互斥锁，确保一次只有一个线程或进程可以执行管程中的操作。\n条件变量：用于线程或进程之间的同步，提供 wait 和 signal（或 broadcast）操作。\n\n\n为什么要引入管程？\n\n把分散在各进程中的临界区集中起来进行管理 \n\n防止进程有意或无意的违法同步操作 \n\n便于用高级语言来书写程序\n\n\n\n管程和互斥锁有什么区别？\n\n互斥锁：是一种低级同步原语，用于确保一次只有一个线程或进程可以访问共享资源。\n管程：是一种高级同步机制，封装了共享数据和操作这些数据的过程（或函数），并提供了一种安全的方式来访问和修改共享数据。\n\n\n形式：\n\n条件变量\n\n当资源不足导致进程阻塞时，同时开放冠层，让挡在管程外的一个进程进入管程。\n条件变量：是出现在管程内的一种数据结构，且只有在管程中才能被访问，它对管程内的所有过程是全局的，只能通过两个原语操作来控制它，用于阻塞进程的信号量。\nwait()：当一个管程过程发现无法继续时(如发现没有可用资源时)，它在某些条件变量上执行wait，这个动作引起调用进程阻塞，直到另一个进程在该条件变量上执行signal()\nsignal()\n如果存在其他进程由于对条件变量执行wait()而被阻塞，便释放之\n如果没有进程在等待，那么信号不被保存，并不是立即退出管程等待队列，而是进入next信号量，以保证多个进程都可以正常退出。\n\n\n条件变量仅仅维护阻塞队列的作用，如果没有等待时发生signal()操作，相当于空操作。\n\n\n使用signal释放等待进程时，可能出现两个进程同时停留在管程内。解决方法：\n执行signal的进程等待，直到被释放进程退出管程或等待另一个条件\n被释放进程等待，直到执行signal的进程退出管程或等待另一个条件\n\n\n霍尔(Hoare, 1974)采用第一种办法\n汉森(Hansen)选择两者的折衷，规定管程中的过程所执行的signal操作是过程体的最后一个操作\n\n\n\n结构\nHoare管程的enter()和leave()操作\nvoid enter(InterfaceModule &amp;IM) &#123;   P(IM.mutex);         //判有否发出过signal的进程?&#125;void leave(InterfaceModule &amp;IM) &#123;   if (IM.next_count&gt;0)      V(IM.next);       //有就释放一个发出过signal的进程   else      V(IM.mutex);      //否则开放管程&#125;\n\nHoare管程的wait()操作\nx_sem: semaphore;       // 与资源相关的信号量x_count: integer;       // 在x_sem上等待的进程数void wait(semaphore &amp;x_sem,int      x_count,InterfaceModule &amp;IM) &#123;   x_count++;           //等资源进程个数加1，x_count初始化为0   if (IM.next_count&gt;0) //判断是否有发出过signal的进程      V(IM.next);       //有就释放一个   else      V(IM.mutex);      //否则开放管程   P(x_sem);            //等资源进程阻塞自己，x_sem初始化为0&#125;\n\nHoare管程的signal()操作\nvoid signal(semaphore &amp;x_sem,int      &amp;x_count,InterfaceModule &amp;IM) &#123;   if(x_count&gt;0) &#123;      //判断是否有等待资源的进程      IM.next_count++;  //发出signal进程个数加1      V(x_sem);         //释放一个等资源的进程      P(IM.next);       //发出signal进程阻塞自己**      x_count--;        //发出signal进程个数减1   &#125;&#125;// 霍尔管程执行signal的进程等待，直到被释放进程退出管程或等待另一个条件\n\n习题哲学家就餐\n读者写者\n生产者消费者\n苹果桔子\n消息死锁\n必要条件：\n互斥条件: 进程应互斥使用资源，任一时刻一个资源仅为一个进程独占\n占有和等待条件: 一个进程请求资源得不到满足而等待时，不释放已占有的资源\n不剥夺条件: 任一进程不能从另一进程那里抢夺资源\n循环等待条件: 存在一个循环等待链，每一个进程分别等待它前一个进程所持有的资源\n前三个是死锁存在的必要条件，但不是充分条件，第四个条件是前三个条件同时存在时所产生的结果。\n\n\n\n\n\n死锁的避免\n死锁的避免\n当不能防止死锁的产生时，如果能掌握并发进程中与每个进程有关的资源申请情况，仍然可以避免死锁的发生\n只需在为申请者分配资源前先测试系统状态，若把资源分配给申请者会产生死锁的话，则拒绝分配，否则接收申请，为它分配资源\n\n\n\n银行家算法\n总结：牢记两个关键点：\n\n\n\n\n\n\n算法背景和目的\n银行家算法是一种预防死锁的资源分配算法，其灵感来源于银行家的贷款原则。在计算机系统中，操作系统就像银行家，管理着有限的资源（如内存、磁盘空间等）。进程就像要求贷款的客户，需要向操作系统申请资源。银行家算法的目标是确保系统在分配资源的过程中不会出现死锁情况，即避免多个进程因相互等待资源而无法继续执行。\n\n数据结构银行家算法使用以下数据结构来管理资源和进程：\n\n资源总数向量（Resource）：\n表示系统中每类资源的总数。\n例如，Resource &#x3D; (R1, R2, …, Rm)，其中R1表示第一类资源的总数，R2表示第二类资源的总数，依此类推。\n\n\n可用资源向量（Available）：\n表示系统中每类资源当前可用的数量。\n例如，Available &#x3D; (V1, V2, …, Vm)，其中V1表示第一类资源当前可用的数量，V2表示第二类资源当前可用的数量。\n\n\n最大需求矩阵（Claim）：\nClaim[i, j]表示进程Pi对Rj类资源的最大需求量。\n例如，Claim[1, 2] &#x3D; 3表示进程P1对第二类资源的最大需求量是3个。\n\n\n分配矩阵（Allocation）：\nAllocation[i, j]表示进程Pi已经分配到的Rj类资源数量。\n初始值为0，随着进程申请资源而更新。\n\n\n需求矩阵（Need）：\nNeed[i, j]表示进程Pi还需要的Rj类资源数量。\n计算公式为：Need[i, j] &#x3D; Claim[i, j] - Allocation[i, j]。\n\n\n请求矩阵（Request）：\nRequest[i, j]表示进程Pi当前申请的Rj类资源数量。\n\n\n\n3. 算法原理银行家算法通过以下步骤确保系统不会进入死锁状态：\n3.1 进程启动时的检查\n当系统要启动一个新进程时，需要检查是否满足以下不等式：\nR**i≥Claim[(n+1),i]+k&#x3D;1∑nClaim[k,i]\n其中，Ri表示第i类资源的总数，Claim[(n+1),i]表示新进程对第i类资源的最大需求量，Claim[k,i]表示已存在的进程对第i类资源的最大需求量。\n\n如果不满足上述条件，系统拒绝启动该进程，以防止资源不足导致死锁。\n\n\n3.2 资源分配过程\n试探性分配：\n当系统收到进程的资源请求后，先进行试探性分配。即假设系统满足了进程的请求，更新资源分配情况。\n\n\n安全性检查：\n系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较。\n在进程集合中找到剩余资源能满足最大需求量的进程。这样可以保证这个进程运行完毕并归还全部资源。\n\n\n资源回收：\n把这个进程从集合中去掉，系统的剩余资源会增加。\n然后反复执行上述步骤，逐步减少进程集合中的进程数量。\n\n\n\n3.3 安全性判断\n如果最后进程集合为空，说明本次申请可行，系统处于安全状态，可以实施本次分配。\n如果进程集合不为空，说明有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。\n\n4. 系统安全性定义在时刻T0，系统是安全的，当且仅当存在一个进程序列P1，…，Pn，对进程Pk满足公式：\nNeed[k,i]≤Available[i]+j&#x3D;1∑k−1Allocation[j,i]\n这个公式的意思是，对于每个进程Pk，它还需要的资源数量（Need[k,i]）不能超过当前可用资源数量（Available[i]）加上前面已经分配资源的进程（j &#x3D; 1到k - 1）所分配的资源数量总和。这说明系统能够按照这个序列依次满足进程的最大资源需求，从而保证系统不会出现死锁。\n5. 示例说明假设系统有三个进程P, Q, R，系统只有一类资源共10个，目前分配情况如下：\n表格\n复制\n\n\n\n进程\n最大需求（Claim）\n已分配（Allocation）\n需求（Need）\n\n\n\nP\n5\n2\n3\n\n\nQ\n4\n1\n3\n\n\nR\n3\n2\n1\n\n\n当前可用资源（Available）为：5\n\n安全性检查：\n检查是否存在一个安全序列。假设序列是P, Q, R。\n对于P：Need[P] &#x3D; 3，Available + Allocation[Q] + Allocation[R] &#x3D; 5 + 1 + 2 &#x3D; 8，满足Need[P] ≤ 8。\nP运行完毕后，释放资源2，Available &#x3D; 7。\n对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 7 + 2 &#x3D; 9，满足Need[Q] ≤ 9。\nQ运行完毕后，释放资源1，Available &#x3D; 8。\n对于R：Need[R] &#x3D; 1，Available &#x3D; 8，满足Need[R] ≤ 8。\nR运行完毕后，释放资源2，Available &#x3D; 10。\n进程集合为空，系统处于安全状态。\n\n\n资源请求：\n假设进程P请求2个资源。\n试探性分配后，Available &#x3D; 3，Allocation[P] &#x3D; 4，Need[P] &#x3D; 1。\n检查安全性：新的序列可能是Q, R, P。\n对于Q：Need[Q] &#x3D; 3，Available + Allocation[R] &#x3D; 3 + 2 &#x3D; 5，满足Need[Q] ≤ 5。\nQ运行完毕后，释放资源1，Available &#x3D; 4。\n对于R：Need[R] &#x3D; 1，Available &#x3D; 4，满足Need[R] ≤ 4。\nR运行完毕后，释放资源2，Available &#x3D; 6。\n对于P：Need[P] &#x3D; 1，Available &#x3D; 6，满足Need[P] ≤ 6。\nP运行完毕后，释放资源4，Available &#x3D; 10。\n进程集合为空，系统处于安全状态。\n\n\n因此，可以真正分配资源给P。\n\n\n\n通过上述步骤，银行家算法能够有效地预防死锁的发生，确保系统资源的安全分配。\n\n\n10.8.5. 银行家算法的程序及实现\ntypedef struct state &#123;//全局数据结构   int resource[m];   int available[m];   int claim[n][m];   int allocation[n][m];&#125;;void resource_allocation( ) &#123; //资源分配算法   if(allocation[i,*]+request[*]&gt;claim[i,*])      &#123;error&#125;; //申请量超过最大需求值   else &#123;      if(request[*]&gt;available[*])         &#123;suspend process.&#125;;      else &#123; //尝试分配，define newstate by:         allocation[i,*]=allocation[i,*]+request[*];         available[*]=available[*]-request[*];      &#125;   &#125;   if(safe(newstate))      &#123;carry out allocation&#125;;   else &#123;      &#123;restore original state&#125;;      &#123;suspend process&#125;;   &#125;&#125;bool safe(state s) &#123; //安全性测试算法   int currentavail[m];   set &lt;process&gt; rest;   currentavail[*]=available[*];   rest=&#123;all process&#125;;   possible=true;   while(possible)&#123; //rest中找一个Pk，满足以下条件      claim[k,*]-allocation[k,*]&lt;=currentavail[*]      if(found)&#123;         currentavail[*]=currentavail[*]+allocation[k,*];         rest=rest–&#123;Pk&#125;;      &#125;else&#123;         possible=false;      &#125;   &#125;   return(rest=null);&#125;C++\n\n10.8.6. 银行家算法例子10.8.6.1. 银行家算法例1\n\n\n\n\n\n\n\n\n\n\n\nP或者R再申请资源时，不能分配，因为现在只剩下2个资源，不能满足它们的最大需求\n10.8.6.2. 实例说明系统所处的安全或不安全状态(1)\n如果系统中共有五个进程和A、B、C三类资源\nA类资源共有10个,B类资源共有5个,C类资源共有7个\n在时刻T0T0,系统目前资源分配情况如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n可以断言目前系统处于安全状态，因为序列{P1,P3,P4,P2,P0}{P1,P3,P4,P2,P0}能满足安全性条件\n\n\n\n假设\nP1P1\n又请求1个A类资源和2个c类资源，得到新的状态如下图所示：\n\nRequest1(1,0,2)≤Need(1,2,2)Request1(1,0,2)≤Need(1,2,2)\nRequest1(1,0,2)≤Available(3,3,2)Request1(1,0,2)≤Available(3,3,2)\n\n\n\n\n\n判定新状态是否安全?可执行安全性测试算法，找到一个进程序列{P1,P3,P4,P0,P2}{P1,P3,P4,P0,P2}能满足安全性条件，所以可正式把资源分配给进程P1；\n\n\n\n假设\nP4P4\n发起资源请求，按照银行家算法检查，资源不足不予以分配\n\nRequest4(3,3,0)≤Need(4,3,1)Request4(3,3,0)≤Need(4,3,1)\nRequest4(3,3,0)&gt;Available(2,3,0)Request4(3,3,0)&gt;Available(2,3,0)\n\n\n假设\nP0P0\n发起资源请求，按照银行加算法检查，得到中间结果如下\n\nRequest0(0,2,0)≤Need(7,3,1)Request0(0,2,0)≤Need(7,3,1)\nRequest0(0,2,0)≤Available(2,3,0)Request0(0,2,0)≤Available(2,3,0)\n\n\n\n\n死锁的检测和解除检测\n解决死锁问题的另一条途径是死锁检测方法\n\n这种方法对资源的分配不加限制，但系统定时运行一个”死锁检测“程序，判断系统内是否已出现死锁，若检测到死锁则设法加以解除\n\n检测的一种方法：可设置两张表格来记录进程使用资源的情况\n\n等待资源表记录每个被阻塞进程等待的资源\n占用资源表记录每个进程占有的资源\n\n\n进程申请资源时，先查该资源\n是否为其它进程所占用\n\n若资源空闲，则把该资源分配给申请者且登入占用资源表\n否则，则登入进程等待资源表\n\n\n\n\n\n死锁检测程序定时检测这两张表，若有进程Pi等待资源rk，且rk被进程Pj占用，则说PiPi和PjPj具有”等待占用关系”，记为W(Pi,Pj)\n死锁检测程序反复检测这两张表，可以列出所有的”等待占用关系”\n如果出现循环等待占用时，显然，系统中存在一组循环等待资源的进程：Pi，Pj，Pk，…，Pm，Pn也就是说出现了死锁\n\n资源分配图与死锁定理\n资源分配图的图例\n每个资源用一个方框表示\n方框中的黑圆点表示此资源类中的各个资源\n每个进程用一个圆圈表示\n有向边表示进程申请资源和资源被分配情况\n\n\n约定Pi→Rj为请求边，表示进程Pi申请资源类Rj中的一个资源得不到满足而处于等待Rj类资源的状态，该有向边从进程开始指到方框的边缘，表示进程Pi申请Rj类中的一个资源。\nRj→Pi为分配边，表示Rj类中的一个资源已被进程Pi占用，由于已把一个具体的资源分给了进程Pi，故该有向边从方框内的某个黑圆点出发指向进程。\n\n\n\n图3.6中存在环路，经过分析是存在死锁的\n\n图3.7中存在环路，但是经过分析是不存在死锁的，因为R1和R2资源都不只一个，P2和P4进程归还后是可以避免的。\n\n简化：\n\n简化步骤：\n\n寻找可完成的进程：找到一个进程 P**i，它请求的资源都能得到满足。即 P**i 所需的资源要么是未分配的，要么是已分配给其他进程但这些进程可以释放这些资源。\n释放资源：假设 P**i 获得了所需资源并运行完成，它会释放所有分配给它的资源。这相当于从图中移除所有与 P**i 相关的申请边和分配边。\n重复步骤：重复上述步骤，寻找下一个可完成的进程，直到所有边都被消去。\n\n如果最终所有边都被消去，资源分配图是可完全简化的，系统不存在死锁。\n\n\n\n\n死锁定理系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是不可完全简化的。该充分条件称为死锁定理\n\n死锁检测的数据结构\n把两张表格中记录的进程使用和等待资源的情况用一个矩阵A来表示\n\n\n死锁检测程序可用Warshall的传递闭包算法\n检测是否有死锁发生，即对矩阵A构造传递闭包A∗[bij]\nA∗[bij]中的每个bij是对A[bij]执行如下算法\n\nfor k:=1 to n do   for i:=1 to n do       for j:=1 to do         bij:= bij 并 (bik 并 bkj)               \n\n在计算完传递闭包矩阵 W∗ 后，检查对角线上的元素 W∗[i][i]：\n\n如果存在某个 i 使得 W∗[i][i]&#x3D;1，则表示存在从节点 i 到自身的路径，即存在循环等待，系统可能处于死锁状态。\n\n死锁的恢复\n死锁被检测到后可以通过各种方法来解除系统死锁以恢复到可运行状态，方法有资源剥夺法、进程回退法、进程撤销法和系统重启法。\n资源剥夺法：剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。可仿照撤销陷于死锁的进程那样来选择剥夺资源的进程。\n进程回退法：根据系统保存的检查点让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检査点、回退及重启机制。\n进程撤销法：\n撤销陷于死锁的所有进程，解除死锁，继续运行。\n逐个撤销陷于死锁的进程，回收其资源并重新分派，直至死锁解除。但是究竟先撤销哪个死锁进程呢？可选择符合下面条件之一的进程先撤销： PU消耗时间最少者、产生的输出量最少者、预计剩余执行时间最长者、分得的资源数量最少者或优先级最低者。\n\n\n系统重启法：结束所有进程的执行并重新启动操作系统。这种方法很简单，但先前的工作全部作废，损失很大。\n\n\n检测死锁是否出现和发现死锁后实现恢复的代价大于防止和避免死锁花费的代价，但是这样的代价是值得的，因为死锁不是经常出现的。\n检测策略的代价依赖于死锁出现的频率\n恢复的代价是指处理器时间的损失。\n\n\n\n笔记第一章 · 导论\n\n____C____操作系统允许在一台主机上同时联接多台终端，多个用户可以通过各自的终端同时交互使用计算机。\nA. 网络    B. 分布式    C. 分时    D. 实时\n\n\n分时操作系统、实时操作系统的特点和应用领域\n\n分时操作系统（Time-Sharing Operating System）\n\n特点：\n多用户交互：允许多个用户同时通过终端与计算机交互。\n时间片轮转：采用时间片轮转（Round Robin）调度算法，将CPU时间分配给多个用户，每个用户感觉像是独占计算机。\n快速响应：系统对用户输入的响应时间较短，通常在几秒内。\n资源共享：系统中的资源（如CPU、内存、I&#x2F;O设备）被多个用户共享。\n\n\n应用领域：\n多用户环境：如大学计算机实验室、企业办公环境等。\n交互式应用：如文本编辑、电子邮件、在线数据库查询等。\n云计算服务：云平台提供多用户访问和资源共享，类似于分时系统。\n\n\n\n\n实时操作系统（Real-Time Operating System, RTOS）\n\n\n特点：\n严格的时间约束：系统必须在严格的时间限制内完成任务，否则可能导致严重后果。\n高可靠性：系统必须高度可靠，能够处理突发的事件和任务。\n优先级调度：采用优先级调度算法，确保高优先级任务优先执行。\n快速响应：系统对事件的响应时间非常短，通常在毫秒甚至微秒级别。\n\n\n应用领域：\n嵌入式系统：如汽车电子控制系统、工业自动化设备、医疗设备等。\n航空航天：如飞行控制系统、卫星通信系统等。\n军事应用：如雷达系统、导弹制导系统等。\n金融服务：如高频交易系统，需要快速处理交易请求。\n\n\n\n\n\n\n配置了操作系统的机器是一台比原来的物理机器功能更强的计算机，这样的计算机只是一台逻辑上的计算机，称为____虚拟____计算机。\n\n\n实时操作系统必须在__ A __内处理来自外部的事件。\n\nA.规定时间；\nB.调度时间；\nC.响应时间；\nD.周转时间；\n\n\n\n\n特权指令是指____A____。\n\nA.其执行可能有损系统的安全性；\nB.机器指令；\nC.控制指令；\nD.系统管理员可用的指令；\n\n\n\n\n‍____Celeron____不是一个操作系统环境。\n\n\n\n‎\n第二章 · 处理器管理\n静态共享进程时间图像如下，注意B处理完IO之后马上就可以执行C的IO。\n\n在做进程调度大题时，列出详细的表格，不会错：\n\n注意可能会需要平分CPU时间！！！\n\n\n\n试写出进程映像包括哪些组成部分(不必详述每个组成部分的具体内容)。(2 分)\n答: 程序块、数据块、核心栈、进程控制块(PCB)\n\n\n七状态图\n\n时间片轮转调度（RR）：\n\n不考虑优先级的，就是先来先服务，服务完了到最后排队。\n如果时间片还没有用完就已经完成了进程的事务，那么就立即释放时间片，调度下一个进程进入占用新的时间片运行。\n\n\n多级反馈调度：\n\n在时间片调度（RR）的基础上，引入了优先级。刚进入队列时优先级最高，被抢占一次就降一级。\n设置的q就是指时间片长度\n而前面笔记中的 q&#x3D;2^i^ 是指我们希望动态调整时间片长度\n\n\n注意看题目中同时最多支持几道程序。\n\n\n实模式下 16 位 CPU 使用段偏移方式的寻址能力为_______B___。\nA. 64kb B. 1M C. 16M D. 4G\n\n\n记住实模式的寻址能力就是20位也可以\n\n\n段偏移：\n\n\n\n通过段地址和偏移地址相加的方式来寻址\n\n为了表示更大范围的地址，我们对段地址左移四位再和偏移地址相加。\n\n此时我们可以认为我们有了20位的寻址能力，即1M\n\n\n\n\n下面哪条指令不是从实模式进入保护模式需要的指令______C____。\nA. lgdt [GdtPtr] B. out 92h, al C. jmp $ D. mov cr0, eax\n\n\njmp $。 其中$是指前地址。这句指令会形成死循环\n\n\n实模式和保护模式：\n\n实模式：\n\n\n\n\n保护模式\n\n\n\n\n模式切换：\n\n实模式切换到保护模式：\n\n一般步骤：\n\n构造 GDT（全局描述符表） 并使用 lgdt [GdtPtr] 加载 GDT。\n\n设置 PE 位（Protection Enable） 把 CR0 的第 0 位（PE 位）设置为 1：\nmov eax, cr0  or eax, 1  mov cr0, eax\n\n立即跳转（Far Jump）刷新流水线和 CS 段寄存器\njmp selector:offset\n\n\n\n\n\n\n\nSolaris 的多线程的实现方式为___B___\nA.纯内核级线程 \nB.混合式 \nC.纯用户级多线程 \nD.单线程结构进程\n\n\n\n引入多道程序设计技术的前ᨀ条件之一是系统具有___C__。\nA. 多个 CPU \nB.多个终端 \nC. 中断功能 \nD.分时功能\n\n\n\n操作系统里没有下面哪种述符表______D___。\nA. GDT B. LDT C. IDT D. KDT\n\n\n\n\nC 语言里面调用汇编的函数方法为______A___。 \nA. C 代码中使用 extern 声明，汇编中使用 global 导出 \nB. C 代码中使用 global 声明，汇编中使用 extern 导出 \nC. C 代码中使用 extern 声明，汇编中使用 extern 导出 \nD. C 代码中使用 global 声明，汇编中使用 global 导出\n\n\n进程包含的实体部分：OS 管理程序的数据结构和程序状态字（对应进程控制块），运⾏程序的内存代码、内存数据（对应程序块和数据块）、通⽤寄存器信息（对应核心栈）\n\n进程映像：进程控制块、进程程序块、进程数据块、核⼼栈\n\n对进程的管理和控制通过原语\n\n系统调用的实现流程，画图！\n\n\n\n\n线程的调度\n\n\n当计算机提供了管态（内核态）和目态（用户态）时，____A____必须在管态下运行\nA. 输入输出指令\nB. 从内存中取数\nC. 运算指令\nD. 把运算结果存回内存\n\n输入输出涉及到IO设备，要用内核指令调用\n\n\n\n\n关于内核级线程，以下描述不正确的是_­­­­­­__­­­­­­_B_­­­­­­__­­­­­­。\n‎\n\nA.内核可以将处理器调度直接分配给某个内核级线程；\nB.控制权从一个线程传送到另一个线程时不需要用户态-内核态-用户态的模式切换；\nC.可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势；\nD.建立和维护线程的数据结构及保存每个线程的入口；\n内核级线程的定义\n内核级线程是操作系统内核能够感知的线程。内核为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息。\n\n\n选项A的正确性\n内核可以将处理器调度直接分配给某个内核级线程。因为内核级线程是内核能够感知和管理的实体，内核可以直接对它们进行调度，将处理器分配给某个线程运行。\n\n\n选项B的错误性\n控制权从一个线程传送到另一个线程时，通常需要进行用户态-内核态-用户态的模式切换。这是因为线程切换涉及到内核对线程上下文的切换，而上下文切换需要内核的参与。具体过程如下：\n当一个线程运行时，它可能处于用户态。\n当需要切换到另一个线程时，当前线程需要将控制权交回内核，这涉及到从用户态切换到内核态。\n内核保存当前线程的上下文，加载下一个线程的上下文，然后将控制权交给下一个线程，这又涉及到从内核态切换回用户态。\n\n\n\n\n选项C的正确性\n可以将一个进程的多个线程分派到多个处理器，能够发挥多处理器并行工作的优势。内核级线程是内核能够感知的线程，内核可以将它们分派到不同的处理器上运行，从而实现多处理器并行工作。\n\n\n选项D的正确性\n建立和维护线程的数据结构及保存每个线程的入口是内核级线程的特性。内核需要为每个线程维护一个上下文环境，包括线程的程序计数器、寄存器集合和堆栈等信息，这些信息构成了线程的数据结构。\n\n\n\n\n\n\n‍__B__优先权是在创建进程时确定的，确定之后在整个进程运行期间不再改变。\n‎\n\nA.短作业；\nB.静态；\nC.先来先服务；\nD.动态；\n\n\n\n\n下面对进程的描述中，错误的是__B__。\n‍\n\nA.进程执行需要处理机；\nB.进程是指令的集合；\nC.进程是有生命周期的；\nD.进程是动态的概念；\n进程是操作系统中一个独立运行的基本单位，它包含了程序运行时所需的全部信息和资源。它不仅仅是一组指令，还包括以下几个重要组成部分\n\n\n\n\n\n\n下面所述步骤中，__ C __不是创建进程所必需的。\n‏\n\nA.为进程分配内存；\nB.建立一个进程控制块；\nC.由调度程序为进程分配CPU；\nD.将进程控制块链入就绪队列；\n\n\n\n\n所谓“可重入”程序是指___C___。\n\nA.在执行过程中其代码自身会发生变化的程序；\nB.不能够被多个程序同时调用的程序；\nC.能够被多个进程共享的程序；\nD.无限循环程序；\n\n\n\n\n‍在下述关于父进程和子进程的叙述中，正确的是__C___。\n\nA.父进程创建了子进程，因此父进程执行完了，子进程才能运行；\nB.撤销子进程时，应该同时撤销父进程；\nC.父进程和子进程可以并发执行；\nD.撤销父进程时，应该同时撤销子进程；\n父进程创建子进程后，父进程和子进程可以独立运行。操作系统会根据调度策略来决定哪个进程运行，而不是依赖于父进程是否完成。父进程和子进程可以并发执行，互不干扰。\n\n\n\n\n\n\n一个可共享的程序在执行过程中是不能被修改的，这样的程序代码应该是­C_。\n\nA.可再现代码；\nB.可执行代码；\nC.可重入代码；\nD.封闭的代码；\n\n\n\n\n第三章 · 存储管理\n页式存储地址转换\n\n在做题时，中间过程可以先用十进制表示，不用完全展开为二进制，提高做题速度。\n\n\nclock算法：\n\n如果在页表中找到了某一页，设置完引用位之后不用推进指针。\n\n那个‘*’叫引用位\n\n淘汰需要推进指针，找到了页不用\n\n\n\nMIN算法和WS算法一次只会引入一个页\n\n页式存储会导致内部碎片，包括段页式，分页式等。而分段式不会\n\n程序装入与链接：\n\n装入是指将程序从外存（如磁盘）加载到内存的过程。\n链接是指将多个目标模块（如程序模块、库模块等）组合成一个可执行程序的过程。链接可以分为静态链接和动态链接。\n\n\n静态重定位：\n\n是一种地址转换的方法，比如把逻辑地址变为物理地址。\n一般在进程装入的时候发生\n\n\n能够装入内存任何位置的代码程序必须是__可动态链接的__。\n\n在分页式虚存中，分页由__操作系统___实现。\n\n缺⻚中断后重新执⾏被中断的指令\n\n分段式不会产生内部碎片，分页式不会产生外部碎片。\n\n在请求分页存储管理中，当访问的页面不在内存时，便产生缺页中断，缺页中断是属于_C_。😥\n\n\n\nA. 访管中断\nB. 外中断；\nC. I&#x2F;O中断；\nD. 程序中断；\n\n\n虚存的可行性基础是____。😥\n\nA. 程序执行的局部性；\nB. 程序执行的顺序性；\nC. 程序执行的离散性；\nD. 程序执行的并发性；\n\n\n把逻辑地址转变为内存的物理地址的过程称作__重定位或地址映射__。\n\n页面替换算法_____有可能会产生Belady异常现象。\n\nA. FIFO；\nB. OPT；\nC. Clock；\nD. LRU；\n\n\nBelady异常是指在分页式虚拟存储器管理中，当使用某些页面置换算法（如FIFO）时，增加分配给进程的页面帧数反而导致页面错误（缺页）次数增加的异常现象。就是可能马上就要访问的页面被淘汰了。\n\n\nFAT12 文件系统里，FAT 表的数量和每张 FAT 表占用的扇区数量为______A___。\nA. 2, 9 B. 2, 10 C. 3, 9 D. 3, 10\n\n没印象，硬记吧\n\n\n\n\n静态重定位的时机是__D__。\n\nA.程序运行时；\nB.程序链接时；\nC.程序编译时；\nD.程序装入时；\n重定位可以理解为地址映射，也就是把逻辑地址转换为物理地址。当程序装入内存的时候就要做转换了\n\n\n\n\n通常所说的”存储保护”的基本含义是__防止程序间相互越界访问__。\n‏\n\n\n\nLRU置换算法所基于的思想是__A__。\n\nA.在最近的过去很久未使用的在最近的将来也不会使用；\nB在最近的过去用得少的在最近的将来也用得少；\n\n\n\n\n作业在执行中发生了缺页中断，经操作系统处理后，应该让其执行____A___指令。\n\nA.被中断的；\nB.被中断的前一条；\nC.被中断的后一条；\nD.启动时的第一条；\n被中断的指令还没做完，要重新做一遍。比如说有两条指令A和B，A执行的过程中发现了缺页中断，那么处理完以后执行指令A\n\n\n\n段式存储是不定长不连续的\n\n\n第四章 · 设备管理\n\n\n死锁：\n\n就是循环等待\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。。\n\n\n通道：通道是一种专门用于处理I&#x2F;O操作的硬件设备，它可以通过通道程序和通道指令独立于CPU运行，控制I&#x2F;O设备与内存之间的数据传输\n\n\n\n注意，J1退出的时间是11:50，是其所需要的时间的两倍。因为用的时间片调度算法，有两个进程。\n\n\n\n过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为__虚拟设备__。😥\n\n通道又称I&#x2F;O处理机，它用于实现__内存与外设__之间的信息传输。\n\n大多数低速设备都属于____设备。\n\nA. 虚拟；\nB. SPOOLing；\nC. 共享；\nD. 独享；\n\n\n在操作系统中，用户程序申请使用I&#x2F;O设备时，通常采用____。😥😇\n\nA. 独占设备名；\nB. 虚拟设备名；\nC. 物理设备名；\nD. 逻辑设备名；\n\n注：逻辑设备名：逻辑设备名是用户程序在请求I&#x2F;O操作时使用的设备名称，它是用户程序与实际物理设备之间的一个抽象层。\n\n\n\n使用SPOOLing系统的目的是为了提高______的使用效率。\n\nA. CPU；\nB. I&#x2F;O设备；\nC. 操作系统；\nD. 内存；\n\n\n工作集模型和工作集置换算法(WS)！！\n\nSPOOLing的实质是让独享型设备变为共享设备\n\n\n在操作系统中，__D__指的是一种硬件机制。\n‌\n\nA.内存覆盖技术；\nB.SPOOLing技术；\nC.缓冲池；\nD.通道技术；\n硬记，ABC是软件机制，D是硬件机制\n\n\n\n\n‏__C__算法是设备分配常用的一种算法。\n‍\n\nA.首次适应；\nB.短作业优先；\nC.先来先服务；\nD.最佳适应；\n\n\n\n\n采用假脱机技术，将磁盘的一部分作为公共缓冲区以代替打印机，用户对打印机的操作实际上是对磁盘的存储操作，用以代替打印机的部分是__C__。\n\nA.独占设备；\nB.一般物理设备；\nC.虚拟设备；\nD.共享设备；\n\n\n\n\n使用SPOOLing系统的目的是为了提高___D___的使用效率。\n‎\n得分&#x2F;总分\n\nA.操作系统；\nB.CPU；\nC.内存；\nD.I&#x2F;O设备；\n\n\n\n\n\n\n第五章 · 文件管理\n逻辑结构的文件：\n\n流式文件\n记录式文件\n\n\n物理结构的文件：\n\n顺序文件\n直接文件（散列文件）\n连接文件（串联文件）\n索引文件\n\n\n文件系统的主要目的是____。\n\nA. 提高外存的读写速度；\nB. 用于存储系统文件；\nC. 实现虚拟存储；\nD. 实现对文件的按名存取；\n\n\n文件系统采用多级目录结构后，对于不同用户的文件，其文件名____。\n\nA. 受系统约束；\nB. 应该不同；\nC. 可以相同也可以不同；\nD. 应该相同；\n\n\n为了解决不同用户文件的“命名冲突”问题，通常在文件系统中采用____。\n\nA. 索引；\nB. 多级目录；\nC. 路径；\nD. 约定的方法；\n\n\n文件系统的主要目的是__实现对文件的按名存取__。\n\n文件目录的主要作用是____按名存取____。\n\n在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中，______具有直接读写文件任意一个记录的能力，又提高了文件存储空间的利用率。\n\nA. 链接结构；\nB. 索引结构；\nC. Hash结构；\nD. 顺序结构；\n\n注：\n散列文件：不适合直接读写文件的任意记录\n链接文件：不支持直接访问文件的任意记录\n顺序文件：不支持高效的随机访问\n\n\n\n存放在磁盘上的文件__既可随机访问，又可顺序访问__。😥\n\nUnix文件系统中，打开文件的系统调用open返回值是____文件描述符（字）____。\n\n文件的动态共享！！！\n\n打开文件的系统调用open接收的参数是文件名，返回值是文件描述符\n\n\n文件系统用__B__组织文件。\n\nA.堆栈；\nB.目录；\nC.指针；\nD.路径；\n\n\n\n\n在inode中的i_count是什么含义？\nA.不同进程在同一系统下共享的文件数\nB.不同进程在不同系统下共享的文件数\nC.相同进程在同一系统下共享的文件数\nD.不同进程在不同系统下共享的文件数\n\ni_count 是 Linux&#x2F;UNIX 内核中 内存中的 inode（也称为 in-core inode） 的一个字段，用于记录： 有多少个进程正在使用这个 inode（即该文件当前被打开了多少次）.它通常作为 引用计数（reference count），防止 inode 被释放（如释放内存）时仍有进程在使用它。\n\n\n\n文件系统磁盘结构：\n\n用户打开文件表：进程的PCB结构中保留一个files_struct，称为用户打开文件表或文件描述符表\n表项的序号为文件描述符fd\n该登记项内登记系统打开文件表的一个入口指针fp\n通过此系统打开文件表项连接到打开文件的活动inode。\n\n\n系统打开文件表：是为解决多用户进程共享文件、父子进程共享文件而设置的系统数据结构file_struct\n一个文件可能被多个进程同时打开或打开多次，导致位移量不同。\n每次打开就是一个file，多次打开就是多个file。\n一个inode可以连接0个或多个file，多个file对应一个inode。\n内核内存区开辟最多存放256项的系统打开表区。\n\n\n主存活动inode表：为解决频繁访问磁盘索引节点inode表的效率问题，系统开辟的主存区，正在使用的文件的inode被调入主活动索引节点inode中，以加快文件访问速度。\n\n\n目录项：包含inode号和文件名\n\n文件操作：\n\n创建文件（create）过程：\n\n例如create(“path”, 0775)\n为新文件newfile分配磁盘inode和活动inode，并把inode编号与文件分量名newfile组成新目录项，记到目录中，这个过程中执行目录检索程序。\n在新文件所对应的活动inode中置初值，如置存取权限i_mode&#x3D;0775，连接计数i_nlink&#x3D;1等。\n分配用户打开文件表项和系统打开文件表项，为后者置初值，包括特征位为写，读写位移f_offset清0。\n把各表项及文件对应的活动inode用指针连接起来\n把文件描述字fd返回给调用者。\n\n\n\n\n删除过程：\n\n删除把指定文件从所在的目录文件中除去。\n如果没有连接用户(i_link为1)，还要把文件占用的存储空间释放。删除系统调用形式为：unlink(filenamep)。\n在执行删除时，必须要求用户对该文件具有”写“操作权。\n\n\n打开过程：\n\n文件使用前需要打开，以建立进程与文件之间的联系，而文件描述符唯一标识了这种连接，其任务是把文件的磁盘inode复制到内存活动inode中去，同时建立一个独立的读写文件数据结构，即系统打开文件表的一个表项。\n打开过程：\n检索目录\n如果没有则会出错\n检索到指定文件后，把它的磁盘inode复制到活动inode表中。\n如果inode号已经在活动表项中则直接执行下一步。\n\n\n根据参数mode核对权限(与创建时的mode)\n如果非法，则这次打开失败。\n当”打开”合法时，为文件分配用户打开文件表项和系统打开文件表项，并为后者赋初值。通过指针建立这些表项与活动inode间的联系。把文件描述字，即用户打开文件表中相应文件表项的序号返回给调用者。\n\n\n\n\n输入是含路径的文件名 →→ 依据层次式目录结构解释与检索 →→ 匹配文件名并读取目录项 →→ 提取inode号 →→ 按号定位，在inode区读取inode数据结构(主存活动inode)\n系统实现上必须有inode号，但是对文件名而言是透明的。\n\n\n关闭过程：\n\n关闭文件时需要释放掉inode来保证空间。\n关闭过程\n根据fd找到用户打开文件表项，再找到系统打开文件表项。释放用户打开文件表项。\n把对应系统打开文件表项中的f_count减1，如果非0，说明还有进程共享这一表项，不用释放直接返回；否则释放表项。\n把活动索引节点中的i_count减1（前提是系统打开文件表项被释放），若不为0，表明还有用户进程正在使用该文件，不用释放而直接返回，否则在把该活动索引节点中的内容复制回文件卷上的相应索引节点中后，释放该活动索引节点。\n\n\nf_count和i_count分别反映进程动态地共享一个文件的两种方式\nf_count反映不同进程通过同一个系统打开文件表项共享一个文件的情况；\ni_count反映不同进程通过不同系统打开文件表项共享一个文件的情况。\n\n\n通过两种方式，进程之间既可用相同的位移指针f_offset，也可用不同位移指针f_offset共享同一个文件。\n\n\n\n\n虚拟文件系统（VFS，Virtual File System）是现代操作系统中用于管理文件系统的一个抽象层。VFS通常分为三个层次：实现层、虚拟层和应用层。\n\n\n\n第六章 · 并发程序设计\n注意，写管程或者PV操作的时候，如果说到“有两个进程”，就要有两个process，例如：\n\n\n在操作系统中，临界区指___D____ \n。\nA．一个缓冲区 \nB.一个数据区 \nC.同步机构 \nD.一段程序\n\n\n死锁的检测和解除\n\n\n","categories":["课业"]},{"title":"机器学习","url":"/2025/12/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"考核形式平时成绩（60%）课程作业30%（每人提交，共八次）\n上机报告30%（小组提交，共六次）\n期末成绩（40%）专题报告（小组提交，共一次）\n\n无期末试卷考试\n\n机器学习四大问题聚类\n定义：一种 无监督学习方法，目标是把样本自动划分为若干组（簇），同一簇内的样本相似度高，不同簇间的相似度低。\n常见算法\nK-means：基于中心点迭代优化，快速但对初始值和簇数敏感。\n层次聚类（Hierarchical Clustering）：逐层合并或拆分，得到树状聚类结构。\nDBSCAN：基于密度，能发现任意形状的簇，并识别噪声。\n高斯混合模型 (GMM)：用概率分布来建模簇。\n\n\n应用：用户分群、市场细分、异常检测、推荐系统。\n\n降维定义：把高维数据映射到低维空间，同时尽量保留数据的主要信息。\n目的\n\n降低计算复杂度\n去除噪声、减少冗余\n便于可视化\n\n方法\n\n线性方法\nPCA（主成分分析）：通过正交变换找到最大方差方向。\nLDA（线性判别分析）：监督方法，最大化类间差异、最小化类内差异。\n\n\n非线性方法\nt-SNE：常用于高维数据的可视化（比如词向量）。\nUMAP：保持局部和全局结构，更适合大规模数据。\n\n\n\n特征工程定义：对原始数据进行处理，构造出更能表达模式的特征，提高模型效果。\n流程\n\n特征预处理\n缺失值处理（均值填充、插值、模型预测）\n标准化 &#x2F; 归一化（Z-score, MinMaxScaler）\n离散化（分箱、one-hot 编码）\n\n\n特征选择\n过滤法（方差选择、相关系数、卡方检验）\n包装法（递归特征消除 RFE）\n嵌入法（Lasso, 决策树特征重要性）\n\n\n特征构造\n组合特征（交互项、多项式特征）\n时间序列特征（滞后、移动平均）\nNLP 特征（TF-IDF, word2vec, BERT）\n\n\n\n模型评估\n目的：衡量训练好的模型在未知数据上的泛化能力。\n评估方法\n分类任务\n准确率（Accuracy）\n精确率（Precision）、召回率（Recall）、F1-score\nAUC-ROC 曲线\n\n\n回归任务\nMSE（均方误差）、RMSE\nMAE（平均绝对误差）\n$R^2$（决定系数）\n\n\n聚类任务\n轮廓系数（Silhouette Coefficient）\nCalinski-Harabasz 指数\nDavies-Bouldin 指数\n\n\n\n\n验证方式\n留出法（Train&#x2F;Test Split）\n交叉验证（k-fold Cross Validation）\n自助法（Bootstrap）\n\n\n\n机器学习流程问题定义    ↓数据收集    ↓数据预处理 &amp; 特征工程    ↓数据划分（训练/验证/测试）    ↓模型选择与训练    ↓模型评估    ↓模型优化（调参/集成/正则化）    ↓模型部署    ↓维护与迭代\n\n一、问题定义（Problem Definition）\n\n目标： 明确你要解决的问题是什么。是分类问题（如垃圾邮件识别）？还是回归问题（如房价预测）？或者是无监督问题（如客户分群）？\n评估指标： 确定如何衡量模型的好坏。分类：准确率（Accuracy）、精确率（Precision）、召回率（Recall）、F1分数等回归：均方误差（MSE）、均方根误差（RMSE）、R²等\n\n\n二、数据收集（Data Collection）\n\n**来源：**公开数据集（如Kaggle、UCI、政府开放数据等）业务系统&#x2F;数据库爬虫&#x2F;传感器&#x2F;日志等\n**类型：**结构化数据（表格数据，如CSV）非结构化数据（文本、图像、音频等）\n\n\n三、数据预处理（Data Preprocessing）\n这是非常关键的一步，数据质量直接影响模型效果。\n\n**数据清洗：**处理缺失值（删除、填充均值&#x2F;中位数&#x2F;众数等）处理异常值（删除、修正、分箱等）去重\n**数据转换：**特征编码：类别型变量 → 数值（如独热编码 One-Hot Encoding、标签编码 Label Encoding）数据标准化 &#x2F; 归一化（如Z-score标准化、Min-Max归一化）\n**特征工程：**特征选择（过滤法、包裹法、嵌入法）特征构造（组合特征、多项式特征等）降维（如PCA、LDA）\n\n\n四、数据划分（Data Splitting）\n将数据划分为训练集、验证集和测试集，常见比例：\n\n训练集（Train）：70% ~ 80%\n验证集（Validation）：10% ~ 15%（用于调参和模型选择）\n测试集（Test）：10% ~ 15%（最终评估模型泛化能力）\n\n或者使用交叉验证（如 k-fold Cross Validation）\n\n五、模型选择与训练（Model Selection &amp; Training）\n\n**选择模型：**线性模型：线性回归、逻辑回归树模型：决策树、随机森林、梯度提升树（如XGBoost、LightGBM、CatBoost）神经网络：多层感知机（MLP）、CNN、RNN等（用于复杂任务）其他：支持向量机（SVM）、K近邻（KNN）、朴素贝叶斯等\n**训练模型：**使用训练集对模型进行拟合（fit）可使用默认参数先跑通流程，再优化\n\n\n六、模型评估（Model Evaluation）\n\n在验证集或测试集上评估模型性能\n根据任务类型选择合适的评估指标\n可视化结果（如混淆矩阵、ROC曲线、学习曲线等）\n\n\n七、模型优化（Model Optimization）\n\n**超参数调优：**网格搜索（Grid Search）随机搜索（Random Search）贝叶斯优化、进化算法等\n**模型融合&#x2F;集成：**Bagging（如随机森林）Boosting（如XGBoost）Stacking、Voting等\n**防止过拟合&#x2F;欠拟合：**正则化（L1&#x2F;L2）Dropout（神经网络）增加数据、简化模型等\n\n\n八、模型部署（Model Deployment）\n\n将训练好的模型应用到实际环境中\n**部署方式：**批处理预测实时API服务（如使用 Flask、FastAPI、Django）嵌入到移动端&#x2F;嵌入式设备\n**模型监控：**模型性能衰减监控数据漂移检测持续更新与迭代\n\n\n九、维护与迭代（Maintenance &amp; Iteration）\n\n收集用户反馈与新的数据\n定期重新训练与优化模型\n持续改进业务流程与模型效果\n\n过拟合和欠拟合过拟合定义：\n\n过拟合是指模型在训练集上表现得非常好，但在新的、未见过的测试集上表现较差的现象。此时，模型过于复杂，记住了训练数据中的噪声和细节，导致无法很好地泛化到新的数据。\n\n影响\n\n过拟合的模型能够在训练数据中准确地预测，但在测试集或实际应用中性能差，不能有效地处理未见过的数据。这是因为模型不仅学习到了数据的普遍规律，还过度关注了训练集的特殊性。\n\n原因\n\n模型过于复杂：例如，神经网络的层数和参数过多，决策树的深度过深，大参数。\n（数值）大参数的模型，尤其是在高维度中，容易导致过拟合。所以我们要小参数，不要大参数\n为什么在相同的参数量下，小参数意味着复杂度低？\n减小参数值的大小会约束模型的灵活性\n小参数使得模型“平滑”\n大参数带来更高的方差\n\n\n\n\n训练数据不足：样本量少，模型无法学习到足够的普遍性规律。\n缺乏正则化：模型没有适当的惩罚项来控制其复杂性。\n\n预防策略\n\n数据方面：\n\n增加训练数据量：更多的数据有助于模型捕捉到数据中的普遍规律，减少对偶然性噪声的依赖。\n数据增强：通过对训练数据进行不同的变换（如旋转、裁剪、翻转等），来生成更多样化的训练数据，增加数据的多样性，帮助模型泛化。\n\n\n模型方面：\n\n使用正则化：正则化技术如 L1 或 L2 正则化可以对模型参数施加约束，从而防止模型过于复杂。\n\nL1正则化：\n\n原理：\n\nL1 正则化是通过在损失函数中加入模型参数的 绝对值 的和来进行惩罚。其惩罚项为：\n\n$$L1 Regularization&#x3D;λ_i∑∣w_i∣$$\n\n其中，w是模型的参数，λ 是正则化强度超参数，控制惩罚的力度。\n\n\n\n特点：适用于特征稀疏的模型，比如在很多特征中只有少数特征对预测有用的情况\n\nL2正则化：\n\n$$L2 Regularization&#x3D;λ_i∑w_i^2$$\n\n\n\n\n\n训练方面：\n\n早停法（Early Stopping）：在训练过程中监控验证集的表现，一旦验证误差开始增加，停止训练，从而避免过拟合。\n交叉验证（Cross-validation）：将数据分成多个子集，每次训练时使用不同的训练集和验证集，确保模型在不同数据集上都有良好的表现。\n特别适用于样本量相对较小的情况\n它通过将数据集分成多个子集，在不同的子集上训练和验证模型，从而使得模型的训练和验证更加稳定，避免过拟合。\nK折交叉验证是最常见的交叉验证方法。将数据集分为 K 个子集，模型会在 K-1 个子集上进行训练，然后在剩下的一个子集上进行验证。这个过程重复 K 次，每次选择不同的子集作为验证集，最终得到一个平均的模型性能评估结果。\n\n\n\n\n\n欠拟合定义\n欠拟合是指模型对训练数据的学习能力不足，无法捕捉到数据的基本规律。表现为训练集和测试集上都无法取得良好的性能。\n影响\n\n欠拟合的模型无法从数据中提取有用的信息，导致预测精度较低。它通常发生在模型过于简单，不能表达数据中复杂关系时。\n\n原因\n\n模型过于简单：例如，使用了线性模型来拟合本应是非线性关系的数据。\n\n特征不足：没有选取到有意义的特征，模型无法有效地学习数据的规律。\n\n训练不充分：模型训练不够充分，未能在训练集上学习到足够的信息。\n\n\n防止策略\n\n增加模型复杂度：选择更复杂的模型，增加更多的特征或增加模型的非线性能力。例如，使用多层神经网络、非线性回归或决策树等。\n增加训练时间：确保模型有足够的时间来学习训练数据中的模式，避免过早终止训练。\n选择更合适的特征：通过特征工程选取更加有意义的特征，使模型能够学习到更复杂的模式。\n降低正则化强度：如果正则化太强，可能会限制模型的学习能力，导致欠拟合。因此，可以适当减小正则化项的系数。\n\n分类和回归任务分类任务定义分类任务的目标是将样本正确地分类到一个或多个预定的类别中\n类别平衡\n定义：类别平衡是指数据集中每个类别的样本数量大致相等。即，不同类别的数据样本数量差不多，分类器可以公平地学习每个类别的特征。\n特点\n每个类别的样本数差异较小。\n模型训练时，每个类别对模型的影响相对均衡。\n评估指标（如准确率、精确率、召回率等）能较为客观地反映模型的性能。\n\n\n\n类别不平衡的影响\n模型偏向于多数类\n在类别不平衡的情况下，多数类的样本在训练集中的占比非常大，模型会倾向于预测多数类样本，从而导致少数类的分类效果较差。\n比如在上面的例子中，模型如果只预测为负类（多数类），它也能取得较高的 准确率，但其实模型并没有有效地识别少数类样本。\n\n\n评估指标失真\n在不平衡的情况下，准确率是一个 误导性指标。因为即使模型忽略了少数类样本，只预测多数类，准确率也可能很高。\n对于 少数类 的评价，精确率 和 召回率 等指标更为重要，尤其是 F1 分数，能够综合考虑精确率和召回率，帮助更好地评估模型对少数类的预测能力。\n\n\n训练困难\n类别不平衡会导致模型的 学习偏差，模型可能会忽略少数类样本的特征，甚至完全不去学习少数类的样本。这样一来，模型的 泛化能力 就会变差，尤其是在实际应用中，少数类样本往往才是 关键性数据（例如，疾病诊断中的患病类别）。\n\n\n不良的泛化能力\n由于模型倾向于学习多数类的特征，它在处理 新数据 时可能会产生较差的预测，特别是当新数据的类别分布与训练集不同（例如，大量少数类数据突然出现时），模型的表现可能会急剧下降。\n\n\n\n如何应对类别不平衡\n重新采样\n类别权重调整\n一些机器学习算法（如 支持向量机、逻辑回归、决策树 等）允许调整每个类别的权重。在类别不平衡时，增加少数类的权重，使得模型在训练时更加关注少数类样本。\n\n\n使用合适的评估指标\n使用 F1 分数、精确率、召回率 或 AUC 等更适合不平衡数据集的指标，而不是简单的准确率。\nAUC（Area Under Curve）：ROC 曲线下的面积，能够更全面地评估模型在不同阈值下的表现，尤其是在数据不平衡的情况下。\nF1 分数：综合考虑 精确率 和 召回率，在不平衡数据中更能准确反映模型的性能。\n\n\n集成学习方法\n一些集成学习方法，如 Bagging 和 Boosting，在处理不平衡数据时也具有优势。例如，随机森林和XGBoost可以通过调整 类别权重 或 数据采样 来处理类别不平衡。\n\n\n生成对抗网络\n\n评价指标\n准确率\n\n定义：准确率是指正确分类的样本数与总样本数之比：$$\\text{Accuracy} &#x3D; \\frac{\\text{正确分类的样本数}}{\\text{总样本数}}$$\n\n​    2. 优点：简单直观，适用于类别均衡的情况。\n\n缺点：当数据类别不平衡时，准确率可能会误导模型的真实性能。\n\n\n精确率\n\n定义：精确率是指被分类为正类的样本中，实际为正类的比例：\n\n$$\\text{Precision} &#x3D; \\frac{\\text{真正例（TP）}}{\\text{真正例（TP）} + \\text{假正例（FP）}}$$\n\n其中，TP 为真正例，FP 为假正例。\n\n\n优点：关注模型的误报率（False Positive），即模型预测为正类的样本中，实际为负类的比例。\n\n缺点：精确率高并不一定意味着模型总体表现好，因为它忽视了召回率（Recall）。\n\n\n\n召回率\n\n定义：召回率是指所有实际为正类的样本中，被正确预测为正类的比例：\n\n$$\\text{Recall} &#x3D; \\frac{\\text{真正例（TP）}}{\\text{真正例（TP）} + \\text{假负例（FN）}}$$\n\n其中，FN 为假负例。\n\n\n优点：关注模型的漏报率（False Negative），即实际为正类但被误预测为负类的比例。\n\n缺点：召回率高并不意味着模型总体表现好，因为它忽视了精确率。\n\n\n\nF1 分数\n\n定义：F1 分数是精确率和召回率的调和平均数，综合考虑了精确率和召回率：\n\n$$\\text{F1 Score} &#x3D; 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}}$$\n\n优点：适用于需要平衡精确率和召回率的场景，尤其是当数据类别不平衡时，F1 分数比准确率更能反映模型性能。\n\n缺点：可能会过于简化，忽略某些特定的应用场景。\n\n\n\nROC 曲线和 AUC（Area Under the Curve）\n\nROC 曲线：通过绘制 假正率（False Positive Rate, FPR） 与 真正率（True Positive Rate, TPR） 的关系图来评估模型的表现。\nTPR（True Positive Rate）即召回率，反映模型对正类样本的识别能力。\nFPR（False Positive Rate）反映模型对负类样本错误分类的能力。\n\n\nAUC（Area Under the Curve）：ROC 曲线下的面积，AUC 值越接近 1，表示模型的分类性能越好，AUC 为 0.5 表示模型没有分类能力。\n\n\n\n回归任务定义回归任务的目标是预测一个连续的数值。\n评价指标\n均方误差（Mean Squared Error, MSE）\n\n定义：均方误差是预测值与真实值之差的平方的平均值：\n\n$$\\text{MSE} &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n} (y_i - \\hat{y}_i)^2$$\n其中，$y_i$ 是真实值，$\\hat{y}_i $是预测值。\n\n优点：常用且简单，能够强调较大的误差。\n\n缺点：对异常值非常敏感。\n\n\n\n均方根误差（Root Mean Squared Error, RMSE）\n\n定义：均方根误差是均方误差的平方根：\n\n$$\\text{RMSE} &#x3D; \\sqrt{\\text{MSE}}$$\n\n优点：相比 MSE，这个RMSE 具有与原数据相同的单位，更直观。\n\n缺点：同样对异常值敏感。\n\n\n\n平均绝对误差（Mean Absolute Error, MAE）\n\n定义：平均绝对误差是预测值与真实值之差的绝对值的平均值：\n\n$$\\text{MAE} &#x3D; \\frac{1}{n} \\sum_{i&#x3D;1}^{n} |y_i - \\hat{y}_i|$$\n\n优点：相较于 MSE，MAE 对异常值不那么敏感。\n\n缺点：不会对大的误差进行惩罚，可能不如 MSE 更加有效。\n\n\n\n\n⽀持向量机与核函数支持向量机\n概念\n支持向量机（SVM）是一种强大的监督学习算法，广泛用于分类和回归任务。它的基本思想是寻找一个 超平面，将数据集分成不同的类别，并且尽量使得各类之间的间隔（边界）最大化。对于线性可分的数据，SVM 可以很好地进行分类，但在面对 线性不可分 的数据时，SVM 就显得有些力不从心。\n\n\n线性可分数据：数据点可以通过一个超平面（线性决策边界）完全分开。线性不可分则反之\n核函数的引入：如何解决线性不可分问题\n概述\n当数据是线性不可分的时，SVM 的标准方法无法找到一个合适的超平面来分割这些数据。为了克服这个问题，SVM 引入了 核函数的思想，通过将数据映射到更高维的空间，使得数据在新的空间中变得线性可分，从而能够找到一个超平面进行分类。\n\n\n核心思想\n映射到更高维空间：核函数通过某种方式将原始数据从低维空间映射到更高维的空间，在高维空间中，数据可能变得线性可分。例如，如果二维数据在三维空间中能够被一个平面分开，核函数的作用就是将数据从二维空间映射到三维空间。\n避免直接计算映射：直接计算映射到高维空间的特征非常复杂，尤其当维度极高时。因此，SVM 使用 核技巧（kernel trick）来避免显式计算这个映射。通过核函数直接计算数据在高维空间中的内积，而不需要实际地将数据投影到高维空间中，从而大大提高了计算效率。\n\n\n内积：\n代数定义就是对应的元素之积的和\n几何定义是两个向量的模之积乘夹角的余弦\n内积的值与两向量之间的夹角相关。内积越大，表示两个向量的方向越相似。\n如果内积为零，则表示两个向量是 正交的（垂直的）。\n\n\n为什么要计算内积？\n内积在高维空间中可以告诉我们数据点之间的相似性，进而帮助我们找到最优的分类超平面。\n核函数通过内积实现了 将数据映射到高维空间，而无需明确计算每个数据点的高维表示。通过这种技巧，SVM 可以有效地解决 线性不可分 问题。\n\n\n\n\n\n\n\n三种决策树算法对比ID3、C4.5 和 CART 是三种经典的 决策树算法。下面，我们将从以下几个方面对这三种算法进行对比：\n特征选择依据特征选择是决策树算法中最重要的步骤之一，它决定了树的结构和分类效果。ID3、C4.5 和 CART 在特征选择时采用不同的标准：\n\n\n\n特性\nID3\nC4.5\nCART\n\n\n\n特征选择依据\n信息增益（Information Gain）\n信息增益比（Information Gain Ratio）\n基尼指数（Gini Index）\n\n\n剪枝策略\n无剪枝或后期剪枝\n后剪枝（Post-pruning）\n成本复杂度剪枝（Cost Complexity Pruning）\n\n\n处理连续特征\n不支持连续特征，需离散化\n允许处理连续特征，选择最佳切分点（如中位数）\n允许处理连续特征，选择最佳切分点\n\n\n处理缺失数据\n忽略缺失数据或使用默认值\n根据条件概率处理缺失数据\n插补方法（多数类或平均值填充）\n\n\n生成树类型\n分类树（Classification Tree）\n分类树（Classification Tree）\n分类树和回归树（Classification and Regression Trees）\n\n\n适用任务\n主要用于分类问题\n主要用于分类问题，但支持概率输出\n既可以用于分类问题，也可以用于回归问题\n\n\n优缺点\n- 简单易实现 - 易过拟合（因为缺乏剪枝机制）\n- 解决了ID3的偏向性 - 计算复杂 - 能处理缺失数据\n- 支持回归任务 - 基尼指数计算简洁 - 处理缺失数据较好\n\n\n\nID3\n\n特征选择依据：ID3 使用 信息增益（Information Gain）作为特征选择的依据。信息增益衡量的是 通过某个特征对数据集的分类效果的提高。信息增益越大，表示该特征越能有效地减少数据的不确定性，因此被优先选择。\n\n信息增益的公式$$Gain(D,A)&#x3D;Entropy(D)−∑_{v∈A}\\frac{∣D∣}{∣D_v|}·Entropy(D_v)$$\n\n优缺点：\n\n优点：计算简单，易于理解。\n缺点：信息增益倾向于选择取值较多的特征，这可能导致偏向复杂特征，从而容易过拟合。\n\n\n\n\nC4.5\n\n特征选择依据：C4.5 在 ID3 的基础上做了改进，使用了 信息增益比（Information Gain Ratio）作为特征选择的依据。信息增益比通过对信息增益进行归一化，解决了 ID3 在特征选择时偏向取值较多的特征的问题。\n\n信息增益比的公式$$GainRatio(D,A)&#x3D;\\frac{Gain(D,A)}{SplitInfo(D,A)}$$其中，SplitInfo 衡量的是特征 A 的 分裂能力，即特征 A 能把数据集分成多少子集。C4.5 通过信息增益比避免了 ID3 中的信息增益偏向取值多的特征的问题。\n\n优缺点：\n\n优点：信息增益比克服了 ID3 的偏向性，能更合理地选择特征。\n缺点：信息增益比并不总能在所有情况下都最优。\n\n\n\n\nCART\n\n特征选择依据：CART（Classification and Regression Trees）使用 基尼指数（Gini Index）作为特征选择的依据。基尼指数衡量的是数据集的不纯度或不确定性。基尼指数越小，表示数据集越纯，分类效果越好。\n\n基尼指数的公式$$Gini(D)&#x3D;1−∑_{i&#x3D;1}^kp_i^2$$\n\n基尼指数与信息增益的对比：\n\n信息增益关注的是特征选择后的信息不确定性的减少，而基尼指数则关注通过某个特征划分数据集后的纯度。基尼指数在处理不平衡数据时效果较好。\n优缺点：\n优点：基尼指数计算简单，并且能有效处理不平衡数据。\n缺点：在某些情况下，基尼指数的表现可能不如信息增益比。\n\n\n\n\n\n\n\n剪枝策略剪枝是用来去除决策树中过拟合部分的步骤。\n\nID3：\n\nID3 没有内置剪枝机制。通常，ID3 构建的树可能会过度拟合训练数据，因此需要在决策树构建后通过其他方法（如交叉验证）进行剪枝。\n\n\nC4.5：\n\nC4.5 提出了 后剪枝（Post-pruning） 方法。C4.5 在构建树时会先完全生成一棵决策树，然后通过对每个子树进行剪枝来避免过拟合。剪枝过程通过 错误率的估计 来决定是否剪除某个节点。\nC4.5 使用了 最小错误率 和 最小增益 等标准来进行剪枝。通过这些标准，可以去掉对训练数据拟合过度的部分，从而提高模型的泛化能力。\n\n\n\n\nCART：\n\nCART 使用 成本复杂度剪枝（Cost Complexity Pruning），也叫 最小化误差剪枝（Error Complexity Pruning）。它通过计算每个节点的 复杂度参数 来判断是否剪枝。在剪枝过程中，CART 会遍历所有可能的子树，选择一个误差最小且复杂度最低的子树作为最终的模型。\n\n复杂度参数的定义：$$\\alpha &#x3D; \\frac{R(T) - R(T’)}{|T| - |T’|}$$\n其中，R(T) 是树 TTT 的误差率，∣T∣ 是树的大小，T′ 是剪枝后的树，α 是剪枝的复杂度系数。\n\n优缺点：\n优点：CART 的剪枝机制可以有效控制树的复杂度，避免过拟合。\n缺点：剪枝过程可能需要更多的计算，尤其是在数据集较大时。\n\n\n\n\n\n\n\n处理连续特征\nID3：\n\n处理连续特征：ID3 原生只支持 离散特征。对于连续特征，ID3 通常需要先将其离散化，将连续特征转化为离散区间，然后再进行处理。\n\n\nC4.5：\n\n处理连续特征：C4.5 允许直接处理连续特征。它会 根据连续特征的值（如某个特征值的中位数）将数据集分成两个子集。然后，根据信息增益比来选择最优的切分点。\n\n\nCART：\n\n处理连续特征：CART 也可以处理连续特征。它会通过 二分法 将连续特征分成两部分（小于某个阈值的部分和大于等于该阈值的部分），并根据基尼指数来选择最佳的切分点。\n\n\n\n处理缺失数据缺失数据是决策树算法中常见的挑战之一。q\n\nID3：\n\n缺失数据：ID3 没有专门的缺失数据处理机制。通常在构建树时，会忽略缺失的数据，或者将缺失值当作某个默认值来处理。\n\n\nC4.5：\n\n缺失数据：C4.5 在遇到缺失数据时，会通过 概率分配 来处理缺失值。如果某个样本缺失了某个特征的值，C4.5 会计算该特征的不同取值的概率，并根据这些概率对数据进行划分。\n\n\nCART：\n\n缺失数据：CART 使用 插补法 来处理缺失数据。对于某个样本的缺失特征，CART 会用 该特征的平均值（回归树）或 多数类值（分类树）来填补缺失数据。\n\n\n\n生成的树类型\nID3：ID3 只生成 分类树，即每个叶子节点都对应一个类标签。\nC4.5：C4.5 也生成 分类树，但它可以处理连续数据，并且生成的树更为平衡。\nCART：CART 既可以生成 分类树（用于分类问题），也可以生成 回归树（用于回归问题）。\n\n三类集成学习⽅法\n\n\n特性\nBagging\nBoosting\nStacking\n\n\n\n基本思想\n通过独立训练多个基学习器，减少方差\n逐步训练基学习器，减少偏差\n综合多个基学习器的预测结果，通过次级学习器进行组合\n\n\n训练过程\n并行化训练基学习器，投票或平均组合\n序列化训练，每个基学习器修正前一轮错误\n并行训练基学习器，次级学习器进行加权组合\n\n\n降低的误差类型\n主要降低方差（防止过拟合）\n主要降低偏差（提高准确度）\n同时降低偏差和方差\n\n\n是否并行化\n可以并行化训练基学习器\n训练过程是串行的，不能并行化\n基学习器可并行化，次级学习器不能并行\n\n\n过拟合风险\n较低，特别适用于高方差模型（如决策树）\n易过拟合，尤其在基学习器复杂时\n较低，但需要合理选择基学习器\n\n\n典型算法\n随机森林（Random Forest）\nAdaBoost，Gradient Boosting，XGBoost\nStacking（Stacked Generalization）\n\n\n集成学习\n集成学习（Ensemble Learning） 是一种将多个学习器（基学习器）组合成一个更强大的模型的技术。与单一模型不同，集成学习的目标是通过结合多个模型的预测结果来提高整体的性能。集成学习的关键思想是：多个模型的组合通常比单个模型更能捕捉数据的复杂性，从而提高预测的准确性和泛化能力。\n\n基学习器（Base Learner）：集成学习中的每一个单独的学习模型，通常是比较简单的模型。例如，决策树、逻辑回归、支持向量机等。\n\n组合方法：集成学习通过某种方式将这些基学习器的结果进行 加权投票（分类任务）或 加权平均（回归任务），从而得到最终的预测结果。\n\n\n\n分类：\n\n并行集成学习：多个基学习器在同一阶段独立训练和预测，然后将结果结合起来。这类方法通常可以并行化训练。\n例如：Bagging（如随机森林）。\n\n\n串行集成学习：基学习器是按顺序逐个训练的，每个基学习器都会在前一个基学习器的基础上进行改进。此类方法通常 不能并行化，训练过程是有依赖关系的。\n例如：Boosting（如 AdaBoost、XGBoost）。\n\n\n\n\n意义\n\n提高模型的准确性\n防止过拟合\n处理不同类型的数据和特征\n增强模型的鲁棒性\n利用不同模型的优势\n改进模型的泛化能力\n\n\n\nBagging（Bootstrap Aggregating）\n训练过程（基本思想）\n数据采样：从原始训练集通过 自助采样法（bootstrap） 随机抽取多个训练子集。每个子集的大小与原始数据集相同，但由于是有放回采样，某些样本可能在一个子集中重复出现，而有些样本则可能缺失。\n训练基学习器：在每个子集上训练一个基学习器。每个学习器的训练过程是独立的。\n组合预测：对于分类任务，使用 多数投票（即选取各学习器预测结果中出现最多的类别）来做最终预测；对于回归任务，使用 平均值 作为最终预测结果。\n\n\n应用特点\n降低方差：Bagging 通过使用多个基学习器来减少模型的方差，特别适用于高方差模型（如决策树）。\n并行化：因为各基学习器的训练过程是独立的，所以 Bagging 具有很好的 并行化能力。\n\n\n\nBoosting\n基本思想\nBoosting 的基本思想是 逐步构建弱学习器，每一步都专注于 修正前一步的错误，即通过 加权调整 样本的重要性，使后续学习器更加关注难以预测的样本。最终的预测结果是所有弱学习器加权后的组合。\n\n\n训练过程\n初始化训练：首先训练一个基学习器，并评估其表现。\n样本加权：根据上一步的预测误差，对训练数据中的样本进行加权。错误预测的样本会被赋予更大的权重，正确预测的样本权重较小。\n训练下一轮学习器：在加权后的数据集上训练下一个基学习器，使其更加关注误分类的样本。\n组合预测：通过对所有基学习器的加权投票（分类任务）或加权平均（回归任务）来得出最终的预测结果。\n\n\n应用特点\n降低偏差：Boosting 主要通过减少模型的偏差来提高模型的准确度，适合处理弱学习器难以拟合的数据。\n序列化训练：由于每个学习器的训练过程都依赖于前一个学习器的结果，因此 Boosting 的训练过程是 串行化的，这意味着它不适合并行化。\n容易过拟合：Boosting 对噪声比较敏感，容易在训练集上过拟合，尤其是基学习器过于复杂时。\n\n\n\nStacking（Stacked Generalization）\n基本思想\nStacking 是一种更复杂的集成学习方法，其基本思想是将多个不同类型的基学习器的预测结果作为输入，训练一个 次级学习器（meta-learner）来对这些预测结果进行加权组合，从而得到最终的预测结果。\n这使得 Stacking 在处理复杂任务时，比单一的模型表现更好，特别是在基学习器类型多样时。\n\n\n训练过程\n训练基学习器：首先，训练多个不同类型的基学习器（例如，决策树、支持向量机、逻辑回归等），并用它们对训练数据进行预测。\n生成次级数据集：将每个基学习器的预测结果作为特征，形成一个新的数据集。这个数据集的每一行是由各个基学习器对原数据的预测组成的。\n训练次级学习器：使用新的数据集来训练一个 次级学习器，该学习器通常是一个简单的模型（如线性回归或逻辑回归），它的任务是 学习如何组合基学习器的预测，从而提高模型的准确性。\n组合预测：最终的预测由次级学习器输出，即基学习器的加权组合。\n\n\n应用特点\n降低偏差和方差：Stacking 通过综合多个不同类型的模型来降低偏差和方差，因此在许多任务中能够取得较好的效果。\n适用多种基学习器：Stacking 可以组合不同类型的基学习器，利用它们各自的优势。\n训练过程复杂：与 Bagging 和 Boosting 不同，Stacking 的训练过程更为复杂，因为它不仅需要训练多个基学习器，还需要训练一个次级学习器。\n\n\n\n三种聚类⽅法K-Means概述\n定义：K-Means 是一种基于划分（partitioning）的聚类方法，其目标是将数据集划分为 K 个簇（cluster），使得每个数据点属于离它最近的簇中心（质心，centroid），并且所有数据点到其所属簇中心的距离平方和（即惯性，inertia 或 Within-Cluster Sum of Squares, WCSS）最小。\n\n算法流程：\n\n随机选择 K 个初始质心。\n将每个数据点分配给距离最近的质心，形成 K 个簇。\n重新计算每个簇的质心（即簇中所有点的均值）。\n重复步骤 2 和 3，直到质心不再发生显著变化或达到最大迭代次数。\n\n\n优点：\n\n简单、易于实现和理解。\n计算效率较高，适合大规模数据。\n\n\n缺点：\n\n必须事先指定 K 值（簇的数量）。\n\n对异常值敏感（异常点可能显著影响质心位置）。\n\n只能发现凸形（通常是球形或类球形）的簇，对复杂形状的簇效果差。\n\n对初始质心敏感，可能收敛到局部最优。\n\n\n\n适用场景：\n\n数据分布大致为球形或类球形的多个簇。\n簇之间分离较好，且大小相近。\n你知道（或可以合理猜测）簇的数量 K。\n比如：客户分群、图像压缩、文档主题初步聚类等。\n\n\n\n处理非球形簇的问题\nK-Means 的核心假设之一是：簇是凸的（通常是球形或类球形），且簇的密度相对均匀。这个假设源于它使用均值作为簇的中心，并通过最小化点到簇中心的距离来进行分配。\n问题具体表现：\n对非球形簇（如环形、月牙形、L形等）效果差K-Means 倾向于将簇的中心放在“中间位置”，并通过距离（通常是欧氏距离）分配样本。如果真实簇的形状是非球形的（例如数据点分布在一个环上），K-Means 很可能会在环的内部找一个“中心点”作为质心，导致环上的点被错误地划分到多个簇，或者都归到一个错误的中心。\n依赖欧氏距离的局限性K-Means 默认使用欧氏距离来衡量数据点与质心的远近，这种距离度量对于方向性强的分布或复杂几何形态并不敏感，它更适合各向同性的、对称分布的数据。\n无法发现具有复杂内部结构的簇如果某些簇是嵌套的、有洞的、或者呈流形分布，K-Means 无法有效捕捉这些结构。\n\n\n\nDBSCAN\n基本思想：\n\nDBSCAN 是一种基于密度的聚类算法，它认为簇是由密度相连的数据点组成的区域，而低密度区域中的点是噪声（outliers）。\n核心概念：\n\nε (eps)：邻域半径\nMinPts：形成一个簇所需的最小邻域点数\n\n一个点被认为是核心点（core point），如果它的 ε 邻域内至少包含 MinPts 个点（包括自己）。通过核心点的“密度可达”关系，可以将相互密度连接的点聚集为一个簇。\n\n\n\n优点：\n\n不需要预先指定簇的数量。\n能发现任意形状的簇（如非球形、环形等）。\n能识别并剔除噪声点（outliers）。\n\n\n缺点：\n\n对参数 ε 和 MinPts 敏感，参数选择不当会影响聚类效果。\n对于密度差异较大的数据集效果不佳（即不同簇的密度相差悬殊时难以处理）。\n当数据维度很高时（高维数据），密度定义变得模糊（“维度灾难”）。\n\n\n适用场景：\n\n簇的形状不规则、非球形。\n数据中含有噪声或离群点，希望算法能自动识别并排除。\n不知道簇的数量，或者簇的密度相对均匀。\n比如：地理信息聚类（如城市中密集的商铺）、异常检测、社交网络中的社区发现等。\n\n\n\n层次聚类\n基本思想：\n层次聚类是一种基于数据点间相似性（或距离）构建树状结构的聚类方法。它分为两种主要类型：\n\n凝聚式（Agglomerative，自底向上）：每个点初始为一个簇，逐步合并最相似的簇，直到满足停止条件（如只剩一个簇，或达到指定的簇数）。\n分裂式（Divisive，自顶向下）：从所有数据点作为一个簇开始，逐步分裂为更小的簇。\n\n常用的是凝聚式层次聚类。\n在每一步，算法根据某种距离度量（如欧氏距离、曼哈顿距离）和连接标准（如单连接、全连接、平均连接、Ward等）来决定哪些簇应该合并。\n 1. 单链接：两个簇之间的距离 = 两个簇中最近的两个数据点之间的距离（即最小距离）\n 2. 全连接：两个簇之间的距离 = 两个簇中最远的两个数据点之间的距离（即最大距离）\n 3. Ward：Ward 方法不是直接定义两个簇之间的距离，而是定义：合并两个簇后，总体 类内方差（intra-cluster variance） 的增量（或者说增加的平方误差）最小。换句话说，Ward 方法在每一步选择：合并后使得 所有点到其簇中心的平方距离之和（SSE）增加最小的那两个簇进行合并。\n\n\n优点：\n\n不需要预先指定簇的数量（但可以依据树状图后期决定）。\n可以生成层次化的聚类结果，便于分析和可视化（比如画出树状图 dendrogram）。\n对于小规模数据效果不错，解释性强。\n\n\n缺点：\n\n计算复杂度高，不适合大规模数据集（时间复杂度通常为 O(n^3) 或优化后 O(n^2)）。\n一旦合并或分裂，无法撤销，缺乏灵活性。\n对噪声和异常值较为敏感。\n对高维数据的距离度量可能失效（维度灾难）。\n\n\n适用场景：\n\n数据量不是特别大，希望探索数据的层次结构。\n想要直观地通过树状图分析不同层次的聚类情况。\n比如：基因表达数据分析、组织结构分析、文档主题的层级归纳等。\n\n\n\nPCA核心思想\n一句话理解：找到那些**最能代表数据分布方向（即数据变化最大的方向）**的轴（主成分），然后把数据投影到这些方向上，从而用更少的维度表示数据的大部分信息。\n这些新的维度（主成分）是彼此正交（不相关）的；\n第一个主成分方向是数据方差最大的方向，第二个主成分是在与第一个正交的方向上方差最大的，依此类推\n\n协方差矩阵的作用\n概念：\n\n方差：反映了单个特征（维度）上的数据分布范围，即该维度上的数据变化程度。方差越大，说明该方向上的信息越多。\n协方差：反映了两个不同特征之间的变化趋势是否一致。如果协方差为正，说明两者倾向于同时增大或减小；为负则相反；接近零则说明几乎不相关。\n协方差矩阵：\n对角线元素：是每个特征的方差（即该特征自身的变化幅度）；\n非对角线元素：是不同特征之间的协方差（反映特征之间的相关性）。\n\n\n\n\n如何发挥作用\n\n协方差矩阵的特征值和特征向量，决定了主成分的方向和重要性：\n\n对协方差矩阵 Σ 进行特征分解（Eigendecomposition）：$$Σ&#x3D;VΛV^T$$\n\n\n\n其中：\n\nΛ 是对角矩阵，对角线上的元素是特征值（λ₁, λ₂, …, λ_d），代表每个主成分方向上的方差大小\nV 的列是对应的特征向量，代表主成分的方向（即新的坐标轴方向）\n\n\n特征值越大，说明对应的主成分方向上数据方差越大，信息量越丰富；\n我们按照特征值从大到小排序，选择前 k 个最大的特征值对应的特征向量，作为新的 k 维空间的基，将数据投影过去，就实现了降维。\n\n\n\nSMOTE缓解不平衡问题\n核心思想：\n\nSMOTE 是一种数据层面的方法，用于解决少数类样本不足的问题。\n通过对少数类样本进行“人工合成”，生成一些新的、合理的少数类样本，从而增加少数类的样本数量，缓解类别不平衡。\n它不是简单地复制少数类样本（那样容易导致过拟合），而是基于现有少数类样本的特征，合成“看起来合理”的新样本。\n\n\n工作原理\n\n假设我们有一个少数类的样本点 $x_i$，SMOTE 的操作步骤大致如下：\n\n选择一个少数类样本点$x_i$；\n计算该样本在少数类样本集中的 K 个最近邻（通常 K&#x3D;5）；\n从这 K 个近邻中随机选择一个样本点 $x_{nn}$ ；\n在$x_i$和 $x_{nn}$ 之间的连线上，随机选择一个位置，合成一个新的样本点：\n\n$$x_{new}&#x3D;x_i+rand(0,1)×(x_{nn}−x_i)$$\n\n这个公式的意思是：在特征空间中，在少数类样本$x_i$和$x_{nn}$之间的“线段”上，随机插值生成一个新的样本点，这个点看起来像是这两个真实样本的“混合体”，是合理的“人造”样本。\n\n\n重复上述过程，为少数类生成足够多的新样本，使其数量接近或达到多数类的水平（或设定的平衡比例）。\n\n\n\n\n优点：\n\n有效增加少数类样本数量，缓解类别不平衡\n生成的新样本是基于真实数据的插值，比单纯复制样本更有效、更不容易导致过拟合\n简单易实现，是处理类别不平衡问题的经典方法之一\n可以与欠采样（如随机删除部分多数类样本）等方法联合使用，效果更佳\n\n\n缺点：\n\n仅适用于数值型特征数据（因为需要在特征空间中进行插值），对于类别型变量不适用，需要额外处理；\n合成样本仍然是“人造”的，如果少数类样本本身很少或噪声较多，生成的新样本可能不太合理，有一定过拟合风险；\nSMOTE 是在原始特征空间中操作的，如果特征维度很高，合成样本的代表性可能下降（可考虑先降维）；\n它只解决训练集中的不平衡问题，不会改变测试集的分布，测试时仍需使用真实分布评估模型效果\n\n\n\n神经网络感知机基本思想\n定义\n\n感知机是一种最简单的前馈神经网络模型，属于单层二分类线性模型，它是现代神经网络和深度学习的最基础组成单元之一。\n\n\n目标：\n\n给定一组输入特征，感知机通过一个线性函数对输入进行加权求和，然后通过一个激活函数（通常是阶跃函数）输出一个类别标签，用于解决二分类问题。\n\n\n基本结构\n\n设有一个样本的特征向量为：$$x&#x3D;[x1,x2,…,xn]（n维输入）$$\n\n感知机模型通过一组权重 w1,w2,…,w**n和一个偏置项 b，对输入进行线性组合：$$z&#x3D;w_1x_1+w_2x_2+⋯+w_nx_n+b&#x3D;W^TX+b$$\n\n然后，通过一个**激活函数（如阶跃函数 &#x2F; sign 函数）**进行二元分类决策：$$y&#x3D;\\left{         \\begin{array}{lr}         +1, \\ \\ 如果 z≥0,  &amp; \\         -1, \\ \\ 如果 z&lt;0,  &amp;         \\end{array}\\right. 或有时定义为 y&#x3D;sign(z)$$\n\n\n\n训练过程\n\n感知机通过迭代的方式调整权重 w和偏置 b，使得模型能够正确分类训练数据。\n\n\n\n单层感知机无法解决 XOR（异或）问题\n问题描述\n\n单层感知机本质是一个线性模型，它只能学习线性决策边界（一条直线&#x2F;一个超平面），而 XOR 是一个非线性可分问题，所以单层感知机无法找到一个线性超平面将两类样本正确分开。\n\n\n解决策略\n\n使用多层感知机（Multi-Layer Perceptron, MLP），即神经网络\n隐藏层引入非线性变换，使网络可学习复杂的非线性决策边界，从而解决 XOR\n\n\n\n\n反向传播神经⽹络概述\n它并不是具体的神经网络类型，而是一种训练算法。\nBP 神经网络（Backpropagation Neural Network，反向传播神经网络）。BP 神经网络是一种多层前馈神经网络，它通过有监督学习的方式进行训练，即给定输入和对应的正确输出（标签），网络通过不断调整内部参数（权重和偏置），使得输出尽可能接近真实值。\n一句话解释核心：利用“前向传播”计算输出，再通过“反向传播”将误差逐层传回，并基于梯度下降法更新网络参数，从而逐步优化模型。\n\n前向传播\n目的：根据当前的网络参数（权重和偏置），将输入数据逐层向前计算，最终得到网络的输出预测值。\n\n一句话总结：前向传播就是：从输入层开始，逐层计算加权和（线性变换），再经过激活函数（非线性变换），最终得到网络输出的过程。这个过程只用到了当前的参数，不涉及任何更新。\n\n过程（以三层网络为例：输入层 → 隐藏层 → 输出层）：\n\n假设：\n\n输入层有 n个神经元，输入向量为：x&#x3D;[x1,x2,…,x**n]T\n隐藏层有 m个神经元\n输出层有 k个神经元（对应分类或回归任务的输出）\n\n\n步骤：\n\n输入层 → 隐藏层\n\n每个隐藏层神经元接收来自所有输入层神经元的加权输入，并加上偏置，然后通过激活函数输出。\n\n设：\n\n输入到隐藏层的权重矩阵为：W(1)∈Rm×n\n隐藏层偏置向量：b(1)∈Rm\n激活函数：如 Sigmoid、ReLU、Tanh，记为 σ\n\n\n则隐藏层的**加权输入（净输入）**为：$$z^{(1)}&#x3D;W^{(1)}x+b^{(1)}$$\n\n隐藏层的**输出（激活值）**为：$$h&#x3D;σ(z^{(1)})$$\n\n\n\n隐藏层 → 输出层\n\n类似地，输出层接收来自隐藏层的输出，再次进行加权求和 + 偏置 + 激活函数\n\n设：\n\n隐藏到输出的权重矩阵：W(2)∈Rk×m\n\n输出层偏置：b(2)∈Rk\n\n输出层激活函数可能根据任务而定（比如分类用 Sigmoid &#x2F; Softmax，回归可能不用或用线性）\n\n\n\n输出层的净输入：$$z^{(2)}&#x3D;W^{(2)}x+b^{(2)}$$\n\n输出层的最终输出（预测值）：$$ypred&#x3D;f(z^{(2)})（比如用 Sigmoid 或 Softmax）$$\n\n\n\n\n\n\n\n\n反向传播\n目的：通过计算预测输出与真实标签之间的误差，然后将该误差从输出层反向传播至每一层，从而计算出每一层参数（权重和偏置）的梯度，为参数更新提供依据。\n\n一句话总结：这个过程会对每一层的所有权重和偏置都进行更新，从而一步步让网络的输出逼近真实值。\n\n基本流程：\n\n计算损失函数（Loss Function）\n\n假设我们使用均方误差（MSE，回归）或交叉熵损失（Cross Entropy，分类）\n\n这个损失函数反映了当前输出与真实值之间的差距，是我们优化的目标。\n\n\n\n反向传播：从输出层开始，逐层回传误差并计算梯度\n\n我们采用**链式法则（Chain Rule）**来计算损失函数对每一层参数（权重和偏置）的偏导数（即梯度）。\n\n计算输出层的误差\n\n根据输出层误差，计算隐藏层的误差。依次倒推\n\n计算梯度（对参数的偏导数）\n\n这些梯度告诉我们：当权重或偏置发生微小变化时，损失函数会如何变化。\n\n\n\n\n参数更新（Gradient Descent）\n\n得到梯度后，我们使用**梯度下降法（或其变种，如 SGD、Adam 等）**来更新参数：\n这个过程会对每一层的所有权重和偏置都进行更新，从而一步步让网络的输出逼近真实值。\n\n\n\n\n\n三大深度神经网络前馈神经网络（Feedforward Neural Network, FNN）概述\n前馈神经网络是最简单、最基础的神经网络类型，也是其他复杂网络的基础。在 FNN 中，信息只沿着一个方向传播（从输入层 → 隐藏层 → 输出层），没有反馈或循环连接。\n特点：\n每一层中的神经元与下一层的所有神经元相连接（全连接），称为全连接层（Dense Layer&#x2F;FC Layer）；\n数据流向是单向的，没有循环或记忆功能；\n通常使用激活函数引入非线性（如 ReLU、Sigmoid 等）。\n\n\n工作原理\n输入数据经过各层的加权求和与激活函数，逐层向前传播，最终在输出层得到预测结果；\n通过反向传播算法和梯度下降等方法优化网络参数，最小化损失函数。\n\n\n\n卷积神经网络（Convolutional Neural Network, CNN）概述\n卷积神经网络是专门为处理具有网格状拓扑结构的数据（如图像、视频）而设计的一种神经网络。它通过局部感知、权值共享、下采样等机制，大幅减少了参数数量，同时能够有效提取空间特征。\n结构特点\n卷积核：在卷积神经网络中，卷积核（也称为滤波器、过滤器）是一个小的矩阵（比如 3×3、5×5 等），它是网络中可学习的参数，用来对输入数据（通常是图像）的局部区域进行卷积运算（Convolution Operation），从而提取某种特定的局部特征。\n卷积层（Convolutional Layer）：使用一组可学习的滤波器（卷积核）对输入数据进行局部区域卷积操作，提取局部特征（如边缘、纹理）；权值共享：同一个卷积核在整个图像上滑动使用，减少参数量；输出称为特征图（Feature Map）。\n激活函数层（如 ReLU）：引入非线性。\n池化层（Pooling Layer）：通常是最大池化（Max Pooling）或平均池化（Average Pooling）；降低特征图的空间尺寸，减少计算量，增强特征不变性。\n全连接层（Fully Connected Layer）：将提取到的高级特征进行整合，用于最终分类或回归。\n\n\n\n工作原理\n通过卷积操作提取局部特征，通过池化逐步降维并保留重要信息；\n\n卷积核如何工作？\n卷积核的参数（权重）是可学习的，训练过程中自动调整以提取对任务最有用的特征；\n参数共享：同一个卷积核在整个图像上滑动使用，大大减少参数数量；\n可以有多个卷积核（如 32 个、64 个），每个提取不同的特征，生成多个特征图。\n\n\n通道\n\n可以理解为，某个点的多维度信息。比如在图片中，一个像素点的信息包含RGB三个维度（三种颜色）的信息，所以通道数为三。\n抽象的，这个维度可以更高。\n\n\n池化\n\n对特征图进行降采样（Downsampling），减少数据维度，降低计算量，同时增强特征的平移、缩放、旋转的鲁棒性。\n通常在卷积层之后使用，每隔一定区域取一个代表性值。\n常见池化方式：\n最大池化（Max Pooling）：取区域内最大值，最常用\n平均池化（Average Pooling）：取区域内平均值\n\n\n\n\n对比项\n最大池化（Max Pooling）\n平均池化（Average Pooling）\n\n\n\n操作\n取窗口内最大值\n取窗口内平均值\n\n\n关注点\n突出最显著、最强的特征（比如边缘、激活）\n反映整体区域的平均信息\n\n\n对噪声的鲁棒性\n较强（不受个别噪点影响）\n一般（会被平均稀释）\n\n\n特征保留能力\n更好保留显著特征、纹理、轮廓\n更强调整体分布、背景信息\n\n\n常用场景\n图像分类、检测任务（主流选择）\n某些回归任务、全卷积网络等\n\n\n效果倾向\n特征更尖锐、显著\n特征更平滑、稳定\n\n\n\n\n\n\n\n最终通过全连接层进行决策（如分类）；\n\n展平：把卷积得到的所有特征图转化为一维向量，将空间特征转换为全连接网络可处理的格式\n全连接：把展平后的特征向量输入到全连接神经网络中，将学到的分布式特征表示映射到样本的类别得分或回归值。\n\n\n同样采用反向传播与梯度下降优化参数。\n\n\n工作流程\n输入图像（H×W×C）       ↓[卷积层] → 提取局部特征 → 生成特征图       ↓[激活函数 e.g. ReLU] → 引入非线性       ↓[池化层] → 降维，减少计算（如 Max Pooling）       ↓（重复多个 [卷积 → 激活 → 池化] 的组合）       ↓[展平层] → 将多维特征图展平为一维向量       ↓[全连接层] → 整合所有特征，用于分类/回归       ↓[输出层] → 输出预测结果（如类别概率）\n\n循环神经网络（Recurrent Neural Network, RNN）概述\n循环神经网络是一类专门用于处理序列数据（如时间序列、文本、语音）的神经网络。与 FNN 不同，RNN 具有记忆能力，能够利用之前的信息影响当前的输出，因此适合处理有前后依赖关系的数据。\n\n结构特点：\n\n\n\nRNN 的关键特点是：神经元之间存在循环连接（反馈连接），使得网络具有“记忆”前一时刻信息的能力；\n\n在每一时间步，RNN 接收当前输入和上一时刻的隐状态，输出当前隐状态和（可能的）输出；\n\n数学上，RNN 的隐状态更新公式大致为：$h_t$&#x3D;f(Whh**t−1+W**x$x_t$+b)$$h_t&#x3D;f(W_hh_{t-1}+W_xx_t+b)$$\n\n\n   其中 $h_t$是当前时刻的隐状态，$x_t$是当前输入，$h_t$−1是上一时刻的隐状态。\n工作原理\n循环结构（核心机制）\n\nRNN 在每一时间步接收两个输入：当前时刻的输入数据（比如一个词、一个时间点的数值）上一时刻的隐藏状态（即之前积累的信息）\n然后通过一个循环计算单元，输出：当前时刻的隐藏状态（新的记忆）当前时刻的输出（可以是预测、分类等）\n\n 这个过程在时间上是重复展开的（unrolled），形成对整个序列的处理。\n\n标准 RNN 在处理长序列时，往往会遇到梯度消失或梯度爆炸，导致难以学到远距离的依赖关系。\n\n为什么在RNN强调，在FNN和CNN力却不提及？\n\n反向传播时逐层计算的，在FNN和CNN中，每一层计算的参数不多\n但是RNN在序列上延伸，每一步是串联起来的，在反向传播时会连乘，参数越来越多。\n\n\n梯度消失\n\n定义：在反向传播过程中，梯度随着网络层数的增加变得越来越小，趋近于 0，导致深层网络的参数几乎得不到更新，模型学不动了，训练停滞。\n原因：在反向传播中，梯度是从输出层逐层反向传播到输入层的，每一层的梯度是通过链式法则相乘得到的。如果这些连乘的因子中，有很多小于 1 的数（比如激活函数导数接近 0，或权重初始化过小），那么随着层数增多，梯度就会指数级地变小，最终趋近于 0。\n\n\n梯度爆炸\n\n定义：在反向传播过程中，梯度值变得非常大，甚至无限增长（溢出），导致参数更新幅度过大，模型无法收敛，损失函数震荡甚至发散。\n原因：和梯度消失类似，连乘的因子中，有很多大于 1 的数，那么随着层数或时间步的增加，梯度就会指数级地变大，导致数值溢出或参数更新过大。\n\n\n解决策略：使用优化后的循环模型\n1. \n\n\n\n\n模型\n说明\n\n\n\nLSTM（长短期记忆网络）\n通过门控机制（输入门、遗忘门、输出门），有选择地记住或遗忘信息，能很好地捕捉长距离依赖，缓解梯度消失.\n\n\nGRU（门控循环单元）\nLSTM 的简化版，效果相当但参数更少，同样能缓解梯度问题\n\n\n\n\n\n\n\n\n工作流程输入序列↓[循环层（RNN层）] → 融合当前输入与上一时刻记忆，计算当前隐藏状态↓[激活函数 e.g. Tanh] → 引入非线性变换（将线性组合通过 tanh 压缩到 [-1, 1]，增强表达能力）↓（可选）[输出层] → 根据当前隐藏状态生成当前时刻输出（如 y_t）（例如：y_t=softmax(Vh_t+c)，用于分类或预测）→ 每个时间步可输出，也可只在最后输出↓（重复多个 [循环 → 激活 → (输出)] 的组合）依次处理x_1到 x_T，得到 h_1,...,h _T）↓[展平或直接使用隐藏状态]（可以选择使用所有隐藏状态，或仅使用最后一个h_T作为整个序列的表示）↓[全连接层（可选）] → 整合序列信息，用于最终决策（例如将h_T映射到类别空间，用于分类任务）↓[输出层] → 输出最终预测结果（如：类别概率、数值预测、序列标签等）\n\nLSTM长短期记忆网络\n核心思想\n\nLSTM 是一种特殊的 RNN，它在每个时间步不仅维护一个隐藏状态（hidden state），还维护一个细胞状态（cell state），后者可以看作是网络的“长期记忆”。LSTM 通过引入三个门结构：遗忘门（Forget Gate）、输入门（Input Gate）、输出门（Output Gate），来控制信息的保留、更新和输出，从而有效地学习长期依赖关系\n\n\nLSTM 的基本结构与变量说明\n\n在每个时间步 t，LSTM 接收当前输入 $x_t$和上一时间步的隐藏状态 $h_{t-1}$，并操作以下主要变量：\n隐藏状态（Hidden State）：$h_t$，用于传递信息到下一个时间步或输出层。\n细胞状态（Cell State）：$C_t$，相当于“记忆单元”，贯穿整个序列，承载长期信息。\n三个门控向量（都是通过 sigmoid 函数输出 0~1 的值，用于控制信息流）：\n遗忘门（Forget Gate）：决定丢弃细胞状态中的哪些信息。\n输入门（Input Gate）：决定哪些新信息需要写入细胞状态。\n输出门（Output Gate）：决定当前隐藏状态的输出内容。\n\n\n\n\n\n\n基本工作原理\n\n\n\n为了实现记忆，引入了记忆元，并通过三个门控制记忆。遗忘门控制过去的记忆的记忆程度，输入门控制当前输入对候选记忆的影响，输出门控制“真正的”记忆元对现在状态H的影响\n\n\n\n工作流程\n\n遗忘阶\n\n\n\n对上一阶段的记忆进行选择，选出重要的相关部分，遗忘无关信息\n\n使用sigmoid函数激活，取值范围[0, 1]\n\n\n\n选择记忆阶段\n\n\n对当前时刻的信息进行筛选，选出重要的部分添加到记忆中\n使用sigmoid函数激活，取值范围[0, 1]\n\n前两个阶段的输出相加，就得到了当前阶段的记忆\n\n\n输出状态\n\n\n\n记忆元先通过tanh函数缩放到[-1, 1]，然后和输出门逐元素相乘\n\n输出门越大，记忆元中的信息就会越多的保存到当前隐藏层输出中\n\n\n\n\n\nLSTM 中的各个门及其作用详解\n\n遗忘门（Forget Gate）\n作用： 控制上一时间步的细胞状态 C**t−1中的哪些信息需要被遗忘（即丢弃）。\n公式：\n\n\n\n解释：\n如果 f**t接近 0，表示遗忘该信息；接近 1 则表示保留。它决定了细胞状态 C**t−1中的哪些内容应该被保留到当前时间步。\n\n\n输入门（Input Gate）\n作用： 决定哪些新信息需要被加入到细胞状态中，即控制新内容的写入。\n公式分为两部分：\n\n\n\n解释：\n输入门与候选状态共同作用，决定哪些新信息被存储进细胞状态，实现“记忆更新”。\n\n\n输出门（Output Gate）\n作用： 控制当前时间步的**隐藏状态 *h**t***（即输出给下一层或下一时间步的内容），它基于当前的细胞状态，但经过筛选。\n\n\n\n公式：\n解释：\n输出门控制了当前细胞状态中有多少信息被暴露或传递出去，从而影响后续时间步的决策。\n\n\nLSTM 总结：门的作用回顾\n\n\n\n\n门名称\n控制目标\n作用简述\n\n\n\n遗忘门\n细胞状态中的旧信息\n决定哪些历史信息需要丢弃，解决“记忆污染”问题\n\n\n输入门\n新的候选信息\n决定哪些新信息需要被添加到记忆中，更新细胞状态\n\n\n输出门\n当前隐藏状态（输出内容）\n决定当前细胞状态中哪些信息作为输出传递给下一层\n\n\n\n\nGRU门控循环单元\n是什么\n\nGRU 是 LSTM 的一种简化版本，由 Cho 等人于 2014 年提出。GRU 同样使用门控机制来控制信息的流动，但相比 LSTM，它合并了细胞状态和隐藏状态，同时只使用了两个门：重置门（Reset Gate）和更新门（Update Gate），结构更简单，计算效率更高，在很多任务中表现与 LSTM 相当甚至更优。\n\n\nGRU 的基本结构与变量说明\nGRU 在每个时间步也接收当前输入 x**t和上一时间步的隐藏状态 h**t−1，并引入以下两个门：\n\n更新门（Update Gate）：决定保留多少旧信息，更新多少新信息（类似 LSTM 中遗忘门和输入门的组合）。\n重置门（Reset Gate）：决定如何将新的输入与历史状态结合起来，控制过去信息的“相关性”。\n\n此外，GRU 没有独立的细胞状态，而是直接更新隐藏状态 h**t。\n\n基本工作原理\n\n\n作为“简化版LSTM”，这里GRU只提出了两个门：重置门控制历史状态对当前输入的影响，更新门控制历史状态和候选信息对当前输出的影响。\n\n\n工作流程\n\n更新门\n\n\n\n\n作用： 控制前一时间步的隐藏状态中有多少信息需要被“重置”或忽略，即决定如何将新输入与历史状态结合。\n公式：\n\n（2）更新门（Update Gate）\n作用： 控制保留多少之前的隐藏状态（历史信息），以及更新多少新的候选状态（新信息）。\n公式：\n\n\n\n解释：\n更新门实际上做了 LSTM 中“遗忘门 + 输入门”的一部分工作，通过控制新旧信息的融合比例，实现状态的更新。\n\n\nGRU 总结：门的作用回顾\n\n\n\n\n门名称\n控制目标\n作用简述\n\n\n\n重置门\n历史隐藏状态\n决定如何将新输入与过去状态结合，控制历史信息的贡献度\n\n\n更新门\n新旧隐藏状态的比例\n决定保留多少旧信息，更新多少新信息\n\n\n\n\nBiLSTM双向长短期记忆网络\n基本原理\n\nBiLSTM 是在 LSTM 基础上的一种扩展，其核心思想是：同时使用两个独立的 LSTM 层，一个按正向顺序处理序列，另一个按反向顺序处理序列，最后将两个方向的隐藏状态进行合并（通常是拼接），从而让每个时间步都能同时“看到”过去和未来的信息。\n结构组成：\n正向 LSTM：按 t&#x3D;1→2→⋯→T的顺序处理序列，得到正向隐藏状态序列 h**t。\n反向 LSTM：按 t&#x3D;T→T−1→⋯→1的顺序处理序列，得到反向隐藏状态序列 h**t。\n合并策略：通常将同一时间步的正向与反向隐藏状态进行拼接（concatenate）。这样，每个时间步的表示 h**t就包含了该位置的前后文信息。\n\n\n\n\n与LSTM的对比\n1. \n\n\n\n\n对比维度\n标准 RNN\nLSTM\nBiLSTM\n\n\n\n梯度问题\n容易出现梯度消失&#x2F;爆炸，难以学习长距离依赖\n通过门控机制与细胞状态，有效缓解梯度消失，擅长长序列建模\n同 LSTM，且能利用双向上下文\n\n\n记忆能力\n几乎没有长期记忆能力\n通过细胞状态实现长期记忆的保存与更新\n同 LSTM，同时获取前后文信息\n\n\n信息利用\n仅使用当前及之前的信息（单向）\n仅使用当前及之前的信息（单向）\n同时利用当前位置的前后文信息（双向）\n\n\n序列理解能力\n弱，尤其对长文本、复杂依赖任务效果差\n强，适合处理长序列、复杂语义\n更强，对上下文语境敏感的任务效果显著提升\n\n\n应用效果\n一般，逐渐被替代\n广泛用于各类序列任务\n在需要上下文信息的任务中表现尤为出色\n\n\n\n\n\n\nTransformer 架构及其变体概述1. 是什么\n\t1. 在现代深度学习，特别是自然语言处理（NLP）和序列建模任务中，**Transformer 架构及其变体**已经成为主流模型，比如 BERT、GPT、T5 等。这些模型虽然应用广泛，但它们的核心结构都可以归类为以下三种基本架构之一：\n    \t1. Encoder-only（仅编码器）结构\n    \t2. Decoder-only（仅解码器）结构\n    \t3. Encoder-Decoder（编码器-解码器）结构\n\t2. 这三种结构本质上都来源于 Transformer 模型，它们在组件构成、信息流动方式以及适用任务上有明显区别。理解它们的差异及适用场景，对于模型选型、任务设计和算法优化至关重要。\n\n\n基本概念与结构来源\nEncoder（编码器）：负责对输入序列进行编码，提取高层次语义表示，通常由多个相同的编码层堆叠而成，每层包含多头自注意力机制和前馈网络。\nDecoder（解码器）：负责根据编码器的输出（或部分信息）逐步生成目标序列，常用于生成式任务，也包含自注意力与交叉注意力机制。\n\n\n\n注意力机制\nAttention Is All You Need\n\n\n自注意力机制（Self-Attention） \n\n是一种让模型在处理一个序列（比如一句话）时，能够自动关注这个序列中其他相关部分的机制。\n\n理解\n\n\n当模型处理某个词时，它不仅仅看这个词本身，还会“看看”这句话里的其他词，找到和它最相关的信息，从而更好地理解这个词的含义。\n.\n比如说“书”一词，他可以指书本，也可以指《尚书》。单独作为一个词时，他有自己的嵌入向量。但是他可能注意到了上下文，知道了这里应该指书本，于是嵌入向量向书本的一方偏移。这个发现上下文含义的过程就是自注意力机制。\n\n\n\n\n\n\n掩码自注意力\n\n在解码器生成token时，不能让解码器看到未来的词（就像看答案），他只能看到前面的词，并以此推理、生成token。否则就是“从答案出发”写过程了。\n\n\n交叉注意力机制\n\n是什么\n\n交叉注意力机制（Cross-Attention） 是注意力机制的一种扩展形式，它可以让一个序列（称为 Query）去关注另一个不同的序列（称为 Key 和 Value），从而实现两个序列之间的信息交互与融合。\n简单来说：\n\n交叉注意力让一组 token（比如问题、目标语言）去“查询”另一组 token（比如上下文、源语言），从而获取与之相关的信息。\n\n\n它最常用于 Transformer 的 Encoder-Decoder 架构中，尤其是在机器翻译、文本摘要、对话系统等任务里，让解码器（Decoder）能够关注编码器（Encoder）的输出，实现从源序列到目标序列的信息传递。\n\n\n\n通俗解释\n\n假设我们在进行机器翻译，任务是把一句英文翻译成中文：\n\nEncoder（编码器）：处理输入的英文句子，得到一组表示（Key 和 Value）。\nDecoder（解码器）：逐步生成中文翻译，每一步生成一个中文词。\n\n\n在生成每个中文词时，Decoder 不仅仅看已经生成的中文词（这部分用自注意力），还需要去看输入的英文句子，从中找到与当前要生成的中文词最相关的信息。 这时就需要用交叉注意力：\n\nQuery（查询）：来自 Decoder 当前要生成的词（或隐藏状态）→ 表示“我想知道什么”\nKey 和 Value（键与值）：来自 Encoder 的输出（即源语言句子的表示）→ 表示“有什么信息可供查询”\n\n\n模型会计算 Query 和 Key 的相似度，得到注意力权重，然后根据这些权重，从 Value（也就是 Encoder 的信息）中提取相关内容，帮助当前生成更准确。\n\n\n\n\n\n\nEncoder-only（仅编码器）结构\n结构组成：\n\n只有 Encoder 部分，没有 Decoder。\n输入一个序列，经过多层编码后，输出该序列的全局语义表示（上下文嵌入）。\n\n\n工作原理：\n\n输入序列通过 自注意力机制（Self-Attention） 捕捉内部各位置的关系。\n最终输出的向量可用于表示整个输入序列的语义，常用于序列理解类任务。\n\n\n典型模型：\n\nBERT\nRoBERTa、ALBERT、DistilBERT 等基于 BERT 的改进模型\n\n\n优点：\n\n能充分理解输入序列的上下文语义。\n适合不需要生成新内容，而是理解、判断、分类的任务。\n\n\n缺点：\n\n不能生成新序列，因为它没有解码器结构。\n\n\n适用场景\n1. \n\n\n\n\n任务类型\n说明\n示例\n\n\n\n文本分类\n判断文本的主题、情感、领域等\n情感分析、垃圾邮件识别\n\n\n命名实体识别（NER）\n识别文本中具有特定意义的实体\n人名、地名、机构名抽取\n\n\n问答系统（QA）\n给定上下文和问题，定位答案区间\nSQuAD 数据集任务\n\n\n句子&#x2F;文本匹配\n判断两个句子是否语义相似、相关\n语义文本相似度（STS）、复述检测\n\n\n序列标注\n对序列中每个 token 打标签\nPOS 词性标注、槽位填充（Slot Filling）\n\n\n\n\n\n\nDecoder-only（仅解码器）结构\n结构组成：\n\n只有 Decoder 部分，没有 Encoder。\n\n通常基于 掩码自注意力（Masked Self-Attention），确保在生成当前 token 时，模型只能看到当前及之前的 token，不能“偷看”未来信息。\n\n\n\n工作原理：\n\n模型根据已经生成的 token 和可能的提示（prompt &#x2F; input），一步一步地预测下一个 token，适用于自回归式生成任务。\n\n通过不断迭代，逐步生成完整的目标序列。\n\n\n\n典型模型：\n\nGPT（Generative Pre-trained Transformer）系列：GPT、GPT-2、GPT-3、GPT-4、ChatGPT\n\n虽然 GPT 是 Decoder-only，但它仍然需要对输入（即你的提示词 &#x2F; Prompt）进行编码（Embedding）和上下文建模，只不过：\n\n它使用的是 Transformer 的 Decoder 结构，而不是 Encoder。\n它对输入也进行Token 嵌入（Embedding） + 位置编码，和 Encoder 做的事情类似。\n它使用的是 掩码自注意力（Masked Self-Attention），确保在处理第 i 个词时，只能看到第 1 到 i-1 个词（不能偷看后面）。\n\n 也就是说：GPT 把你的提示词当作一个“序列”输入到 Decoder 中，通过自注意力机制对它们进行编码和理解，然后基于此生成后续内容。\n\n\n\n问题\n答案\n\n\n\nGPT 是不是不编码提示词？\n不是！它对提示词也进行了编码（嵌入 + 注意力），只是没有专门的 Encoder 模块。\n\n\n为什么是 Decoder-only？\n因为 GPT是生成式模型，只用 Decoder 就能同时完成“理解输入 + 生成输出”，不需要分离的 Encoder。\n\n\n它怎么理解我的输入（Prompt）？\n把输入当作一个序列，通过 Decoder 的自注意力机制进行编码和建模，再基于此生成后续内容。\n\n\n为什么不用 Encoder-Decoder？\n为了简化结构、提升效率、统一训练与推理流程，GPT 选择仅用 Decoder 实现理解与生成\n\n\n\n\nLLaMA、Falcon、Mistral 等大语言模型（LLMs）\n\n\n\n适用任务（生成类任务）：\n\n\n\n\n\n任务类型\n说明\n示例\n\n\n\n文本生成\n根据提示生成连贯的文本内容\n文章生成、故事创作、对话生成\n\n\n代码生成\n根据注释或需求生成程序代码\nGitHub Copilot、CodeX\n\n\n对话系统（Chatbot）\n与用户进行多轮自然语言交互\n智能客服、虚拟助手\n\n\n机器翻译（部分实现）\n根据源语言生成目标语言（若输入已嵌入提示）\n简单翻译任务\n\n\n摘要生成\n根据输入文本生成简洁摘要\n新闻摘要、会议纪要\n\n\n\n优点：\n\n擅长生成连贯、上下文相关的文本。\n\n模型结构简单，推理时只需 decoder，计算效率高（相对 encoder-decoder）。\n\n\n\n缺点：\n\n缺乏显式的编码器结构，对复杂输入的结构化理解能力较弱（不过通过 prompt engineering 可部分弥补）。\n\n对需要同时理解输入 + 生成输出的任务（如翻译、问答），不如 encoder-decoder 灵活。\n\n\n\n\nEncoder-Decoder（编码器-解码器）结构\n结构组成：\n\n包含完整的 Encoder 和 Decoder 两部分，两者通过**交叉注意力机制（Cross-Attention）**相连。\n\nEncoder 负责理解输入序列，Decoder 负责基于编码信息生成目标序列。\n\n\n\n工作原理：\n\n输入序列（如源语言句子）通过 Encoder 编码成一个或多个上下文向量。\n\nDecoder 在生成目标序列（如目标语言句子）时，通过交叉注意力机制关注 Encoder 的输出，从而实现输入到输出的信息映射。\n\n\n\n典型模型：\n\nTransformer（原始论文模型）\n\nT5（Text-To-Text Transfer Transformer）\n\nBART（Bidirectional and Auto-Regressive Transformer）\n\nmBART、PEGASUS 等\n\n\n\n适用任务（理解 + 生成类 &#x2F; 序列到序列任务）：\n\n\n\n\n\n任务类型\n说明\n示例\n\n\n\n机器翻译（Machine Translation）\n源语言 → 目标语言\n英文 → 中文翻译\n\n\n文本摘要（Text Summarization）\n长文本 → 摘要\n新闻摘要生成\n\n\n问答系统（问答生成）\n问题 + 上下文 → 答案文本\n开放域问答\n\n\n对话生成（多轮生成）\n用户输入 → 系统回复\n多轮对话系统\n\n\n语音转文本后再生成（ASR + TTS）\n语音 → 中间表示 → 自然语言\n语音问答系统\n\n\n图像描述生成（Image Captioning）\n图像特征 → 描述文本\nAI 看图说话\n\n\n\n优点：\n\n同时具备强大的理解能力（Encoder）和生成能力（Decoder）。\n\n适合处理输入与输出均为序列，且两者结构&#x2F;语义均较复杂的任务。\n\n\n\n缺点：\n\n模型结构更复杂，训练成本更高。\n\n推理时需要同时运行 encoder 和 decoder，计算开销较大。\n\n\n\n\n序列生成任务评价指标\nBLEU \n\n是最经典、最广泛使用的机器翻译评价指标，由 IBM 研究者在 2002 年提出。它通过比较模型生成的译文（Candidate）与一个或多个参考译文（Reference）之间的 n-gram 匹配程度，来衡量生成结果的质量。\n\n\n 核心思想： 生成文本与参考文本在 n-gram（如 1~4 个词连续组合）层面越匹配，BLEU 分数越高，说明生成质量越好。\n\n\n计算方法（简化版）：BLEU 的计算主要包括两个部分：\n\nn-gram 精度（Precision）\n\n统计生成文本中每个 n-gram（比如 1-gram: 单词，2-gram: 词对，…）出现的次数，\n并计算这些 n-gram 在参考译文中也出现了多少次，取最小值（避免夸大），\n最终对多个 n（通常为 1~4）做加权平均。\n\n\nBP（Brevity Penalty，长度惩罚）\n\n如果生成的句子比参考句子短太多，即使 n-gram 匹配很高，也会扣分。\n\n\n\n\n适用场景\n\n\n\n任务类型\n是否适用\n原因\n\n\n\n机器翻译\n非常常用\n标准评价指标，广泛用于 MT 任务（如 WMT 比赛）\n\n\n文本摘要\n可用\n但更推荐 ROUGE（见下）\n\n\n对话生成 &#x2F; 问答\n一般\n对语义要求高，BLEU 对词面匹配敏感，不太关注语义正确性\n\n\n代码生成\n不适用\n代码不是自然语言，要用 CodeBLEU（见下）\n\n\n 优点： 客观、可复现、与人工评价有一定相关性\n 缺点： 只看词面 n-gram 匹配，不关心语义、词序灵活性、同义词替换等\n\n\n\nCodeBLEU（针对代码生成任务）\n\n概述\nCodeBLEU 是在 BLEU 基础上，为代码生成任务（如自动编程、代码补全、SQL 生成等） 设计的改进评价指标，由华为研究者提出。\n\n\n\n\n代码 ≠ 自然语言，不能只看词频匹配！CodeBLEU 综合考虑了：\n\nToken 级 BLEU（词法层面）\n语法树结构（AST，Abstract Syntax Tree）相似度\n数据流信息\n代码功能正确性（可选，需额外工具）\n\n\n\n\n计算思路（简化）\n\nCodeBLEU 分数通常是几部分的加权组合：$$CodeBLEU&#x3D;w_1⋅BLEU+w_2⋅AST+w_3⋅Dataflow+…$$\n\nBLEU：普通词法 n-gram 匹配\nAST：抽象语法树匹配（代码结构是否相似）\nDataflow：变量使用、控制流等是否合理\n不同任务可调整权重\n\n\n\n适用场景\n\n\n\n\n任务类型\n是否适用\n原因\n\n\n\n代码生成 &#x2F; 补全 &#x2F; 翻译\n✅ 推荐\n比 BLEU 更适合代码，综合语法与结构信息\n\n\n自然语言生成\n❌ 不适用\n是为代码任务定制的\n\n\n优点： 更贴近代码语义与结构，评价更准确\n缺点： 实现复杂，依赖语法树等工具\n\nROUGE（Recall-Oriented Understudy for Gisting Evaluation）\n\n概述\n\n\n   ROUGE 是用于文本摘要（Text Summarization）任务的主要评价指标，由 Lin 等人提出。它侧重于衡量生成摘要与参考摘要之间的词重叠度（尤其是召回率）。\n\n与 BLEU 不同，ROUGE 更关注生成内容是否覆盖了参考中的重要信息（词、短语、n-gram）。\n\n\n\n常见变体\n\n\n\n\n指标\n说明\n\n\n\nROUGE-N\nN-gram 重叠（如 ROUGE-1：单词；ROUGE-2：词对）\n\n\nROUGE-L\n基于最长公共子序列（LCS），衡量生成与参考之间的最佳匹配顺序\n\n\nROUGE-S &#x2F; ROUGE-W\n基于跳跃 n-gram 或加权匹配\n\n\n\n\n适用场景\n\n\n\n\n任务类型\n是否适用\n原因\n\n\n\n文本摘要\n主流指标\n重点看是否涵盖关键信息\n\n\n机器翻译\n可用但非主流\n一般更偏向 BLEU\n\n\n问答 &#x2F; 对话\n可尝试\n但通常不用作主要指标\n\n\n   优点： 更关注内容覆盖，对词序相对宽容\n   缺点： 仍基于词面匹配，不涉及深层语义\n\nMETEOR（Metric for Evaluation of Translation with Explicit ORdering）\n\n简介\n\nMETEOR 是一种兼顾精确率、召回率、词义相似性、词序的评价指标，由 Banerjee &amp; Lavie 提出，目标是更贴近人工评价。\n\n它不仅看词是否出现，还考虑了：\n\n同义词匹配（通过 WordNet）\n词干还原（stemming）\n词序与句法结构\n精确率 + 召回率的调和\n\n\n\n\n计算思路（简化）: METEOR 分数综合考虑：\n\n匹配的 unigrams（词）数量\n\n是否同义词 &#x2F; 词干相同\n\n词序信息\n\n使用 F-mean（精确率与召回率的加权调和）\n\n\n\n\n\n\n适用场景\n\n\n\n\n任务类型\n是否适用\n原因\n\n\n\n机器翻译\n✅ 推荐（比 BLEU 更接近人工）\n更关注语义相似性\n\n\n文本生成 &#x2F; 摘要\n✅ 可用\n对语义更友好\n\n\n代码 &#x2F; 对话\n⚠️ 较少用\n不是主流\n\n\n优点： 更接近人工判断，考虑同义词与词序\n缺点： 计算复杂，使用不如 BLEU 广泛\n\n\n⽣成式对抗⽹络（GAN）概述\n是什么\n\n生成式对抗网络（Generative Adversarial Network，GAN）由生成器（Generator）和判别器（Discriminator）这两个核心部分组成，二者通过对抗博弈的方式进行训练，以提升各自的性能。\n基本结构\n生成器（Generator）功能：生成器的任务是学习从一个潜在空间到目标数据分布的映射。简单来说，就是根据随机输入的噪声向量 z，生成尽可能逼真的数据样本，这些数据样本与真实数据分布相似。\n结构：一般由多层神经网络构成，常见的如多层全连接网络或者卷积神经网络（在处理图像等数据时）。\n例如，在图像生成任务中，生成器可能是一个反卷积神经网络（也称为转置卷积网络），它可以将低维的噪声向量逐步转换为高维的图像数据。\n\n\n判别器（Discriminator）功能：判别器的作用是区分输入的数据是来自真实数据分布还是由生成器生成的假数据。它接收真实数据样本和生成器生成的假数据样本作为输入，然后输出一个概率值，表示输入数据是真实数据的可能性。\n结构：同样由多层神经网络组成，其结构与生成器类似，但在设计上更侧重于对数据的特征提取和分类能力。\n例如，在图像判别任务中，判别器也是一个卷积神经网络，通过对图像的特征提取和分析，判断图像的真实性。\n\n\n\n\n生成器和判别器以对抗的方式进行交互，生成器试图生成能够欺骗判别器的假数据，而判别器则努力准确区分真实数据和假数据，二者在不断的博弈过程中逐渐提升性能，是为对抗\n\n\n工作原理\n\n目标：GAN 的训练过程是一个迭代优化的过程，目标是找到生成器和判别器的最优参数，使得生成器能够生成与真实数据分布高度相似的数据，同时判别器难以区分真实数据和生成器生成的数据。其训练过程主要基于一个极小极大博弈的目标函数。\n\n$$\\min_{G}\\max_{D}V(D,G)&#x3D;E_{x∼pdata(x)}[logD(x)]+E_{z∼pz(z)}[log(1−D(G(z)))]$$\n\n等式左侧：即要求只考虑D的情况下，最大化损失函数（以便判别器更好的区分），然后再只考虑G的情况下，最小化损失函数（以便生成器更好的拟合）。\n\n\n\n工作步骤：\n\n训练步骤初始化：随机初始化生成器 G和判别器 D的参数。\n训练判别器：固定生成器的参数，通过优化判别器的参数，使其能够更好地区分真实数据和生成器生成的假数据。\n训练生成器：固定判别器的参数，通过优化生成器的参数，使其生成的数据能够更有效地欺骗判别器。\n迭代训练：重复步骤 2 和步骤 3，不断交替训练判别器和生成器，直到达到预设的训练轮数或者满足一定的收敛条件。\n\n\n\n\n\nWasserstein GAN（WGAN）\n核心区别：损失函数不同。\n\n传统GAN使用的是JS散度（Jensen - Shannon散度）来衡量真实数据分布 Pr和生成数据分布 Pg之间的差异，JS散度衡量的是 两个分布 *P*和 *Q*有多“不同”，数值越小，说明两个分布越相似。其判别器的目标是最大化如下目标函数：\n\n$$V(D,G) &#x3D; {E}{x \\sim P_r}[\\log D(x)] + {E}{x \\sim P_g}[\\log(1 - D(x))]$$\n\n\nWGAN使用Wasserstein距离（也称为推土机距离）来衡量两个分布之间的差异。Wasserstein距离定义为：$W(P_r, P_g) &#x3D; \\inf_{\\gamma \\in \\Pi(P_r, P_g)} \\mathbb{E}_{(x,y) \\sim \\gamma}[|x - y|]$，即把真实分布 Pr的数据“移动”成生成分布 Pg的数据所需的最小“成本”，这里的“成本”是样本间的欧氏距离 ∥x−y∥。判别器目标是最大化这个函数： \n\n$$L &#x3D; {E}{x \\sim P_r}[D(x)] - {E}{x \\sim P_g}[D(x)]$$\n\n\n\n\n由此引出的差异\n1. \n\n\n\n\n对比维度\n传统GAN\nWasserstein GAN (WGAN)\n\n\n\n分布差异度量\nJS散度：当真实分布 P**r和生成分布 P**g不重叠时，退化为常数 log2，导致梯度消失\nWasserstein距离：即使分布不重叠，仍能提供有意义的梯度，反映分布间的“平移距离”\n\n\n训练稳定性\n极不稳定： - 判别器过强时，生成器梯度消失（JS散度为常数） - 容易出现模式崩溃（生成单一模式样本）\n更稳定： - Wasserstein距离提供平滑梯度 - 判别器（Critic）不会过强，生成器持续学习\n\n\n模式崩溃问题\n常见： - 生成器可能只生成少数几种样本（陷入局部最优）\n缓解： - 更稳定的训练使生成器能覆盖更多数据模式\n\n\n判别器&#x2F;Critic设计\n判别器输出概率（0~1），使用Sigmoid激活函数\nCritic输出实数（无Sigmoid），不直接预测概率\n\n\n额外技术要求\n无特殊约束\n需保证Critic的Lipschitz连续性（通常通过权重裁剪或梯度惩罚实现）\n\n\n\n\n\n\n条件⽣成式对抗⽹络（Conditional GAN，cGAN）\n核心思想\n\n传统的GAN（如原始GAN、DCGAN等）生成的样本是无条件的（unconditional），即生成器（Generator）随机生成数据，无法控制生成内容的属性（如生成特定类别的图像、特定风格的文本等）。\n\ncGAN 的核心思想是将条件信息（condition）同时输入生成器和判别器，使它们在训练时都“知道”要生成或判断什么内容。例如：\n\n在图像生成任务中，可以控制生成特定类别的图像（如“生成一张猫的图片”）。\n\n在文本生成任务中，可以控制生成符合特定主题的句子（如“生成一篇关于AI的短文”）。\n\n\n\n\n\n结构\n\n生成器：输入 &#x3D; 随机噪声向量 *z*+ 条件信息 *c*输出 &#x3D; 符合条件 *c*的生成数据（如图像、文本等）（例如，c可以是类别标签、文本描述、用户指定的属性等）\n判别器：输入 &#x3D; 真实数据（或生成数据） + 条件信息 *c*输出 &#x3D; 判断该数据是否真实（且是否符合条件 *c*）\n数学目标函数（cGAN的损失函数）：\n\n\n\n$$\\min_{G}\\max_{D}V(D,G)&#x3D;E_{x∼pdata(x)}[logD(x|c)]+E_{z∼pz(z)}[log(1−D(G(z|c)|c))]$$\n（即判别器要区分真实数据+条件和生成数据+条件，生成器要欺骗判别器）\n\n实现方式\n\n条件信息 *c*的形式：\n类别标签（Class Label）：如MNIST手写数字分类（0~9），生成器输入“生成数字3”。\n文本描述（Text Description）：如用自然语言描述生成图像（如“一只红色的猫”）。\n用户指定属性（Attributes）：如生成特定发型、肤色的人脸图像。\n\n\n如何输入条件 *c*：\n直接拼接（Concatenation）：将 c和 z拼接后输入生成器（最简单的方式）。\n嵌入（Embedding）：如果 c是离散的（如类别标签），先将其转换为嵌入向量（embedding），再与噪声 z结合。\n条件批归一化（Conditional BatchNorm）：在生成器中使用条件信息调整批归一化层的参数。**\n\n\n\n\n典型应用\n\n图像生成：如条件MNIST（生成特定数字）、条件CelebA（生成特定属性的人脸）。\n\n图像翻译（Image-to-Image Translation）：如将黑白图像着色、将草图生成真实图像（Pix2Pix）。\n\n文本到图像生成（Text-to-Image）：如根据文字描述生成对应图像（StackGAN、AttnGAN）。\n\n\n\n\n可控生成（Controllable Generation）\n基本思想\n\n可控生成（Controllable Generation） 是比cGAN更广泛的概念，它指的是让生成模型能够按照用户指定的多种控制条件生成数据，而不仅仅是简单的类别标签。\n\ncGAN 是可控生成的一种特例（控制条件通常是类别标签或简单属性）。\n\n更高级的可控生成 可以控制： 多个属性（Multi-Attribute Control）：如生成“戴眼镜、棕色头发、微笑的女性人脸”。 连续控制（Continuous Control）：如调节生成图像的“亮度、风格强度、人脸年龄”等。 交互式控制（Interactive Control）：如用户实时调整生成参数（如GANpaint、StyleGAN的潜空间控制）。\n\n\n\n\n\n实现方法\n\n基于cGAN的扩展\n\n多条件输入（Multiple Conditions）： 例如，生成人脸时，同时输入性别、年龄、发型、表情等多个条件。\n\n条件嵌入（Condition Embedding）： 如果条件是文本或复杂属性，先将其编码为向量（如用BERT、MLP），再输入生成器。\n\n\n\n潜空间控制（Latent Space Manipulation）\n\nGAN的潜空间（Latent Space） 是一个高维向量 z，生成器通过 z生成数据。\n\n可控生成的关键：找到潜空间中哪些维度控制哪些属性（如“第10维控制微笑，第20维控制头发颜色”）。\n\n方法： 线性插值（Linear Interpolation）：在潜空间中调整某些维度，观察生成数据的变化。 属性解耦（Disentangled Representation Learning）：让潜空间的不同维度控制不同属性（如StyleGAN、β-VAE）。 潜空间优化（Latent Optimization）：通过优化算法（如梯度下降）调整 z，使生成结果符合用户要求。\n\n\n\n条件批归一化 &amp; 注意力机制\n\n条件批归一化（Conditional BatchNorm）：让生成器的不同层根据条件调整特征。\n\n注意力机制（Attention）：让生成器聚焦于特定区域（如文本到图像生成时，让模型关注描述的物体）。\n\n\n\n\n\n典型应用\n\n文本到图像生成（Text-to-Image）：如 DALL·E、Stable Diffusion（根据文字生成图像）。\n\n图像编辑（Image Editing）：如 GANpaint（修改生成图像的局部区域）。\n\n人脸生成 &amp; 控制：如 StyleGAN（控制年龄、姿势、表情）。\n\n音乐&#x2F;视频生成：如 根据用户输入生成特定风格的音乐或视频。\n\n\n\n\ncGAN vs. 可控生成（对比总结）\n\n\n\n\n\n\n特性\nConditional GAN (cGAN)\n可控生成（Controllable Generation）\n\n\n\n控制方式\n通常基于单一条件（如类别标签）\n可以基于多条件、连续控制、交互式控制\n\n\n输入条件\n类别标签、文本、简单属性\n多属性、潜空间调节、用户交互\n\n\n典型方法\ncGAN（条件输入+判别器）\n潜空间控制、注意力机制、条件批归一化\n\n\n应用场景\n生成特定类别的图像&#x2F;文本\n精细控制生成内容（如人脸属性、风格强度）\n\n\n代表模型\nPix2Pix、AC-GAN\nStyleGAN、DALL·E、GANpaint\n\n\n强化学习（Reinforcement Learning）\n在网上看到的用AI来玩游戏的就属于强化学习了\n\n概述\n是什么\n\n强化学习是一种通过智能体（Agent）与环境（Environment）交互来学习最优策略（Policy）的学习范式，其核心目标是让智能体在动态环境中采取一系列行动（Actions），以最大化长期累积奖励（Rewards）。\n\n核心结构：强化学习的核心要素可以概括为 5 个关键组成部分，它们共同构成了RL的基本框架：\n\n智能体（Agent）\n\n定义：智能体是执行动作的决策者（如机器人、游戏玩家、算法等）。\n作用：观察环境状态，选择动作，并通过与环境交互学习最优策略。\n示例：在围棋游戏中，智能体就是下棋的AI（如AlphaGo）；在自动驾驶中，智能体就是控制车辆的决策系统。\n\n\n环境（Environment）\n\n定义：环境是智能体所处的外部世界，它接收智能体的动作并返回新的状态和奖励。\n\n作用：动态响应智能体的行为，并提供反馈（状态和奖励）。\n\n示例：在机器人控制中，环境可能是物理世界；在游戏中，环境可能是游戏规则和虚拟世界。\n\n\n\n状态（State, S）\n\n定义：状态是环境在某一时刻的描述，包含了智能体做出决策所需的所有信息。\n\n特点：在马尔可夫决策过程（MDP）中，当前状态包含了历史信息（马尔可夫性），即未来只依赖于当前状态，而与过去无关。\n\n示例： 在围棋中，状态可以是棋盘的当前布局。 在自动驾驶中，状态可以是车辆的速度、位置、周围障碍物等。\n\n\n\n动作（Action, A）\n\n定义：动作是智能体在某个状态下可以采取的行为。\n\n特点：动作空间（Action Space）可以是离散的（如“左转、右转、直行”）或连续的（如“方向盘角度 0~360°”）。\n\n示例： 在游戏中，动作可能是“向上移动、攻击、跳跃”。 在机器人控制中，动作可能是“移动左腿、施加力矩”。\n\n\n\n奖励（Reward, R）\n\n定义：奖励是环境在智能体采取某个动作后返回的即时反馈信号，用于衡量该动作的好坏。\n\n特点：奖励通常是标量（正、负或零），智能体的目标是最大化长期累积奖励。\n\n示例： 在围棋中，胜利可能获得 +1 奖励，失败获得 -1 奖励。 在机器人导航中，到达目标位置可能获得 +10 奖励，撞墙可能获得 -5 奖励。\n\n\n\n\n\n\n\n工作原理\n\n强化学习的基本流程\n\n智能体（Agent） 观察当前环境状态（State）。\n智能体 根据策略（Policy）选择一个动作（Action）。\n环境（Environment） 接收动作并转移到新的状态，同时返回一个奖励（Reward）。\n智能体 根据新的状态和奖励，更新策略，以在未来获得更高的累积奖励。\n\n\n这一过程不断循环，形成一个马尔可夫决策过程（Markov Decision Process, MDP）。\n\n\n\n\n强化学习的交互过程\n\n\n强化学习的交互过程可以用 马尔可夫决策过程（MDP） 来形式化描述，其核心要素包括：\n\n\n\n符号\n含义\n说明\n\n\n\nS\n状态空间（State Space）\n所有可能的状态集合\n\n\nA\n动作空间（Action Space）\n所有可能的动作集合\n\n\nP(s’, s, a)\n状态转移概率（Transition Probability）\n在状态 s下采取动作 a并转移到状态 s′的概率\n\n\nR(s,a,s′)\n奖励函数（Reward Function）\n在状态 s下采取动作 a并转移到状态 s′后获得的即时奖励\n\n\nγ\n折扣因子（Discount Factor）\n用于权衡短期和长期奖励（0 ≤ γ ≤ 1）\n\n\n\n马尔可夫性（Markov Property）\n\n定义：未来状态 st+1只依赖于当前状态 st和当前动作 at，而与过去的状态和动作无关。\n\n数学表达：\nP(st+1∣st,at,st−1,at−1,…)=P(st+1∣st,at)\n\n\n智能体的目标\n\n智能体的目标是找到一个最优策略（Optimal Policy） π∗(a∣s)，使得在长期内获得的累积奖励（Return） 最大化。\n累积奖励（Return, Gt）：\n\nGt=Rt+1+γRt+2+γ2Rt+3+⋯=k=0∑∞γkRt+k+1\n\n（γ是折扣因子，用于平衡短期和长期奖励）\n\n策略（Policy, π）： 策略是智能体在某个状态 s下选择动作 a的规则。 可以是 确定性策略（a&#x3D;π(s)）或 随机性策略（π(a∣s)表示在状态 s下选择动作 a的概率）。\n\n目标：找到最优策略 π∗，使得 长期累积奖励 Gt最大化：\n\n\nπ∗=argπmaxEπ[k=0∑∞γkRt+k+1]\n\n\n\n强化学习的核心挑战\n\n探索与利用（Exploration vs. Exploitation） 探索：尝试新的动作，发现可能更好的策略。 利用：选择已知能获得高奖励的动作。 挑战：如何在探索新策略和利用已知策略之间取得平衡？\n\n延迟奖励（Delayed Reward） 智能体的某些动作可能不会立即获得奖励，而是影响未来的长期奖励。 挑战：如何让智能体学会考虑长期影响，而不仅仅是短期奖励？\n\n高维状态与动作空间（High-Dimensional Spaces） 在复杂任务（如机器人控制、游戏AI）中，状态和动作空间可能非常大甚至连续。 挑战：如何高效地搜索最优策略？\n\n\n\n\n\n\n强化学习的典型算法（简要提及）\n\n\n\n\n算法类型\n代表算法\n特点\n\n\n\n值函数方法（Value-Based）\nQ-Learning、Deep Q-Network (DQN)\n学习状态-动作值函数 Q(s,a)，选择最大 Q值的动作\n\n\n策略梯度方法（Policy-Based）\nREINFORCE、Proximal Policy Optimization (PPO)\n直接优化策略 (\\pi(a\n\n\nActor-Critic 方法\nA2C、A3C、SAC\n结合值函数和策略梯度，兼顾稳定性和灵活性\n\n\n基于模型的方法（Model-Based）\nDyna-Q\n学习环境模型，用于预测未来状态和奖励\n\n\nActor-Critic方法\nActor-Critic方法的基本思想\n\nActor-Critic（演员-评论家） 是强化学习中一类重要的 结合值函数（Value Function）和策略（Policy） 的方法，它综合了 值函数方法和策略梯度方法 的优点，旨在 更高效、更稳定地学习最优策略。\n\n\n核心概念\n\nActor（演员）： 负责策略，即根据当前状态选择动作。 通常是一个 策略网络（Policy Network），输出动作的概率分布（在随机策略中）或直接输出动作（在确定性策略中）。 目标：学习一个 最优策略 π(a∣s)，使得长期累积奖励最大化。\n\nCritic（评论家）： 负责评估，即评估当前状态或状态-动作对的价值（如状态值函数 V(s)或动作值函数 Q(s,a)）。 通常是一个 值函数网络（Value Network），用于估计 当前策略下的长期回报。 目标：评估 Actor 选择的动作有多好，并提供 改进策略的信号（如TD误差）。\n\n\n\n为什么需要Actor-Critic？\n\n纯策略梯度方法： 直接优化策略，但 方差大（高方差梯度估计），训练不稳定。\n\n纯值函数方法： 适用于离散动作空间，但在 连续动作空间中难以直接优化策略。\n\nActor-Critic： Actor 负责探索（选择动作），Critic 负责评估（指导Actor改进）。 结合策略梯度和值函数估计，降低方差，提高训练稳定性。\n\n\n\n训练过程\n\nActor-Critic 方法的核心是 Actor 和 Critic 同时学习：\n\nActor 学习 策略 π(a∣s)（如何选择动作）。\n\nCritic 学习 值函数 V(s)或 Q(s,a)（如何评估动作的好坏）。\n\n\n\n基本流程\n\nActor 根据当前状态 st选择一个动作 at（基于策略 π(a∣s)）。\n环境 接收动作 at，返回下一个状态 st+1和奖励 rt。\nCritic 计算 TD误差（Temporal Difference Error） 或 值函数误差，用于评估当前动作的好坏。\nCritic 更新值函数（如 V(s)或 Q(s,a)），提供更准确的评估。\nActor 根据 Critic 的反馈（如TD误差） 更新策略（如调整动作选择概率）。\n循环：不断重复上述过程，直到策略收敛。\n\n\n\n\n关键组件\n\nCritic 的值函数（Value Function）：Critic 通常学习以下两种值函数之一：\n\n状态值函数 V(s)：\n\n估计在状态 s下，遵循当前策略 π的长期回报。\n\nTD误差（Temporal Difference Error）：\nδt=rt+γV(st+1)−V(st)\n\n（γ是折扣因子，rt是即时奖励，V(st+1)是下一状态的值）\n\n\n\n动作值函数 Q(s,a)：\n\n估计在状态 s下采取动作 a的长期回报。\n\nTD误差：\nδt=rt+γQ(st+1,at+1)−Q(st,at)\n\n\n\n\nActor 的策略（Policy）\n\n策略 π(a∣s) 可以是 随机策略（概率分布） 或 确定性策略（直接输出动作）。\n\nActor 的更新 通常基于 Critic 提供的TD误差 δt，例如：\n\n策略梯度更新（适用于随机策略）：\n∇θJ(θ)≈E[δt⋅∇θlogπθ(at∣st)]\n\n（θ是策略网络的参数，δt是Critic提供的TD误差）\n\n确定性策略梯度（如DDPG）：适用于连续动作空间。\n\n\n\n\n\n\n\nActor-Critic方法的优点\n\n结合策略梯度和值函数： 策略梯度方法（Actor） 直接优化策略，但方差大。 值函数方法（Critic） 提供更稳定的评估信号，降低方差。\n适用于连续动作空间（如机器人控制）。\n比纯策略梯度方法更稳定（Critic 提供TD误差指导）。\n比纯值函数方法（如Q-Learning）更灵活（适用于连续动作）。\n\n\n\n强化学习在生成模型中的潜在应用\n核心思想\n\n将生成过程视为序列决策问题，用强化学习（RL）的奖励信号直接优化生成结果（如文本质量、图像美观度等），弥补传统方法（如最大似然）只能优化局部目标的不足。\n\n\n典型应用与实例\n\n文本生成（如翻译、对话、故事）\n\n问题：传统模型（如NLP）倾向生成“安全但平淡”的文本（追求单词语义正确，而非整体质量）。\n\nRL作用：用全局奖励（如BLEU分数、用户满意度）优化生成策略，提升连贯性&#x2F;创意性。\n\n实例：谷歌机器翻译引入RL优化BLEU；对话系统优化回复质量。\n\n\n\n图像生成（如文本到图像、艺术创作）\n\n问题：生成图像需匹配复杂条件（如文本描述），传统方法难直接优化匹配度。\n\nRL作用：通过奖励（如图像-文本对齐度、美学评分）指导生成，提升细节与相关性。\n\n实例：AttnGAN结合RL优化图像与文本匹配；艺术生成追求风格一致性。\n\n\n\n分子&#x2F;药物设计（生成功能性分子）\n\n问题：需生成具有特定性质（如药效、稳定性）的分子结构。\n\nRL作用：以分子性质（如生物活性、毒性）为奖励，指导分子图逐步构建。\n\n实例：RL生成高药物相似性分子（优化QED&#x2F;LogP指标）。\n\n\n\n游戏&#x2F;虚拟内容生成\n\n问题：自动生成游戏关卡&#x2F;地图需平衡难度与趣味性。\n\nRL作用：以玩家体验（如挑战性、探索性）为奖励，优化内容设计。\n\n实例：RL生成Mario&#x2F;Doom游戏关卡。\n\n\n\n\n\n常用RL方法\n\n策略梯度（如REINFORCE）：直接优化生成策略（适合文本&#x2F;分子）。\nActor-Critic：结合策略与值函数，更稳定（适合图像&#x2F;复杂生成）。\n奖励驱动：用外部指标（BLEU、化学性质、用户反馈）定义奖励。\n\n\n核心优势\n\n优化复杂目标（如美学、功能性、用户偏好）\n\n适配序列生成任务（文本&#x2F;图像&#x2F;分子逐步构建）\n\n灵活设计奖励信号（模拟&#x2F;人工&#x2F;仿真反馈）\n\n\n\n\n","categories":["课业"]},{"title":"毛概复习","url":"/2024/12/04/%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/","content":"导论马克思主义中国化时代化的内涵（3点）***\n运用马克思主义的基本理论来指导我国的革命和建设：运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。\n\n例子：例如，在新民主主义革命时期，马克思主义帮助中国共产党明确了中国社会的主要矛盾和革命任务，而在改革开放过程中，马克思主义为中国特色社会主义道路的选择提供了理论指导，提出了“发展是硬道理”的理念，为中国的快速发展指明了方向。\n\n\n把中国革命和建设中的经验上升为理论：总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。\n\n例子：如邓小平理论、三个代表重要思想、科学发展观等，都是在总结历史经验的基础上形成的新的理论，这些理论帮助我们把握了社会主义发展的规律，推动了中国特色社会主义事业的发展。\n\n\n把中国传统文化与马克思主义结合起来：运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其根植于中华优秀传统文化的土壤之中，具有中国特色、中国风格、中国气派。\n\n例子：例如，习近平新时代中国特色社会主义思想就体现了这一点，特别是在推动中华民族伟大复兴的过程中，提出了“文化自信”，强调中国传统文化在现代社会中的重要作用，提倡从中国传统文化中汲取智慧，在马克思主义理论的指导下构建现代化的社会主义国家。\n\n\n\n马克思主义中国化的理论成果及其关系\n成果：\n毛泽东思想\n邓小平理论\n“三个代表”重要思想\n科学发展观\n习近平新时代中国特色社会主义理论\n\n\n关系：马克思主义中国化时代化的理论成果是一脉相承又与时俱进的关系。\n一方面，毛泽东思想所蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系提供了基本遵循。\n另一方面，中国特色社会主义理论体系在新的历史条件下进一步丰富和发展了毛泽东思想。\n\n\n\n第一章毛泽东思想的主要内容 （6点）\n新民主主义革命理论：基本点一是认为中国资产阶级分为大资产阶级和民族资产阶级，二是认为中国革命只能以长期的武装斗争为主要形式。\n\n社会主义革命和社会主义建设理论：将马克思主义基本原理同中国国情”第二次结合“，是对如何进行社会主义革命和建设的具体指引\n\n革命军队建设和军事战略的理论：规定了党对军队的绝对领导的原则。\n\n政策和策略的理论：指出政策和策略是党的生命，必须根据政治形势、阶级关系和实际情况及其变化制定党的政策。\n\n思想政治工作和文化工作的理论：思想政治工作是一切工作的生命线。要实行政治与经济、技术统一的方针，要发展民族的科学的大众的文化。\n\n党的建设理论：注重思想建党、理论强党，是我们党的鲜明特色和光荣传统。\n\n\n毛泽东思想的活的灵魂（3点）***\n实事求是：是毛泽东思想的基本点，是毛泽东思想的精髓。实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。\n\n例如，毛泽东在土地改革和农村革命中，依据中国当时的社会结构和农民的实际情况，提出了有针对性的政策，实施了“打土豪分田地”，取得了广泛的支持。\n\n\n群众路线：毛泽东指出：“群众观点是共产党员革命的出发点和归宿。”群众路线是党在实际工作中形成的一套从群众中来、到群众中去的领导方法和工作方法。\n\n例如，在抗日战争时期，党通过组织广泛的人民抗战运动，发动了大量的群众力量，取得了战争的胜利。在土地改革时期，毛泽东依靠农民的力量开展了广泛的土地革命，改变了农村的阶级结构。\n\n\n独立自主：是中华民族的优良传统，是中国共产党、中华人民共和国立党立国的重要原则，是我们党从中国实际出发、依靠党和人民力量进行革命、建设、改革的必然结论。\n\n毛泽东在中国革命过程中始终坚持独立自主，不依赖外部势力的帮助，特别是在抗日战争期间，中国共产党通过坚持独立自主的道路，不仅赢得了战争的胜利，也奠定了党在国内外的威信。在建国后，毛泽东提出的“自力更生”政策，尤其体现在经济发展和外交战略上。\n\n\n\n第二章新民主主义革命的总路线（4点）\n内容：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。\n革命的对象：近代中国社会的性质和主要矛盾，决定了中国革命的主要敌人是帝国主义、封建主义和官僚资本主义。（三座大山）\n革命的动力：包括无产阶级（最基本的动力）、农民阶级（主力军）、城市小资产阶级（可靠同盟者）和民族资产阶级（动力之一）。\n革命的领导力量：无产阶级的领导权是中国革命的中心问题。新民主主义革命的领导权是在无产阶级手中。\n革命的性质和前途：\n性质：资产阶级民主主义革命\n前途：社会主义\n\n\n\n新民主主义革命基本纲领\n新民主主义的政治纲领：人民民主专政。推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。\n经济纲领：保护个体手工业，没收官僚资本。没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。\n文化纲领：反帝反封建，形成科学的民族的大众的文化。新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。\n\n新民主主义革命的三大法宝\n统一战线：一要建立巩固的工农联盟，二要正确对待资产阶级，尤其是民族资产阶级，三要采取区别对待的方针，四要坚持独立自主的原则\n武装斗争：革命人民只有武装起来，以武装的革命反对武装的反革命。\n党的建设：中国共产党要领导革命取得胜利，必须不断加强党的思想建设、组织建设和作风建设。\n\n第三章社会主义改造的历史经验\n坚持社会主义工业化建设和社会主义改造同时并举。实践证明，并举的方针对于在深刻的社会变革中保持社会稳定、经济发展具有十分重要的意义。\n采取积极引导，逐步过渡的方式。实践证明，这种逐步过渡的办法符合农民的特点和生产力状况。\n用和平方法进行改造。坚持用和平的办法，不仅保证了我国社会主义改造的顺利进行，而且维护了社会稳定，极大地促进了社会主义事业的发展。\n\n第四章初步探索的经验教训（6点）\n第一，必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。\n\n第二，必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。\n\n第三，必须从实际出发进行社会主义建设，建设规模和速度要与国力相适应，不能急于求成。\n\n第四，必须发展社会主义民主，健全社会主义法制\n\n第五，必须坚持党的民主集中制和集体领导制度，加强执政党建设（党建）。\n\n第六，必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。\n\n\n第五章社会保障体系的内容和作用\n内容（4点）\n社会救济：穷人\n社会保险：主要劳动者\n社会福利：共享社会…\n优抚安置\n\n\n作用（4点）\n稳定社会：通过社会保障制度的实施，减少社会不安定因素，维护社会稳定和国家长治久安。\n保障基本生活需求‌：在年老、疾病、伤残、失业等情况下，提供基本生活保障，确保公民的基本生存与生活需要。\n保护劳动力的生产和再生产。在劳动力再生产遇到障碍时给予劳动者及其家属以基本生活、生命的必要保障,以维系劳动力再生产的需要,从而保证社会再生产的正常进行。\n宏观调控：如建立社会保障基金\n\n\n\n国民收入再分配的原因和途径\n原因（3点）\n保持非物质生产部门的生存和发展\n保证国民经济协调稳定发展：国民收入再分配有助于促进社会生产力既能较高速度地又能平衡协调地发展‌\n建立社会后备基金：为了保障劳动者的基本生活，建立社会保障基金，包括应对突发事故和自然灾害的社会后备基金‌\n\n\n途径（3点）\n国家预算：通过国家年度集中性财政收支计划来实现‌\n服务收费：各种非生产性劳务提供服务性劳动，享受这种服务的人们要以自己初次分配或再分配取得的收入支付劳务费用，从而使一部分国民收入向这些非生产性劳务部门转移‌\n价格体系：商品价格的高低将直接影响有关当事人的收入分配，通过价格杠杆来实现国民收入的再分配‌\n\n\n\n国外市场经济模式\n美国的，分散的，面向消费者的模式：\n自由的企业制度\n完善的法律体系\n\n\n德国的，社会化的市场经济\n完备的社会保障制度\n鼓励自由竞争\n\n\n法国的，计划化的市场经济\n完备的国民经济计划\n高度集中，高度集权\n\n\n日本的，协调式的市场经济\n独特的企业文化（儒家文化）\n官民共管\n\n\n\n第六章邓小平理论首要的基本的理论问题（了解）\n首要的基本的问题：\n什么是社会主义：社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕\n要坚持的原则：一是以社会主义公有制经济为主体，二是共同富裕\n\n\n精髓：解放思想，实事求是\n\n邓小平理论的主要内容（7点）\n社会主义初级阶段理论和党的基本路线\n\n理论：社会主义本身是共产主义的初级阶段，而我们中国有处在社会主义的初级阶段，就是不发达的阶段\n党的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自己更生，艰苦创业，为把我国建成富强明主文明的社会主义现代化国家而奋斗\n\n\n社会主义根本任务和发展战略理论\n\n社会主义的根本任务是发展生产力\n分三步走基本实现现代化的发展战略\n第一步：到1990年，实现国民生产总值比1980年翻一番，解决人民的温饱问题\n第二步：到20世纪末，使国民生产总值再增长一倍，人民生活达到小康水平\n第三步：到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化。然后在此基础上继续前进。\n\n\n\n\n社会主义改革开放和社会主义市场经济理论：\n\n改革开放：要发展生产力，经济体制改革是必由之路。改革是从根本上改变束缚生产力发展的经济体制，促进生产力的发展，解决社会主义社会发展动力的问题。\n中国的对内改革先从农村开始，1978年11月，实行“分田到户，自负盈亏”的家庭联产承包责任制（大包干）。在城市，国营企业的自主经营权得到了明显改善。\n\n\n市场经济：不再把计划经济和市场经济对立起来，实行计划与市场内在统一的体制，允许市场调节存在和发挥作用\n\n\n“两手抓，两手都要硬”：社会主义精神文明是社会主义社会的重要特征，社会主义发展应实现物质文明与精神文明的共同进步。\n\n“一国两制”与祖国统一：实现祖国的完全统一，是中华民族的根本利益所在。“一国两制”，指在一个中国的前提下，国家的主体坚持社会主义制度，香港、澳门、台湾保持原有的资本主义制度长期不变。\n\n中国特色社会主义外交和国际战略\n\n外交：明确维护我国的独立和主权，促进世界的和平与发展，是中国外交政策的基本目标。\n国际战略：冷静观察，稳住阵脚，沉着应对\n\n\n党的建设理论：建设中国特色社会主义，关键在于坚持、加强和完善党的领导。没有中国共产党，就没有社会主义的新中国\n\n\n第七章三个代表重要思想的核心观点和主要内容\n核心观点：\n始终代表中国先进生产力的发展要求\n始终代表中国先进文化的前进方向\n始终代表中国最广大人民的根本利益\n\n\n主要内容（6点）：\n发展是党执政兴国的第一要务\n建立社会主义市场经济体制\n全面建设小康社会\n建设社会主义政治文明\n实施“引进来”和“走出去”相结合的对外开放战略\n推进党的建设新的伟大工程\n\n\n\n第八章科学发展观的内涵\n推动经济社会发展是科学发展观的第一要义\n以人为本是科学发展的核心立场，发展是为了人民\n全面协调可持续是科学发展观的基本要义\n统筹兼顾是科学发展观的根本方法\n\n","categories":["课业"]},{"title":"数据结构与算法","url":"/2024/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","content":"第一章 · 导论什么是数据结构数据结构涉及三个方面： \n\n数据的逻辑结构—–从用户视图看，是面向问题的。 \n数据的物理结构—–从具体实现视图看，是面向计算机的。 \n相关的操作及其实现。\n\n注意：非线性逻辑结构的物理结构不一定是非线性的，反之亦然。\nADT\nADTs: Abstract Data Types \n是将类型和与这个类型有关的操作集合封装在一起的数据模型。\n如：栈，字典，列表等等\n\n思想：将数据类型的使用与它的表示（机内存储）、实现（机内操作的 实现）分开。更确切的说，把一个数据类型的表示及在这个类型 上的操作实现封装到一个程序模块中，用户不必知道它。\n\n\nOO\nOO：object-oriented＝object＋class＋inherit＋ communicate\n面向对象编程核心思想：\n封装\n继承\n多态\n\n\n\n算法思想：递归（Recursion)基本原则\n基本情况：考虑“第一项”\n递归过程：考虑第n项和第n-1项之间的关系\n注：递归过程一定要最终落在基本情况上，否则该递归是错误的\n\n\n\n分类\n直接递归（自递归）：自己调用自己\n简介递归（互递归）：多个函数相互调用形成回路的递归\n\n泛型\n理解：其实就是代码复用。有时候会通过模版来实现。java中看到的就是泛型的的例子\n定义：泛型（Generics）是一种编程语言的特性，允许在定义函数、类或数据结构时使用类型参数，以便这些代码可以适用于多种数据类型，而不需要为每一种类型编写单独的代码。\n\n第二章 · 算法分析\n只关注量级，不太关心细节\n计算机领域默认log的底数为2\n\n空间复杂度\n数变量的时候多一个少一个也没关系，不影响数量级就好\n\n\n组成：\n\n指令空间\n\n数据空间：\n\n常量\n简单变量\n组件变量\n\n\n环境栈空间\n\n\n\n两个部分：\n\n固定部分：指令空间，简单变量等等，在程序加载的时候就已经确定，大小是固定的。\n可变部分：包括组件变量，动态分配，递归栈等等。\n\n\n\n时间复杂度\n关注关键步骤，忽略次要步骤（都是相对而言），如：关注比较，忽略赋值；关注元素比较，忽略下标比较；\n最优最差平均复杂度：以查找为例，最优为1，第一个就找到了，最坏是n，遍历全部，平均为（n+1)&#x2F;2。\n\n基本思想：分治(divide-and -conquer)\n两个阶段：\n分阶段：把问题分成两个大致相等的子问题，然后递归地 对它们求解。 \n治阶段： 将两个子问题的解合并到一起，可能再做些少 量的附加工作，最后得到整个问题的解。\n\n\n\n表示法\n大O表示法：表示量级上界\nOmega表示法：表示量级下界\nθ表示法：表示量级\n\n第三章 · 列表，栈和队列线性表 ***\n逻辑层：\n定义和功能：\nAbstractDateType LinearList&#123; instances\tordered finite collections of zero or more elementsoperations\tCreate(); Destroy();\tIsEmpty(); Length();\tFind(k,x); Search(x);\tDelete(k,x); Insert(k,x);\tOutput(out);&#125; \n\n物理层：\n\n用数组表示线性表\n根据索引访问：O(1)\n查找：O(len)\n根据索引删除：O(n)。因为需要挪动数据。\n特点：\n优势：查找很快，O(1)\n缺点：插入，删除慢\n\n\n\n\n用链表表示\n时间复杂度\n访问：O(n)\n查找：O(n)\n删除：O(1)\n插入：O(1)\n\n\n有表头节点的单链表：\n在第一个节点之前有一个header节点，不储存数据。它被header指针指向。\nfirst是指第一个数据指针\n\n\n有游标的单链表\n定义了游标类LinkedListItr。\n\n\n\n\n\n\n\n栈 ***\n逻辑层：\n\n理解：实际上是对线性表做了限制，只允许有一端可以增添，删除和查找，其他地方都不行。活动端叫栈顶，另一端叫栈底。\n\n操作：\n\npush：压栈（添加）\npop：出栈（删除）\npeek：查看栈顶元素\nisEmpty\n\n\n\n\n物理层：和线性表一致。\n\n\n队列 ***\n逻辑层：\n理解：像水管一样，一头进数据，一头出数据。出数据的叫队首，进数据的叫队尾。\n操作：\nenqueue：入队\ndequeue：出队\npeek：查看队首数据\n\n\n\n\n物理层：和线性表一致\n用数组表示：要把数组看成环形。表示下一个位置时，表示为front &#x3D; (front + 1) % arr.length。\n\n\n\n第四章 · 树\n主要研究二叉树\n\n性质补充\n根节点的高度为0\n一棵树的叶有n个，有m个度数为2的节点，则：n&#x3D;m+1\n如果对完全二叉树按层标号，则可以根据标号算出某个节点的子节点和父节点\n\n表示\n用数组表示\n用广义表：A（B，C，（D，E））\n用双亲表示法\n左子女，右兄弟法：注意，这种方法的逻辑层和物理层都是树\n\n遍历\n二叉树遍历算法：\n\n深度优先：先序、中序、后序。用递归实现，也可以用栈。\n\nvoid PreOrder(BinaryNode&lt;T&gt;* t)&#123;// preorder traversal of *t.\tif(t)&#123; \t\tvisit(t);\t\tPreOrder(t-&gt;Left);\t\tPreOrder(t-&gt;Right);\t&#125;\t&#125;\n\n\n广度优先：按层次遍历。用队列实现\n\n\n一般树遍历：\n\n深度优先：\n逻辑上先根遍历（物理上先序遍历）\n逻辑上后根遍历（物理上中序遍历）\n\n\n\n\n森林遍历：\n\n先根&#x3D;&gt;先序\n中根&#x3D;&gt;中序\n后根&#x3D;&gt;后序\n\n\n\n二叉树\n完全二叉树：除了最后一层，其它层节点都是满的\n满二叉树：其中每个节点要么是叶子节点，要么是有两个子节点（即每个非叶子节点都有两个子节点）。每一层的节点数都达到了该层的最大节点数。\n满二叉树一定是完全二叉树，完全二叉树也不一定是满二叉树\n\n线索树\nn个结点的二叉树有2n个链域，其中真正有用的是n – 1个，其它n + 1个都是空域。让左指针指向前驱，右指针指向后继。\n增加了2个标记位，leftThread和rightThread。为0则代表指向子女，为1则代表指向前驱后继。\n\n搜索树\n可以构造出一颗二叉搜索树，使得每个节点的左子树的所有节点比自己小，右子树的所有节点比自己大\n\n带索引的搜索树（Index BST）在每个节点左侧添加一个索引，为其左子树中的所有节点数加一（也就是要包括自身）\n平衡二叉搜索树（AVL Tree）\n定义：\n是二叉搜索树\n左右子树高度差不能超过一\n\n\n旋转：详见算法\n\nm路搜索树\n定义：\n\n树中最多有m路分叉\n\n一个节点最少有一个key，最多有m-1个key\n\n\n节点中的key是从小到大排好序的\n\n分叉中的所有节点总是小于分叉的右边的key，大于左边的key\n\n\n\n\n平衡m路搜索树（B-Tree)\n定义：\n根节点至少有2个子节点（即至少有1个key）\n每个节点中的至少有 [m&#x2F;2]（向上取整）路\n外节点全都在同一层，即树同高\n\n\n性质：\n外节点总数是key值总数加一\n\n\n\n霍夫曼树\n概念：\n增长树：对原二叉树中度为1的结点， 增加一个空树叶 对原二叉树中的树叶， 增加两个空树叶\n外通路长度（外路径）E： 根到每个外结点（增长树的叶子） 的路径长度的总和（边数） E&#x3D;3+3+2+3+4+4+3+3&#x3D;25 \n内通路长度（内路径）I： 根到每个内结点（非叶子）的路径长度的总和（边 数）。 I&#x3D;2+1+0+3+2+2+1&#x3D;11 \n结点的带权路径长度： 一个结点的权值与结点的路径长度的 乘积。\n权的外路径长度： 各叶结点的带权路径长度之和。\n带权的内路径长度：各非叶结点的带权路径长度之和。\n霍夫曼树 1) \n给出m个实数W1，W2，…，Wm （m&gt;&#x3D;2） 作为m个外结 点的权构造一棵增长树， 使得带权外路径长度 \nWi l i最小。 m i&#x3D;1 其中l i 为从根结点出发到具有权为wi的外结点的通路长。\n\n\n\n\n霍夫曼算法\n\n第五章 · 散列表（Hash）(需要掌握代码)设计目标\n为了让插入和查找的时间复杂度为O(1)\n代价是会有严重空间浪费\n“hash值”是会冲突的，我们可以让冲突的数据挂在一个链表上，并且放在hash表的冲突的位置\n\n常见的散列函数\n取余法\nH(key) &#x3D; Key % M\n其中M是基本区长度的最大质数，这样的冲突概率最小。\n\n\n平方取中 todo\n乘法杂凑函数\nH（Key) &#x3D; M * ((C * Key) % 1)向下取整\nM是表的大小，C是任意无理数\n原理是表达大小乘以一个0~1之间的数，得到下标\n\n\n\n冲突处理\n同义：算出来地址相同\n\n线性探测法\n发生冲突后往后面放，指导遇到空位置。\n如果满了，就不放\n缺点：堆积\n\n二次探测法\n遇到冲突时，处理不一样。线性探测是一个一个往后找，二次探测是用一个平方算出来。$$h(x,i)&#x3D;(h(x)+i^2 )modm$$\n\n双散列\n遇到冲突时，用另外一个完全不同的hash函数计算一个值，再从冲突位置按照这个值往后数。还冲突，再数。$$h(x,i)&#x3D;(h1​ (x)+i⋅h2​ (x))modm$$\n\n分离链接法冲突了就用单链表接在后面\n第六章 · 堆最大（小）优先队列最大（小）堆\n性质\n完全二叉树：最大堆必须是一个完全二叉树，即除了最后一层，其他层的节点都要满，最后一层的节点都集中在左侧。\n父节点大于或等于子节点：对于堆中的每一个父节点，其值都大于或等于它的两个子节点的值。换句话说，根节点的值是最大值。\n树的性质：最大堆的树结构是无序的，仅通过父子节点关系来确保堆性质\n\n\n算法：\n插入（Insert）：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。\n删除最大元素（Extract Max）：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。\n\n\n求第K大元素：\n不用堆：\n\n1A算法：全部排序一遍，找到第K个。O(n^2^)\n1B算法：取前K个数据排序，然后把后面的数据和前面K个数据中的最小值比较。如果小于，则跳过；若大于，则删除原来那个，把这个值插入合适位置。O(n*k)\n\n\n用堆\n\n6A算法：建堆，执行K次出堆。O(n*log(n))\n6B算法：道理一样的，取前K个元素建堆，比较，重构。O(n*log(k))\n\n\n\n\n\n第七章 · 并查集\n定义：每个集合通过一个代表元素（root）来表示，每个元素都指向它所在集合的代表元素。通过这种方式，可以快速确定两个元素是否属于同一个集合，以及在需要时将两个集合合并成一个集合。\n其物理层是森林，更进一步可以是数组。数组内容0或负数表示自己是父节点，非零表示父节点下标\n操作：\nFind 操作：用于查找某个元素所在的集合（即根节点），并在查找的过程中进行路径压缩，即每次查找让路径上的所有节点指向根节点，以减小树的高度，提高查找效率。\nUnion 操作：用于合并两个集合，即将两个集合的代表元素连接在一起，通常按照某种规则（如按秩合并）来决定连接的方式，以保持树的平衡。为了不让union后的树形状太糟糕，采用下面的方法：\n在树根上缓存一个树高，把树高小的挂在树高大的上面\n\n\n\n\n实现\n用一个数组来实现，根结点中放负数，而且是代表高度。\n\n\n\n第八章 · 图概念\n有向图和无向图\n\n完全图\n\ne表示边，v表示节点\n\nTD表示度数，ID表示入读，OD表示出度\n\n$\\sum^n_{i&#x3D;1}TD(v_i)&#x3D;2*e$\n\n子图\n\n连通分量：指的是一个图的一个子图，该子图是连通的，并且和图中任何其他子图都不连通。\n\n有向图的连通分量可以分为强连通分量（strongly connected component）和弱连通分量（weakly connected component）。\n强连通分量：有向图中每个顶点都能到达该分量中的其他顶点。\n弱连通分量：忽略边的方向后，图是连通的。\n\n\n\n\n生成树：实际上是极小连通子图\n\n\n物理层\n邻接矩阵（数组）***\n矩阵的行列数都为v\n\n\n邻接表（链表）***\n对于无向图来说，邻接表节点数量是边的两倍；对有向图来说，是一样多的\n每个表头代表起点，其后每个节点代表一个终点\n\n\n邻接多重表\n\n生成树\n定义：\n设G &#x3D;(V，E)是一个连通的无向图(或是强连通有向图) 从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE(G)，显然 G‘&#x3D;(V，TE)是G之子图， G‘被称为G的生成树(spanning tree)，也称为一个连通图.\nn个结点的生成树有n-1条边。\n生成树的代价(cost)：TE(G)上诸边的代价之和\n生成树不唯一\n\n\n\n最短路径\n概述\n\n三种算法： 1)边上权值为非负情况的从一个结点到其它各结点的最短路径 （单源最短路径）（Dijkstra算法） 2)边上权值为任意值的单源最短路径 3)边上权值为(任意值)的所有顶点之间的最短路径\n\n\nDijkstra算法：\n\n起点V0，首先直接连接，不管是否直接连接。\n\n\n\n排好序后，V0-V1 10已经是最小的了，不可能再找到更短的路径\n\n\n\n接下来，尝试V0-v2通过V1绕会不会比原来的更短(考虑V1-V2直连)，V0-V4从V1绕会不会比原来更短(考虑V2-V3直连)，如果短则更新，此时V0-V3是三者中最小值，所以选择V0-V3。\n\n\n\n尝试绕行V3，计算直连，更新掉，然后重复\n\n\n\n红色是已经选择好的，绿色是绕行选择。\n\n\n\n进一步思考，就是只进行一步，不进行多不步。\n总体来讲:不可能走更长的路径，然后回来\n\n\n\n数值更新，路径数组对应位置更新\n\n\n\n贝尔曼·福特改进算法\n\n允许有负边，但是不允许有负环\n思想是动态规划（迭代？），找到走一步的最短路径，再找两步以内的，一直到n-1步以内的。实际上是看现状加上直连边来看，每一个节点都可能会更新。\n\n\nfloyed\n\n简单来说就是:每次都会选择一个中介点，然后遍历整个数组，更新相应的需要更新的数组。\n在更新A时，也更新path矩阵，里面的值是到数第二个节点\n\n\n\n活动网络\n用顶点表示活动的网络（AOV网络）\nAOV网（Activity On Vertex network)用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网。直接前驱，直接后继：&lt;i,j&gt;是网中一条弧，则i是j的直接前驱，j是i的直接后继。前驱，后继：从顶点i顶点j有一条有向路径，则称i是j的前驱， j是i的后继。AOV网中，不应该出现有向环\n拓扑排序\n\n\n用边表示活动的网络（AOE网络）\n用边表示活动的网络（AOE网络, Activity On Edge Network）又称为事件顶点网络• 顶点：表示事件（event）事件——状态。表示它的入边代表的活动已完成，它的出边代表的活动可以开始，如下图v0表示整个工程开始，v4表示a4，a5活动已完成a7，a8活动可开始。有向边：表示活动。边上的权——表示完成一项活动需要的时间\n关键路径（critical path）1)目的 : 利用事件顶点网络，研究完成整个工程需要多少时间加快那些活动的速度后，可使整个工程提前完成。2)关键路径：具有从开始顶点(源点）完成顶点（汇点）的最长的路径\n一些定义\n\n对于事件:\nVe[i]－表示事件Vi的可能最早发生时间。定义为从源点V0-&gt;Vi的最长路径长度, 如Ve[4]&#x3D;7天\nVl[i]－表示事件Vi的允许的最晚发生时间。是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi-&gt;Vn－1的最长路径长度。是从最后汇点时间长度-两者之间最长路径\n\n\n\n\n\n解释:\n计算到最后汇点的总共最短时间:找到从源点到汇点的最大路径\n最早12，因为之前不能做。\n最晚12，是因为如果这时候不开始，最后完成不了。\n\n\n对于活动:\ne[k]－表示活动ak&#x3D;&lt;Vi,Vj&gt;的可能的最早开始时间。 即等于事件Vi的可能最早发生时间。 e[k]&#x3D;Ve[i]\nl[k]－表示活动ak&#x3D; &lt;Vi,Vj&gt; 的允许的最迟开始时间 l[k]＝Vl[j]-dur(&lt;i,j&gt;);\nl[k]-e[k]－表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack time)\nl[k]&#x3D;&#x3D;e[k]－表示活动ak是没有时间余量的关键活动\n\n\n\n\n找关键路径\n\n找关键活动的算法：（1）定义几个量对事件而言Ve[i]－表示事件Vi的可能最早发生时间定义为从源点V0 Vi的最长路径长度, 如Ve[4]&#x3D;7天Vl[i]－表示事件Vi的允许的最晚发生时间。是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi  Vn－1的最长路径长度。\n\n\n\n\n\n\n\n第九章 · 排序概述\n稳定性：如果待排序的对象序列中，含有多个关键码值 相等的对象，用某种方法排序后，这些对象的 相对次序不变的，则是稳定的，否则为不稳定 的。\n两大类：\n内排序：对内存中的n个对象进行排序。\n外排序：内存放不下，还要使用外存的 排序。\n\n\n排序的算法分析： \n时间开销—比较次数，移动次数 \n所需的附加空间\n\n\n\n插入排序直接插入排序\n思想：一个一个排\nO(n^2^)\n稳定的\n\n折半插入排序\n在直接插入排序的基础上，让比较的过程变成折半查找，而不是线性查找.注意，是在已经排好序的部分进行的二分查找。\nO(n*log n)\n稳定的\n\n希尔排序\n又称为缩小增量排序\n\n\n\ntemplate &lt;class Type&gt;void Shellsort(datalist&lt;Type&gt;&amp; list)&#123;    int gap = list.CurrentSize / 2;    while (gap)    &#123;        ShellInsert(list, gap);        gap = (gap == 2) ? 1 : gap / 2;    &#125;&#125;template &lt;class Type&gt;void ShellInsert(datalist&lt;Type&gt;&amp; list, const int gap)&#123;    for (int i = gap; i &lt; list.CurrentSize; i++)    &#123;        Element&lt;Type&gt; temp = list.Vector[i];        int j = i;        while (j &gt;= gap &amp;&amp; temp.getkey() &lt; list.Vector[j - gap].getkey())        &#123;            list.Vector[j] = list.Vector[j - gap];            j -= gap;        &#125;        list.Vector[j] = temp;    &#125;&#125;\n\n时间复杂度大概在n^1.3^左右\n\n不稳定\n\n\n交换排序冒泡排序\n注意，我们可以记录是否有交换，如果某一次迭代时没有交换，就可以终止了。\n\ntemplate &lt;class Type&gt;void BubbleSort(datalist&lt;Type&gt;&amp; list)&#123;    int pass = 1;     int exchange = 1;    while (pass &lt; list.CurrentSize &amp;&amp; exchange)    &#123;        exchange = 0;  // 重置交换标志        BubbleExchange(list, pass, exchange);  // 执行一轮交换        pass++;    &#125;&#125;template &lt;class Type&gt;void BubbleExchange(datalist&lt;Type&gt;&amp; list, const int pass, int&amp; exchange)&#123;    // 执行一轮交换    for (int j = list.CurrentSize - 1; j &gt;= pass; j--)    &#123;        if (list.Vector[j - 1].getkey() &gt; list.Vector[j].getkey())        &#123;            swap(list.Vector[j - 1], list.Vector[j]);  // 交换元素            exchange = 1;  // 记录发生交换        &#125;    &#125;&#125;\n\nO(n^2^)\n\n稳定的\n\n\n快速排序 ***\n方法： 1）在n个对象中，取一个对象（如第一个对象——基 准pivot），按该对象的关键码把所有 该关键码 的对象分划在它的左边。该关键码的对象分划 在它的右边。 2） 对左边和右边（子序列）分别再用快排序。\n\ntemplate &lt;class Type&gt;void QuickSort(datalist&lt;Type&gt;&amp; list, const int left, const int right)&#123;    if (left &lt; right)    &#123;        int pivotpos = partition(list, left, right);  // 获取基准元素的位置        QuickSort(list, left, pivotpos - 1);  // 排序左侧子数组        QuickSort(list, pivotpos + 1, right);  // 排序右侧子数组    &#125;&#125;template &lt;class Type&gt;int partition(datalist&lt;Type&gt;&amp; list, const int low, const int high)&#123;    int i = low, j = high;    Element&lt;Type&gt; pivot = list.Vector[low];  // 选择基准元素（这里选择第一个元素）    while (i &lt; j)    &#123;        // 从右向左找小于基准值的元素        while (list.Vector[j].getkey() &gt; pivot.getkey() &amp;&amp; i &lt; j) j--;                // 从左向右找大于基准值的元素        if (i &lt; j)         &#123;            list.Vector[i] = list.Vector[j];  // 交换            i++;        &#125;        // 再次从右向左找小于基准值的元素        while (list.Vector[i].getkey() &lt; pivot.getkey() &amp;&amp; i &lt; j) i++;                if (i &lt; j)         &#123;            list.Vector[j] = list.Vector[i];  // 交换            j--;        &#125;    &#125;    // 将基准值放到正确的位置    list.Vector[i] = pivot;    return i;  // 返回基准值的位置&#125;\n\n不稳定\n\n时间平均O(n*log n)\n\n空间：O(log n) ~ O(n)\n\n不稳定\n\n选取枢纽元\n\n用第一个元素作pivot是不太好的。\n方法1：随机选取pivot, 但随机数的生成一般是昂贵的。 \n方法2：三数中值分割法（Median-of-Three partitioning) N个数，最好选第N&#x2F;2个最大数，这是最好的中值，但这是很困难的。 一般选左端、右端和中心位置上的三个元素的中值作为枢纽元。 8, 1, 4, 9, 6, 3, 5, 2, 7, 0 (8, 6, 0) 具体实现时：将 8，6，0 先排序，即 0, 1, 4, 9, 6, 3, 5, 2 , 7, 8, 得到中值pivot为 6 。\n\n\n分割策略：将pivot与最后倒数第二个元素交换，使得pivot离开要被分割的数据段。然后， i 指向第一个元素，j 指向倒数第二个元素。 0, 1, 4, 9, 7, 3, 5, 2, 6, 8 然后进行分\n\n\n选择排序直接选择排序\n思想：首先在n个记录中选出关键码最小（最大）的 记录，然后与第一个记录（最后第n个记录） 交换位置，再在其余的n-1个记录中选关键码 最小（最大）的记录，然后与第二 个记录（ 第n-1个记录）交换位置，直至选择了n－1个 记录。\n不稳定\n每次寻找都要扫描\n\n竞标赛排序\n直接选择排序存在重复做比较的情况，锦标赛 排序克服了这一缺点。 \n方法： 1. n个对象的关键码两两比较得到 n&#x2F;2 个 比较的优胜 者(关键码小者)保留下来, 再对这 n&#x2F;2 个对象再进行关键 码的两两比较, ……直至选出一个最小的关键码为止。 如果n不是2的K次幂，则让叶结点数补足到满足 2 k\n\n树根为当前最小元素。取出后，把对应位置改为无穷\n第一次扫描需要建树，但是后面更新只需要比较树高。\n\n堆排序\n归并排序\n分治思想，会合并\n\n笔记 · 错题集\n如何求时间复杂度？\n\n步骤：\n\n找关键步骤。明确到底那些地方才算时间。\n抓最大规模。如果问题有多个部分，取最慢、最复杂的部分算时间复杂度（其实大O就是这样）。\n计算。嵌套向乘，平级相加。\n\n\n注意：\n\n一定要明确那些地方算时间，如：\nfor( i = 1; i &lt; n; i++ )     \tfor( j = 0; j &lt; i*i; j++ )    \tif( j % i == 0 )        \tfor( k = 0; k &lt; j; k++ )            \tsum++; \n\n不要把所有的循环都算到时间复杂度里，要抓的是执行了多少次sum++。\n\n写成加和的形式，不要写成乘法，否则容易搞混。有一重循环就写一重加和。\n\n\n\n\n\n链表实现栈和队列：\n\n栈：表头为栈顶\n队列：两个指针记录首尾\n\n\nComparable 不是一个类，而是一个接口，它用于在 Java 中定义对象的自然顺序。任何实现了 Comparable 接口的类都可以通过该接口提供的 compareTo 方法来进行对象的比较。这个接口是 Java 类库中非常重要的一部分，它允许你定义自定义的排序规则。\n\n\n笔记 · 算法集排序算法选择排序func(int[] a, int size)&#123;\tfor(int n = size; n &gt; 1; n--)&#123;\t\tint j = Max(a, n); //找到数组a中的最大数，返回其索引\t\tswap(a[j], a&#123;n-1&#125;); //交换\t&#125;&#125;\n\n\n二重循环\n\n时间复杂度为：$$(n-1)+(n-2)+…+3+2+1&#x3D;\\frac{n*(n-1)}{2} ··· O(n^2)$$\n\n\n冒泡排序func(int[] a, int size)&#123;\tfor(int i = 0; i &lt; size-1; i++)&#123;\t\tif(a[i] &gt; a[i+1])swap(a[i], a[i+1]);\t&#125;&#125;main()&#123; \tfor(int i = size; i &gt; 1; i--)&#123; \t\tfunc(a, i); \t&#125; &#125;\n\n\n二重循环\n时间复杂度：\n\n$$O(n^2)$$\n秩排序（Rank Sort） ***//排名Rank(int[] a, int n, int[] r)&#123;\tfor(int i = 0; i &lt; n; i++) //r数组初始化\t\tr[i] = 0;\t\t\tfor(int i = 1; i &lt; n; i++)&#123;\t\tfor(int j = 0; j &lt; i; j++)&#123;\t\t\tif(a[j] &lt;= a[i])\t\t\t\tr&#123;i&#125;++;\t\t\telse\t\t\t\tr[j]++;\t\t&#125;\t&#125;&#125;//重排序public static void Rearrange(int[] a, int n, int[] r) &#123;\t\t// In-place rearrangement into sorted order\t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\twhile (r[i] != i) &#123;\t\t\t\tint t = r[i];\t\t\t\tswap(a[i], a[t]);\t\t\t\tswap(r[i], r[t]);\t\t\t&#125;\t\t&#125;&#125;\n\n\n解释：先给数组里的每个数算排名，然后把数据按照排名放在对应的位置。\n时间复杂度：\n\n插入排序\n理解：\n从第二个元素开始，假设第一个元素已排序。\n将当前元素与已排序部分的元素逐个比较，从后向前找到合适的位置。\n将当前元素插入到适当的位置，移动已排序部分的元素以腾出空间。\n重复以上步骤，直到所有元素都已排序。\n\n\n\nInsertionSort( int [ ]a, int n)&#123; \tfor(int i=0;i&lt;n;i++) &#123; \t\t//insert a[i] into a[0:n-1]\t\tint t=a[i];\t\t\tint j;\t\tfor(j=i-1; j&gt;=0&amp;&amp;t&lt;a[j]; j--)\t\t\ta[j+1]=a[j];\t\ta[j+1]=t;\t&#125;&#125;\n\n\n时间复杂度：$O(n^2)$\n\n基数排序\n基数：用什么进制，基数就是几。\n理解：\n进桶。有基数个桶（每个桶实际上是单链表），把数字按照最高位放进桶里。\n出桶。把每个桶接到前一个桶后面，这样就实现了按照某一位从小到大的排序。\n循环，每次比较下一位。\n\n\n\n拓扑排序\n有向图G&#x3D;(V,E),V里结点的线性序列（vi1,vi2,…,vin),如果满足: 在G中从结点vi到vj有一条路径，则序列中结点vi必先于结点vj，称这样的线性序列为一拓扑序列。\n拓扑序列不是唯一的\n算法思想：1）从图中选择一个入度为0的结点输出之。（如果一个图中，同时存在多个入度为0的结点，则随便输出那一个结点）2）从图中删掉此结点及其所有的出边。3）反复执行以上步骤：a）直到所有结点都输出了，则算法结束b）如果图中还有结点，但入度不为0，则说明有环路\n\n查找算法顺序查找字面意思\n\n时间复杂度O(n)\n\n二分查找其他分治法：求最大子序列和（还有更简的算法）\n思想：\n\n从中间分裂成左右两个数组，分别递归调用求最大序列和\n求横跨左右的最大序列和：以中点为边界，分别求向左、右的最大子序列，再把两者相加，得到横跨左右的最大子序列和。\n把左最大、右最大、横跨最大三者相比较，保留最大的。\n\n\n时间复杂度：$O(n·log(n))$\n\n分：每次递归都是折半的，所以一共会分出log(n)层\n治：每次递归都要调用两次，处理左边和右边。所以实际上如果我们把同一层的调用拼在一起，每一层都处理了完整的规模为O(n)的数据。\n每层处理的规模为O(n)，有log(n)层，则有时间复杂度$O(n·log(n))$.\n\n\n\n寻找数组中第K小元素\n实际上就是在做选择排序，但是把问题规模限制在K，即做K个元素的排序后就结束\n\n杨辉三角\n用队列实现：\nimport java.util.LinkedList;import java.util.Queue;public class YangHui &#123;    public static void printYangHui(int n) &#123;        // 使用队列来保存计算过程中的值        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();        q.add(1); // 初始化队列        q.add(1);        for (int i = 1; i &lt;= n; i++) &#123;            System.out.println();            // 打印前置空格以对齐            for (int k = 1; k &lt;= 10 - i; k++) &#123;                System.out.print(&quot; &quot;);            &#125;            // 在每行计算开始前添加一个辅助的 0            q.add(0);            int s = 0; // 用于记录前一个出队元素            for (int j = 1; j &lt;= i + 2; j++) &#123;                int t = q.poll(); // 队列出队                q.add(s + t); // 将新的值入队                s = t; // 更新 s                if (j != i + 2) &#123; // 控制打印范围                    System.out.print(s + &quot; &quot;);                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        int n = 5; // 打印前 5 行杨辉三角        printYangHui(n);    &#125;&#125;\n\n\n\n用可变长的二维数组实现：\npublic class Yanghui &#123;    public static void main(String[] args) &#123;        int n = 10; // 杨辉三角的行数        int[][] mat = new int[n][]; // 申请第一维的存储空间        // 生成杨辉三角        for (int i = 0; i &lt; n; i++) &#123;            mat[i] = new int[i + 1]; // 申请第二维的存储空间，每行长度不同            mat[i][0] = 1; // 每行的第一个元素为 1            mat[i][i] = 1; // 每行的最后一个元素为 1            for (int j = 1; j &lt; i; j++) &#123;                mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j]; // 计算中间元素            &#125;        &#125;        // 打印杨辉三角        for (int i = 0; i &lt; mat.length; i++) &#123;            // 打印前置空格，用于对齐            for (int j = 0; j &lt; n - i; j++) &#123;                System.out.print(&quot; &quot;);            &#125;            // 打印每行的元素            for (int j = 0; j &lt; mat[i].length; j++) &#123;                System.out.print(&quot; &quot; + mat[i][j]);            &#125;            System.out.println(); // 换行        &#125;    &#125;&#125;\n\n约瑟夫问题//rear: 每次指向要出队列的前一个结点//出队列的人也用链表来表示：//head: 指向出队列结点链表的开头结点//p: 指向出队列结点链表的尾结点//以上rear, head, p都是ListNode的一个对象引用。1. w = m;2. for( int i = 1; i&lt;= n-1; i++)&#123;\t1) for (int j =1; j&lt;=w-1; j++) \t\trear = rear.link;\t2) if (i = = 1)&#123; \thead = rear.link ; p = head; &#125;\telse&#123; \t\tp.link = rear.link; \t\tp = rear.link;\t&#125;\t3) rear.link = p.link;\t&#125;3. P.link = rear;\trear.link = null;\n\n\n\n辗转相除法：求最大公因数\n代码：\npublic static long gcd( long m, long n )&#123; \twhile( n != 0 )&#123; \t\tlong rem = m % n;\t\tm = n;\t\tn = rem;\t&#125;\treturn m;&#125;\n\n\n最坏情况是m, n取斐波那契数列的连续两位。\n时间复杂度：估计得$O(n·log(n))$\n\n\n\n一般二叉搜索树\n每个节点有一个唯一的key值，左子结点比自己小，右子节点比自己大\n\n查找算法（递归）\n每个节点都有一个key值，当要查找的节点的key值小于当前节点，则只搜索左子树，反之搜索右子树\nFind operation for binary search treesprivate BinaryNode find( Comparable x, BinaryNode t )&#123; \t\tif( t = = null )\t\treturn null;\tif( x. compareTo( t.element ) &lt; 0 )\t\treturn find( x, t.left );\telse if( x.compareTo( t.element ) &gt; 0 )\t\treturn find( x, t.right );\telse\t\treturn t; //Match&#125;\n\n插入算法（递归）\n不能够插入已有的key\n\n当要插入的节点的key值小于当前节点，则只在左子树插入，反之在右子树插入\nprivate BinaryNode insert( Comparable x, BinaryNode t )&#123;\tif( t = = null )\t\tt = new BinaryNode( x, null, null );\telse if( x.compareTo( t.element ) &lt; 0 )\t\tt.left = insert( x, t.left );\telse if( x.compareTo( t.element ) &gt; 0 )\t\tt.right = insert( x, t.right );\telse\t\t; //duplicate; do nothing\treturn t;&#125;\n\n删除算法 ***\n考虑：\n\nP是叶节点\nP有一棵子树\nP有两棵子树\n\n\n前两种情况好理解，第三种情况下删除之后这个位子空出来怎么办呢?\n\n找到该节点左子树的最大节点或右子树的最小节点，代替到这个位置。找到的最大或最小节点一定至多有一颗子树。\n\nprivate BinaryNode remove( Comparable x, BinaryNode t )&#123;\tif( t == null )\t\treturn t;\tif( x.compareTo( t.element ) &lt; 0 )\t\tt.left = remove( x, t.left );\telse if( x.compareTo( t.element ) &gt; 0 )\t\tt.right = remove( x, t.right );\telse if( t.left != null &amp;&amp; t.right != null )&#123;\t\t\tt.element = findMin( t.right ).element;\t\tt.right = remove( t.element , t.right );\t&#125;\telse\t\tt = ( t.left != null ) ? t.left : t.right;\treturn t; &#125;\n\n平衡二叉搜索树（AVL Tree）查找算法\n同一般搜索树\n\n插入算法 ***\n考虑情景：要插入一个比根节点大的节点，但是右子树的高度已经比左子树大一了。\n解决方案：旋转。在这个情境中，左单旋，让右子节点变成根节点，原来的根节点变成左子结点，其余不变。然后向右子树插入。\n\n\n但是要讨论插入的位置，在外侧还是在内侧\n\n![屏幕截图 2024-11-01 152713](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-11-01 152713.png)\n\n也可这样讲：插入一个新结点后，需要从插入位置沿通向根 的路径回溯，检查各结点左右子树的高度差， 如果发现某点高度不平衡则停止回溯。 \n单旋转：外侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一直线A，C，E \n双旋转：内侧—从不平衡结点沿刚才回溯的路径取直接下两层 如果三个结点处于一折线A，C，D\n左双旋则先左旋再右旋，右双旋反之\n\n\n*以上以右外侧，右内侧为例，左外侧，左内侧是对称的。 与前面对称的情况：左外侧，左内侧\n时间复杂度：对数关系\n\n删除算法\n在一般二叉搜索树的删除算法基础上，引入平衡性检查和旋转\n每个节点都有一个自己的树高的数据，用以回溯时检查平衡性\n\nm路搜索树\n查找算法\n从左到右排好序的，直接找就好了\n\n\n插入算法\n先查找，找到了就不用插入\n找不到：\n找到了要插入的那个位置，如果key值没满，则插入一个key值；如果满了，就在那个位置的分叉上插入一个节点\n\n\n\n\n删除算法\n没有子树：直接删除\n一颗子树：找到对接近自己的key来代替自己\n两颗子树：找到左或右子树中最接近自己的Key代替\n\n\n\nB-Tree\n查找算法：直接找\n\n树高：$log_m(n+1)&lt;&#x3D;h&lt;&#x3D;1+log_{m&#x2F;2}(n+1)&#x2F;2$\n\n\n插入算法：\n\n总是先在叶节点插入\n如果节点满了，就把节点从中间key值分裂，并在父节点中插入。对于根节点，把根节点分裂，提出新的根节点。\n\n![image-20241105175508641](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-11-05 175449.png)\n\n删除算法：\n\n所有删除会转化为叶节点的删除\n\n若下溢，先找兄弟节点借，让旁边的key到父节点，从父节点拉下一个key下来\n\n没得借的，说明两个都是最小数（m&#x2F;2-1），就合并。合并后要从父节点拉一个key下来，注意检查父节点下溢问题，要满足B-Tree要求。\n\n\n\n\n\n最大堆\n插入：当插入一个新的元素时，首先将其放在堆的最后一个位置，然后通过“上浮”操作（heapify-up）将其调整到正确的位置，确保堆的性质。\n删除最大元素：删除根节点（最大元素）后，将堆的最后一个元素移动到根节点的位置，然后通过“下沉”操作（heapify-down）将新的根节点调整到正确的位置，确保堆的性质。\n建堆（初始化）：拿到一颗二叉树，有两种初始化方法。但是，完全二叉树的绝大多数节点都集中在底层附近，所以我们选择下滤算法，这样绝大多数节点跑的路径短，少数节点跑的路径长。注意，在数组中，下标为i的节点的父节点下标为i&#x2F;2。\n由底向上（更优）：总共有n个节点。叶节点不用下滤，我们从倒数第二层开始，所以索引从n&#x2F;2开始往下走，对每个节点做下滤。做完之后就完成了。\n由顶向下：依次插入节点，然后做上滤（也只能上滤）。\n\n\n排序算法：以数组为物理层为例\n如何不额外创建数组就实现排序呢？当你从最大堆中取出根节点（最大值）后，剩下的节点要重构，这样数组的最后就会空出一格来，这样你可以把最大值放在最后。做到最后，数组就排序好了。\n工作流程：\n先建堆\n再排序（取出最大值，放在最后）\n\n\n\n\n\n图遍历\n深度优先DFS\n\n思想: 从图中某个顶点V0出发,访问它,然后选择一个 V0 邻接到的未被访问的一个邻接点V1出发深度优先遍 历图,当遇到一个所有邻接于它的结点都被访问过了的 结点U时,回退到前一次刚被访问过的拥有未被访问的 邻接点W,再从W出发深度遍历,……直到连通图中的所 有顶点都被访问过为止.\n\n//利用的是邻接矩阵来表示的图\n//C++写的\n//主过程:\ntemplate&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS( ) {\n    int *visited=new int[NumVertices];\n    for ( int i=0; i&lt;NumVertices; i++)\n        visited[i]=0;\n        DFS(0,visited);//从顶点0开始深度优先搜索\n        delete[] visited;//释放visited的空间\n    }\n//子过程\ntemplate&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::DFS(int v, visited[]) {\n    cout&lt;&lt;GetValue(v)&lt;&lt;&quot;&quot;;\n    visited[v]=1;\n    int w = GetFirstNeighbor(v);\n    while (w!=-1) {\n        if(!visited[w])\n            DFS(w,visited);//最坏情况，就是每一次w都没有被访问过\n        w = GetNextNeighbor(v,w);\n    }\n    //无论如何，最坏情况下访问次数，也就只能是图中所有边的个数。\n    //也就是对邻接矩阵所有边会被扫一遍\n}\n   3. 用邻接表表示 O(n+e)   4. 用邻接矩阵表示 O(n2)2. 广度优先BFS   - 广度优先算法是一种先进先出的算法，所以常常用队列来实现   1. 思想：从图中某顶点V0出发，在访问了V0之后依次访      问v0的各个未曾访问过的邻接点，然后分别从这些邻接      点出发广度优先遍历图，直至图中所有顶点都被访问      到为止.   2. 算法同样需要一个辅助数组visited[] 表示顶点是否被访问过. 还需要一个队列,记正在访问的这一层和上一层的顶点. 算法显然是非递归的.   3. ```c++      template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::BFS(int v) &#123;          //这个算法使用了队列          int* visited=new int[NumVertices];          for (int i=0; i&lt;NumVertices; i++)              visited[i]=0;          cout &lt;&lt; GetValue(v) &lt;&lt; &quot;&quot;;                //访问结点          visited[v]=1;                //使用队列来存储顶点          queue&lt;int&gt; q;          q.EnQueue(v);          while(!q.IsEmpty()) &#123;              v= q.DeQueue();              int w= GetFirstNeighbor(v);              while (w!=-1) &#123;                  if(!visited[w]) &#123;                      cout&lt;&lt;GetValue(w)&lt;&lt;&quot;&quot;;                       visited[w]=1;                      q.EnQueue(w);                  &#125;                  w= GetNextNeighbor(v,w);                  //访问完成一层的结点              &#125;          &#125;          delete[] visited;      &#125;\n\n\n\n\n\n贪心算法：最小生成树\nPrim（贪点）\n\n优化\n优化内容：\n使用两个数组Lowcost[ ]、nearvex[ ]\nLowcost[]:存放生成树顶点集合内顶点到生成树外各顶点的边上的当前最小权值\nnearvex[]:记录生成树顶点集合外各顶点，距离集合内那个顶点最近。\n\n\n步骤：\n在Lowcost[ ]中选择nearvex[i]不等于-1,且lowcost[i] 最小的边用v标记它。，则选中的权值最小的边为(nearvex[v],v), 相应的权值为lowcost[v]。 例如在上面图中第一次选中的v&#x3D;5;则边(0，5)，是选中的权值最小的边，相应的权值为lowcost[5]&#x3D;10。 反复做以下工作\n将nearvex[v] 改为-1，表示它已加入生成树顶点集合。将边(nearvex[v],v,lowcost[v])加入生成树的边集合。\n修改。取lowcost[i]&#x3D;min{lowcost[i],Edge[v][i]},即用生成树顶点集合外各顶 点i到刚加入该集合的新顶点 v的距离(Edge[v][i])与原来它所到生成树顶点 集合中顶点的最短距离lowcost[i]做比较，取距离近的，作为这些集合外顶 点到生成树顶点集合内顶点的最短距离。\n如果生成树顶点集合外的顶点i到刚加入该集合新顶点v的距离比原来它 到生成树顶点集合中顶点的最短距离还要近，则修改nearvex[i]: nearvex[i]&#x3D;v 表示生成树外顶点i到生成树的内顶点v 当前距离最短。\n\n\nO(n^2^)\n\n\n\n\nKruskal（贪边），小细节：用并查集判断回路\n1. \nvoid Graph&lt;string,float&gt;::Kruskal(MinSpanTree&amp;T) &#123;    //结果赋值给T    MSTEdgeNode e;    MinHeap&lt;MSTEdgeNode&gt;H(currentEdges);    int NumVertices=VerticesList.Last , u , v ;    Ufsets F(NumVertices);//建立n个单元素的连通分量    for(u=0;u&lt;NumVertices;u++)        for (v=u+1;v&lt;NumVertices;v++)            if(Edge[u][v]!=MAXINT) &#123;                e.tail=u;                e.head=v;                e.cost=Edge[u][v];                H.insert(e);                //完成堆的初始化，将每一条边插入到优先级队列中去            &#125;    int count=1;//生成树边计数    while(count&lt;NumVertices) &#123;        H.RemoveMin(e);        u=F.Find(e.tail);//找到并查集的树根        v=F.Find(e.head);//找到并查集的树根        if(u!=v)&#123;            //并查集做回边检测，在同一个并查集中就是一个回边，不然就不是            F.union(u,v);            T.Insert(e);            count++;//计数已经查找出来的个数        &#125;        //最坏的情况时所有的边都被访问一次，比如目标边是最后一条边。    &#125;&#125;\n\n\n算法分析：\n建立e条边的最小堆\n检测邻接矩阵O(n2)\n每插入一条边，执行一次 fiterup() 算法：log2e 所以，总的建堆时间为O(elog2e)\n\n\n构造最小生成树时\ne次出堆操作：每一次出堆，执行一次filterdown(), 总时间为O(elog2e)\n没有考虑悬挂问题\n\n\n2e次find操作：O(elog2n)，树高是log2n\n从头开始生成，两个高为1的树，做union，才有高度为2的树\n两个高为2的树，做union，才有高度为3的树\n树的高度最坏情况下是log2n，当切仅当第一个二叉树\n\n\nn-1次union操作：O(n)\n所以，总的计算时间为O(elog2e+elog2n+n2+n)\n\n\n\n\n\n\n\n笔记 · 代码集链表类\nListNode：代表结点的类\nclass ListNode &#123;       object element;    ListNode next;    ListNode( object theElement) &#123;        this( theElement, null);    &#125;    ListNode( object theElement, ListNode n) &#123;        element = theElement;         next = n;    &#125;&#125; \n\nLinkedListItr：代表游标(指针）位置的类。这里很重要！在Java中已经有一个封装好的类了，不要再自己用指针了。?\npublic class LinkedListItr &#123;    LinkedListItr( ListNode  theNode) &#123;        current = theNode;    &#125;    public boolean isPastEnd( ) &#123;        return current == null;     &#125;    public object retrieve() &#123;        //获得当前节点的数据        return isPastEnd( ) ? null : current.element;     &#125;    public void advance( ) &#123;        if( ! isPastEnd( ) ) current = current.next;     &#125;    ListNode current; &#125;\n\nLinkedList：代表表本身的类\npublic class LinkedList &#123;    private ListNode header;    public LinkedList( ) &#123;//这里是含有表头节点的单链表，如果不带表头的话，应该是heder = null        header = new ListNode( null );    &#125;    public boolean isEmpty( ) &#123;        return header.next = = null ;    &#125;    public void makeEmpty( ) &#123;        header.next = null;    &#125;    //指向头指针的Itr    public LinkedListItr zeroth( ) &#123;        return new LinkedListItr( header );    &#125;    //指向第一个项的Itr    public LinkedListItr first( ) &#123;        return new LinkedListItr( header.next );    &#125;     public LinkedListItr find( object x )    public void remove( object x )    public LinkedListItr findPrevious( object x )    public void insert( object x, LinkedListItr p )&#125;\n\n操作\n查找\npublic LinkedListItr find (object x) &#123;    ListNode itr = header.next;    while ( itr != null &amp;&amp; !itr.element.equals( x ))        itr = itr.next;        return new LinkedListItr( itr );&#125; \n\n\n\n移除\npublic void remove( object x ) &#123;    LinkedListItr p = findprevious( x );    if( p.current.next != null )        p.current.next = p.current.next.next;&#125;\n\n其他\n约瑟夫问题\nw = m;for( int i = 1; i&lt;= n-1; i++) &#123;    for (int j = 1; j&lt;=w-1; j++) rear = rear.link;    if (i = = 1) &#123;         head = rear.link ; p = head;    &#125; else &#123;         p.link = rear.link;        p = rear.link;    &#125;    rear.link = p.link;    &#125;    P.link = rear; rear.link = null;\n\n静态链表\n\n静态链表是由数组实现的单链表。\n\n\n\n在系统中，对于系统来说，内存时这样子的被系统管理的。\n如果next是0，那么相当于null\n\n\n\n栈链表实现public void push(object x)&#123;    topOfStack = new ListNode(x, topOfStack);&#125;public object top()&#123;    if(isEmpty())        return null;    return topOfStack.element;&#125;public void pop() throws Underflow &#123;    if(isEmpty())        throw new Underflow();    topOfStack = topOfStack.next;&#125;public object topAndPop()&#123;    if(isEmpty())        return null;    object topItem = topOfstack.element;    topOfStack = topOfStack.next;    return topItem;&#125;\n\n数组实现public StackAr()&#123;    this(DEFAULT_CAPACITY);&#125;public StackAr(int capacity) &#123;       theArray = new object [capacity];    topOfStack = -1;&#125;public void push(object x) throws Overflow &#123;    if (isfull())        throw new Overflow();    theArray[++topOfStack] = x;&#125;public object top() &#123;    if( isEmpty())        return null;    return theArray[ topOfStack ];&#125;public void pop() throws Underflow &#123;    if(isEmpty())        throw new Underflow( );    theArray[ topOfStack-- ] = null;&#125;public object topAndPop() &#123;    if(isEmpty())        return null;    object topItem = top( );    theArray[ topOfStack-- ] = null;    reurn topItem;&#125;\n\n例题\n括号匹配\n\n#include &lt;iostream.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;stack.h&quot;const int Maxlength = 100; // max expression lengthusing namespace std;void PrintMatchedPairs(char *expr) &#123;    Stack&lt;int&gt; s(Maxlength);    int j, length = strlen(expr);    for ( int i = l; i &lt;= length; i++) &#123;        if (expr[i-1]==&quot;(&quot;)            s.Add(i);        else if (expr[i-1]==&quot;)&quot;)            try &#123;                s.Delete(j);//进栈的是括号的位置                cout &lt;&lt; j &lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt; endl;&#125;            catch (OutOfBounds)                &#123;cout &lt;&lt; &quot;No match for right parenthesis&quot; &lt;&lt; &quot;at&quot;&lt;&lt; i &lt;&lt; endl;&#125;    &#125;    while ( !s.IsEmpty ())&#123;        s.Delete(j);        cout&lt;&lt; &quot;No match for left parenthesis at &quot; &lt;&lt; j &lt;&lt; endl;        &#125;&#125;void static main(void) &#123;    char expr[MaxLength];    cout&lt;&lt; &quot;type an expression of length at most&quot; &lt;&lt;MaxLength&lt;&lt;endl;    cin.getline(expr, MaxLength);    cout&lt;&lt;&quot;the pairs of matching parentheses in&quot;&lt;&lt;endl;    puts(expr);    cout&lt;&lt;&quot;are&quot;&lt;&lt;endl;    printMatcnedPairs(expr);&#125;//复杂度O(n)\n\n\n表达式求值\n\n中缀表达式变成后缀表达式\n根据操作的元数来决定弹出几个来进行计算\n分量是指除了运算符以外的值\n\nimport java.util.*;public class Infix &#123;    // 优先级映射    private static final Map&lt;String, Integer&gt; precedence = new HashMap&lt;&gt;();    static &#123;        precedence.put(&quot;+&quot;, 1);        precedence.put(&quot;-&quot;, 1);        precedence.put(&quot;*&quot;, 2);        precedence.put(&quot;/&quot;, 2);        precedence.put(&quot;(&quot;, 0);    &#125;    // 主方法：计算中缀表达式的值    public float infix(String[] tokens) &#123;        // Step 1: 中缀转后缀        List&lt;String&gt; postfix = infixToPostfix(tokens);        // Step 2: 计算后缀表达式的值        return evaluatePostfix(postfix);    &#125;    // Step 1: 将中缀表达式转为后缀表达式    private List&lt;String&gt; infixToPostfix(String[] tokens) &#123;        Stack&lt;String&gt; stack = new Stack&lt;&gt;();        List&lt;String&gt; output = new ArrayList&lt;&gt;();        for (String token : tokens) &#123;            if (isNumber(token)) &#123;                output.add(token);  // 如果是数字，直接加入输出            &#125; else if (token.equals(&quot;(&quot;)) &#123;                stack.push(token);  // 左括号直接入栈            &#125; else if (token.equals(&quot;)&quot;)) &#123;                while (!stack.isEmpty() &amp;&amp; !stack.peek().equals(&quot;(&quot;)) &#123;                    output.add(stack.pop());  // 弹出栈顶操作符直到遇到左括号                &#125;                stack.pop();  // 弹出 &#x27;(&#x27;            &#125; else if (isOperator(token)) &#123;                while (!stack.isEmpty() &amp;&amp; precedence.get(stack.peek()) &gt;= precedence.get(token)) &#123;                    output.add(stack.pop());  // 弹出栈顶优先级更高的操作符                &#125;                stack.push(token);  // 将当前操作符压入栈            &#125;        &#125;        // 最后将栈中剩余的操作符添加到输出中        while (!stack.isEmpty()) &#123;            output.add(stack.pop());        &#125;        return output;    &#125;    // 判断一个字符串是否是数字    private boolean isNumber(String token) &#123;        try &#123;            Double.parseDouble(token);  // 尝试转换为数字            return true;        &#125; catch (NumberFormatException e) &#123;            return false;        &#125;    &#125;    // 判断一个字符串是否是操作符    private boolean isOperator(String token) &#123;        return precedence.containsKey(token);    &#125;    // Step 2: 计算后缀表达式的值    private float evaluatePostfix(List&lt;String&gt; postfix) &#123;        Stack&lt;Float&gt; stack = new Stack&lt;&gt;();        for (String token : postfix) &#123;            if (isNumber(token)) &#123;                stack.push(Float.parseFloat(token));  // 操作数直接压入栈            &#125; else if (isOperator(token)) &#123;                float b = stack.pop();  // 弹出右操作数                float a = stack.pop();  // 弹出左操作数                float result = 0;                switch (token) &#123;                    case &quot;+&quot;:                        result = a + b;                        break;                    case &quot;-&quot;:                        result = a - b;                        break;                    case &quot;*&quot;:                        result = a * b;                        break;                    case &quot;/&quot;:                        result = a / b;                        break;                &#125;                stack.push(result);  // 将运算结果压入栈            &#125;        &#125;        // 最后栈中的唯一元素即为结果        return stack.pop();    &#125;&#125;\n\n中缀转后缀\n\n基本想法:\n\n遇到操作数(运算分量)直接输出。\n遇到操作符:当前的操作符一定是不输出的，如果当前运算符低于栈顶预算符优先级低，则输出，一直到当前运算符高于栈顶运算符优先级\n\n\n括号比较麻烦:需要单独处理\n\n左半括号需要压栈，也就是只要保证任何一个优先级低就行，也就是我们希望左半括号永远不要输出出来，在遇到右半括号的时候出去左半括号。\n\n\n每一个符号都有两个优先级，加减乘除的两个优先级都是一样的，而括号的优先级不是。\n\n经过计算和推断，我们可以得知一个优先级体系是不能满足\n\n\n例子\n我们来一步一步地将表达式 3 - 9 + 3 * 4 + 2 - 1 转换成后缀表达式，并且根据这个后缀表达式来求值。步骤 1：中缀转后缀中缀表达式：3 - 9 + 3 * 4 + 2 - 1初始化操作符栈：[]（空）输出队列：[]逐步处理：处理数字 3：是操作数，直接加入输出队列。操作符栈：[]输出队列：[3]处理操作符 -：是操作符，压入栈。操作符栈：[-]输出队列：[3]处理数字 9：是操作数，直接加入输出队列。操作符栈：[-]输出队列：[3, 9]处理操作符 +：当前栈顶是 -，其优先级与 + 相同，先将 - 弹出并加入输出队列，再将 + 压入栈。操作符栈：[+]输出队列：[3, 9, -]处理数字 3：是操作数，直接加入输出队列。操作符栈：[+]输出队列：[3, 9, -, 3]处理操作符 *：* 的优先级高于 +，直接压入栈。操作符栈：[+, *]输出队列：[3, 9, -, 3]处理数字 4：是操作数，直接加入输出队列。操作符栈：[+, *]输出队列：[3, 9, -, 3, 4]处理操作符 +：* 的优先级高于 +，所以先将 * 弹出并加入输出队列，再将 + 压入栈。操作符栈：[+]输出队列：[3, 9, -, 3, 4, *]处理数字 2：是操作数，直接加入输出队列。操作符栈：[+]输出队列：[3, 9, -, 3, 4, *, 2]处理操作符 -：+ 的优先级与 - 相同，先将 + 弹出并加入输出队列，再将 - 压入栈。操作符栈：[-]输出队列：[3, 9, -, 3, 4, *, 2, +]处理数字 1：是操作数，直接加入输出队列。操作符栈：[-]输出队列：[3, 9, -, 3, 4, *, 2, +, 1]结束：最后将栈中的操作符 - 弹出并加入输出队列。操作符栈：[]输出队列：[3, 9, -, 3, 4, *, 2, +, 1, -]后缀表达式：[3, 9, -, 3, 4, *, 2, +, 1, -]\n\n\n\n队列链表实现template&lt;class T&gt;class LinkedQueue &#123;//T是任意的类型    public:        LinkedQueue()&#123;front=back=0;&#125;        ~LinkedQueue();//无法调用析构函数，在delete对象的时候可以直接释放        bool IsEmpty()const&#123;return ((front)?false:true);&#125;        bool IsFull()const;        T First()const;        T Last()const;        LinkedQueue&lt;T&gt;&amp;Add(const T&amp; x);        LinkedQueue&lt;T&gt;&amp; Delete(T&amp; x);    private:        Node&lt;T&gt;*front;        Node&lt;T&gt;*back;    &#125;;       \n\n例题\n杨辉三角\n#include &lt;stdio.h&gt;#include &lt;iostream.h&gt;#include &quot;queue.h&quot;void YANGHUI(int n) &#123;    Queue&lt;int&gt; q;    q.makeEmpty();    q.Enqueue(1);    q.Enqueue(1);    int s=0;    for (int i=1; i&lt;=n;i++) &#123;        cout &lt;&lt; endl;        for (int k=1;k&lt;=10-i;k++)            cout &lt;&lt;&quot; &quot;;        q.Enqueue(0);        for (int j=1;j&lt;=i+2;j++) &#123;            int t = q.Dequeue();            q.Enqueue(s+t);            s = t;            //0不需要进行打印            if (j!=i+2) cout&lt;&lt; s &lt;&lt;&quot; &quot;;        &#125;    &#125;&#125;\n\n循环移动？\n\n\n树左子女右兄弟\n用于遍历森林\nclass TreeNode&#123;    T data;    TreeNode *firstchild, *nextsibling;&#125;class Tree&#123;    TreeNode *root, *c&#125; // 插入算法template&lt;class T&gt;void Tree&lt;T&gt;::Insertchild(T value)&#123;    TreeNode&lt;T&gt;* newnode = new TreeNode&lt;T&gt;(value);    if(current-&gt;firstchild == NULL)&#123;        current-&gt;firstchild = newnode;    &#125; else&#123;        TreeNode&lt;T&gt; *p = current-&gt;firstchild;        while(p-&gt;nextsibling != NULL)&#123;            p = p-&gt;nextsibling;        &#125;        p-&gt;nextsibling = newnode;    &#125;&#125;\n\n遍历\n中序（利用栈，非递归）\n//基于栈实现非递归中序遍历//非递归使用stack实现中序遍历void Inorder(BinaryNode &lt;T&gt;*t)&#123;      Stack&lt;BinaryNode&lt;T&gt;*&gt; s(10);    BinaryNode&lt;T&gt;*p = t;    for (;;)&#123;        //无条件进行循环        while(p!=NULL)&#123;            //一直进行压栈，直到最左下部分            s.push(p);            p = p-&gt;Left;        &#125;        if(!s.IsEmpty())&#123;            //出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。            p = s.pop();            cout &lt;&lt; p-&gt;element;            p = p-&gt;Right;        &#125;else            return;    &#125;&#125;\n\n\n\n后序（利用栈，非递归）\n//非递归实现后序遍历//结点的实现struct StkNode &#123;    BinaryNode &lt;T&gt; * ptr;    int tag;//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.&#125;//非递归实现后序遍历void Postorder(BinaryNode &lt;T&gt; * t) &#123;    Stack &lt;StkNode&lt;T&gt;&gt; s(10);    StkNode&lt;T&gt; Cnode;    BinaryNode&lt;T&gt;*p = t;    for(;;) &#123;        //优先访问到最左下        while (p!=NULL)&#123;            Cnode.ptr = p;            Cnode.tag = 0;            s.push(Cnode);            p = p-&gt;Left;        &#125;        //将最左下结点出栈        Cnode = s.pop();        p = Cnode.ptr;        while (Cnode.tag == 1)//从右子树回来         &#123;            //如果已经被访问一次了才进行输出            cout &lt;&lt; p-&gt;element;            if (!s.IsEmpty())&#123;                Cnode = s.pop();                p = Cnode.ptr;            &#125;else&#123;                //访问结束                return;            &#125;           &#125;        Cnode.tag = 1;//从左子树遍历完，而右子树还没有动。        s.push(Cnode);        p = p-&gt;Right;//从左子树回来    &#125;//for&#125;      \n\n\n另外，非二叉树：\n先根：与原树的左子女右兄弟表示法的先序一致\n后根：与原树的左子女右兄弟表示法的中序一致\n\n\n\n\n广度优先\n//基于栈实现层次访问public static void levelTravel(Node root)&#123;    if (root == null) return;    Queue&lt;Node&gt; q=new LinkedList&lt;Node&gt;();    q.add(root);    while(!q.isEmpty())&#123;        Node temp = q.poll();        System.out.println(temp.value);        if(temp.left!=null) q.add(temp.left);        if(temp.right!=null) q.add(temp.right);    &#125;&#125;\n\n森林的遍历\n\n将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连\n先根次序遍历： \n访问F的第一棵树的根 \n按先根遍历第一棵树的子树森林 \n按先根遍历其它树组成的森林\n等于二叉树的先序\n\n\n中根次序遍历： \n按中根遍历第一棵树的子树森林 \n访问F的第一棵树的根 \n按中根遍历其它树组成的森林\n等于二叉树的中序\n\n\n\n\n后根次序遍历： \n按后根遍历第一棵树的子树森林 \n按后根遍历其它树组成的森林 \n访问F的第一棵树的根\n等于二叉树的后序\n\n\n\n\n\n根据前中后序表达式建树\n根据先序遍历和中序遍历\n\n先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树\n\n// 根据先序遍历和中序遍历构建二叉树\n    public static BinTree CreateBT(char[] pres, char[] ins) {\n        // 如果先序或中序为空，则返回null\n        if (pres.length == 0 || ins.length == 0) {\n            return null;\n        }\n\n        // 构建根节点，先序遍历的第一个元素是根节点\n        BinTree tree = new BinTree();\n        tree.element = pres[0];\n\n        // 查找根节点在中序遍历中的位置\n        int i = 0;\n        while (i &lt; ins.length &amp;&amp; ins[i] != pres[0]) {\n            i++;\n        }\n\n        // 如果根节点存在\n        if (i &lt; ins.length) {\n            // 中序遍历中，根节点左侧是左子树的元素，右侧是右子树的元素\n            // 递归构建左子树和右子树\n            tree.left = CreateBT(Arrays.copyOfRange(pres, 1, i + 1), Arrays.copyOfRange(ins, 0, i));\n            tree.right = CreateBT(Arrays.copyOfRange(pres, i + 1, pres.length), Arrays.copyOfRange(ins, i + 1, ins.length));\n        }\n\n        return tree;\n    }\n2. 根据中序遍历和后序遍历   + 后序遍历树根在尾部，思路一致3. 根据先序遍历和后序遍历   + **单独依赖先序和后序遍历，无法唯一确定一棵二叉树**。如果只给出先序和后序遍历的结果，存在多个可能的二叉树结构。### 线索数1. 按中序遍历中序线索树   ```c++   //使用是current来记录下来当前节点   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::First() &#123;       while (current-&gt;leftThread==0)&#123;           current = current-&gt;leftchild;       &#125;       return current;//找中序遍历的第一个节点   &#125;   template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::Next() &#123;       ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;//可能是右子树的根节点，也可能是右链        if(current-&gt;rightThread==0)           while(p-&gt;leftThread==0)&#123;               //如果有右子树就要搜索到最左下部分               p=p-&gt;leftchlid;           &#125;       current=p;   &#125;   template&lt;class Type&gt; void ThreadInorderIterator&lt;Type&gt;:: Inorder() &#123;        ThreadNode&lt;Type&gt; *p;       for ( p=Frist(); p!=NULL; p=Next())            cout&lt;&lt; p-&gt;data &lt;&lt; endl;   &#125;\n\n\n\n\n构造中序线索树\n\n对已存在的一棵二叉树建立中序线索树\n\n在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱\n\n代码实现\nVoid Inthread(threadNode&lt;T&gt; * T) &#123;    stack &lt;threadNode &lt;T&gt;*&gt; s(10)    ThreadNode &lt;T&gt; *p = T ;    ThreadNode &lt;T&gt; *pre = NULL;    for (;;) &#123;        //查找到最左下部分的        while (p!=NULL) &#123;            s.push(p);            p = p -&gt;leftchild;        &#125;        //开始弹出栈        if (!s.IsEmpty())&#123;            p = s.pop;            if (pre != NULL) &#123;                //添加的代码，在这时候处理pre                if (pre -&gt;rightchild == NULL)&#123;                    pre -&gt;rightchild = p;                      pre -&gt;rightthread = 1;                &#125;                //处理p                if( p -&gt; leftchild == NULL) &#123;                    p -&gt; leftchild = pre;                    p -&gt;leftthread = 1;                &#125;//添加的代码            &#125;            pre = p ; //这里更新了pre            p = p -&gt; rightchild ;        &#125;        else return;    &#125;//for &#125;//建议把pre和p存储成全局变量\n\n\n\n霍夫曼树\n算法：\n\n从m个权值中找出两个最小值W1，W2构成\nW &#x3D; W1 + W2表示通过该节点的频度\n\n然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解\n\n\n\n当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15\n\n\n\n搜索树二叉搜索树\n二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：\n\n每一个元素有key值（关键码、主码），key值独一无二不重复\n一个树的左子树的关键字小于根中的关键字\n一个树的右子树的关键字大于根中的关键字\n根的左右子树还是二叉搜索树\n\n\n二叉搜索树可以在很大的数据量下，快速完成增删查改\n\n索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1\n\n方法实现\n// BinaryNode 类class BinaryNode &#123;    BinaryNode( Comparable theElement ) &#123;        this( theElement, null, null );//调用本类中的其他构造方法    &#125;    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;        element = theElement        left = lt;        right = rt;    &#125;    Comparable element;    BinaryNode left;    BinaryNode right;&#125;// 查找某元素private BinaryNode find( Comparable x, BinaryNode t ) &#123;    if( t == null )        return null;    if( x.compareTo( t.element ) &lt; 0 )        return find( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        return find( x, t.right );    else        return t;//Match &#125;//查找值最小的结点，找最大同理，往右找//使用递归查找结点private BinaryNode findMin( BinaryNode t ) &#123;      if( t == null )        return null;    else if( t.left == null )        return t;    return findMin( t.left );&#125;//迭代找最小结点private BinaryNode findMin(BinaryNode t)&#123;    if(t != null)&#123;        while(t.left != null)&#123;            t = t.left;        &#125;    &#125;    return t;&#125;//将数值插入固定位置的算法private BinaryNode insert( Comparable x, BinaryNode t ) &#123;    //先查找一次，如果找到了就不用进行查找    if( t == null )        t = new BinaryNode( x, null, null );    else if( x.compareTo( t.element ) &lt; 0 )        t.left = insert( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        t.right = insert( x, t.right );    else ;//duplicate; do nothing    return t;&#125;//compareTo()方法如果小于返回负数，大于返回正数\n\n// 删除/* * 如果结点本身不在树内，那么不需要删除 * 如果结点本身在树里面，删除需要分类 *  1.无子树:删除叶节点 *  2.一颗子树:直接连接 *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点 */private BinaryNode remove( Comparable x, BinaryNode t ) &#123;    if( t == null )        return t;    if( x.compareTo( t.element ) &lt; 0 )        t.left = remove( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        t.right = remove( x, t.right );    else if( t.left != null &amp;&amp; t.right != null ) &#123;        t.element = findMin( t.right ).element;//把右树最小的复制给t        t.right = remove( t.element , t.right );//递归的删除    &#125;else&#123;        t = ( t.left != null ) ? t.left : t.right;//一颗子树的情况    &#125;&#125;\n\n二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)\n\nBest Case：$O(log_2n)$\n最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去\n\n\n\n堆\n插入（进堆，上滤）\ntemplate&lt;class T&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: Insert(const T&amp; x)&#123;    if(CurrentSize= =MaxSize) throw NoMem();     int i= ++CurrentSize;    while(i!=1 &amp;&amp; x&gt;heap[i/2])&#123;        //0不使用        heap[i]=heap[i/2];        //不必每次都进行完全交换        i/=2;    &#125;    heap[i]=x;    return *this;&#125;\n\n\n\n删除（出堆、下滤）\ntemplate&lt;class T&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: DeleteMax(T&amp; x)&#123;    if(CurrentSize==0) throw OutOfBounds();     x = heap[1];    //0无存储，这个就是root结点    T y=heap[CurrentSize--];    int i=1;//i标向树根    ci=2;//ci先标到左子树    while(ci&lt;=CurrentSize)&#123;        if(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci+1])//如果ci未越界，并且左子树的值小于右子树的值。            ci++;//转向右子树        if(y&gt;=heap[ci]) break;        heap[i]=heap[ci];        i=ci;        ci*=2;    &#125;    heap[i]=y;//y是最后一个节点    return *this;&#125;    \n\n线性时间建堆\n\n步骤：\n\n先将n个元素按输入顺序存入，先满足完全二叉树的结构特性\n从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性\n\n\n代码\n//注意是对每个子树进行递归处理Template&lt;class T&gt; void MaxHeap&lt;T&gt;::Initialize (T a[],int size,int ArraySize) &#123;     delete[] heap;    heap=a;    CurrentSize=Size;    MaxSize=ArraySize;    for( int i=CurrentSize/2; i&gt;=1; i--) &#123;        T y=heap[i];        int c=2*i;        while(c &lt;= CurrentSize)&#123;            if(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c+1])                c++;            if(y&gt;=heap[c])                break;            heap[c/2] = heap[c];            c*=2;            //找到其子节点位置        &#125;        heap[c/2]=y;    &#125;&#125;\n\n如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)\n\n\n\n\n图邻接矩阵const int MaxNumEdges = 50// 最大边数const int MaxNumVertices = 10//最大顶点数 template&lt;class NameType, class DistType&gt; class Graph&#123;    private:        SeqList&lt;NameType&gt; VerticesList(MaxNumVertices) //顶点表        DistType Edge [MaxNumVertices] [MaxNumVertices]  //邻接矩阵，一定是方阵        int CurrentEdges;//当前边数        int FindVertex (Seqlist &lt;NameType&gt; &amp;L; const  NameType &amp;Vertex)            &#123;return L.Find(Vertex);&#125;        int GetVertexPos (const NameTyoe &amp;Vertex)            &#123;return FindVertex(VerticesList);&#125;// 给出了顶点Vertex在图中的位置    public:        Graph (const int sz=MaxNumEdges);         int GraphEmpty() const&#123;return VerticesList.IsEmpty();&#125;        int GraphFull() const&#123;return VerticesList.IsFull() || CurrentEdges= =MaxNumEdges;&#125;        int NumberofVertices()&#123;return VerticesList.last;&#125;        int NumberofEdges() &#123;return CurrentEdges;&#125;        NameType Getvalue(const int i) &#123;return  i&gt;=0 &amp;&amp; i&lt;VerticesList.last ? VerticesList.data[i] :  NULL;&#125;         DistType Getweight (const int v1,const int v2);                int GetFirstNeighbor(const int v);         int GetNextNeighbor(const int v1,const int v2);                void InsertVertex(const NameType &amp; Vertex);        void InsertEdge(const int v1,const int v2, DistType weight);        void removeVertex(const int v);        void removeEdge(cosnt int v1,const int v2);&#125; \n\n\n\n邻接表//邻接表的声明const int Defaultsize = 10;template &lt;class NameType，class DistType&gt; class Graph;template &lt;class DistType&gt; struct Edge &#123;       //边的定义     friend class Graph &lt;NameType,DistType&gt;;//友元函数    int dest;//边的另一顶点在顶点表中的位置     DistType cost;//边上的权    Edge&lt;DistType&gt; *link;//下一条边的链指针    Edge() &#123;&#125;    Edge(int D,DistType C):dest(D),cost(C),link(NULL)&#123;&#125;    int operate != (const Edge&lt;DistType&gt; &amp;E) const &#123;return dest != E.dest; &#125;&#125;template&lt;class NameType, class DistType&gt; struct Vertex &#123;    friend class Edge&lt;DistType&gt;;    friend class Graph&lt;NameType, DistType&gt;;     NameType data;//顶点名字    Edge&lt;DistType&gt; *adj;//出边表头指针&#125; \n\nkruskalpublic void kruskal() &#123;    int edgesAccepted;    DisjSet s;    priorityQueue h;    Vertex u, v;    SetType uset, vset;    Edge e;        h = readGraphIntoHeapArray( );    h.buildHeap() ;    s = new DisjSet( NUM_VERTICES );    edgesAccepted = 0 ;    while( edgesAccepted &lt; NUM_VERTICES – 1 )&#123;        e = h.deleteMin() ;//Edge e = (u, v)        uset = s. find(u);        vset = s.find(v);        if( uset != vset ) &#123;            edgesAccepted++;            s.union( uset, vset );        &#125;    &#125;&#125;\n\nPrimvoid graph&lt;string,float&gt;::Prim(MinSpanTree&amp;T)&#123;    int NumVertices=VerticesList.last;     float*lowcost=new float[NumVertices];     int * nearvex=new int[NumVertices];    for (int i=1;i&lt; NumVertices;i++) &#123;        lowcost[i] = Edge[0][i];//0到其他所有边的权值        nearvex[i]=0;    &#125;    nearvex[0]=-1;    MSTEdgeNode e;    for (int i=1; i&lt; NumVertices; i++) &#123;        float min=MAXINT;        int v=0;        for ( int j=1; j&lt; NumVertices; j++)            if(nearvex[j]!=-1&amp;&amp;lowcost[j]&lt;min) &#123;                v=j;                min=lowcost[j];            &#125; //for j,  选择最小的边        if(v) &#123;            e.tail=nearvex[v];            e.head=v;            e.cost=lowcost[v];            T.Insert(e);            //添加边进入最小生成树中去            nearvex[v]=-1;                        for(int j=1; j&lt; NumVertices; j++)                if( nearvex[j]!=-1 &amp;&amp; Edge[v][j]&lt;lowcost[j] ) &#123;                    lowcost[j]=Edge[v][j];                    nearvex[j]=v;                &#125;        &#125; //if    &#125; //for i&#125;\n\nDijkstraconst int NumVertices = 6;//大于所有边的权重的值class graph &#123;    private:        int Edge[NumVertices][NumVertices];         int dist[NumVertices];        int path[NumVertices];        int S[NumVertices];    public:        void shortestpath(int,int);&#125;;void Graph::shortestpath(int n,int v) &#123;      for( int i=0; i&lt;n; i++) &#123;        //v为当前节点，dist数组是表示距离的数组        //遍历n次        dist[i] = Edge[v][i];        s[i] = 0;        if( i!=v &amp;&amp; dist[i]&lt; MAXNUM )            path[i]= v;//如果可达，则用path数组记录下路径        else            path[i]=-1;//如果不可达，则用path数组记录下不可达(-1)        &#125;        s[v]=1;        dist[v]=0;        //表示访问过当前节点，并且距离为0        for( i=0; i&lt;n-1; i++) &#123;            float min=MAXNUM;            int u = v;            for( int j = 0;  j &lt; n;  j++)                if( !s[j] &amp;&amp; dist[j]&lt;min ) &#123;                    //如果结点j还没有访问过，并且dist[j]小于最小值                    u = j;                    min = dist[j];                &#125;            s[u]=1;            for ( int w=0; w&lt;n; w++)                // 若 dist[u] + Edge[u][w] &lt; dist[w]，则说明通过 u 更新路径更短，更新 dist[w] 和 path[w]。                if( !s[w] &amp;&amp; Edge[u][w] &lt; MAXNUM &amp;&amp; dist[u]+Edge[u][w] &lt; dist[w]) &#123;                    //dist[u]就是起点到u的距离，下面是关键条件                    dist[w]=dist[u]+Edge[u][w];                    path[w]=u;                &#125;        &#125;//for&#125;   \n\n排序归并排序\n迭代\npublic class MergeSort &#123;     // 迭代版的归并排序    public static void mergeSort(int[] list) &#123;        int n = list.length;        int[] tempList = new int[n];        int len = 1;                // 每次将len扩展，逐步合并        while (len &lt; n) &#123;            mergePass(list, tempList, len);            len *= 2;        &#125;    &#125;        // 合并函数，合并两个有序数组    private static void mergePass(int[] list, int[] tempList, int len) &#123;        int n = list.length;                // 以len为子数组的大小，进行合并        int i = 0;        while (i + len &lt; n) &#123;            merge(list, tempList, i, i + len, Math.min(i + 2 * len - 1, n - 1));//这里的数字看一下            i += 2 * len;        &#125;                // 处理剩余的部分        if (i + len &lt; n) &#123;            merge(list, tempList, i, i + len, n - 1);        &#125; else &#123;            // 若后半部分已经是有序的            for (int j = i; j &lt; n; j++) &#123;                tempList[j] = list[j];            &#125;        &#125;                // 将临时数组的内容复制回原数组        System.arraycopy(tempList, 0, list, 0, n);    &#125;    // 合并两个有序区间的函数    private static void merge(int[] list, int[] tempList, int left, int mid, int right) &#123;        int i = left, j = mid + 1, k = left;                // 合并两个子数组        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;            if (list[i] &lt;= list[j]) &#123;                tempList[k++] = list[i++];            &#125; else &#123;                tempList[k++] = list[j++];            &#125;        &#125;                // 复制剩余的部分        while (i &lt;= mid) &#123;            tempList[k++] = list[i++];        &#125;        while (j &lt;= right) &#123;            tempList[k++] = list[j++];        &#125;    &#125;&#125;\n\n\n\n递归\n//java递归实现public static void mergeSort( Comparable [ ] a ) &#123;    Comparable [ ] tmpArray = new Comparable[a.length];    mergeSort( a, tmpArray, 0, a.length – 1 );&#125;                            private static void mergeSort( Comparable [ ] a, Comparable [] tmpArray, int left, int right ) &#123;    if( left &lt; right ) &#123;        int center = ( left + right ) / 2;        mergeSort(a, tmparray, left, center );        mergeSort(a, tmpArray, center + 1, right );        merge( a, tmpArray, left, center + 1, right );    &#125;&#125;private static void merge( Comparable [ ] a, Comparable [] tmpArray, int leftPos, int rightPos, int rightEnd ) &#123;    int leftEnd = rightPos – 1;    int tmpPos = leftPos;    int numElements = rightEnd – leftPos + 1;    while( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )        if( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= 0 )            tmpArray[ tmpPos++ ] = a[ leftPos++ ];        else            tmpArray[ tmpPos++ ] = a[ rightPos++ ];    while( leftPos &lt;= leftEnd )        tmpArray[ tmpPos++ ] = a[ leftPos++ ];    while( rightpos &lt;= rightEnd)        tmpArray[ tmpPos++] = a[ rightpos++ ];    for( int i = 0; i &lt; numElements; i++, rightEnd-- )        a[ rightEnd ] = tmpArray[ rightEnd ];&#125;     \n\n复习期末重点第一章一、数据结构的定义（选择、填空）\n数据结构是指某一数据元素的集合与该集合中数据元素之间的关系\nData Structure &#x3D; {D，R}\nD is a data object\nR is a limited set of relationship of all the data members in D\n\n\n\n二、数据结构的逻辑结构与物理结构（理解即可）\n逻辑结构——从用户视图看，是面向问题的\n物理结构——从具体实现视图看，是面向计算机的\n\n三、ADT、OO不考，需要理解\nADT：abstract data types抽象数据类型\n\n将类型和有关操作封装在一起的数据模型\n思想：将数据类型的使用与它的表示（机内存储）、实现（机内操作的实现）分开。更确切的说，把一个数据类型的表示及在这个类型上的操作实现封装到一个程序模块中，用户不必知道它\n\n\nOO：object-oriented面向对象\n\nobject-oriented＝object＋class＋inherit＋communicate\n思想：封装、继承、多态，使得软件开发团队个成员能够不关心其他成员代码，二只关注接口（这块可以看软工一的板块，主要抓住这三个概念）\n\n\n\n四、算法概念（选择、填空）定义、五个性质\n算法是一个用来解决实际问题的计算机操作序列\n五个性质：\n明确的输入\n\n明确的输出\n\n确定性（definiteness）有明确的定义，每一个步骤都明确地定义\n\n可行性\n\n有穷性\n\n\n\n\n五、数学部分过一遍即可六、递归需要掌握（物理过程、逻辑过程）\n见下算法思想板块\n\n七、泛型不考\n第二章一、空间复杂度、时间复杂度概念\n空间复杂度：程序运行到完成所需要的内存量\n时间复杂度：程序运行到完成所需要的时间\n\n二、最好情况、最差情况、平均情况（等概率）\n平均情况：以等概率为前提 各情况求和取平均\n平均情况较难确定，一般将分析限制在最好和最坏情况中\n\n三、大O表示法（重点）\n为函数提供一个上界，算法复杂度量级的上界\n\n\n四、二分查找（过程+复杂度）\n$O(log_2n)$\n\n五、指定复杂度设计算法六、辗转相除（过程）public static long gcd( long m, long n ) &#123;       while( n != 0 ) &#123;            long rem = m % n;         m = n;         n = rem;     &#125;    return m;&#125;// 复杂度为O(logN)\n\n\n第三章（线性表） 一定有题一、ADT的基本操作（比如栈的进栈出栈peek）\n创建、查找、删除、插入、输出、得到长度、判断为空……\n代码实现基于ADT的物理实现\n数组实现：一整块连续内存，依次排放元素\n在这种情况下，查找操作复杂度为O(1)，但删除与插入操作为O(length)\n\n\n单链表实现：不要求连续内存，一个节点中存放一个数据，一个指针\n这样的物理实现，是的删除与插入的复杂度大大降低，具体内容在下一版块讨论\n\n\n\n\n\n二、单链表（带不带表头，一般不考双链表，循环链表一般不太考）\n一个问题：单链表带不带表头，表头节点是没有数据的，其指针指向list的第一个元素\n\n一些操作的实现\n\n删除操作：Delete(index, x)\n\n删除第一个节点：重新指向新的第一个节点\nfirst = first.next;// C++中需要delete掉被解引用的对象\n\n删除中间节点：先查询，后删除\nbefore = first.next; // 通过不断next，至要删除的节点前before.next = before.next.next;// C++中需要delete掉被解引用的对象\n\n\n插入操作：Insert(index, x)\n\n在线性表开头插入元素：先插入，后移动表头\nNode newNode = new Node(&#x27;f&#x27;, first);first = newNode;\n\n在线性表中间插入元素：先查询，后插入\nbefore = first.next; // 通过不断next，至要删除的节点前Node newNode = new Node(&#x27;f&#x27;,before.next);before.next = newNode;\n\n\n\n\njava实现（看一下PPT或者笔记，关注一些方法，尤其是指针操作）DataStructure包中有LinkedListItr类：代表游标位置\n\n双链表与循环链表看一下笔记\n\n\n三、例题过一遍（懂）\n多项式相加\n循环链表解约瑟夫问题\n最高效查找倒数第k个节点\n\n四、栈和队列（小重点）\n栈：LIFO，后进先出\n\n方法：push、pop\n\n可以用单链表（表头为栈顶）也可以用数组（最后一位做栈顶，记录）进行实现\n\n使用数组实现栈的时候，可能存在空间的浪费，如果只有两个栈时，可以使他们从数组的头尾向中间生长\n\n\n无论何种的实现，栈操作的复杂度都是O(1)\n\n例题：括号匹配、表达式计算、中缀和后缀表达式\n\n括号匹配（输出匹配的对）\n#include &lt;iostream.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;stack.h&quot;const int Maxlength = 100; // max expression lengthusing namespace std;void PrintMatchedPairs(char *expr) &#123;    Stack&lt;int&gt; s(Maxlength);    int j, length = strlen(expr);    for ( int i = l; i &lt;= length; i++) &#123;        if (expr[i-1]==&quot;(&quot;)            s.Add(i);        else if (expr[i-1]==&quot;)&quot;)            try &#123;                s.Delete(j);//进栈的是括号的位置                cout &lt;&lt; j &lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt; endl;&#125;            catch (OutOfBounds)                &#123;cout &lt;&lt; &quot;No match for right parenthesis&quot; &lt;&lt; &quot;at&quot;&lt;&lt; i &lt;&lt; endl;&#125;    &#125;    while ( !s.IsEmpty ())&#123;        s.Delete(j);        cout&lt;&lt; &quot;No match for left parenthesis at &quot; &lt;&lt; j &lt;&lt; endl;        &#125;&#125;void static main(void) &#123;    char expr[MaxLength];    cout&lt;&lt; &quot;type an expression of length at most&quot; &lt;&lt;MaxLength&lt;&lt;endl;    cin.getline(expr, MaxLength);    cout&lt;&lt;&quot;the pairs of matching parentheses in&quot;&lt;&lt;endl;    puts(expr);    cout&lt;&lt;&quot;are&quot;&lt;&lt;endl;    printMatcnedPairs(expr);&#125;//复杂度O(n)\n\n表达式计算看作业代码\n\n后缀转中缀看SpriCoder\n\n\n\n\n\n队列：FIFO，先进先出\n\n方法：add、delete\n\n实现：\n\n数组实现：记录首尾\n\n如果delete不进行左移，一段时间后，数组的前段会存在一段free space，如何更好地利用？\n\n\n如何实现环形数组？\n\n当首或尾达到theArray.length-1时，重置为0\nback = (back + 1) % theArray.length front = (front + 1) % theArray.length\n\n\n\n\n链表实现：两个指针记录首尾\n\n\n\n例题：杨辉三角、循环移动\n\n\n\n\n\n第四章（树）一、概念（填空选择）\n树：非线性的数据结构，是一个可以为空的节点集，有一个独立节点为root和多棵（可以为0）子树\n节点的度数：有多少个子节点\n树的度数：树中子节点的最大度数\nleaf叶节点：度数为0的节点\nbranch分支节点：度数不为0的节点\nlevel层数：根节点的层数为0（或规定为1），子节点的层数是其父节点层数+1\n树的高度：其节点的最大层数\n二叉树：每个节点度数为2，如果有子树，则子树均为二叉树（称为左右子树）\nn个节点的二叉树有n-1条边（n &gt;&#x3D; 1）\n第i层最多有2^i^个节点（根节点层数为0）\n高度为h的二叉树，最少有2h+1个节点，最多有2^h+1^-1个节点\n叶节点数量为n0，度数为2的节点数量为n2，则n0 &#x3D; n2 + 1\n有n个结点的二叉树的高度最大为n-1，最小为log2(n+1)(向上取整)-1\n\n\n满二叉树\n把二叉树排满，即如果高度为n，则其节点数为2^n+1^ - 1\n\n\n完全二叉树\n定义：假设我们为一个高度为h的满二叉树从上到下，从左到右使用1 - 2^h+1^的数字进行编码，删除编号为2^h+1^ - i（1 &lt;&#x3D; i &lt;&#x3D; k）的节点，得到一棵完全二叉树\n假设i,0&lt;&#x3D;i&lt;&#x3D;n-1，是一个确定二叉树的一个节点的编号\n如果i&#x3D;0，则是根节点，不然其父结点的编号为 (i-1)&#x2F;2(向下取整)\n如果2*i+1&gt;&#x3D;n，那么这个元素没有左子树，不然左子树的编号就是这个数字\n如果2*i+2&gt;&#x3D;n，那么这个元素没有右子树，不然右子树的编号就是这个数字\n\n\n\n\n完全二叉树和满二叉树是不同的，完全二叉树的最后一层可以不全满，但是必须从左开始顺序无空缺\n\n二、表示方式\n广义表不考\n双亲表示法见并查集\n左子女右兄弟（重点）\n用于遍历森林\n\n\nclass TreeNode{\n    T data;\n    TreeNode *firstchild, *nextsibling;\n}\nclass Tree{\n    TreeNode *root, *c\n} \n// 插入算法\ntemplate&lt;class T&gt;void Tree&lt;T&gt;::Insertchild(T value){\n    TreeNode&lt;T&gt;* newnode = new TreeNode&lt;T&gt;(value);\n    if(current-&gt;firstchild == NULL){\n        current-&gt;firstchild = newnode;\n    } else{\n        TreeNode&lt;T&gt; *p = current-&gt;firstchild;\n        while(p-&gt;nextsibling != NULL){\n            p = p-&gt;nextsibling;\n        }\n        p-&gt;nextsibling = newnode;\n    }\n}\n### 三、**树的遍历（重点）**+ #### 深度优先遍历  + ##### 前序VLR    ```C++    //递归实现先序遍历    template&lt;class T&gt;    void PreOrder(BinaryNode&lt;T&gt;* t) &#123;        // preorder traversal of *t.        if(t)&#123;            visit(t);            PreOrder(t-&gt;Left);            PreOrder(t-&gt;Right);        &#125;    &#125;\n\n\n中序LVR//基于栈实现非递归中序遍历//非递归使用stack实现中序遍历void Inorder(BinaryNode &lt;T&gt;*t)&#123;      Stack&lt;BinaryNode&lt;T&gt;*&gt; s(10);    BinaryNode&lt;T&gt;*p = t;    for (;;)&#123;        //无条件进行循环        while(p!=NULL)&#123;            //一直进行压栈，直到最左下部分            s.push(p);            p = p-&gt;Left;        &#125;        if(!s.IsEmpty())&#123;            //出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。            p = s.pop();            cout &lt;&lt; p-&gt;element;            p = p-&gt;Right;        &#125;else            return;    &#125;&#125;\n\n后序LRV//非递归实现后序遍历//结点的实现struct StkNode &#123;    BinaryNode &lt;T&gt; * ptr;    int tag;//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.&#125;//非递归实现后序遍历void Postorder(BinaryNode &lt;T&gt; * t) &#123;    Stack &lt;StkNode&lt;T&gt;&gt; s(10);    StkNode&lt;T&gt; Cnode;    BinaryNode&lt;T&gt;*p = t;    for(;;) &#123;        //优先访问到最左下        while (p!=NULL)&#123;            Cnode.ptr = p;            Cnode.tag = 0;            s.push(Cnode);            p = p-&gt;Left;        &#125;        //将最左下结点出栈        Cnode = s.pop();        p = Cnode.ptr;        while (Cnode.tag == 1)//从右子树回来         &#123;            //如果已经被访问一次了才进行输出            cout &lt;&lt; p-&gt;element;            if (!s.IsEmpty())&#123;                Cnode = s.pop();                p = Cnode.ptr;            &#125;else&#123;                //访问结束                return;            &#125;           &#125;        Cnode.tag = 1;//从左子树遍历完，而右子树还没有动。        s.push(Cnode);        p = p-&gt;Right;//从左子树回来    &#125;//for&#125;      \n\n另外，非二叉树：\n\n先根：与原树的左子女右兄弟表示法的先序一致\n后根：与原树的左子女右兄弟表示法的中序一致\n\n\n\n\n广度优先遍历（分层访问）//基于栈实现层次访问public static void levelTravel(Node root)&#123;    if (root == null) return;    Queue&lt;Node&gt; q=new LinkedList&lt;Node&gt;();    q.add(root);    while(!q.isEmpty())&#123;        Node temp = q.poll();        System.out.println(temp.value);        if(temp.left!=null) q.add(temp.left);        if(temp.right!=null) q.add(temp.right);    &#125;&#125;\n\n森林的遍历\n将森林转换为二叉树，每棵树表示为左子女右兄弟，后把它们用右链相连\n先根次序遍历： \n访问F的第一棵树的根 \n按先根遍历第一棵树的子树森林 \n按先根遍历其它树组成的森林\n等于二叉树的先序\n\n\n中根次序遍历： \n按中根遍历第一棵树的子树森林 \n访问F的第一棵树的根 \n按中根遍历其它树组成的森林\n等于二叉树的中序\n\n\n\n\n后根次序遍历： \n按后根遍历第一棵树的子树森林 \n按后根遍历其它树组成的森林 \n访问F的第一棵树的根\n等于二叉树的后序\n\n\n\n\n\n补、根据前中后序表达式建树\n根据先序遍历和中序遍历\n\n先序遍历的第一个一定是树根，然后在中序遍历中找到树根，由此确定左右子树\n\nC++实现（java实现看作业4.0）\n//是一个递归算法BinaryNode&lt;Type&gt;*void CreateBT (String pres, ins) &#123;    int inpos;    BinaryNode &lt;Type&gt;* temp;//当前二叉树的节点    String prestemp, instemp;    if (pres.length()==0) return NULL;    else &#123;        temp = new BinaryNode;         temp-&gt;element=pres.ch[0];        inpos=0;        //从中序遍历中找到根节点的位置，这样子根节点左侧的是左子树，右侧的是右子树        while (ins.ch[inpos]!=temp-&gt;element)             inpos++;                prestemp = pres(1,inpos);//小括号是重载的，将先序遍历字符串的1到inpos取出来，赋给中间变量        instemp= ins(0,inpos-1);        temp-&gt;left = CreateBT(prestemp, instemp);                prestemp=pres(inpos+1, pres.length()-1);        instemp=ins(inpos+1, pres.length()-1);        temp-&gt;right = CreateBT(prestemp, instemp);        return temp;//完成组装返回    &#125; &#125;\n\n\n根据中序遍历和后序遍历\n\n后序遍历树根在尾部，思路一致\n\n\n根据先序遍历和后序遍历\n\n先序遍历第二个位置是左子树的根，在后序遍历中，它是左右子树的分界点\n\n\n\n四、线索化二叉树（常考）\n目的：为了让二叉树的遍历更快\n\n结构：在树的节点中加入一个指针\n\n指针放在哪？——n个节点有2n个链域，期中只有n-1个有用，剩余均为空域。\n\n\n机内存储\n\n一个节点增加两个标记域\n\n\n\nleftchild\nleftthread\ndata\nrightthread\nrightchild\n\n\n\n\nleftthread与rightthread为bool型，用于表示leftchild与rightchild指向子女还是前驱（后继）\n\n\n\n\n几个算法\n\n按中序遍历中序线索树\n\n找到中序下的第一个节点（first），不断找后继（next）\n\np指节点没有右子树（p-&gt;rightthread &#x3D;&#x3D; 1），则rightchild就是后继\np指节点有右子树（p-&gt;rightthread &#x3D;&#x3D; 0），则去找右子树的第一个节点\n\n\n代码实现\n//使用是current来记录下来当前节点template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::First() &#123;    while (current-&gt;leftThread==0)&#123;        current = current-&gt;leftchild;    &#125;    return current;//找中序遍历的第一个节点&#125;template&lt;class Type&gt; ThreadNode&lt;Type&gt;* ThreadInorderIterator&lt;Type&gt;::Next() &#123;    ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;//可能是右子树的根节点，也可能是右链     if(current-&gt;rightThread==0)        while(p-&gt;leftThread==0)&#123;            //如果有右子树就要搜索到最左下部分            p=p-&gt;leftchlid;        &#125;    current=p;&#125;template&lt;class Type&gt; void ThreadInorderIterator&lt;Type&gt;:: Inorder() &#123;     ThreadNode&lt;Type&gt; *p;    for ( p=Frist(); p!=NULL; p=Next())         cout&lt;&lt; p-&gt;data &lt;&lt; endl;&#125;\n\n\n构造中序线索树\n\n对已存在的一棵二叉树建立中序线索树\n\n在中序遍历的过程中，填充左空域、右空域的指针。故还需要一个pre指针，总指向遍历指针p的中序前驱\n\n代码实现\nVoid Inthread(threadNode&lt;T&gt; * T) &#123;    stack &lt;threadNode &lt;T&gt;*&gt; s(10)    ThreadNode &lt;T&gt; *p = T ;    ThreadNode &lt;T&gt; *pre = NULL;    for (;;) &#123;        //查找到最左下部分的        while (p!=NULL) &#123;            s.push(p);            p = p -&gt;leftchild;        &#125;        //开始弹出栈        if (!s.IsEmpty())&#123;            p = s.pop;            if (pre != NULL) &#123;                //添加的代码，在这时候处理pre                if (pre -&gt;rightchild == NULL)&#123;                    pre -&gt;rightchild = p;                      pre -&gt;rightthread = 1;                &#125;                //处理p                if( p -&gt; leftchild == NULL) &#123;                    p -&gt; leftchild = pre;                    p -&gt;leftthread = 1;                &#125;//添加的代码            &#125;            pre = p ;            p = p -&gt; rightchild ;        &#125;        else return;    &#125;//for &#125;//建议把pre和p存储成全局变量\n\n\n\n\n\n五、霍夫曼树（小结构，还有散列表优先级队列，并查集，交替考）\n一些概念：\n\n增长树：原二叉树中度为1的节点，增加一个空树叶；元二叉树中的树叶，增加两个空树叶\n外通路长度（外路径）E：根到每个外节点（增长树的叶）的路径长度的总和\n内通路长度（内路径）I：更到每个内节点（增长树的非叶）的路径长度总和\n节点的带权路径长度：一个节点的权值与节点的路径长度的乘积\n带权的外路径长度：各叶节点的带权路径长度之和\n带权的内路径长度：各非叶节点的带权路径长度之和\n\n\n霍夫曼树\n\n给出m个实数W1，W2，…，Wm（m&gt;&#x3D;2）作为m个外节点的权构造一颗增长树，是的带权外路径长度最小\n\n\n霍夫曼算法：\n\n思想：权大的外节点靠近根，权小的远离根\n\n算法：\n\n从m个权值中找出两个最小值W1，W2构成\n\n\nW &#x3D; W1 + W2表示通过该节点的频度\n\n然后对m-1个权值W，W3，W4，…，Wm经由小到大排序，求解\n\n\n\n当内结点的权值与外结点的权值相等的情况下， 内结点应排在外结点之后。除了保证带权外路径长度最小外，还保证外通路长之和也有最小值。例如: 7, 8, 9,15\n\n\n\n\n霍夫曼编码：\n\n利用Huffman算法， 把各字符出现的频率作为外部结点的权， 构造具有最小带权外路径长度的增长树，把每个结点的左子女的边标上0， 右子女标上1。 这样从根到每个叶子的路径上的号码连接起来， 就是外结点的字符编码\n使得电文总长度最小，并且任意字符的编码不是其他字符的前缀（不相互干扰）\n\n\n\n六、搜索树（AVL树常考，B树常考）各个算法与操作的复杂度，算法流程6.1 二叉搜索树\n二叉搜索树是一个可以为空。一个非空的二叉树都满足如下性质：\n\n每一个元素有key值（关键码、主码），key值独一无二不重复\n一个树的左子树的关键字小于根中的关键字\n一个树的右子树的关键字大于根中的关键字\n根的左右子树还是二叉搜索树\n\n\n二叉搜索树可以在很大的数据量下，快速完成增删查改\n\n索引二叉搜索树：在二叉搜索树的基础上，增加leftSize，leftSize &#x3D; 左子树元素个数+1\n\n方法实现\n// BinaryNode 类class BinaryNode &#123;    BinaryNode( Comparable theElement ) &#123;        this( theElement, null, null );//调用本类中的其他构造方法    &#125;    BinaryNode( Comparable  theElement, BinaryNode lt, BinaryNode rt ) &#123;        element = theElement        left = lt;        right = rt;    &#125;    Comparable element;    BinaryNode left;    BinaryNode right;&#125;// 查找某元素private BinaryNode find( Comparable x, BinaryNode t ) &#123;    if( t == null )        return null;    if( x.compareTo( t.element ) &lt; 0 )        return find( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        return find( x, t.right );    else        return t;//Match &#125;//查找值最小的结点，找最大同理，往右找//使用递归查找结点private BinaryNode findMin( BinaryNode t ) &#123;      if( t == null )        return null;    else if( t.left == null )        return t;    return findMin( t.left );&#125;//迭代找最小结点private BinaryNode findMin(BinaryNode t)&#123;    if(t != null)&#123;        while(t.left != null)&#123;            t = t.left;        &#125;    &#125;    return t;&#125;//将数值插入固定位置的算法private BinaryNode insert( Comparable x, BinaryNode t ) &#123;    //先查找一次，如果找到了就不用进行查找    if( t == null )        t = new BinaryNode( x, null, null );    else if( x.compareTo( t.element ) &lt; 0 )        t.left = insert( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        t.right = insert( x, t.right );    else ;//duplicate; do nothing    return t;&#125;//compareTo()方法如果小于返回负数，大于返回正数\n\n// 删除/* * 如果结点本身不在树内，那么不需要删除 * 如果结点本身在树里面，删除需要分类 *  1.无子树:删除叶节点 *  2.一颗子树:直接连接 *  3.两颗子树:可以选择左子树的最大结点（或右子树的最小节点）作为新结点 */private BinaryNode remove( Comparable x, BinaryNode t ) &#123;    if( t == null )        return t;    if( x.compareTo( t.element ) &lt; 0 )        t.left = remove( x, t.left );    else if( x.compareTo( t.element ) &gt; 0 )        t.right = remove( x, t.right );    else if( t.left != null &amp;&amp; t.right != null ) &#123;        t.element = findMin( t.right ).element;//把右树最小的复制给t        t.right = remove( t.element , t.right );//递归的删除    &#125;else&#123;        t = ( t.left != null ) ? t.left : t.right;//一颗子树的情况    &#125;&#125;\n\n二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)\n\nBest Case：$O(log_2n)$\n最坏的情况：把一个有序的数列添加进入到空的二叉搜索树中去\n\n\n\n6.2 AVL树\n自平衡的二叉搜索树\n始终保持高度是数据量的对数，目的是为了降低增删改查的复杂度\n定义：是一棵二叉搜索树；对于任意一个节点为树根，其左子树与右子树的高度差不能超过1\n结构：\n多一个元素，记录树高度，或者平衡因子（两子树高度差）\n\n\n\n方法（具体看笔记C6-搜索树）：\n查询：与正常二叉搜索树相同\n插入：外增高，单旋（左外增则右下旋）；内增高，双旋（左内增则先左下旋后右下旋）看清楚对谁而言的内外与左右\n删除：与二叉搜索树删除相同，再检查平衡因子，进行旋转\n\n\n算法分析：\n具有n个结点的平衡二叉树（AVL），进行一次插入或删除的时间最坏情况 &lt;&#x3D; O(log2 n)\n\n\n\n6.3 m叉搜索树\nm叉搜索树可能为空，非空m叉搜索树满足如下属性：\n\nm路搜索树每个节点里最多有m-1个值和m个索引\n\n每个具有p元素的节点正好有p+1个子节点\n\n\n\n假设任何节点都有p个元素，那么C0 - Cp是他们对应的p+1个子节点\n\n\n对于节点（以上为例）\n\n在以C0为根的所有子树中的结点的值都小于k1\n在以Cp为根的子树中的所有子树的值都大于kp\n在以Ci为根的子树中的所有子树的值都在ki与ki+1之间\n\n\n\n\n为什么选择m叉搜索树？\n\n复杂度（高度）进一步减小\nm叉搜索树是可以存入磁盘的，增删改查任意一个数据，只需要访问高度次磁盘\n\n\n操作（具体看笔记C6-搜索树）：\n\n插入：未满同级插，已满下级插\n删除：删完不空直接删，删完空了下上提\n\n\n行高：\n\n一个高为h的m路搜索树最少有h个结点(每一层只有一个结点)，最多有m^h^-1个结点\nn个节点的m路搜索树高度在logm(n+1)和n之间\n\n\n\n6.4 B树\n平衡的m路搜索树\n\n在m路搜索树的基础上，非空B树有以下扩展属性\n\n每个根结点至少有两个子女\n所有内节点都至少有m&#x2F;2(向上取整)个子结点\n所有的外节点必须都在同一层（所有子树高度一样高）\n外部节点的个数等于关键字数+1\n\n\n操作：\n\n搜索：与m路搜索数相同，与树高有关，一个m节有n个节点的树，高度在logm(n+1)与1+log⌈m&#x2F;2⌉(n+1)&#x2F;2之间\n\n\n插入：\n\n算法思想\n如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序\n否则的话这一节点已经满了，将它平均地分裂成两个节点：\n从该节点的原有元素和新的元素中选择出中位数\n小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值\n分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）\n\n\n\n\n算法分析：如果操作导致s个节点分裂，那么磁盘查找次数为：h+2s+1\nh为在搜索路径上的读操作；2s为写出两个新节点操作；1为新节点（可能是创建的新根，也可能是最终一个节点被修改）\n\n\n\n\n删除：\n\n算法思想：\n\n如果要删除的关键码不在B数中，则直接退出\n\n如果要删除的关键码在外部节点：\n\n如果删除后节点仍有超过⌈m&#x2F;2⌉个节点，则直接删除\n\n如果不足，则需要向邻居借关键码：\n\n\n\n邻居够借（进行调整）\n邻居不够借（与邻居合并，导致上级节点关键码减少，再借或合并）\n\n\n\n注意：相当于根节点与被借节点的一次旋转\n删除后“367 379 389 401 419 439”为新节点，但“283 353”出现不足，再求助与邻居\n\n\n\n\n\n如果要删除的关键码在非叶节点：\n\n删除这个节点\n把这个节点替换成右子树中的最小关键码(或者左子树中的最大关键码)\n因为相当于删除了右子树的最小关键码(或者左子树中的最大关键码)，所以重复删除叶结点关键码的操作。\n\n\n\n\n\n\n\n\n\n\n第五章（散列表）一、散列函数\n散列函数是为了将增删改查的复杂度降低至常数，代价是特别浪费空间\n\n负载因子与再散列：\n\n为了减少冲突处理的次数，哈希表一般都是稀疏的。我们记整个哈希表容量为$n$，负载因子为$\\alpha$，则一旦哈希表内数据量达到$n\\alpha$，我们就需要扩充表容量了，这叫再散列\n再散列：\n尽量保证表项数&gt;表的70%，也就是意味着如果不满足，就需要进行再散列\n取比原表长*2大的指数再散列\n\n\n\n\n取余法（大部分情况下）：\n\nH(key) = key % M，M取小于基本区长度的最大质数\n\n\n平方取余法\n\nH(key) = key * key的中间部分\n\n\n乘法杂凑函数\n\n\n二、冲突处理\n碰撞的两个（或多个）关键码称为同义词，即H(k1) &#x3D; H(k2)，k1 不等于 k2\n开放地址的线性探测法\n方法：如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会按照线性顺序向后成环形查找\n带来几个问题：\n散列表越满，查找的复杂度可能越高，需要更多的遍历\n堆积问题：指不同的同义词表合为一张了。从而增加了插入，查找的时间\n删除问题：不能进行真删除，会截断环型查找，而是通过标记表示数据无效\n\n\n\n\n二次探测很少考\n如果key的哈希值是d，并且d对应的位置已经被占据，然后我们会检查d+1，d+4，d+9，…的位置\n\n\n双散列（有时考）\n如果k的第一哈希值为d，而这个对应的格子已经被占用则我们继续计算k的第二哈希值，然后检查d+c…\n第一个散列函数发生冲突，那么使用第二个散列函数来放置，如果再次冲突则进行相应探测\n\n\n\n三、分离链接\n冲突了拖个链表，查找的时候需要遍历对应链表\n\n四、应用环境下发现其应用\n一般是元素本身可以提取出一个关键码，并且有需求实现快速增删改查的场景下\n\n上段代码实现\n// C++的线性探测法实现template&lt;class E,class K&gt;// 假设每一元素的类型为E，并且有一个类型为k的关键码class HashTable&#123;     public:        HashTable(int divisor = 11);        ~HashTable()&#123;            delete[]ht;            delete []empty;        &#125;        bool Search(const K&amp;k ,E&amp; e)const;         HashTable&lt;E,K&gt;&amp;Insert(const E&amp;e);    private:        int hSearch(const K&amp; k)const;        int D;//hash function divisor        E *ht ; //hash table array        bool *empty ; //1D array，为了实现标记删除&#125;;//hashtable的构造方法template&lt;class E,class K&gt;//E和K需要被实例化后，这个类才能被调用。HashTable&lt;E,K&gt;::HashTable(int divisor)&#123;    D = divisor;    ht = new E[D];    empty= new bool[D];    for(int i=0;i&lt;D;i++)        empty[i] = true;&#125;template&lt;class E,class K&gt;int HashTable&lt;E,K&gt;::hSearch(const K&amp;k)const &#123;    int i= k % D;//home bucket    int j= i ; //start at home bucket    do &#123;        if(empty[j] || ht[j]==k) return j;//fit        j=(j+1)%D; //next bucket，%D是为了实现环型遍历    &#125; while(j!= i);  //returned to home?是否循环完成一遍    return j; //table full;&#125;//参数进行引用K&amp;ktemplate&lt;class E,class K&gt;bool HashTable&lt;E,K&gt;::Search(const K&amp;k,E&amp;e)const&#123;    //put element that matches k in e.    //return false if no match.    int b= hSearch(k);    if(empty[b]||ht[b].key!=k)return false;    e=ht[b];    return true;&#125;template&lt;class E,class K&gt;HashTable&lt;E,K&gt;&amp; HashTable&lt;E,K&gt;::Insert(const E&amp; e) &#123;     K k=e.key;//extract key     int b=hSearch(k);     if(empty[b])&#123;        empty[b]=false;        ht[b]=e;        return *this;    &#125;    throw NoMem();  //table full&#125;\n\n\n java二次探测与分离链接实现去看SpriCoder\n\n\n\n\n第六章（优先级队列）\n一个优先级队列是0个或者更多元素的集合，每一个元素都有一个优先级或者值\n分为最大和最小优先级队列：删除（出列）优先删除优先级最大（小）的元素\n\n一、堆（上滤下滤进堆出堆）过程复杂度，线性时间建堆\n最大优先级队列——最大堆，最小优先级队列——最小堆\n最大堆是一棵完全二叉树，每一个节点上的值都大于或等于它的子节点\n\n1.1 插入（进堆、上滤）\n算法思想：在树最后插入后，与父节点进行比较，如果比父节点大，则交换，一直到不再大于父节点\n\n复杂度分析：log2(n)\n\n代码实现\ntemplate&lt;class T&gt;MaxHeap&lt;T&gt;&amp; MaxHeap&lt;T&gt;:: Insert(const T&amp; x)&#123;    if(CurrentSize= =MaxSize) throw NoMem();     int i= ++CurrentSize;    while(i!=1 &amp;&amp; x&gt;heap[i/2])&#123;        //0不使用        heap[i]=heap[i/2];        //不必每次都进行完全交换        i/=2;    &#125;    heap[i]=x;    return *this;&#125;\n\n1.2 删除（出堆、下滤）\n算法思想：将根删除，将树最后一个节点换为根，然后进行下滤操作\n\n复杂度分析：log2(n)\n\ntemplate&lt;class T&gt;MaxHeap&lt;T&gt;&amp;  MaxHeap&lt;T&gt;:: DeleteMax(T&amp; x)&#123;    if(CurrentSize==0) throw OutOfBounds();     x = heap[1];    //0无存储，这个就是root结点    T y=heap[CurrentSize--];    int i=1;//i标向树根    ci=2;//ci先标到左子树    while(ci&lt;=CurrentSize)&#123;        if(ci&lt;CurrentSize &amp;&amp; heap[ci]&lt;heap[ci+1])//如果ci未越界，并且左子树的值小于右子树的值。            ci++;//转向右子树        if(y&gt;=heap[ci]) break;        heap[i]=heap[ci];        i=ci;        ci*=2;    &#125;    heap[i]=y;//y是最后一个节点    return *this;&#125;    \n\n1.3 线性时间建堆\n步骤：\n\n先将n个元素按输入顺序存入，先满足完全二叉树的结构特性\n从最后一个节点的父节点开始对其之前的每个节点进行下滤操作，来满足最大堆的有序性\n\n\n代码\n//注意是对每个子树进行递归处理Template&lt;class T&gt; void MaxHeap&lt;T&gt;::Initialize (T a[],int size,int ArraySize) &#123;     delete[] heap;    heap=a;    CurrentSize=Size;    MaxSize=ArraySize;    for( int i=CurrentSize/2; i&gt;=1; i--) &#123;        T y=heap[i];        int c=2*i;        while(c &lt;= CurrentSize)&#123;            if(c&lt;CurrentSize &amp;&amp; heap[c]&lt;heap[c+1])                c++;            if(y&gt;=heap[c])                break;            heap[c/2] = heap[c];            c*=2;            //找到其子节点位置        &#125;        heap[c/2]=y;    &#125;&#125;\n\n算法分析：\n\n\n\n如果按输入顺序把n个元素依次插入最大堆，则复杂度为O(nlgn)\n\n\n\n\n第七章（并查集）一、并查集功能（Union、Find）\nCombine：合并包含元素a和b的两个等价类为一个等价类\n\nCombine(a, b) ：i = Find(a); j = Find(b); if(i != j) Union(i, j);\n\n并查集的实现通过森林（下图是union(1,5)的实现，parent数组存放节点的父节点）\n\n\n\n\n\n\n\n\n\n\n\nFind：找到包含元素e的等价类\n\n代码实现\n//simple tree solution to union-find problem //使用简单的树结构解决并集的查找问题void Initialize(int n)&#123;    parent=new int[n+1];    for(int e=1;e&lt;=n;e++) parent[e]=0;&#125;int Find(int e) &#123;    //向上找到其根结点    while(parent[e]) e=parent[e];    return e;&#125;void Union(int i, int j) &#123;    //合并两个结点    parent[j]=i;&#125; \n\n性能估计\n\nFind——O(n)，n为树高\nUnion——$\\theta$(1)\n\n\n性能提升\n\n优化Union\n\n方法一：（权值规则）节点数少的树挂到节点数多的树下\n\n如何记录weight？新建一个bool类型数组表示是否为根节点，如果为根，则其父节点字段记录书中节点总数（如何省略标记根的数组？——用负数来表示）\n// 加入上两条优化//Union with the weight rulevoid Initialize(int n) &#123;    root=new bool[n+1];    parent=new int[n+1];    for(int e=1;e&lt;=n;e++) &#123;        parent[e]=1;        root[e]=true;    &#125;&#125;int Find(int e) &#123;    while(!root[e])        e=parent[e];    return e;&#125;void Union(int i, int j) &#123;    if(parent[i]&lt;parent[j])    //i becomes subtree of j    &#123;        parent[j]=parent[j]+parent[i];        root[i]=false;        parent[i]=j;    &#125; else &#123;        parent[i]=parent[i]+parent[j];        root[j]=false;        parent[j]=i;    &#125;&#125;\n\n\n方法二：（高度规则）高度低的树挂到高度高的树的下\n\n\n\n优化Find\n\n如果路径上的点父节点非根节点，则将其与根节点相连\n\n\n\nint Find(int e) {\n    /* C++ */\n    int j = e;\n    while(!root[j])\n        j=parent[j];\n    int f = e;\n    while(f!=j) {\n        int pf = parent[f];\n        parent[f] = j;\n        f = pf;\n    }\n}\n### 二、一般和最小生成树算法一起考（kruskal算法）---## 第八章（图）### 一、概念（选择填空）+ Graph = (V, E)，顶点集+边集+ 有向图与无向图，完全与否+ 度数：连到这个顶点的边的数量，有向图有出度与入度之分，所有顶点度数之和为边的两倍+ 子图：图 G=(V, E) 和图 G&#x27;=(V&#x27;, E&#x27;) ，如果V&#x27;包含于V，E’包含于E,并且E&#x27;中顶点的边也在G&#x27;中，那么G&#x27;是G的子图+ 路径：在图 G= (V, E)中，如果边(i~j~，i~j+1~)都在E中，1&lt;= j&lt; k，则顶点序列P=i~1~，i~2~，…,i~k~是i~1~到i~k~的路径  + 简单路径：路径除了第一个和最后一个顶点没有出现相同的顶点  + 环：起点和终点相同的简单路径+ 连通图：无向图中任意两个点是连通的，则为连通图+ 强连通图：有向图中，每对不同的顶点i, j，包含从i到j和从j到i的有向路径是，则为强联通图+ 加权图：边被分配权值+ 生成树：对于连通图来说，是其极小连通子图；n顶点的生成树有n-1条边### 二、邻接矩阵、邻接表掌握，邻接多重表不要求#### 2.1 邻接矩阵&lt;img src=&quot;C:\\Users\\User\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221130091646130.png&quot; alt=&quot;image-20221130091646130&quot; style=&quot;zoom:60%;float:left&quot; /&gt;+ 无向图的邻接矩阵：对称的、对角线为0（无自环）、度数等于对应行的和+ 有向图的邻接矩阵：行为起点，列为终点、出度对行求和，入度对列求和+ 加权图的邻接矩阵：  &lt;img src=&quot;C:\\Users\\User\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221130093426305.png&quot; alt=&quot;image-20221130093426305&quot; style=&quot;zoom:80%;float:left&quot; /&gt;#### 2.2 邻接表+ &lt;img src=&quot;C:\\Users\\User\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221130093948312.png&quot; alt=&quot;image-20221130093948312&quot; style=&quot;zoom:57%;float:left&quot; /&gt;  &lt;img src=&quot;C:\\Users\\User\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221130094057188.png&quot; alt=&quot;image-20221130094057188&quot; style=&quot;zoom:60%;float:left&quot; /&gt;+ 代码看notes### 三、最小生成树（2个）算法掌握，流程复杂度清晰### 四、最小路径（3个）算法掌握，流程复杂度清晰### 五、活动网络常考（AOV拓扑排序，AOE关键路径）流程复杂度+ 上三个看notes---## 排序算法+ 流程+ 看代码（无代码不看代码）+ 复杂度+ 性质要求的+ 折半插入排序不做重点+ **快排**重点+ 锦标赛排序考得不多+ **选择排序**+ **堆排序**+ 堆排序注意其是一个固定算法，不额外占用空间+ **归并排序**### 一、PPT**最后的表格**| 排序方法        | 比较次数     | 平均比较次数 | 稳定性 | 移动次数     | 辅助存储    || --------------- | ------------ | ------------ | ------ | ------------ | ----------- || **1、插入排序** |              |              |        |              |             || 直接插入排序    | n~n^2^/2     | $O(n^2)$     | 稳定   | 2n~n^2^/2    | $O(1)$      || 二分法插入排序  | nlog~2~n     | $O(nlog_2n)$ | 稳定   | 2n~n^2^/2    | $O(1)$      || 表插入排序      | n~n^2^/2     | $O(n^2)$     | 稳定   | 0            | $O(n)$      || shell排序       |              |              | 不稳定 |              | $O(1)$      || **2、选择排序** |              |              |        |              |             || 直接选择排序    | n(n-1)/2     | $O(n^2)$     | 不稳定 | 3*(n-1)      | $O(1)$      || 堆排序          | $O(nlog_2n)$ | $O(nlog_2n)$ | 不稳定 |              | $O(1)$      || **3、交换排序** |              |              |        |              |             || 冒泡排序        | n-1          | $O(n^2)$     | 稳定   | 0~3/2*n(n-1) | $O(1)$      || 快排            | nlog~2~n     | $O(nlog_2n)$ | 不稳定 | &lt;=nlog~2~n   | $O(log_2n)$ || **4、分配排序** |              |              |        |              |             || 基数排序        | $O(d*(n+r))$ | $O(d*(n+r))$ | 稳定   | 拉链         | $O(n+r)$    || **5、归并排序** |              |              |        |              |             || 归并排序        | $O(nlog_2n)$ | $O(nlog_2n)$ | 稳定   |              | $O(n)$      |### 二、快排+ 方法：在n个对象中，取一个对象（如第一个对象）为基准pivot，按该对象的关键码把所有不大于该关键码的对象划在它的左边，大于该关键码的对象划到它右边；然后对于左右两个子序列再进行快排+ 注意这里的划分方法：PPT中采用两个指针，交换基准数与非序数（自己起的名字）来实现，直到两指针都指向基准数+ ```c++  template &lt;class Type&gt; void QuickSort( datalist &lt;Type&gt;&amp; list, const int left,  const int right ) &#123;      if (left&lt;right) &#123;          int pivotpos = partition(list, left, right);          QuickSort(list, left, pivotpos-1);          QuickSort(list, pivotpos+1, right);      &#125;  &#125;  //partition  template &lt;class Type&gt; int partition(datalist&lt;Type&gt; &amp;list, const int low, const int high) &#123;      int i=low,j=high;      Element&lt;Type&gt;pivot=list.Vector[low];      while (i != j ) &#123;          while(list.Vector[j].getkey()&gt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;              j--;          &#125;          if (i&lt;j) &#123;              list.Vector[i]=list.Vector[j];              i++;          &#125;          while(list.Vector[i].getkey()&lt;pivot.getkey( ) &amp;&amp; i&lt;j)&#123;              i++;          &#125;          if (i&lt;j) &#123;              list.Vector[j]=list.Vector[i];              j--;          &#125;      &#125;      list.Vector[i]=pivot;      return i;  &#125;\n\n\n\n\n\n\n时间复杂度$O(nlog_2n)$\n\n空间复杂度：非递归算法需要使用栈来存放左部或右部的上下界的下标:$O(log_2n)$ ~ $O(n)$\n\n选择pivot：三数中值分割法（左端、右端和中心三个元素的中值为枢纽元）\n\n将枢纽元放在数组的末尾（倒数第二个位置，因为最后的值确定比枢纽元大）\n三数中值分隔法\n\n\n\n三、选择排序\n方法：每次都选出一个最大（小）值，将其放到数组最前\n\npublic static void SelectionSort(int [] a, int n) &#123;    //sort the n number in a[0:n-1].    //找到大数字放置到后面    for(int size = n; size&gt;1; size--)&#123;        int j = Max(a,size);        swap(a[j],a[size-1]);    &#125;&#125; \n\n算法分析：\n\n比较次数，固定为n(n-1)&#x2F;2\n移动次数，固定为3*(n-1)，每次swap有3次操作\n$O(n^2)$\n\n\n\n四、堆排序\n是固定的算法\n\n方法：一开始先建立最大堆，最后调整为最小堆\n\n如何调整：将树根（最大值）与最后一个未定序的节点交换，再对新根做下滤，知道所有节点都定序\n\n\n//java programpublic static void heapsort( Comparable []a) &#123;    for( int i = a.length / 2; i &gt;= 0; i-- )        percDown( a, i, a.length );// 建最大堆    for( int i = a.length – 1; i &gt; 0; i-- ) &#123;        swapReferences( a, 0, i );        percDown( a, 0, i);    &#125;&#125;private static int leftChild( int i ) &#123;       return 2 * i + 1;&#125;private static void percDown( Comparable [ ] a, int  i,  int n ) &#123;    int child;    Comparable tmp;    for( tmp = a[i];leftChild(i) &lt; n ; i = child ) &#123;        child = leftchild( i );        if( child!=n – 1&amp;&amp; a[child].compareTo( a[ child + 1 ] ) &lt; 0 )            child ++;        if( tmp . compareTo( a[ child ] &lt; 0 )            a[ i ] = a[ child ];        else            break;    &#125;    a[i] = tmp;&#125;\n\n复杂度：$O(nlog_2n)$\n\n\n五、归并排序\n方法：每次去除两个序列中最小的元素输出，当一序列完，则输出另一序列\n\n迭代的归并排序算法\n\nn个长为1的对象两两合并，得n&#x2F;2个长为2的文件\nn&#x2F;2个长为2的对象两两合并，得n&#x2F;4个长为4的文件\n……\n2个长为n&#x2F;2的对象两两合并，得1个长为n的文件\n\n\n//java递归实现public static void mergeSort( Comparable [ ] a ) &#123;    Comparable [ ] tmpArray = new Comparable[a.length];    mergeSort( a, tmpArray, 0, a.length – 1 );&#125;                            private static void mergeSort( Comparable [ ] a, Comparable [] tmpArray, int left, int right ) &#123;    if( left &lt; right ) &#123;        int center = ( left + right ) / 2;        mergeSort(a, tmparray, left, center );        mergeSort(a, tmpArray, center + 1, right );        merge( a, tmpArray, left, center + 1, right );    &#125;&#125;private static void merge( Comparable [ ] a, Comparable [] tmpArray, int leftPos, int rightPos, int rightEnd ) &#123;    int leftEnd = rightPos – 1;    int tmpPos = leftPos;    int numElements = rightEnd – leftPos + 1;    while( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )        if( a[ leftPos ].compareTo( a[ rightPos ] ) &lt;= 0 )            tmpArray[ tmpPos++ ] = a[ leftPos++ ];        else            tmpArray[ tmpPos++ ] = a[ rightPos++ ];    while( leftPos &lt;= leftEnd )        tmpArray[ tmpPos++ ] = a[ leftPos++ ];    while( rightpos &lt;= rightEnd)        tmpArray[ tmpPos++] = a[ rightpos++ ];    for( int i = 0; i &lt; numElements; i++, rightEnd-- )        a[ rightEnd ] = tmpArray[ rightEnd ];&#125;     \n\n算法分析：$O(nlog_2n)$\n\n有序链表的merge算法\n\n切断链表：设两个流动指针p,q指向表的结点 一般来讲让p前进一步，q前进二步，最后当q&#x3D; NULL时，这时p 恰好指向前半张表的最后一个结点\n\n\n\n算法思想一、递归\n程序调用自己的编程技巧。函数和函数的调用可以构成一个环，就可以称作一个递归\n通过重复将问题分解为同类子问题来解决问题\n注意：\n递归就是在过程或函数里面调用自身(自递归)\n使用递归，必须有一个明确的递归结束条件，称为递归出口。只有一个就行\n两个或者多个函数互相递归(互递归)\n\n\n过程：\n递归：把复杂的问题的求解推到比原问题更简单的问题的求解\n回归：获得最简单的情况后，逐步返回，依次得到复杂的解\n\n\n物理层面：递归栈\n\n二、分治\n分阶段：把问题分成两个大致相等的子问题，然后递归地对它们求解。\n治阶段： 将两个子问题的解合并到一起，可能再做些少量的附加工作，最后得到整个问题的解。\n\n三、贪心\n逐步求解，只关心眼前\nPrim、Kruskal、Dijkstra\n\n四、动态规划\n通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。\n动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。\n\nBellman-Ford\n\n\n考点\n最短路径算法\n不会考概念默写\n\n第一章\n递归会考\n汉诺塔？\n\n第二章\n大O表示法，theta表示法，omega表示法，分析复杂度\n分治？\n\n第三章 （线性表，栈，队列）\n线性表\n单链表\n双向链表不考，循环链表记不清了\n约瑟夫不考\n所有的排序都要注意\n\n\n栈\n栈的物理层实现不考\n\n\n队列\n\n第四章\n概念要理解，如满二叉树和完全二叉树的区别\n广义表不考\n遍历，递归和非递归\n由序列建树\n一般树的表示法：\n双亲表示（和并查集什么关系？）\n左子女右兄弟\n广义表（不考）\n\n\n线索树\n搜索树\n霍夫曼树\nAVL树\nB树\n\n第五章\n平方取中法没考，杂乘没考，二次探测没考\n线性探测容易考\n链地址法（分离链接法）看看\n\n第六章\n优先级队列就考堆了\n证明不考\nO（N）复杂度的建堆方法\n\n第七章\n并查集好像没考\n\n第八章 （图）\n领接矩阵，邻接表要考\n领结多重表不考\n遍历算法\n最小生成树，最短路径\nAOE常考\n拓扑排序\n算时间\n\n\n\n第九章\n折半不考？\n希尔不考\n竞标赛不考\n选择排序，快排，堆排序\n归并是重点！！！\n\n","categories":["课业"]},{"title":"计算机组成结构","url":"/2024/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84/","content":"导论第一章 · 计算机系统概述计算机的定义通用电子数字计算机\n组织与结构 ***\n组织：对编程人员不可见。（类比：实现乘法是通过硬件单元还是重复加法，我们不得而知）\n\n操作单元及其相互连接。\n包括控制信号，存储技术等等。\n\n\n结构：对编程人员可见。（类比：有没有乘法指令）\n\n直接影响程序逻辑执行的属性。\n\n包括指令集，表示数据类型的位数等等。\n\n\n\n\n计算机简史发展迭代\n第一代：真空管\n第二代：晶体管\n第三代以及之后：集成电路\n\n冯诺依曼模型\n五部分：\n主存储器\n算术逻辑单元 &#x2F; 处理单元\n程序控制单元 &#x2F; 控制单元\n输入设备\n输出设备\n\n\n存储程序思想：\n指令和数据以同等地位储存到存储器中，并且可以按地址访问\n指令和数据以二进制表示\n\n\n\n摩尔定律\n单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) &#x2F; 1970年起减慢为每18个月 翻一番 \n影响 \n由于单个芯片的成本几乎不变，计算机逻辑电路和存储电路的成本显著下降 \n这里“成本”是指原料，但制作成本是不断增加的 \n更小的尺寸带来更多灵活性和可能性 \n更强的计算能力带来更多可能性 \n减小了对电能消耗和冷却的要求 \n集成电路上的内部连接比焊接更可靠，芯片间的连接更少\n\n计算机性能 ***\n计算机的关键参数：性能，成本，尺寸，安全性，可靠性，能耗……\n性能评价标准\nCPU：速度\n存储器：速度，容量\nI&#x2F;O：速度，容量\n\n\n\nCPU性能系统时钟\n时钟频率 &#x2F; 时钟速度（单位：Hz）：计算机在单位时间内（例如1秒钟）执行最基本操 作的次数 \n\n时钟周期 &#x2F; 周期时间（单位：s）：执行每次最基本操作的时间\n\n\n\n时钟滴答（有时也称为“时钟周期”）：CPU 中用于同步执行最基本操作的单个电子脉冲 \n\n因此，周期时间即为两个电子脉冲之间的时间\n\n\n   注：\n\n不是主频越高性能越好，因为可能一个步骤要用几个时钟周期\n\n\n   $$   时钟周期*时钟频率&#x3D;1   $$\n指令执行\n处理器由时钟驱动，时钟具有固定的频率f，或等价为固定的时钟周期t \n\n如果用$CPI_i$来表示指定类型i所需要的周期数，用 表示在某一给定程序中所执行的i 类 指令的条数，则计算整个CPI如下：$$CPI&#x3D;\\frac{\\sum_{i&#x3D;1}^{n}(CPI_i*I_i)}{I_c},I_c&#x3D;\\sum_{i&#x3D;1}^{n}I_i$$\n\n执行一个给定程序的处理时间表示为：$$T&#x3D;I_cCPIt$$每秒百万条指令（ Million Instructions Per Second ，MIPS）：$$MIPS&#x3D;\\frac{I_c}{T10^{6}}&#x3D;\\frac{f}{CPI10^6}$$\n 每秒百万条浮点操作（Million Floating Point Operations Per Second，MFLOPS)：$$MFLOPS&#x3D;\\frac{N_{floating-point op}}{T*10^6}$$\n\n\n基准程序使用一系列基准程序来测量系统的性能 \n\n平均结果：\n算数平均值（Arithmetic mean） \n调和平均值（Harmonic mean）\n\n性能设计的基本原则\n大概率事件优先原则\nAmdahl定律 \n加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性比例 \n性能增加的递减规则：如果仅仅对计算机中的一部分做性能改进，改进越多，系统获得 的效果越\n\n\n\n第二章 · 计算机的顶层视图计算机的工作原理\n指令和数据存储在单个读写储存器中\n主存中的内容按位置访问，不考虑内容类型\nCPU以顺序的方式执行指令（除非明确修改）\nI&#x2F;O模块与CPU，主存交换计算机系统外部的信息\n注：I&#x2F;O模块不是I&#x2F;O设备\n\n\n\n计算机体系结构遇到的问题及解决方案\nCPU的频率不能无限提高 ➔ 改进CPU芯片结构 \n内存墙的存在 ➔ 采用高速缓存（Cache） \nCPU等待I&#x2F;O传输数据 ➔ 采用中断机制 \n兼顾存储容量、速度和成本 ➔ 层次式存储结构 \nI&#x2F;O设备传输速率差异大 ➔ 采用缓冲区和改进I&#x2F;O操作技术 \n计算机部件互连复杂 ➔ 采用总线\n\n第三章 · 数据的机器级表示信息的二进制编码\n编码：用少量简单的基本符号对复杂多样的信息进行一定规律的组合。实际上是现实世界的无限连续的信号到计算机有限离散的映射。\n\nk位二进制编码可以至多表示2^k个不同的值\n\n注：可以小于等于，不能大于。比如我令00和11都表示值0。\n\n\n补码，互补。一个数的补码和他本身加起来得到2^k。或者说，一个数的补码就是2^k减去它。\n\n在补码表示中，正数的第一位为0，负数的第一位为1。即使不是符号位，也有这个规律。\n\n\n\n浮点数的表示 ***\n规格化表示：要求要表达的浮点小数点左边为1。\n\n32位表示：\n\n符号位（s)：1位\n指数位（E)：8位\n尾数（S)：23位\n\n\n•补码（相对于无符号数） （实际上是强制无符号数变成有符号数）\n\n000…000 ~ 011…111：表示的值 不变\n100…000 ~ 111…111：表示的值由 2^(k-1)2^k-1变为-2^(k-1)-1\n真值为原来的无符号数对应的真值减去2^k（取反加1的由来）\n\n\n规格化数可表示范围：$$-(2-2^{-23})*2^{127}到-2^{-127}之间的负数$$和$$2^{-127}到(2-2^{-23})*2^{127}之间的正数$$\n\n有非规格化的数：\n\n解决了下溢的情况\n\n\n浮点数编码表示的性质：\n\n总体是不均匀的，局部是均匀的。\n对于32位数，它所能表示的数上限一定是确定的。\n总体上，绝对值越大的范围内可以表示的数越“稀疏”。1\n在同一个数量级上（即指数位相同）的范围里，数的表示是均匀的。\n\n\n多种情况：\n\n指数位：00000000\n非规格化数，尾数表示 0.S ，能表示0到2^-126^的数。注意！！！指数位全为零时表示2^1-127&#x3D;-126^。（？\n\n\n指数位：11111111\n尾数位全零：无穷\n尾数位非纯零：NaN\n\n\n指数位：其他情况\n规格化数\n\n\n\n\n舍入：\n\n朝正无穷舍入\n朝负无穷舍入\n朝零舍入\n就近舍入\n\n\n\n二进制编码十进制（BCD）\n自然BCD码 (NBCD, 8421 码) \n0 ~ 9: 0000 ~ 1001 \n符号: 使用四个最高有效位 \n正: 1100 &#x2F; 0 ， 负: 1101 &#x2F; 1 \n例子： \n+2039: 1100 0010 0000 0011 1001 &#x2F; 0 0010 0000 0011 1001\n-1265: 1101 0001 0010 0110 0101 &#x2F; 1 0001 0010 0110 0101\n\n\n\n\n其他BCD码 • 2421, 5211, 4311, …\n\n第四章 · 数据校验奇偶校验海明校验码P1：1,2,4,5,7\nP2：1,3,4,6,7\nP3：2,3,4,8\nP4：5,6,7,8\n循环冗余校验码中央处理器（CPU）第五章 · 整数运算加法全加器（FA）\n延时：\n逻辑门延时：\n与门延迟：1级门延迟 (1ty)\n或门延迟：1级门延迟 (1ty)\n异或门延迟：3级门延迟 (3ty)\n\n\n运算延时：\n$S_i&#x3D;X_i⊕Y_i⊕C_{i-1}$\n$C_i&#x3D;X_iC_{i-1}+Y_iC_{i-1}+X_iY_i$\n\n\n\n\n\n\n缺点：慢\n\n全先行进位加法器（CLA）\n缺点：复杂\n\n部分先行进位加法器乘法\n乘法器原理\n\n![屏幕截图 2024-09-26 062919](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-26 062919.png)\n\n有符号乘法：\n原理：布斯算法 ***\n流程：\n记$Y_0&#x3D;0$\n根据$Y_i-Y_{i+1}$, 决定是否增加+X，-X，0；\n右移部分积\n重复第二、三步\n\n\n注意：\n由于是有符号数的运算，在右移时补位要补的是符号位\n\n\n\n\n\n\n\n除法\n计算机除法原理：不断的削减被除数的绝对值到最小而不变号。\n\n注意：在计算机内，余数是和被除数同号的。即，若被除数为负数，余数也为负数。这与数学上不一样。\n部分余数：计算过程中的余数\n\n\n无符号除法![屏幕截图 2024-09-26 072639](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-26 072639.png)\n![屏幕截图 2024-09-26 072720](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-26 072720.png)\n\n有符号\n恢复余数流程：\n![屏幕截图 2024-09-26 073410](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-26 073410.png)\n\n\n不恢复余数流程：\n通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄 存器中 \n将余数和商左移，判断是否“够减”\n如果“够”，则做减法（同号）或者加法（异号），并上 商为1 \n如果“不够，则上商为0\n\n\n重复以上步骤 \n如果除数和被除数不同号，则将商替换为其相反数 \n余数存在余数寄存器中\n\n\n\n\n\n\n\n![屏幕截图 2024-10-10 063945](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-10 063945.png)\n\n本质就是这次多减了，下次加回去\n\n第六章 · 浮点数运算加减法\n流程：![屏幕截图 2024-10-10 065152](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-10 065152.png)\n查零    \n对阶：小向大对齐，尾数右移，损失小。同时查零。\n相加并调整浮点\n处理溢出\n舍入：若上溢，设为无穷；若下溢，用非规格化表示\n\n\n减法：加第二个操作数的补码（一个数的原码和补码之和为2^k^）\n如果最高位有进位，正确 (符号与被减数相同) \n否则，计算它的补码作为原码，且符号与被减数相反\n\n\n\n乘法![屏幕截图 2024-10-11 195205](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-11 195205.png)\n\n流程\n\n无论哪个操作数是0，乘积 即为0 \n\n指数运算：从阶值的和中减去一个偏移量$$E_{mul}&#x3D;E_a+E_b-127$$\n\n\n\n尾数运算：有效值相乘 （就直接乘就完了）\n\n结果的规格化和舍入处理，规格化可能导致阶值下溢\n\n\n除法\n流程：\n\n如果除数为0，则报告出错， 或将结果设置为无穷大\n\n如果被除数是0，则结果是0\n\n被除数的阶值减除数的阶值， 加上偏移量$$E_{div}&#x3D;E_a-E_b+127$$\n\n有效值相除\n\n结果规格化和舍入处理\n![屏幕截图 2024-10-11 200340](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-11 200340.png)\n\n\n\n保护位：24位有效值做运算时，放在ALU左端，右端多出来的几位作保护位。\n\n对有效值操作的结果通常保存在更长的寄存器中。当结果转换回浮点格式时，必须要去掉多余的位，有四种方法\n\n\n\n第七章 · 二进制编码的十进制数运算\n表示：\n\n数字• 0 ~ 9：0000 ~ 1001\n\n符号\n• 正: 1100 &#x2F; 0• 负: 1101 &#x2F; 1\n\n\n\n\n加法\n补偿：用4位二进制实际上可以看作十六进制，这比十进制能多表示6个数。所以当运算之后某处表示了大于十的数，应该加6帮忙进位。\n\n第九章 · 高速缓冲存储器（Cache）基本思路\n解决内存墙带来的CPU和主存协作问题\n\n\n在使用主存（相对大而慢）之余，添加一块小而快的cache\nCache位于CPU和主存之间，可以集成在CPU内部或作为主板 上的一个模块\nCache中存放了主存中的部分信息的“副本”\n\n工作流程\n检查（Check）：当CPU试图访问主存中的某个字时，首先检查 这个字是否在cache中\n\n检查后分两种情况处理：\n\n命中（Hit）：如果在cache中，则把这个字传送给CPU\n\n未命中（Miss）：如果不在cache中, 则将主存中包含这个字固定 大小的块（block）读入cache中，然后再从cache传送该字给CPU\n\n注：\n\n如何判断命中与否？\n\n冯·诺伊曼体系的设计： CPU通过位置对主存中的内容进行寻址，不关心存储在其中的内容\nCache通过标记（tags）来标识其内容在主存中的对应位置\n\n\n如果未命中，为什么不直接把所需要的字从内存传送到CPU?为什么从内存中读入一个块而不只读入一个字?\n\n程序访问的局部性原理：处理器频繁访问主存中相同位置或者相邻存储位置的现象\n类型：\n时间局部性：在相对较短的时间周期内，重复访问特定的信息（也就是访问相同位置的信息） \n空间局部性：在相对较短的时间周期内，访问相邻存储位置的数据\n顺序局部性：当数据被线性排列和访问时，出现的空间局部性 的一种特殊情况。例如：遍历一维数组中的元素\n\n\n\n\n利用时间局部性：可能多次取同一个数据，所以第一次取的时候会把数据复制到cache中，以便之后取用。\n利用空间局部性：可能短时间内取多个相邻数据，所以复制一个块以便之后取用。\n\n\n使用Cache后需要更多的操作，为什么还可以节省时间?\n\n假设p是命中率， $T_c$是cache的访问时间，$T_m$是主存的访问时间，使用cache时的平均访问时间为$$T_A&#x3D;pT_C+(1-p)(T_C+T_M)&#x3D;T_C+(1-p)*T_M$$\n\n命中率p越大， $T_C$越小， 效果越好\n如果想要 $T_A&lt;T_M$, 必须要求 $p&gt;T_C&#x2F;T_M$\n难点：cache的容量远远小于主存的容量\n\n\n\n\n\n设计要素\n容量：扩大容量可以提高p，但是增加了成本和$T_C$\n\n映射功能：\n\n直接映射：\n\n将主存中的每个块映射到一个固定可用的cache行中\n\n假设𝑖是cache行号，𝑗是主存储器的块号，𝐶是cache的行数\n\n\n   i &#x3D; j mod C\n\n\n\n前两部分合称为块号\n\n\n流程：\n\n对块号进行mod C，得到了块所在的行号。对于二进制而言，mod 4 表示取后两位。\n找到行号cache中对应的行，检查块号前的tag和行号前的tag。若相同则表示这一行后面的数据是所求的块。\n找到对应的块，再利用块内地址找到数据。\n\n\n优点：简单，快速\n\n缺点：抖动现象：如果一个程序重复访问两个需要映射到 同一行中且来自不同块的字，则这两个块不断地被交换到cache中， cache的命中率将会降低\n\n适合大容量cache\n\n\n\n关联映射：\n\n一个主存块可以装入cache任意一行\n寻找块时要遍历cache所有行\n优点：避免抖动现象\n缺点：实现起来比较复杂，$T_C$变长\n适合小容量cache\n\n\n组关联映射\n\nCache分为若干组，每一组包含相同数量的行，每个主存块被映射到固定组的任意一行。组间为直接映射，组内为关联映射。\n假设𝑠是cache组号，𝑗是主存块号，𝑆是组数 𝑠 &#x3D; 𝑗 𝑚𝑜𝑑 𝑆 \nK-路组关联映射 𝐾 &#x3D; C &#x2F; S。即：每个组里有几行。\n\n\n优点：结合了前两种的优点\n缺点：结合了前两种的缺点\n\n\n\n\n替换算法\n\n直接映射没得选，每个块只有一个位置可以放\n\n\n最近最少使用算法\n假设：最近使用过的数据块更有可能会被再次使用\n策略：替换掉在cache中最长时间未被访问的数据块\n\n\n先进先出算法\n假设：最近由主存载入Cache的数据块更有可能被使用\n策略：替换掉在Cache中停留时间最长的块\n最不经常使用算法\n假设：访问越频繁的数据块越有可能被再次使用\n策略：替换掉cache中被访问次数最少的数据块\n随机替换算法\n假设：每个数据块被再次使用的可能性是相同的\n策略：随机替换cache中的数据块\n实现：随机替换。随机替换算法在性能上只稍逊于使用其它替换算法\n\n\n写策略\n\n写直达：\n所有写操作都同时对cache和主存进行\n优点：确保主存中的数据总是和cache中的数据一致，总是最新的\n缺点：产生大量的主存访问，减慢写操作\n\n\n写回法\n先更新cache中的数据，当cache中某个数据块被替换时，如 果它被修改了，才被写回主存。利用一个脏位（dirty bit）或者使用位（use bit）来表示块是 否被修改\n优点：减少了访问主存的次数\n缺点：部分主存数据可能不是最新的\n\n\n\n\n行大小\n\n假设从行的大小为一个字开始，随着行大小的逐步增大，则Cache命中率会增加\n当行大小变得较大之后，继续增加行大小，则Cache命中率会下降\n\n\nCache数目：\n\n一级VS.多级\n统一VS.分立\n\n\n\n第十三章 · 指令系统寻址方式\n立即寻址：指令里存放操作数\n直接寻址：指令里存放操作数地址（A），把操作数放在内存中\n间接寻址：指令里存放的是有效地值（EA）的地址，EA放在内存中，再访问EA得到操作数\n寄存器寻址：指令里存放寄存器编号，寄存器里面放操作数\n寄存器间接寻址：指令里存放寄存器编号，寄存器放EA\n偏移寻址：EA &#x3D; （R）+ A\n相对寻址：R默认为PC。A为偏移量\n基址寄存器寻址（寄存器为基）：被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地址的偏移量\n变址寻址（寄存器为变）：指令中有一个形式地址，被引用的寄存器含有对于该地址的一个正的偏移量\n\n\n栈寻址：栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式\n\n指令格式\n指令格式通过它的各个构成部分来定义指令的位安排\n一个指令格式必须包含一个操作码，以及隐式或显式的、零个或多个操作数\n指令格式必须显式或隐式地为每个操作数指定其寻址方式\n大多数指令集使用不止一种指令格式\n\n第十四章 · 指令周期和指令流水线间址周期\n指令的执行可能涉及一个或多个存储器中的操作数，它们每   个都要求一次存储器访问。使用间接寻址，还需要额外的存储器访问\n间址周期：把间接地址的读取看成是一个额外的指令子周期\n\n数据流\n指令流水线\n指令流水线：一条指令的处理过程分成若干个阶段，每个阶段由  相应的功能部件完成\n\n\n两阶段方法：\n\n将指令处理分成两个阶段：取指令和执行指令。在当前指令的执行期间取下一条指令\n问题：\n执行时间一般要长于取指时间\n主存访问冲突\n条件分支指令使得待取的下一条指令的地址是未知的\n\n\n\n\n六阶段方法：\n\n六个阶段\n取指令（Fetch instruction，FI）：读下一条预期的指令到缓冲器\n译码指令（Decode instruction，DI）：确定操作码和操作数指定符\n计算操作数（Calculate operands，CO）：计算每个源操作数的有效地址\n取操作数（Fetch operands，FO）：从存储器取出每个操作数，寄存器中的操作数不需要取\n执行指令（Execute instruction，EI）：完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置\n写操作数（Write operand，WO）：将结果存入存储器\n\n\n注意：\n不是所有指令都包含6个阶段• 例：一条LOAD指令不需要WO阶段\n为了简化流水线硬件设计，在假定每条指令都要求这6个阶段的基础上来建立时序\n不是所有的阶段都能并行完成• 例：FI、FO和 WO都涉及存储器访问\n若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待\n\n\n限制：\n条件转移指令能使若干指令的读取变为无效\n\n\n\n\n误解：流水线中的阶段数越多，执行速度越快。$t &#x3D; t_m + d$，d是固定的\n\n对于k阶段流水线执行n条指令所需时间为：$T_{k,n}&#x3D;[k+(n-1)]t$\n\n加速比：$$S_k&#x3D;\\frac{T_{1,n}}{T_{k,n}}&#x3D;\\frac{nkt}{[k+(n-1)]t}&#x3D;\\frac{n}{1+\\frac{n-1}{k}}&gt;1$$\n\n\n冒险\n类型：\n结构冒险（Structure hazard） &#x2F; 硬件资源冲突\n数据冒险（Data hazard） &#x2F; 数据依赖性\n解决方案三：旁路(处理不了load)\n解决方案四：交换指令顺序\n\n\n控制冒险（Control hazard）\n\n\n\n第十五章 · 控制器微操作\n定义\n\n执行程序时，计算机操作是由一系列指令周期组成，每个周期执行一条机器指令\n每个指令周期又可以看作是由几个更小的子周期组成，包括：取指、间址、执行、中断\n每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些 步骤称为微操作\n\n\n分组原则：\n\n所谓同组或者同时进行，就是说交换顺序也不会影响结果\n\n\n事件的流动顺序必须是恰当的\n必须避免冲突\n满足上述条件下，所用的时间单位尽可能少\n\n\n\n指令周期代码（ICC，Instruction Cycle Code）\n控制器\n\n\n注：AC是累加器，是ALU的数据源之一\n\n\n控制CPU的功能需求\n\nCPU的基本元素 \nALU，寄存器组，内部数据通路，控制器，外部数据通路\n\n\nCPU需要完成的微操作 \n在寄存器之间传送数据\n将数据由寄存器传送到外部接口（如系统总线）\n将数据由外部接口传送到寄存器\n将寄存器作为输入和输出，完成算术和逻辑运算\n\n\n控制器的两个基本任务\n定序（sequencing）：根据正被执行的程序，控制器使CPU以正确 的顺序通过一系列微操作\n执行（execution）：控制器使每个微操作得以完成\n\n\n\n\n控制器的输入\n\n指令寄存器（IR）：当前指令的寻址方式（影响间址周期）和操作码（影响执行）\n\n外部控制信号（包括中断）\n\n标志：确定CPU的状态和前一个ALU操作的结果\n时钟：控制器要在每个时钟脉冲完成一个或一组同时的微操作\n来自控制总线的控制信号：向控制器提供控制信号\n\n\n标记\n\n\n\n\n控制器的输出\n\n\n控制器的最小特性\n\n它只需要知道将被执行的指令和算术、逻辑运算结果的性质（如 正负、溢出等），而不需要知道正被处理的数据或得到的实际结 果具体是什么\n它只是以少量的送到CPU内的和送到系统总线上的控制信号来实 现控制\n\n\n控制器的实现\n\n硬布线实现（hardwired implementation）：控制器是一个组合电路，把输入逻辑信号转换为一组输出逻辑信号， 即控制信号\n微程序实现（microprogrammed implementation）：控制逻辑是微程序指定的，控制器是一个相对简单的逻辑电路，通 过执行每条微指令来产生控制信号\n\n\n\n微程序\n基本思路和概念\n\n构成\n\n注意，存入控制缓冲寄存器的微指令就可以认为是直接执行了\n\n\n工作流程\n\n\n\n存储第八章 · 内部存储器回顾存储器（Memory）由一定数量的单元构成，每个单元可以被唯一标识，每个单元都有存储一个数值的能力\n\n地址：单元的唯一标识符（采用二进制）\n地址空间：可唯一标识的单元总数\n寻址能力：存储在每个单元中的信息的位数\n大多数存储器是字节寻址的，而执行科学计算的计算机通常是64位寻址的\n\n半导体存储器![屏幕截图 2024-10-21 172723](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-21 172723.png)\n用半导体芯片作主存储器是目前的主流做法\n\n位元（memory cell）\n\n半导体存储器的基本元件，用于存储1位数据\n\n特性\n\n呈现两种稳态（或半稳态）：分别表示二进制的0和1\n\n它们能够至少被写入（write）数据一次：用来设置状态\n\n它们能够被读取（read）来获得状态信息\n\n\n\n\n\n\n随机存取存储器（RAM）\n特性：\n随机访问：访问地址的时间是相对一致的\n可以简单快速的读写\n易失的\n\n\n类型\n动态RAM（DRAM）\n在电容器上用电容充电的方式存储数据，电容器中有无电荷在分别代表二进制的1与0\n需要周期地充电刷新以维护数据存储\n原因：电容器有漏电的自然趋势\n由一个阈值来确定电荷是被解释为1还是0\n\n\n\n\n静态RAM（SRAM）\n只要有电源，就可以一直维持数据\n要有电源，但不用刷新\n\n\nDRAM和SRAM类型对比\n相同点： 易失的：两者都要求电源持续供电才能保存位值\n不同点：\nDRAM比SRAM具有更简单、更小的位元，但要求能支持刷新的电路\nDRAM比相应的SRAM集成度更高，价格更低\nSRAM通常比DRAM快\nDRAM更倾向于满足大容量存储器的需求，SRAM一般用于高  速缓存，DRAM用于主存\n\n\n\n\nSDRAM（要刷新）\n传统DRAM是异步的，DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓 冲将数据输出，处理器只能等待这段延迟，即存取时间 。延时后，DRAM才写入或读取数据\nSDRAM与处理器的数据交互同步与外部的时钟信号，并且以处理器&#x2F;存储器总 线的最高速度运行，而不需要插入等待状态。由于SDRAM随系统时钟及时移动数据，CPU知道数据何时准备好，控制器可以完成其它工作\n理解：在内存没有准备好数据的时候，CPU先干其他事情\n\n\n\n\n\n只读存储器（ROM）\n特性：\n随机访问\n非易失的\n\n\n类别：\nROM：只能写一次，用掩膜\n可编程ROM（PROM）：也只能写一次，只是这次用电来“编程”，用户写入想要的东西\n（紫外线）可擦除PROM（EPROM）：电写入，光擦除\n电可擦除PROM（EEPROM）：电写入，电擦除\n快闪存储器（Flash Memory）：\n特电可擦除：与EEPROM相同，优于EPROM \n擦除时间为几秒：优于EPROM，不如EEPROM \n可以在块级擦除，不能在字节级擦除：优于EPROM，不如EEPROM\n达到与EPROM相同的密度：优于EEPROM \n与EPROM、EEPROM对比 ：价格和功能介于EPROM和EEPROM之间\n\n\n\n\n\n从位元到主存![屏幕截图 2024-10-21 202052](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-21 202052.png)\n寻址单元：由若干相同地址的位元组成\n\n寻址模式：\n\n字节（Byte）\n字（Word）\n\n\n如何寻址：用地址译码器\n\n一个n位译码器有2^n^种输出\n\n\n如何刷新：\n\n集中式刷新（Centralized refresh）• 停止读写操作，并刷新每一行• 刷新时无法操作内存\n分散式刷新（Decentralized refresh）• 在每个存储周期中，当读写操作完成时进行刷新• 会增加每个存储周期的时间\n异步刷新（Asynchronous refresh）• 每一行各自以64ms间隔刷新• 效率高：常用\n\n\n存储阵列：由大量寻址单元组成\n\n2048 * 2048 * 4 表示有2048行，2048列，每个单元4位。\n地址线可表示2^n^个单元，数据线表示只能n位。\n一个字的每一位都需要数据线。\nRAM和ROM采用的都是地址复用技术，地址线是原来的一半。\n\n\n\n\n模块组织\n\n位扩展：地址线不变，数据线增加• 使用 8 块 4K1 bit 的芯片组成 4K8bit 的存储器\n字扩展：地址线增加，数据线不变• 使用 4 个 16K8 bit 的芯片组成64K8 bit 的存储器\n字、位同时扩展：地址线增加，数据线增加• 使用 8 个 16K4 bit 的芯片组成64K8 bit 的存储器\n\n\n交叉编址：\n\n模块序号 &#x3D; 访存地址 % 存储器交叉模块数。\n给定的访存地址在相邻的四次访问中出现在同一个存储模块内，则会发生冲突。\n\n\n\n第十章 · 外部存储器概述\n特性：\n用于存储不经常使用的、数据量较大的信息\n非易失\n\n\n类型：\n磁盘存储器（magnetic disk）\n光存储器（optical memory）\n磁带（magnetic tape）\nU盘（USB flash disk），固态硬盘（solid state disk，SSD）\n\n\n\n硬磁盘存储器\n结构\n\n\n由磁头对盘片读写·\n\n\n读写机制\n\n在读或写操作期间，磁头静止，而盘片在其下方旋转\n磁头的数量\n单磁头：读写公用同一个磁头（软盘、早期硬盘）\n双磁头：使用一个单独的磁头进行读取（当代硬盘）\n\n\n写入机制\n电流脉冲被发送到写入磁头\n变化的电流激发出磁场\n产生的磁性图案被记录在下面的盘片表面上\n反转电流方向，则记录介质上的磁化方向也会反转\n\n\n读取机制\n读取磁头是由一个部分屏蔽的磁阻（MR）敏感器组成，其电阻 取决于在其下移动的介质的磁化方向\n电流通过MR敏感器时，通过电压信号检测其电阻变化\nMR敏感器允许更高频率的操作，实现更高的存储密度和更快的 操作速度\n\n\n\n\n数据组织\n\n盘片上的数据组织呈现为一组同心圆环，称为磁道（track）\n\n数据以扇区（sector）的形式传输到磁盘或从传出磁盘\n\n默认值为512B\n\n\n相邻磁道之间有间隙（gap），相邻的扇区之间也留有间隙\n\n扇区划分\n\n恒定角速度\n多带式记录 &#x2F; 多重区域记录\n提升了存储容量，但是需要更复杂的电路\n\n\n\n\n所有盘片上处于相同的相对位置的一组磁道被称为柱面 (cylinder)\n\n格式化：\n\n磁道必须有一些起始点和辨别每个扇区起点及终点的方法\n格式化时，会附有一些仅被磁盘驱动器使用而不被用户存取 的额外数据\n\n\nI&#x2F;O访问时间\n\n寻道时间（seek time）：磁头定位到所需移动到的磁道所花 费的时间\n初始启动时间，跨越若干磁道所用的时间\n\n\n旋转延迟（rotational delay）：等待响应扇区的起始处到达 磁头所需的时间\n通常是磁道旋转半周所需的时间\n\n\n传送时间（transfer time）：数据传输所需的 时间\n\n$$T&#x3D;\\frac{b}{rN}&#x3D;\\frac{1}{r}·\\frac{b}{N}$$\n​    T：传送时间，b：传送的字节数，N：每磁道的字节数，r：旋转速率，单位是 转每秒（rad&#x2F;s).\n\n柱面：写入时是在某一磁道写完一圈之后，不动读写头位置，继续读写另一面。\n\n\n\n磁盘调度\n效率：SSTF &gt; LOOK &gt; SCAN ~ C-LOOK &gt; C-SCAN &gt; FCFS\n公平性反过来\n\n\n第十一章 · 冗余磁盘阵列（RAID）概述\n基本思想\n将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量\n将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率\n采用数据冗余来进行错误恢复以提高系统可靠性\n\n\n特性：\n由一组物理磁盘驱动器组成，被视为单个的逻辑驱动器\n数据是分布在多个物理磁盘上\n冗余磁盘容量用于存储校验信息，保证磁盘万一损坏时能恢复数据\n\n\n\n\n七种类型\nRAID 0 ***：\n数据以条带的形式在可用的磁盘上分布\n不采用冗余来改善性能（不是RAID家族中的真正成员）\n用途 \n高数据传输率\n高速响应I&#x2F;O请求\n\n\n如果一个文件横跨四个盘，如果一个盘损坏，就会导致所有文件都不可用。\n\n\nRAID 1 ***：\n采用简单地备份所有数据的方法来实现冗余\n优点\n高速响应I&#x2F;O请求：即便是同一个磁盘上的数据块，也可以由两 组硬盘分别响应\n读请求可以由包含请求数据的两个对应磁盘中的某一个提供服 务，可以选择寻道时间较小的那个\n写请求需要更新两个对应的条带：可以并行完成，但受限于写 入较慢的磁盘\n单个磁盘损坏时不会影响数据访问，恢复受损磁盘简单\n\n\n缺点： 价格昂贵\n\n\nRAID 2：\n所有磁盘都参与每个I&#x2F;O请求的执行\n纠错：对位于同一条带的各个数据盘上的数据位计算校验码（通常采 用海明码），校验码存储在该条带中多个校验盘的对应位置\n\n\nRAID 3：\n采用并行存取技术\n各个驱动器的轴同步旋转\n采用非常小的数据条带\n\n\n对所有数据盘上同一位置的数据计算奇偶校验码\n当某一磁盘损坏时，可以用于重构数据。注意，是恢复不是纠错，RAID 3只能解决损坏的问题，但是不能解决出错的问题，换句话说也就是我们不能确定出错的是哪一位。\n\n\n\n\nRAID 4：\n采用相对较大的数据条带\n根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校 验位存储在奇偶校验盘的对应条带上\n\n\nRAID 5 ***：\n在所有磁盘上都分布了奇偶校验条带\n避免潜在的I&#x2F;O瓶颈问题\n访问时的“两读两写”：\n既要读或写用户数据，也要读写校验条带。\n一定是先读后写。\n最好是两读或两写分别同时进行，最短时间为一次读加一次写，最长时间为两次度加两次写。\n\n\n\n\n\n\nRAID 6：略\n\n第十二章 · 虚拟存储器分区\n固定分区：会造成浪费\n可变长分区：会出现碎片\n\n分页\n基本思想\n将内存分为一个个叫做页框的固定长度的块，然后将程序分为可以放进块的叫做页的部分\n程序叫做页，放程序的地点叫做页框\n页放在哪里由OS决定，在我们的程序中写的是逻辑地址，由操作系统的决定物理地址。\n页放进去并不是连续的放入，记录页存在的位置\n像链表一样，存放不是连续的，必须要页表来记录地址\n\n\n页表\n页表中包含了所有虚拟页的信息，包括虚拟页的存放位置、装入位（valid）、修改位（dirty）、存取权限位等等\n保存在主存中\n虚拟地址\n虚拟页号 + 页内偏移量\n\n\n逻辑地址:指令中的地址\n物理地址:内存中的地址\n\n\n\n虚拟存储器\n从此，CPU不管物理地址了，程序员可以假设独享一块大的连续的内存。\n\n\n设计：\n\n页大小• 4KB, 8KB, …\n映射算法• 关联映射\n写策略• 写回\n类型• 分页式虚拟存储器• 分段式虚拟存储器• 段页式虚拟存储器\n\n\n将虚拟页号转换为物理页号\n\n\nnull：申请了，但没用\nPP0：物理页号\n空白：一个指针\n\n\n\n快表（TLB）\n类比cache\n页表的使用增加了主存的访问次数。为了减少访存次数，把页表中最活跃的几个页表项复制到高速缓存中\n后备转换缓冲器（简称“快表”）：将页表项放入高速缓存中• 映射：关联映射，组关联映射• 替换：随机替换• 主存中的页表相应地称之为“慢表”\n\n总线第十六章 · 总线概述\n分类\n芯片内部总线\n系统总线：连接CPU、存储器、IO控制器和其他功能设备\n通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统\n\n\n复用：\n数据线和地址线可以服用\n控制线不能复用\n\n\n总线结构：\n数据线：在系统组件之间传输数据。数据线的数量决定了一次可以传输的数据的大小\n地址线：在数据线和地址I&#x2F;O端口上指定数据的来源和去向。地址线的数量决定了寻址空间的大小\n控制线：控制对数据线和地址线的存取和使用\n时钟（clock）：用于总线同步操作\n总线请求（bus request）：表示模块需要获得对总线的控制\n总线允许（bus grant）：发出请求的设备已经被允许控制总线\n中断请求（interrupt request）：表示某个中断正在悬而未决\n中断响应（interrupt ACK）：未决的终端请求被响应 • 存储器读（memory read）：从存储器读数据到总线\n存储器写（memory write）：将数据从总线写入存储器\nI&#x2F;O读（I&#x2F;O read）：从I&#x2F;O端口读数据到总线\nI&#x2F;O写（I&#x2F;O write）：将数据从总线写入I&#x2F;O端口\n\n\n\n\n总线上数据传输的特点\n总线可以被多个设备监听，但同一时刻只能由一个设备发送数据\n如果同一时刻多个设备同时发送数据，会造成数据之间的混淆\n使用总线进行数据传输：如果连在总线上的某个设备希望向另一个设备发送数据，需要：\n获得总线的使用权\n通过总线传送数据\n\n\n如果连在总线上的某个设备希望向另一个组件请求数据，需要：\n获得总线的使用权\n通过总线向另一个设备发送请求，等待另一个设备发送数据\n\n\n当总线在被使用过程中，其它设备不可以抢占\n\n\n设计要素\n用途：专用总线，复用总线\n仲裁：集中式，分布式\n时序：同步，异步，半同步，分离事务\n总线带宽和数据传输速率\n总线层次结构：单总线，双总线，多总线\n\n\n\n用途\n专用总线：始终只负责一项功能，或始终分配给 特定的计算机组件\n优点：高吞吐量，减少总线冲突\n缺点：增加了系统的规模和成本\n\n\n复用（multiplexed）总线：将同一线路用于多种用途\n优点：使用的布线数量少，节省空间和成本\n缺点：每个模块需要更复杂的控制电路，且共享可能会降低性能\n\n\n\n仲裁\n总线仲裁：当多个设备需要与总线通信时，通过某种策略选择一个设备\n平衡因素\n优先级：优先级高的设备优先被服务\n公平性：优先级最低的设备不能一直被延迟\n\n\n仲裁方案\n分类\n集中式（centralized）：由仲裁器（arbiter）或总线控制器 （bus controller）负责分配总线使用权\n链式查询 &#x2F; 菊花链（daisy chain）\n计数器查询（query by a counter）\n独立请求（independently request）\n\n\n分布式（distributed）：每个设备都包含访问控制逻辑，各设 备共同作用分享总线\n自举式（self selection）\n冲突检测（collision detection）\n\n\n\n\n链式查询\n优点：\n确定优先级很简单\n可以很灵活地添加设备\n\n\n缺点\n不能保证公平性\n对电路故障敏感\n限制总线的速度\n\n\n\n\n计数器查询\n优点：\n通过使用不同的初始计数，可以灵活地确定设备优先级\n强调优先级：从1开始\n强调公平性：从下一个设备的ID开始\n对电路故障不敏感\n\n\n缺点\n需要添加设备ID线\n需要解码和比较设备ID信号\n限制总线的速度\n\n\n\n\n独立请求\n优点\n快速响应\n可编程的优先级\n\n\n缺点\n复杂的控制逻辑\n更多的控制线路\n\n\n\n\n自举式\n需要n条线\n\n\n冲突检测\n\n\n\n时序\n事务：传输一次地址和数据。\n同步时序\n优点：容易实现\n缺陷：所有设备共享一个时钟，总线长度受到始终偏差的限制\n\n\n异步时序\n握手策略\n异步数据传输\n实际上是一个七次握手3+1+3\n\n\n优点：可以灵活地协调速度不同的设备\n缺点：接口逻辑复杂，对噪声敏感\n\n\n半同步时序\n为了减少噪声的影响，在异步计时中使用时钟\n准备和响应信号在时钟上升沿有效\n\n\n结合同步和异步定时的优点\n\n\n分离事务\n将一个总线事件分离为两个过程\n优点：增加总线利用率\n缺点：增加每个总线事件的持续时间和系统复杂度\n\n\n\n总线带宽和数据传输速率\n主要是些计算\n\n\n数据块传输：\n为了提高效率，我们采用数据块传输的方法，这样只需要传输一次地址就可以得到多个字的数据。\n一次事务四个时间：\n地址传输\n数据准备\n数据传输\n空闲\n\n\n上一个数据传输时，可以同时准备下一个数据\n例题\n\n\n\n输入输出第十七章 · 输入 &#x2F; 输出概述\nI&#x2F;O模块：本身属于计算机，不是外设。外围设备要与I&#x2F;O模块相连，才能与计算机交互。\n外围设备的接口：不同的外设可能有不同的编码，在与I&#x2F;O模块相连时，要用接口把数据格式转换过来，并且要能够接受控制信号。\n\nI&#x2F;O模块结构\n\n注意：控制线是CPU控制I&#x2F;O模块本身的，如果想控制外设，走数据线\n外部接口：\n接口类型\n并行接口：多根线连接输入&#x2F;输出模块和外设，同时传送多位数据\n串行接口：只有一根线用于传输数据，每次只传输一位数据\n\n\n由于并行接口要求每次同时传送，当传输速度和总线长度增加时， 总线的时钟频率会受到限制。所以我们用串行接口。\n\n\n外设至少要有三个内容的交互：数据，状态，控制。数据能交换，状态能出来，控制能进去。\n\nI&#x2F;O操作技术\n分类：\n\n编程式 I&#x2F;O：处理器通过执行程序来直接控制I&#x2F;O操作，当处理器 发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成\n中断驱动式 I&#x2F;O：处理器发送一条I&#x2F;O命令后，继续执行其他指令； 并且当I&#x2F;O模块完成其工作后，才去中断处理器工作\n直接存储器读取（Direct Memory Access，DMA）：I&#x2F;O模块与 主存直接交换数据，而不需要处理器的干涉\n\n\n编程式\n\n\n在编程式I&#x2F;O中，CPU的占用率是100%。即CPU不能够执行其他任务。\n这是因为I&#x2F;O不会“敲门”，所以他要不断地检查I&#x2F;O是否就绪\n但是不代表CPU一直在工作，只是占用\n\n\n中断驱动\n\n从I&#x2F;O的视角来看：\n\nI&#x2F;O模块接收来自处理器的读命令\nI&#x2F;O模块从相关的外设中读入数据\n一旦数据进入I&#x2F;O模块的数据寄存器后，该模块通过控制总线给处 理器发送中断信号\nI&#x2F;O模块等待直到处理器请求该数据时为止\n当处理器有数据请求时，I&#x2F;O模块把数据传送到数据总线上，并准 备另一个I&#x2F;O操作\n\n\n从控制器的视角来看\n\n处理器发送一个读命令\n处理器离开去做其它的事情，并在每个指令周期结束时检查中断\n当来自I&#x2F;O模块的中断出现时，处理器保存当前程序的现场到栈中\n处理器从I&#x2F;O模块读取数据字并保存到主存中\n处理器恢复刚才正在运行的程序的现场，并继续运行原来的程序\n\n\n\n\n中断启用\n\n中断优先级\n\n响应优先级：“抢得快”\n处理优先级：“优先级高”\n掩码字 &#x2F; 屏蔽字：“不用管”\n主程序没有优先级（或者说优先级最低）\n例子\n注意：从哪来回哪去。因为保存恢复是看栈中内容，所以一定会对称。\n\n\n\n\n\n直接存储器存取DMA\n\n\nCPU和DMA访问内存冲突时，CPU让DMA。否则DMA的缓冲可能溢出。\n\nDMA内存访问：\n\nCPU停止法\n周期窃取\n交替访问\n\n\n\n知识点拾遗\n计算机性能\n\n如果用$CPI_i$来表示指定类型i所需要的周期数，用 表示在某一给定程序中所执行的i 类 指令的条数，则计算整个CPI如下：$$CPI&#x3D;\\frac{\\sum_{i&#x3D;1}^{n}(CPI_i*I_i)}{I_c},I_c&#x3D;\\sum_{i&#x3D;1}^{n}I_i$$\n\n执行一个给定程序的处理时间表示为：$$T&#x3D;I_cCPIt$$\n\n每秒百万条指令（ Million Instructions Per Second ，MIPS）：$$MIPS&#x3D;\\frac{I_c}{T10^{6}}&#x3D;\\frac{f}{CPI10^6}$$\n\n每秒百万条浮点操作（Million Floating Point Operations Per Second，MFLOPS)：   $$   MFLOPS&#x3D;\\frac{N_{floating-point op}}{T*10^6}   $$\n\n基准程序\n\n\n\n奇校验多一个异或1\n\n海明码校验\n\n\n错题本\n一定与机器字长相同的部件是ALU和通用寄存器。\n机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数，它直接影响了CPU内部数据通路的宽度以及运算的精度和速度。\nALU（算术逻辑单元）作为执行算术和逻辑操作的核心部件，其设计通常是基于机器字长的，能够处理与机器字长相同位数的数据，因此ALU的位数一定与机器字长相同。\n通用寄存器用于存储临时数据和计算结果，这些寄存器通常与机器字长相匹配，以便能够存储和处理与机器字长相同位数的数据，因此通用寄存器的位数也与机器字长相同。\n\n\n量级单位：K, M, B, T, G, P, E\nCPU区分指令和数据的依据是指令周期的不同阶段\n当最高位进位和符号位进位的值不相同时才产生溢出\n只有在表述内存时，M表示2^20^，例如Mb就是2^20^bit。在表示速度时，M表示10^6^。所以Mbps是M*bps，而不是Mb&#x2F;s。\n\n整数运算\n加法器：（学会分析）\n逻辑运算延时：与、或、非均为1ty，异或为3ty\n\n得到进位后，计算本位和要3ty，计算进位要2ty。\n\n\n串行进位加法器：\n在FA0运算时，其他的XY也在同时运算。在$C_1$出结果之前，各个位置上的XY已经完成异或\n由此，我们得到，向第n位进位$C_n &#x3D; (2n+3)ty$，第n位本位和$S_n&#x3D;(2n+6)$。注意，索引从0开始。\n从第二位开始，计算出本位和的时间比得到进位的时间多3ty，计算出向下进位的多2ty\n\n\n先行进位加法器\nC3 &#x3D; 𝐺3 + 𝑃3𝐺2 + 𝑃3𝑃2𝐺1 + 𝑃3𝑃2𝑃1𝐶0\n\n\n\n\n\n\n内存\n搞清楚哪些需要刷新，哪些可以改写\n\n判断可能发生访存冲突的规则如下：给定的访存地址在相邻的四次访问中出现在同一个 存储模块内。\n\n\n使用 32 个 64K×1bit 的 DRAM 芯片组成一个 256K×8bit 的存储器。\n a) 若采用集中刷新方式，则存储器刷新一遍最少用多少次刷新操作？\n 64K×1bit 的 DRAM 由 256×256 的位元阵列组成，即每个芯片有 256 行、256 列的位元 阵列。集中式刷新按行刷新，因此需要用 256 次刷新操作。\n b) 若采用异步刷新方式，每单元刷新间隔不超过 2ms，则生成的刷新信号的间隔时间 最长是多少？（保留一位小数，单位为 μs） 2ms&#x2F;256≈7.8μs \n c) 若改用 16K×4bit 的 DRAM 芯片构成上述 256K×8bit 的存储器，则以集中式刷新一 遍所有单元需要多少次刷新操作？ 16K×4bit 的 DRAM 芯片由 4 个 128×128 的位元阵列组成，这 4 个存储阵列中行号相同 的那些行将被同时刷新，共有 128 行，因此需要 128 次刷新操作。\n\n\n\nCache\n要会分析主存地址的格式，用已知条件推断出地址的某几位是什么功能\n\ne.g. 一个组关联 Cache 由 64 个行组成，每组 4 行。主存储器包含 4K 个块，每块 128 字，请表示主存 地址的格式。\n\n解：由每块 128 字得到块内地址长 7 位，64 行每组 4 行得一共 16 组，需要 4 位表示，标记需要 12（4K） -4（组号）&#x3D;8 位\n\n\n\n先分析多少块，再分析块内地址，块，行，再分析tag\n一行一块\n\n\n直接映射：\n块数 &#x3D; 总数据区大小 &#x2F; 块大小\n块内地址：表示块大小\n行号 &#x3D; 块数 mod 行数\ntag\n\n\n关联映射\n块内地址：表示块大小\n\n\n组关联映射：\n块数 &#x3D; 总数据区大小 &#x2F; 块大小\n组数 &#x3D; 块数 &#x2F; 每组行数\n块内地址 &#x3D; 表示块大小\n组号：表示组数\ntag\n\n\n\n\n题目中说的Cache的行号是数据区的大小。在数据之前还有额外的几位作为tag\n\n1K &#x3D; 2^10^ , 1M &#x3D; 2^20^ \n\n采用指令 Cache 与数据 Cache 分离的主要目的是减少指令流水线资源冲突\n\nCache 的总容量包括：存储容量和标记阵列容量（有效位、标记位、一致性维护位和替换算法控制位）。\n\n\n外存\n平均访问时间 &#x3D; 平均寻道时间 + 平均旋转延迟 + 扇区传送时间\n磁盘存储器的最小读写单位为一个扇区，即磁盘按块存取。一个扇面默认为512字节。\n磁盘存储数据之前 需要进行格式化，将磁盘分成扇区，并写入信息，因此磁盘的格式化容量比非格式化容量小\n磁盘扇区中包含数据、地址和校验等信息\n磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成\nRAID0 方案是无冗余和无校验的磁盘阵列，而 RAID1～RAID5 方案均是加入了冗余(镜 像）或校验的磁盘阵列。\n\n虚拟内存\n解决问题时也要分析地址结构，区分页内地址和页号，然后查表\n\n关于缺页处理：\n\n缺页是在地址转换时 CPU 监测到的一种异常\n缺页处理由操作系统提供的缺页处理程序来完成\n缺页处理程序根据页故障地址从外存读入所缺失的页\n缺页处理完成后回到发生缺页的指令继续执行\n\n\nCache和TLB的相同点：\n\n命中率都与程序局部性有关\n缺失后都需要去访问主存\n缺失处理都可以由硬件实现\nCache 由 SRAM 组成；TLB 通常由相联存储器组成，也可由 SRAM 组成。DRAM 需要不断刷 新，性能偏低，不适合组成 TLB 和 Cache。静态存储器（SRAM），读写速度快，但成本高， 多用于容量较小的高速缓冲存储器。\n\n\n例题\n\n假设一个分页虚拟存储系统的虚拟地址为 40 位，物理地址为 36 位，页大小为 16KB，按字节编址。 若页表中的有效位、存储保护位、修改位、使用位共占 4 位，磁盘地址不在页表中。则该存储系统 中每个程序的页表大小为多少（单位：MB）？（说明：1.假设每个程序都能使用全部的虚拟内存； 2.页表项的长度必须为字节的整数倍） \n答：256MB\n按字节编址，故： 虚拟主存页面个数：2^(40-14)^&#x3D;2^26^ 物理主存页面数：2^(36-14)^&#x3D;2^22^ 页表项的最小长度：22+4&#x3D;26 根据说明 2，取 32 位（4B） 页表大小：2^26^ * 4B&#x3D;256MB\n\n\n通过虚拟地址查页，取到的物理页号和页内地址拼起来，就是物理地址了。\n\n看第七次作业第二题，每一步都搞懂\n\n\n为什么 Cache 可以采用直写策略，而修改页面内容时总是采用回写策略？\n答：因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在 Cache-主存层次，Cache 可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是 采用回写策略。\n\n\n计算cache的总容量时，除了数据位，注意每一行都还有一些标志位，如脏位，策略位等等。\n\n策略：\n\n最近最少使用算法（Least Recently Used, LRU）：在2路组时，需要一位标志位\n先进先出算法（First In First Out, FIFO）：需要一位标志位\n最不经常使用算法（Least Frequently Used, LFU）：需要一个计数器，不是标志位\n随机替换算法（Random）：不需要\n\n\n映射：\n\n关联映射又称为全相联映射\n\n\n\n\n\n指令系统\n牢记多种寻址方式\n\n括号（）表示取其内容。\n\n汇编语言程序员可见的是程序计数器(PC),即汇编语言程序员通过汇编程序可以对某个寄存器进行访问。 汇编程序员可以通过指定待执行指令的地址来设置 PC 的值，如转移指令、子程序调用指令等。而 IR、 MAR、MDR 是 CPU 的内部工作寄存器，对程序员不可见。\n\n汇编程序员可见的寄存器有基址寄存器(用于实现多道程序设计或者编制浮动程序)和状态&#x2F;标志寄存器、 程序计数器 PC 及通用寄存器组；而 MAR、MDR、IR 是 CPU 的 内部工作寄存器，对汇编程序员不 可见。微指令寄存器属于微程序控制器的组成部分，它是硬 件设计者的任务，对汇编程序员是不可见的。\n\n程序计数器 PC 给出下一条指令字的访存地址（指令在内存中的地址），它取决于存储器的字数，而不是编址的字节数。所以对于32字按字节编址的机器来说，每条指令要4字节，PC应该+4.\n\n例题\n\n【2017 统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29  条、二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是( )。 A. 24 位 B.26 位 C. 28 位 D.32 位\n答：A\n三地址指令有 29 条，所以其操作码至少为 5 位。以 5 位进行计算，它剩余 32-29&#x3D;3 种操作码给二地址。 而二地址另外多了 6 位给操作码，因此其数量最大达 3×64&#x3D;192。所以指令字长最少为 23 位，因为计算 机按字节编址，需要是 8 的倍数，所以指令字长至少应该 24 位，选 A。\n\n\n\n指令流水线\n字段直接编码法将微命令字段分成若干小字段，互斥性微命令组合在同一字段中，相容性微命令分在不 同字段中，每个字段还要留出一个状态，表示本字段不发出任何微命令。\n\n数据在功能部件之间传送的路径被称为数据通路，包括数据通路上流经的部件，如程序计 数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路由控制部件控制，控制部件 根据每条指令功能的不同生成对数据通路的控制信号。因此，不包括控制部件。\n\n加速比的计算：\n\n误解：流水线中的阶段数越多，执行速度越快。$t &#x3D; t_m + d$，d是固定的\n\n对于k阶段流水线执行n条指令所需时间为：$T_{k,n}&#x3D;[k+(n-1)]t$\n\n加速比：$$S_k&#x3D;\\frac{T_{1,n}}{T_{k,n}}&#x3D;\\frac{nkt}{[k+(n-1)]t}&#x3D;\\frac{n}{1+\\frac{n-1}{k}}&gt;1$$\n\n\n冒险\n\n控制器\n在编写微操作序列时，别忘记括号\n\n例如，(MBR)表示取到MBR中的值\n例如，（IR(address1)）表示取到IR中一地址的部分的值\n\n\n做减法时，为操作数一减操作数二\n\n\n一个指令周期有 4 个主要阶段：取指、间址、执行和中断。硬布线方式实现时，采用一个 2 位的寄 存器来标志当前阶段，但微程序式控制器却不需要类似的标志。请问为什么硬布线式控制器需要这 些标志，而微程序式控制器不需要这些标志？\n答：在硬连线式控制器中，当前阶段会作为输入的一部分，用于布尔逻辑式的计算，因此需要采用 2 位 的寄存器来标志当前阶段。 在微程序式控制器中，所有的微指令都存储在控制存储器中，排序逻辑会确定下一条将要执行的微 指令，各个阶段之间通过跳转来实现，因此不需要状态标志。\n\n\n\n总线\n在计算数据传输速率时，读出一个字，要考虑把地址传给内存，内存准备，内存把数据送回来的三个过程。\n\n同步总线中的各个步骤的时间要求是时钟周期的整数倍，注意时钟同步！！！\n\n在异步总线中，数据准备是2,3,4步。内存收到地址就立马开始准备，同时发送第2次握手的信息。\n\nUSB(通用串行总线)的特点有：①即插即用；②热插拔；③有很强的连接能力，采用菊花链 形式将众多外设连接起来；④有很好的可扩充性，一个 USB 控制器可扩充高达 127 个外 部 USB 设备；⑤高速传输，速率可达 480Mb&#x2F;s。所以 A、B、C 都符合 USB 总线的特点。 对于 D,USB 是串行总线，不能同时传输 2 位数据。\n\nUSB 是一种连接外部设备的 I&#x2F;O 总线标准，属于设备总线，是设备和设备控制器之间的接 口。而 PCI、AGP、PCI-E 作为计算机系统的局部总线标准，通常用来连接主存、网卡、视 频卡等。\n\n猝发(突发)传输是在一个总线周期中，可以传输多个存储地址连续的数据，即一次传输一个 地址和一批地址连续的数据，并行传输是在传输中有多个数据位同时在设备之间进行的传 输，串行传输是指数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输的方 式，同步传输是指传输过程由统一的时钟控制。\n\n【2016 统考真题】下列关于总线设计的叙述中，错误的是（A）。 A.并行总线传输比串行总线传输速度快 B.采用信号线复用技术可减少信号线数量 C.采用突发传输方式可提高总线数据传输率 D.采用分离事务通信方式可提高总线利用率\n\n初看可能会觉得 A 正确，并行总线传输通常比串行总线传输速率快，但这不是绝对的。在 实际时钟频率较低的情况下，并行总线因为可以同时传输若干比特，速率确实比串行总线快。 但是，随着技术的发展，时钟频率越来越高，并行总线之间的相互干扰越来越严重，当时钟 频率提高到一定程度时，传输的数据已无法恢复。而串行总线因为导线少，线间干扰容易控 制，反而可通过不断提高时钟频率来提高传输速率，A 错误。\n总线复用是指一种信号线在不 同的时 间传输不同的信息，它可使用较少的线路传输更多的信息，从而节省空间和成本， 因此 B 正确。\n突发(猝发)传输是指在一个总线周期中，可以传输多个存储地址连续的数据， 即一次传输一个地址和一批地址连续的数据，C 正确。\n分离事务通信是总线复用的一种，相 比单一的传输线路可以提高总线的利用率，D 正确。\n\n\n各总线通过桥接器相连，后者起流量交换作用。\n\n如果每个时钟周期传送两次数据，则意思是上升沿和下降沿各传送一次数 据\n\n注意，事务间空闲要算到事务时间当中，即使是最后一个事务，也要有空闲时间。\n\n\n一个 32 位的微处理器，它有 16 位的外部数据总线，由 40MHz 输入时钟驱动。 \na) 假设一个总线事务需要的最短时间等于 4 个输入时钟周期，那么需要 16 个时钟周 期的总线事务中，这个处理器可能维持的最大数据传输率是多少（单位：Mbps）？\nb) 如果将它的外部数据总线扩展为 32 位，那么该总线的最大数据传输率提高到多少 （单位：Mbps）？ \n解：\na）一个总线事务过程除了数据传送阶段外，还包括其他阶段，如传送地址和总线 命令、准备数据等，所以，完成一个总线事务所用的所有时钟周期并不都用来传输数据。 由于一个总线事务需要的最短时间为4个时钟周期，这表明在传输最少数据的情况下（占 用1个时钟周期），依然需要3个时钟周期来传送其它信息。 假设一个总线事务占用n个时钟周期，那么最大数据传输率为： 16bit * (n-3)&#x2F;n * 40MHz &#x3D; 640(n-3)&#x2F;n Mbps 例如，当n为16时，最大数据传输率为520Mbps \nb）若采用32位总线宽度，则总线带宽可以提高到1280(n-3)&#x2F;n Mbps。这种措施 的效果和加倍外部处理器总线时钟频率的效果相同。 补充：由于处理器是32位的，地址可能为32位。当采用16位数据总线时，需要 2个时钟周期传递地址；而改成32位总线，只需要1个周期传递地址。原来所需要的 3个额外时钟周期可能减少到2个，因此带宽可以提高到1280(n-2)&#x2F;n Mbps，优于加 倍时钟频率。\n\n\n带宽是最大数据传输率，可以认为是一秒钟最多传多少位。注意，若地址线和数据线不复用，也只算数据线。\n\n\n每次传输 8 个字的数据块，其中 60%的访问是读操作总线事务，40%的访问是写操 作总线事务，总线 2 的数据传输率是多少（单位：Mbps）？\n\n\n\n\nI&#x2F;O\n.I&#x2F;O 接口中 CPU 可访问的寄存器称为 I&#x2F;O 端口\n\n\n【2014 统考真题】下列有关 I&#x2F;O 接口的叙述中，错误的是( D )。\n A.状态端口和控制端口可以合用同一个寄存器 \nB.I&#x2F;O 接口中 CPU 可访问的寄存器称为 I&#x2F;O 端口 \nC.采用独立编址方式时，I&#x2F;O 端口地址和主存地址可能相同 \nD.采用统一编址方式时，CPU 不能用访存指令访问 I&#x2F;O 端口\n\n\n采用统一编址时，CPU 访存和访问 I&#x2F;O 端口用的是一样的指令，所以访存指令可访问 I&#x2F;O 端 口，D 选项错误。其他三个选项均为正确陈述。\n\n\n外部中断是指 CPU 执行指令以外的事件产生的中断，通常指来自 CPU 与内存以外的中断。 \n\n在单级(或单重)中断系统中，不允许中断嵌套。中断处理过程为：① 关中断；② 保存断点； ③ 识别中断源；④ 保存现场；⑤ 中断事件处理；⑥恢复现场；⑦ 开中断；⑧ 中断返回。 其中①～③由硬件完成，④～⑧由中断服务程序完成。\n\n所以如果问中断程序内的事务，不考虑关中断。\n响应外部中断的过程中，中断隐指令完成的操作，不算在中断服务程序内，也就是硬件部分的操作\n\n\n中断处理方式：在 I&#x2F;O 设备输入每个数据的过程中，由于无须 CPU 干预，因而可使 CPU 与 I&#x2F;O 设备并行工作。仅当输完一个数据时，才需 CPU 花费极短的时间去做一些中断处理。 因此中断申请使用的是 CPU 处理时间，发生的时间是在一条指令执行结束之后，数据在软 件的控制下完成传送。而 DMA 方式与之不同。DMA 方式：数据传输的基本单位是数据块， 即在 CPU 与 I&#x2F;O 设备之间，每次传送至少一个数据块；DMA 方式每次申请的是总线的使 用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开 始和结束时，才需要 CPU 干预，整块数据的传送是在控制器的控制下完成的。\n\nDMA也不是仅适用于快速外部设备，只是低速的不划算\n\n一个多重中断系统的中断可以看做是三大步：保护现场，中断处理，恢复现场。其中，中断处理时为开中断。\n\n每类设备都配置一个设备驱动程序，设备驱动程序向上层用户程序提供一组标准接口，负责 实现对设备发出各种具体操作指令，用户程序不能直接和 DMA 打交道。\n\nDMA 的数据传送 过程分为预处理、数据传送和后处理 3 个阶段。\n\n预处理阶段由 CPU 完成必要的准备工作， 数据传送前由 DMA 控制器请求总线使用权；\n数据传送由 DMA 控制器直接控制总线完成\n传送结束后，DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处 理。\n\n\n周期挪用法就是周期窃取\n\n周期挪用法由 DMA 控制器挪用一个或几个主存周期来访问主存，传送完一个数据字后立 即释放总线，是一种单字传送方式，每个字传送完后 CPU 可以访问主存，选项 C 错误。停 止 CPU 访存法则是指在整个数据块的传送过程中，使 CPU 脱离总线，停止访问主存。\n\n\n\nDMA获得和释放总线权限的时间都要算\n第一问：五个时间分别是：获取权限，第一个字节的准备时间，后面127字节的准备时间和前127字节的传送时间（同时进行取最大），最后一个字节的传输时间，释放权限\n第二问：为什么没有考虑准备时间呢？\n\n\n周期窃取中，如果CPU和DMA没有访存冲突，则在数据传输阶段时，CPU不受影响，不用考虑CPU占用时间。\n\n在传输数据时，可以同时准备数据！！！要比较他们的时间（一般来说是准备时间比较长）\n\n总结：\n\nI&#x2F;O访问方式：\n查询：注意CPU占用率总是100%\n中断驱动：注意中断服务程序可能包含了数据传输\n\n\nDMA访存\nCPU停止法\n周期挪用\n交替分时访问（没考过？）\n\n\n\n\n\n在包含 DMA 模块的系统中，一般 DMA 存取主存储器的优先级比处理器存取主存储器的优 先级高，为什么？\n答： 如果处理器被停止访问主存储器，除处理时间延长外不产生其它问题。但 DMA 可能连接 高速数据传输设备，如果不及时获取主存储器的存取权限来及时写入数据，则可能会因 为缓冲区溢出而造成数据丢失。所以，一般 DMA 存取主存储器的优先级会高于处理器。\n\n\n注意描述速度时，1K&#x3D;1000；描述内存大小时，1K&#x3D;1024\n\n\n","categories":["课业"]},{"title":"编译原理","url":"/2024/05/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":"Ch1 · 综述\n编译路线\n\n源代码 (Source Code)\n→ 词法分析 (Lexical Analysis) → 生成标记 (Tokens）→ 语法分析 (Syntax Analysis) → 生成抽象语法树 (AST)→ 中间表示生成 (Intermediate Rep. Generation) → 生成中间表示 (IR)→ 目标代码生成 (Target Code Generation) → 生成机器代码 (Machine Code)\n\n\n\n词法分析（Lexical Analysis)\n正则语言(Regular Language)\n有穷自动机(Finite Automata)\n\n\n语法分析 (Syntax Analysis)：\n上下文无关语言 (Context-Free Language)\n下推自动机 (Push-Down Automata)\n\n\n更复杂的语言（例如递归语言等）：\n递归语言 (Recursive Language)\n图灵自动机 (Turing Automata)\n\n\n\n\n\nCh3-1 · 有穷自动机确定有穷自动机（Deterministic Finite Automata，DFA）\n概述\n是一个五元组\n\n有限的状态集Q\n有限的输入Σ\n转换函数𝛿\n初始状态q\n终止状态集F\n\n\n总能输出”accept”或”reject”\n\n有两个“基本集合”：最终状态和非最终状态\n\n\nMinimization\n首先，把状态区分为最终状态和非最终状态两个集合\n然后细分集合，把“去向”不同状态的分开\n\nBi-Simulation\n用于判断两个状态机是否等价\n\n\n用一个pair把两者的起始状态表示出来\n写出它们分别经过a, b后的pair\n若这些pair没有出现在state pairs中，则加入进去，重复上述操作\n如果两个状态机同时进入最终状态，则等价\n\n不确定有穷自动机（Non-deterministic Finite Automata，NFA）概述\n判断：\n\n“路径”是不确定的，可能有多条路\n含有空字符边\n\n\n如果一个走不通，就试其他路径\n\n只要有一条路通了，就认为这个自动机接受这个字符串\n\n\n𝜖-Closure\n如果从状态集合 S 出发，可以经过零个或多个ε转换到达其他状态，那么这些状态都属于𝜖-Closure(S)。\n\n$δ^*$\nδ∗(q,w)&#x3D;{q′∣q′∈δ(q,a) for some a∈Σ or w&#x3D;ϵ}\n用于描述在给定状态下，经过一整个输入字符串的处理后，自动机可能到达的状态集合。\n\nDFA和NFA的关联\nNFA&lt;&#x3D;&gt;DFA，二者可以相互转化\n\nDFA是特殊的NFA，只不过没有空串，且只有一条出边\n\nNFA可以通过子集构造法变为DFA\n\n\n\n若一个集合中含有final state，则整个集合构成的状态是final state\n\n子集构造法：\n\n核心思想：让构造的DFA的每个状态对应NFA的一个状态集合\n如果NFA中有n个状态，则DFA中最多可以有2^n^个状态。因为DFA中的状态是NFA状态集合的子集。\n\n\nL(a)表示a的自动机\n\n\nCh3-2 · 词汇分析（Lexical Analysis)正则语言(Regular Language)从正则到NFA\n$L_1 U L_2$\n\n$L_1L_2$\n\n$L_1^R$\n\n$L$\n\n$L_1$取反\n\n交集\n\n正则的性质\n\n\n从DFA到正则\n变量消除法：把各个状态都表示出来，再把终止状态表达式中的其他状态消去。\n\nPumping Lemma\nPumping Lemma 证明不是正则语言：如果你能够找到一个语言 LL的字符串 w，并证明无论如何分解都无法满足 Pumping Lemma 中的条件，那么就可以证明该语言不是正则的。\n\n\n内容：\n理解：若|w| &gt; n（n是自动机的状态数），则一定有“回头路”。$w_i&#x3D;xy^iz$且|xy|&lt;n, |y|&gt;1.\n若存在k使得$xy^kz$不属于L，则L不是正则\n上面这条可以证明$a^nb^n$不是正则语言\n\n\n\nCh4-1 · 上下文无关语言上下文无关文法（Context-Free Grammar，CFG）\n定义\n上下文无关文法（Context-Free Grammar，CFG）是一种用于描述计算机语言和自然语言语法的形式文法。它由四元组 G&#x3D;(V,Σ,P,S)G &#x3D; (V, \\Sigma, P, S)G&#x3D;(V,Σ,P,S) 组成，其中：\n终结符集合 Σ：一组基础符号，不能再被替换（如字母、数字、标点等）。\n非终结符集合 V：一组可以继续展开的符号（如语法成分：句子、名词短语等）。\n规则集合 P：一组产生式规则，每条规则的形式为 A→α，其中 A 是非终结符，α 是终结符和&#x2F;或非终结符的序列。\n起始符号 S：语法生成的起点，通常是一个非终结符。\n\n\n\n\n推导\n最左推导和最右推导：就是优先把最左边或者最右边的符号展开\n\n\n歧义性：\n如果一个表达式可以构造出两棵语法树，则是有歧义的\n例子：w &#x3D; a + a * a.这是有歧义的\n\n\n\n下推自动机(Push-Down Automata, PDA)概述\n上下文无关文法&#x3D;PDA&#x3D;NDA + Stack（z0）\n就是NDA加挂一个栈\n定义（是七元组，GPT说错了）：\n例子：\n\n简洁表达（三元组）：\n注意，有两种情况接受字符串：\n终止状态\n空栈\n\n\n\nCFG等价于PDA从CFG到PDA\n\n总是只有一个状态q\n若栈中为非终止符，则展开（如图前两行）\n如果读入终止符，则从栈中弹出\n\n从PDA到CFG\n\n注：\n$V_{pXq}$是一个中间字符，意思是从p到q状态，从栈中弹出了X。\n\n\n\n\n从初始状态到另一个状态，消耗了$S$，得到中间字符$V_{pSq}$\n从p到q，读入了a，弹出了X（PDA的读入和CFG的展开是一回事）\n读到了非终结符，展开，压入对应的中间字符\n\nNPDA和DPDA\nNPDA有歧义，DPDA没有\n两者不等价\n\n上下文无关语言（CFL）\n给定两个CFL：$L_1,L_2$\n\n仍然是CFL的\n\n并，$L_1UL_2$\n连接，$L_1L_2$\n星号，$L_1^*$\n倒置，$L_1^R$\n\n\n不一定是CFL的\n\n\n\n\n\n\nCFL与RL\n\n两者相交为也CFL\n\n\n\nPumping Lemma for CFLChomsky Normal Form（CNF）\nChomsky Normal Form (CNF, 乔姆斯基范式) 是上下文无关文法（Context-Free Grammar, CFG）的一种标准形式。若一个上下文无关文法符合 CNF，则它的所有产生规则必须满足以下两种形式之一：\n\n二元规则（Binary Rules）： 形如 A → BC，其中 A, B, C 均为非终结符（B 和 C 不能是起始符 S）。\n终结规则（Terminal Rules）： 形如 A → a，其中 A 为非终结符，a 为终结符。\n\n此外，还允许一个特殊的起始符规则：\n\nS → ε（仅当 S 不出现在其他产生式的右侧时），表示空串。\n\n\n\nPuming Lemma\n\n是RL的Puming Lemma的升级版，要分解为五部分\n要重复的是2,4两部分，两者不能都为空\n\nCh4-2 · 语法分析(Syntax Analysis)自上而下的语法分析（Top-down parsing）概述\nTop-down parsing 是一种解析技术，用于分析输入字符串的语法结构。它从语法的起始符号（根节点）开始，逐步向下扩展，直到生成与输入字符串匹配的解析树\n特点：\n解析树的构建方向：从根节点（起始符号）开始，逐步向下构建解析树。\n推导方式：使用左推导（leftmost derivation），即每次替换最左边的非终结符。\n解析过程：解析器尝试应用语法规则，逐步匹配输入字符串。如果匹配失败，可能需要回溯（backtracking）。\n\n\n主要类型\n递归下降解析（Recursive Descent Parsing）：\n通过递归函数实现解析，每个非终结符对应一个函数。\n可能需要回溯，尤其是在语法存在左递归或多个可选规则时。\n\n\n预测解析（Predictive Parsing）：\n一种特殊的递归下降解析，通过向前看（lookahead）符号预测应用的规则。\n不需要回溯，效率更高，但对语法的要求更严格。\n\n\n\n\n\nLL（1）文法\n定义\nLL(1) 是一种 自上而下的预测分析文法，其中：\n\n第一个 L：表示 Left-to-right（从左到右解析）\n第二个 L：表示 Leftmost derivation（最左推导）\n(1)：表示 每次只查看一个输入符号 来决定如何推导\n\n\n特点：\n\n不是二义性的 (Not ambiguous)：每个输入字符串最多有一个语法分析树。\n没有左递归 (Not left-recursive)：文法不能包含直接或间接左递归，否则预测分析无法工作。\n可以使用一个符号的前瞻 (1-token lookahead) 进行预测。\n\n\nLL(1) 文法的条件\n文法是 LL(1) 当且仅当 所有产生式$A→α∣βA \\to \\alpha | \\beta A→α∣β$ 满足：\n\nα 和 β 不能以相同的终结符开头（避免选择冲突）。\n\n解决方法：左因子提取 (left factoring)\n\n例如：\nA → ab | ac\n\n不是 LL(1)，因为 ab 和 ac都以 a开头，可以重写为：\nA → a BB → b | c\n\n\n至多一个选项可以推导空串 (ε)，否则 Follow 集合会冲突。\n\n例如：\nA → α | β\n\n\n如果 FIRST(α) 和 FIRST(β) 有交集，则不是 LL(1)\n如果 ε ∈ FIRST(α) 并且 ε ∈ FIRST(β)，则 FOLLOW(A) 可能冲突。\n\n\n\n\n如果某个选项能推出空串（ε），另一个选项不能以 FOLLOW(A) 里的终结符开头，否则解析器无法确定如何解析。\n\n例如：\nA → α | ε\n\n\n如果 FOLLOW(A) 包含 b，且 FIRST(α) 也包含 b，则不是 LL(1)。因为当输入 b 时，解析器无法确定使用 A → α 还是 A → ε。\n\n\n\n\n\n\n右下角的示例文法E  →  T E&#x27;E&#x27; →  + T E&#x27; | εT  →  F T&#x27;T&#x27; →  * F T&#x27; | εF  →  ( E ) | id\n\n验证是否 LL(1)：\n\n没有左递归\nE&#39; → + T E&#39; | ε，由于 + 不在 FOLLOW(E&#39;) 中，因此符合条件\nT&#39; → * F T&#39; | ε，由于 * 不在 FOLLOW(T&#39;) 中，因此符合条件\n没有 FIRST 集合冲突\n\n✅ 符合 LL(1) 文法规则！\n\n\n递归下降解析（Recursive Descent Parsing）\n思想：通过递归函数实现解析，每个非终结符对应一个函数。\n\n问题和解决：\n\n需要回溯。当一种情况不被接受，还要回过头去尝试。\n\n例子：\n显然cAb应该被接受。但是在函数A()中，提前把b消了，导致结果为False。此时应回溯\n\n\n解决：\n我们定义两个函数：\nFirst(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身\nFollow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。\n\n\n\n\n\n\n\n左递归循环。\n\n问题描述：\n\n\n会发现没有读入任何字符，在A()中无限循环\n\n\n解决：套公式\n\n有“循环项”和“非循环项”，先表示全部的非循环项，在用A’表示所有循环项。\n\n\n消除直接左递归\n就是要得到展开式不以相同字符开头。\n$A{\\to}Ab|c$变为$A{\\to}cB,B{\\to}bB|𝜖$\n以这样的形式就可以至少读入一个字符，避免无限循环\n\n\n消除间接左递归\n带入，然后消除直接左递归\n\n\n\n\n\n\n\n\n\nCh6-1 · 中间表示（Intermediate Representation，IR）三地址码\n形式：\n\n右侧最多只有一个运算符\n每条语句最多只有三个地址（变量）\n\n\n四元式（Quadruples）：四元式（Quadruples）是一种中间代码，用于表示三地址代码。\n\n形式：(op, arg1, arg2, result)\n\n\n三元式（Triples）：\n\n形式：\n(op, arg1, arg2)\n优化：Triples with Syntax DAG（有向无环图）。避免重复运算。\n在表达式计算或代码优化时，相同的子表达式可能会重复出现。DAG 通过共享公共子表达式，减少重复计算，提高效率。\n\n\n\n\n\n\n\n\n语法制导翻译\n语法制导定义SDD\n\nSDD由两部分组成\n上下文无关文法（CFG）\n属性和语义规则\n\n\nCFG 只能描述语法，而 Ruler 规则使 CFL 具备了语义处理能力。\nCFG表述了一颗语法树在某一步如何展开，对应的Ruler告诉你在某一步应该计算什么\n\n\nGeneration of Syntax DAG：消除重复计算\n\n\n语法制导翻译（Syntax-Directed Translation，SDT）\n\n变量声明\n\n\nrecord是一个终结符，后面跟一个声明的列表，用大括号包围\n\n有offest指针\nrecord嵌套怎么办？用栈记录\n\n\n\n\n一般语句：\n符号说明：\n“||”表示拼接\nE.addr：计算结果的地址，通常是一个临时变量或标识符\nE.code：计算该表达式的中间代码\n\n\n\n\n\n流控制：\n符号说明：\nS.next：S的下一条语句\nB.true &#x2F; B.false：是标签，表示B这个布尔表达式的值为true &#x2F; false时，要跳转的标签\n\n\n\n\n布尔语句\n\n\n\nCh6-2 · 翻译为SSA形式静态单赋值（Static Single Assignment，SSA）\n特点：\n\n每个变量只能定义（赋值）一次\n\n用φ函数，根据流从多条路径中合并定义（赋值）\n\n例：\nif (cond) &#123;    x1 = 1;&#125; else &#123;    x2 = 2;&#125;x3 = φ(x1, x2)   // 选择 x1 或 x2 作为 x3y1 = x3 + 3;\n\n\n\n\nGated SSA：\n\n使用“门”变量（Gate Variables）来控制 φ（phi）函数的赋值，避免不必要的计算和存储开销。加一个条件\n\n在上例中，φ(x1, x2) 在控制流合并点 无条件执行，即使 cond 为 true，x2 也会被计算（在 else 分支不执行的情况下）。\n\n使用GSSA，φ_g(cond, x1, x2) 只有在 cond 确定后才执行对应的赋值，不会无条件执行所有分支的赋值。\n\n𝛍（mu）函数 处理 循环入口（Loop Entry） 的变量初始化。之后遇到，让X2直接继承X4的值。\n𝛈（eta）函数 处理 循环体（Loop Body） 内部变量的更新。\n\n\n\n\nLLVM IR\nFunction\n每个变量都用“%n”标记，这就保证了SSA的要求\n\n\nGEP（指令，GetElementPtr，获取元素指针）\n\n翻译为 SSA\n基本块\n基本块的第一条指令一定是leader：\n函数的第一条指令是leader\n跳转目标地址的指令是leader\n跳转指令后紧跟的指令是leadeer\n\n\n一些基本块相关的名词\n自然循环\n定义：\n只有一个header，称作支配\n最大的SCC（强联通分量）\n\n\n\n\n支配：\n\nA支配B：从入口开始进入B的所有路径一定经过A\nA后支配B：从B开始到出口的所有路径一定经过A\nA严格支配B：A支配B但是A不等于B。所有基本块都支配自己，但它们不会严格支配自己\nA立即支配B：A严格支配B，且不存在A严格支配C的同时C严格支配B\n\n\n\n\n控制依赖\n如果A节点的结果决定了会不会经过B，则B控制依赖于A。\n注意可以自己控制依赖自己\n\n\n依赖前沿\n就是B所支配的块的后继，且该后继不被B支配。\n出入口节点的支配前沿一定是空集\n迭代的支配前沿：计算出支配前沿，再把结果加入Bset，然后循环，直到不动点。\n\n\n\n\nIDF vs. SSA\n某个块中的变量可能传播到其支配前沿，所以要在支配前沿需要插入φ。\n\n\n\n\nCh8-1 · Target Code Generation块内优化基于树的指令选择\n例子：\n\n窥孔优化\nCh8-2 · Translation out of SSA消除φ\n两大问题：\nThe Lost Copy Problem\nThe Swap Problem\n\n\n统一的解决方法（不考）\n\n\n\n\nCh8-3 · 寄存器分配\n一般考局部而不是全局\n\n局部分配（Local Register Allocation）\n要求\n生成的代码只能用到不多于k个寄存器\n最少地使用loads, stores\n足够高效O(N), O(N logN)\n\n\n术语\nlive：在后面还会被调用，即在最后一次调用之前\nspilling：溢出，把值从寄存器存入内存\n\n\n方法：\n检查最大同时使用的寄存器数量n\n若k&gt;&#x3D;n，则容易处理\n若k&lt;n，则要spilling。把暂时不用的数据存到内存中，要用的时候再调出来。\n\n\n\n\n\n全局分配（Global Register Allocation）\n思想：图着色算法\n\n先画出干扰图\n会同时生存的寄存器之间加一条边\n\n\n计算着色最少需要的颜色n\n若k&gt;&#x3D;n，即能够用k种颜色着色，则容易处理\n如果k&lt;n则spilling\n\n\n\n\nChaitin’s Algorithm（一个图着色算法）\n\n易知，若节点的度小于k，则容易用k色着色\n\n\n所以，我们先把度小于k的节点压栈，最后着色\n如果没有，则选择一个度最小的节点放入列表。\n若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。\n迭代第1、2、3条\n\n\nChaitin-Briggs Algorithm（前一个算法等等改进）\n\n思想是不急着spilling，减少spill code\n即使没有满足要求的节点，我们也尝试把一个节点压栈。\n不一定成功\n\n\n\n\n\nCh10 · 指令流水线去看PPT上的示例\n\n我们能否通过调整寄存器分配和指令顺序，从而生成出更快的代码呢？\n\n指令调度的约束（Scheduling Constraints）\n依赖关系\n真依赖关系（Read-After-Write Dependence）：无论如何调度，都不能打乱指令的顺序\n假依赖关系：看似不能打乱顺序，但可以通过重命名寄存器解决1.\nAntidependence\n左图不能交换两条指令的顺序，否则MUL拿到了R2就不对了。\n但事实上可以像右图那样解决\n\n\nOutput dependence（Write-After-Write）\n\n\n\n\n\n基本块调度\n依赖图：\n节点(Node): Instructions\n边（Edge): True Dependence (Read-After-Write Dependence)\n深度(Depth)：从某一块到结束所需要的时钟周期\n\n\nList Scheduling（列表调度）\n\n\n\n\n全局代码调度\nExtended Basic Block（EBB）\n\n定义：\n\n扩展基本块只有一个入口点\n除了第一个基本块可以有多个前驱基本块外，其他基本块都只有一个前驱基本块，且这个前驱基本块必须在扩展基本块内。\n\n\n\n可以把每条EBB path当做一个基本块来指令调度\n\n但是可能破坏程序的语义。比如说g需要c，但是我们把c移动到了B2，导致B3语义变化\n我们要添加一些指令来保证语义\n\n\nDownward Code Motion（下移）\n\nsrc 不支配 dst\n我们需要把dst块复制一下，保证其他路径的语义\n\n\ndst 不后支配 src\n要把下移的指令也复制到其他块\n\n\n\nsrc支配dst 且 dst后支配src\n直接下移即可，因为没有其他路径\n\n\n\n\nUpward Code Motion（上移）\n\ndst 不后支配 src：每条路径都要复制一条才行\n\nsrc 不支配 dst：\n\n对于其他路径，其”父节点“多出来一条指令。我们需要做逆操作\n\n但是可能会有干扰，比如说你添加undo指令之后，其他父节点又多出来一句。解决方式是复制基本块：\n 变为\n\n\n\n\n\n\n\n\nCh9-1 · 数据流分析（Data Flow Analysis）数据流方程\n\n代码优化：\nLocal common subexpression\nGlobal common subexpression\nCopy propagation\nStrength reduction\nInduction-variable elimination\n\n\n相关概念：\n分析算法：\n前两行是初始化\n后面的操作可以自定义。下面有几种不同的定义。\n要求：是单调的。这样才能让OUT[B]最终确定下来。\n\n\n\n\n\n三大经典DFA\nReaching Definitions（到达定义分析）\n函数定义\n定义传递函数$f_B$为基本块B输入的定义减去覆盖（kill）的定义加上生成的定义。\n定义合并函数&#x2F;\\为并集\n\n\n分析的例子见PPT\n\n\nAvailable Expressions（可用表达式分析）\n什么是avaliable的？\n后面的4*i可以用前面的代替，也就是中间没有重新定义\n\n\n函数定义\n定义传递函数$f_B$为基本块B输入的定义减去覆盖（kill）的定义加上生成的定义。\n定义合并函数&#x2F;\\为交集\n\n\nLive Variable Analysis（活跃变量分析）\n\n这是一个从后向前的分析，因为是根据某一个块的表达式来分析前一个块的信息。\n\n\nWhat’s the Best Order of Blocks\n深度优先。在这里，深度优先搜索是一个逆向的后序搜索。\n\n\n\n\n\n局部冗余（Partial Redundancy）\n冗余的来源\n\n\n\n无法完全消除冗余\n我们希望尽可能的不要重复计算，多次变一次\n分析步骤见PPT\n\n懒惰代码运动问题（The Lazy Code Motion Problem）\n是什么（3点）\n\n\n\n消除所有可以消除的表达式冗余计算\n优化后的程序不会执行原程序中不存在的计算\n尽可能晚地计算表达式\n\n\n怎么办（4点）\n\n\n\n第一步：找到预期表达式\n\n\n预期表达式是指从此到结束一定会计算的表达式（像后支配）\n从后往前，如果从程序点 p 出发的所有路径最终都会计算表达式 e，那么称 e 在 p 处是预期的\n\n\n第二步：可用表达式\n\n\n从前往后，如果表达式 e 在到达程序点 p 的所有路径上都是预期的，并且在到达 p 之前没有被覆盖，那么称 e 在 p 处是可用的。\n\n\n第三步：\n\n\n从前往后，如果到达程序点 p 的所有路径都看到了表达式 e 的最早放置位置，但尚未使用它，那么称 e 在 p 处是可推迟的。\n\n\n第四步：\n\n\n从后往前，如果表达式 e 在程序点 p 之后的某个路径上被使用，那么称 e 在 p 处是已使用的\n\n\n\n常数传播（Constant Propagation）\n概述：\n\n常数传播的基本概念\n在常数传播中，每个变量 v 被赋予一个状态，表示它在程序的某个点上的值。这些状态通常有以下几种：\n\nUNDEF：表示变量的值是未定义的。\nConstant：表示变量的值是一个具体的常数。\nNAC（Not a Constant）：表示变量的值不是常数，即变量的值在运行时可能会变化。\n\n这些状态可以用一个函数 m(v) 来表示，其中 m(v) 的值可以是 UNDEF、Constant 或 NAC\n\nm(v)的合并：\n\nMerge Function: m(x) ∧ m(x’)\nUNDEF ∧ Constant &#x3D; Constant，把UNDEF看做任意值\nNAC ∧ Constant &#x3D; NAC\nConstant ∧ Constant &#x3D; Constant，相同的constant合并后还是const\nConstant ∧ Constant’ &#x3D; NAC，不同的const合并后就不对了。\n\n\n\n\n单调性：\n\n\n\n\n\n\n两大特征：\n\n可能的数据流值集合是无界的（It has a unbounded set of possible data-flow values）：在常数传播中，一个变量在程序的不同路径上可能有不同的值。这些值的集合可能是无界的，即没有上限或下限。\n它不是分配的（It is not distributives）：f(a ∧ b) ≠ f(a) ∧ f(b).先合并再传播，和先传递再合并，不一样\n\n\n\nCh9-2 · 符号执行（Symbolic Execution）\n限制Limitations\n\n• Scalability\n• (1) Path Explosion\n• (2) External Calls\n• (3) Constraint Solving\n\n\n\n\n命题逻辑（PL）\n语法（syntax）：\nsolution\n可满足性(satisfiability)和有效性(validity)：\n\n\n\n\n\n范式\nNegation Normal Form (NNF)\n不允许出现$¬F$：例如：¬(a ∧ b) 写为 ¬a ∨ ¬b\n不允许出现$F⇒G$：例如：a ⇒ b 写为 ¬a ∨ b\n\n\n析取范式，Disjunctive Normal Form (DNF)\n\n\n\n合取范式，Conjunctive Normal Form (CNF)\n类似于DNF，只不过析取合取换位了\n\n\n\n\n可满足性等价（Equisatisfiability）\n两个公式 ϕ 和 ψ 是可满足性等价的，如果满足以下条件： ϕ 是可满足的⇔ψ 是可满足的\n\n\n\nTseitin Transformation\nTseitin 变换是一种将任意命题逻辑公式转换为合取范式（CNF）的方法，同时保持可满足性等价。![屏幕截图 2025-05-16 105137](E:\\Pictures\\Screenshots\\屏幕截图 2025-05-16 105137.png)\n![屏幕截图 2025-05-16 105146](E:\\Pictures\\Screenshots\\屏幕截图 2025-05-16 105146.png)\n把逻辑树写出来，根据逻辑树写出合取式，再改写以满足规范\n\nSAT problem\n如何判断一个式子是否可满足呢？真值表法太慢！\n\n\nDPLL\nDPLL算法是一种用于解决布尔可满足性问题（SAT问题）的回溯搜索算法。\n算法：\n选择一个未赋值的变量，为其分配一个真值（通常是True或False）。\n简化公式，递归地调用DPLL算法。\n如果递归调用返回不可满足，则回溯，为该变量分配另一个真值。\n\n\n小结论：\n$(a_1 ∨ a_2 ∨ ¬c) ∧ (b_1 ∨ b_2 ∨ c)$可以立即简化为$a_1 ∨ a_2 ∨ b_1 ∨ b_2$（无论c的取值）\n\n\n\n\nCDCL\n冲突驱动的子句学习（CDCL） 是一种先进的布尔可满足性问题（SAT）求解算法\n\n遇到需要讨论的地方，就假设。例如，假设x1&#x3D;0，那么x4&#x3D;1.\n遇到冲突，例如x9&#x3D;1 &amp;&amp; x9 &#x3D; 0，就分析导致冲突的条件。由图可知，是x3,x7,x8导致的。这就说明x3&#x3D;1,x7&#x3D;1,x8&#x3D;0不能够同时满足\n把¬x3 ∨ ¬x7 ∨ x8加入原式\n\n\n\n一阶逻辑（FOL）可满足性模理论（Satisfiability Modulo Theories， SMT）\nSMT求解器用于确定这些逻辑公式在给定理论下的可满足性。\n步骤：\nStep 1: Word-Level Preprocessing\n简化公式\n\n\n\nStep 2: Bit-Blasting (From FOL to PL)\n\n\n\nStep 3: DPLL&#x2F;CDCL\n\n\n\nCh12-1 · Inter-procedural Data Flow Analysis概述\n交叉过程数据流分析是一种程序分析技术，用于分析程序中数据在不同过程（函数、方法）之间的流动。与仅分析单个过程的**内过程（intra-procedural）**数据流分析不同，交叉过程分析考虑了过程之间的调用关系，能够更全面地理解程序的行为和数据依赖关系\n\n调用图和调用链\n调用图是一个有向图，表示程序中各个函数之间的调用关系。每个节点代表一个函数，每条有向边表示一个函数调用了另一个函数。\n调用链是从程序的入口点到某个特定函数的调用路径。调用链可以看作是调用图中的一条路径，表示函数调用的顺序。\n\n上下文敏感的数据流分析（Context-Sensitive Data Flow Analysis）\n基于克隆的交叉过程数据流分析（Clone-based Interprocedural DFA）\n\n克隆过程：\n对于每个过程，根据其调用上下文创建多个副本。每个副本对应一个特定的调用路径。\n例如，如果一个过程被两个不同的调用者调用，那么该过程会被克隆为两个副本，每个副本对应一个调用者。\n\n\n\n\n基于摘要的交叉过程数据流分析（Summary-based Inter-procedural DFA）\n\n自顶向下（Top-Down, TD）分析自顶向下的分析方法从调用者（caller）开始，逐步分析被调用者（callee）。这种方法更具体地考虑了调用上下文，能够更精确地捕捉数据依赖关系。\n\n自底向上（Bottom-Up, BU）分析自底向上的分析方法从被调用者（callee）开始，逐步分析调用者（caller）。这种方法需要假设所有可能的调用上下文，但更容易并行化。\n\n\n\n\nDFA as Graph Reachability\n图可达性问题\n图可达性问题是图论中的一个基本问题，用于判断从一个节点到另一个节点是否存在路径。在数据流分析中，图可达性问题可以用来确定数据在程序中的流动路径。\n节点：表示程序中的基本块（Basic Blocks），即一段没有分支的代码序列。\n边：表示控制流的转移，即从一个基本块到另一个基本块的跳转。\n\n\n如何判断节点可达呢？两种方法：\n计算传递闭包\n深度优先搜索\n\n\n\nIFDS问题\nInterprocedural Finite Distributive Subset Problem：IFDS问题是一类用于交叉过程数据流分析的框架，它将数据流分析问题转化为图可达性问题，从而提供了一种高效的解决方案。IFDS框架适用于具有有限域上的分配流函数的问题，能够精确地处理全程序分析\n特点：\n过程间（Interprocedural）：考虑整个程序，包括过程调用和返回。\n有限（Finite）：数据流事实的定义域是有限的。\n分配性（Distributive）：流函数具有分配性，即对于任意两个数据流事实 x 和 y，有 F(x∪y)&#x3D;F(x)∪F(y)。\n\n\n传递闭包方法：\n\n能从0到达的地方代表着UNDEF\n\n\n一个错误的例子：\n有一条路径可以从0到y，但是y显然不是UNDEF（因为z&#x3D;read（）让z变为DEF，进而y&#x3D;get（z）也是DEF）。\n原因是这条路径不是上下文敏感的。蓝色的是x&#x3D;get(z)的call，绿色的却是y&#x3D;get(z)的ret。\n解决方法：\n\n\n\n\n深度优先方法：\n两种方法的比较：\n\nIndexing Conventional Reachability\n\n标签的定义\n标签通常是一个包含两个值的数组 [low, high]，其中：\n\nlow：表示子图中的最小值。\nhigh：表示节点的后序遍历值（post-order value）。\n\n\n标签的性质\n\nA → B ⇒ LabelB ⊆ LabelA：\n如果存在一条从节点 A 到节点 B 的路径，则节点 B 的标签必须是节点 A 标签的子集。\n这是因为在路径上，节点 B 的 low 值必须大于或等于节点 A 的 low 值，而 high 值必须小于或等于节点 A 的 high 值。\n\n\nLabelB ⊈ LabelA ⇒ A ↛ B：\n如果节点 B 的标签不是节点 A 标签的子集，则不存在从节点 A 到节点 B 的路径。\n这是因为如果 B 的 low 值小于 A 的 low 值，或者 B 的 high 值大于 A 的 high 值，那么 B 一定不在 A 的子图中。\n\n\n\n\n\n\n\n上下文敏感的数据依赖分析（CS-DDA）\n概述\n\n同级依赖指的是相同函数中的变量依赖，不同级则是不同函数的变量\n依赖就是“左手依赖右手”。\n\n不同级依赖分析时要注意比配。不能让h()的调用匹配到了给g()的返回值\n\n\n\n同级数据依赖分析\n\n和“summary edge”异曲同工\n\n关键步骤：\n\n计算TC（传递闭包）\n更新TC\n\n\nKey Observation: The graph of each function is sparse, i.e., has a low treewidth (&lt; 10)\n\nKey Result: Answer any same-level data dependence query in O(1) after a O(n + k*log n) preprocessing\n\n如何降低计算TC的复杂度呢\n\n\n\n引入树分解：\n\n定义：\n\n定义 [树分解]给定一个图 G&#x3D;(V,E)，图 G 的树分解 Tree(G)&#x3D;(V**T,E**T) 是一个树，其中每个节点称为一个袋子（bag），每个袋子是一个顶点子集 B**i⊆V。树分解需要满足以下条件：\n\n顶点覆盖：\n\n图中的每个顶点 v∈V 必须至少出现在一个袋子 B**i 中。形式化地表示为：对于每个 v∈V，存在一个袋子 B**i，使得 v∈B**i。\n\n\n边覆盖：\n\n图中的每条边 (u,v)∈E 必须有一个袋子 B**i 包含 u 和 v。形式化地表示为：对于每条边 (u,v)∈E，存在一个袋子 B**i，使得 u∈B**i 且 v∈B**i。\n\n\n连通性：\n\n对于图中的任意一个顶点 v∈V，包含 v 的所有袋子在树中必须形成一个连通的子树。换句话说，如果 v 出现在多个袋子中，这些袋子在树中必须通过边相连。\n\n\n树宽\n定义：图 G 的树宽是其所有树分解中，袋子大小的最大值减1。形式化地表示为：\ntw(G)&#x3D;Tree(G)min(B**i∈Tree(G)max∣B**i∣−1)\n\n意义：树宽越小，图的结构越接近树，许多图算法在树宽较小的图上可以更高效地运行。\n\n\n\n\n\n理解：\n\n在同一个Bag内的节点代表能够互相到达\n\n\n\n\n计算TC\n\n想要知道两个节点能不能互相到达，就让两个Bag从下向上爬树。如果到达了同一个Bag，就说明他们能互相到达\n\n\n\n\n\n\n\n不同级数据依赖分析\nCh12-2 · 指针别名分析概述\n别名：two expressions that denote the same memory location\n\nMay&#x2F;Must Pointer Alias Analysis\n定义：\n\nMay Alias（可能别名）\n\n定义：如果两个指针可能指向同一个内存位置，则称它们之间存在 May Alias 关系。\n\nMust Alias（必须别名）\n\n定义：如果两个指针一定指向同一个内存位置，则称它们之间存在 Must Alias 关系。\n\nSoundness（可靠性）定义：一个分析方法是 sound 的，如果它能够保证所有可能的运行时行为都被考虑在内，即不会漏掉任何可能的情况。换句话说，sound 分析方法不会产生假阴性（false negatives）。\n\nCompleteness（完整性）定义：一个分析方法是 complete 的，如果它能够精确地描述所有可能的运行时行为，即不会引入任何假阳性（false positives）。换句话说，complete 分析方法能够完全准确地描述指针之间的关系。\n\nOver-approximation（过近似）（上近似）定义：Over-approximation 是一种保守的分析方法，它会引入一些假阳性（false positives），以确保不会漏掉任何可能的情况。换句话说，over-approximation 会高估指针之间的别名关系。\n\nUnder-approximation（欠近似）（下近似）定义：Under-approximation 是一种精确的分析方法，它会漏掉一些可能的情况（false negatives），以确保不会引入任何假阳性。换句话说，under-approximation 会低估指针之间的别名关系。\n\n\n\n\n\n\nAndersen’s Algorithm\n\n\n\n笔记第三章\n如何证明表达式是正则的？把自动机画出来。正则的定义就是能被自动机表示\n\n如何证明表达式不是正则的？Pumping Lemma。\n\n泵引理可以证明不是RL，但是不能证明是RL。当存在至少一种情况不会改变文法结构时，泵引理失效。\n\n确定有限自动机的五元组要搞清楚\n\n字符串能否被NFA接受\n\n正则到NFA转换为DFA\n\n正则变为NFA，关注几个基本方法\nNFA到DFA：子集构造法\n先得到初始状态集，即只需要𝜖就能到达\n然后经过一次字符运算，得到新的集合\n把新的集合拿出来继续迭代\n有点像workLIst算法，算到不动点\n\n\n带终结状态的集合作为DFA的终结状态\n最后可能需要最小化\n\n\n\n\nDFA最小化：\n\n把终结态和非终结态分为两个集合\n最每个集合中的每个状态进行传递，把结果落在相同集合的状态放一起，不同的则分开来成为新的集合\n迭代\n等价则只保留一个\n\n\n\n第四章\n所有正则语言都是上下文无关语言\n对于一个题，可以先写出正则语言\n如何表示$a^nb^m,n!&#x3D;m$\n$S-&gt;aSb|X|Y,X-&gt;aX|𝜖,Y-&gt;bY|𝜖$\n就是ab先相同，最后多出来几个a或者几个b\n\n\nPDA：$a^ib^jc^k,i&#x3D;j,or,j&#x3D;k$\n$a^nb^n$是CFL，但不是RL\n$a^nb^nc^n$不是CFL\n\n\nRL和CFL\n\n\n\n假设L是CFL，\n令L交$a^*b^c^$，后者为RL，则整体为CFL\n交下来结果是$a^nb^nc^n$，不是CFL\n矛盾，假设不成立\n\n\n\n\nPuming Lemma for CFL\n{$a^nb^{n^2}$}\n\nTop-down parsing自上而下分析\n$$A\\to{Ba}\\newlineB\\to{dab}\\newlineB\\to{Cb}\\newlineC\\to{cB}\\newlineC\\to{Ac}\\newline$$\n\n消除左递归：带入消除。但是$B\\to{cBd}$这样的消不掉，保留。\n\n\n\n\n符号\nFirst\nFollow\n\n\n\na\na\n&#x2F;\n\n\nb\nb\n&#x2F;\n\n\nc\nc\n&#x2F;\n\n\nd\nd\n&#x2F;\n\n\nA\nc, d\n$, d\n\n\nB\nc, d\nc, d\n\n\nC\nc, d\nc\n\n\n\n\n\nLL(1)文法：\n\n特点：\n无左递归\n无二义性\n最左推导\n\n\n判断方法：First 和 Follow 集合\n为了判断一个文法是否是 LL(1) 文法，需要计算每个非终结符的 First 集合 和 Follow 集合：\nFirst(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身\nFirst(A)要么是终结符，要么是𝜖\n\n\nFollow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。\n理解：\nFollow(A)要么是终结符，要么是$。\nS是开头，$是结尾\n不能有𝜖\n\n\n计算：\nFollow(S) &#x3D; {$}\n若$A\\to{BD}$，则把First(D) \\ {𝜖}加入Follow(B)\n若$A\\to{aB}$，注意，此时A的follow一定是B的follow，换言之Follow(A)是Follow(B)的子集。\n\n\n\n\n\n\n求出来了FIrst和Follow，如何判断文法是不是LL(1)文法呢？\n观察，无左递归\n无二义性：对于每个非终结符 A 的产生式 A→α 和 A→β，检查 First(α) 和 First(β) 是否有交集。例\n对于 A→a 和 A→ϵ，First(a)&#x3D;{a} 和 First(ϵ)&#x3D;{ϵ} 互斥。\n如不互斥，则不是LL(1)文法\n\n\nFirst 集和 Follow 集的互斥性\n如果 α 可以推导出空串 ϵ，则检查 First(β) 和 Follow(A) 是否有交集。\n对于 A→ϵ，First(ϵ)&#x3D;{ϵ} 和 Follow(A)&#x3D;{b,$} 互斥\n如果有交集，则文法不是 LL(1) 文法。\n\n\n\n\n\n\n\n\n预测分析表：预测分析表是实现 LL(1) 语法分析的关键工具。它通过 First 集和 Follow 集的计算，帮助分析器在解析输入字符串时选择合适的产生式进行推导。\n\n预测分析表的结构\n预测分析表是一个二维表，其结构如下：\n\n行：对应文法中的非终结符。\n列：对应输入符号（包括终结符和输入结束符 $）。\n表项：每个表项存储一个产生式或特殊标记（如错误标记或空产生式 ϵ）。\n\n\n\n\n\n\n\nBottom-Up Parsing自下而上分析\n位移规约解析\n位移规约解析是一种自底向上的语法分析方法，广泛应用于编译器设计中。它通过将输入符号逐步推入栈中，并根据文法规则进行规约，最终生成语法树。位移规约解析的核心在于两个基本操作：位移（Shift） 和 规约（Reduce）。\n基本概念\n位移（Shift）\n操作：将输入符号从输入缓冲区移动到分析栈的栈顶。\n目的：将输入符号逐步推入栈中，为后续的规约操作做准备。\n\n\n规约（Reduce）\n操作：根据文法规则，将栈顶的若干符号替换为规则的左侧非终结符。\n目的：逐步构建语法树，将输入符号归约为更高层次的语法结构。\n\n\n句柄：具体来说，句柄是当前栈顶符号序列中最左边的一个子序列，该子序列可以匹配某个产生式的右侧。\n\n\n位移规约解析的步骤\n初始化：\n创建一个分析栈，初始时栈中只有一个特殊的起始符号（如 $）。\n创建一个输入缓冲区，包含输入符号和输入结束符（如 $）。\n\n\n分析过程：\n重复以下步骤，直到分析栈和输入缓冲区都为空：\n位移操作：\n如果当前输入符号是一个终结符，并且根据当前状态和输入符号，应该进行位移操作，则将输入符号推入分析栈，并移动输入指针到下一个符号。\n\n\n规约操作：\n如果分析栈的栈顶符号可以匹配某个产生式的右侧，则根据该产生式进行规约操作。将产生式右侧的符号从栈顶弹出，并将产生式左侧的非终结符推入栈中。\n\n\n接受状态：\n如果分析栈中只剩下起始符号和输入结束符，且输入缓冲区为空，则解析成功。\n\n\n错误处理：\n如果无法进行位移或规约操作，则报告语法错误。\n\n\n\n\n\n\n\n\n\n\n\n\n第五章\nSDT语法制导翻译，和SDD很像：\n\n\n\n\n\n\nSDD：语法制导的定义\n\nSDD三要素：文法，属性，规则\nS属性定义：父节点的值有子节点计算出来。\nL属性定义：产生式中某个节点的值只能由其左侧的值求出。\n属性：\n综合属性.syn：\n用的是自身的产生式所关联的语义规则来定义\n即通过N的子节点或本身的属性值来定义\n\n\n继承属性.inh：\n用的是父节点所关联的语义规则来定义\n即通过N的父节点、本身或兄弟节点的属性值来定义\n\n\n\n\n\n\n\n\n左图是传统的左递归，右图是右递归（消除左递归的结果）\n左图是自底向上计算，右图是从顶往下计算\n右图.inh是指继承属性，即从父节点或兄弟节点获得的值。.syn是综合属性，即向父节点传送的值\n\n\n公式：\n\n\n第六章\nDAG：有向无环图\n\n从下往上画，箭头指向父节点\n符号写在节点下面\n\n被减数或者被除数放在左边\n在表达式计算或代码优化时，相同的子表达式可能会重复出现。DAG 通过共享公共子表达式，减少重复计算，提高效率。\n\n\n\n内存结构\n栈内部有哪些必要部分？\n\n局部变量\n返回值，参数\n返回地址\ndata to recover(?)\n\n\n函数调用时，栈中发生了什么（即函数调用的步骤）：\n\n. 调用前\n调用者的状态保存：在调用函数之前，调用者（即调用当前函数的代码）的执行状态需要被保存。这通常包括：\n寄存器保存：某些寄存器（如通用寄存器、状态寄存器等）的值会被保存到栈中。这些寄存器可能包含调用者的局部变量、状态信息等。\n返回地址保存：调用者的下一条指令地址（即函数调用完成后需要返回到的位置）会被保存到栈中。这个地址通常被称为返回地址。\n参数准备：调用者会将函数调用所需的参数准备好，并按照一定的顺序（通常是从右到左）压入栈中。这些参数将被传递给被调用的函数。\n\n\n\n2. 调用时\n栈帧创建：当函数被调用时，系统会为被调用的函数创建一个新的栈帧（Stack Frame）。栈帧是栈中的一个区域，用于存储函数调用期间所需的所有信息。\n局部变量分配：被调用函数的局部变量会在栈帧中分配空间。这些局部变量只在函数调用期间有效，函数调用结束后，这些空间会被释放。\n寄存器保存与恢复：某些寄存器的值可能会被保存到栈帧中，以便在函数调用期间使用这些寄存器。函数调用结束后，这些寄存器的值会被恢复。\n函数执行：被调用的函数开始执行，它会使用栈帧中的局部变量和参数进行计算。在函数执行过程中，可能会进行更多的函数调用，从而在栈中创建更多的栈帧。\n\n\n\n3. 调用后\n返回值处理：函数执行完成后，会将返回值（如果有）存储在某个约定的位置（通常是某个寄存器或栈中的某个位置）。\n栈帧销毁：被调用函数的栈帧会被销毁。这包括释放局部变量占用的空间，恢复之前保存的寄存器值等。\n返回地址恢复：从栈中恢复之前保存的返回地址，程序控制权会跳转到这个地址，继续执行调用者的代码。\n调用者状态恢复：调用者的寄存器值等状态信息被恢复，调用者的代码继续执行。\n\n总结\n调用前：保存调用者的状态，准备参数。\n例如：sw ra, 4(sp)把调用者的返回地址线保存到栈上。\n\n\n调用时：创建栈帧，分配局部变量空间，执行函数。\n例如：addi sp, sp, -4\n\n\n调用后：销毁栈帧，恢复调用者状态，继续执行调用者的代码。\n例如：恢复返回地址lw ra 0(sp)，销毁栈帧：addi sp, sp, 4\n\n\n\n\n\n\n\n三地址码\n可能出一个快排的题目\n\n三地址语句不是三地址码！！！\n\n三地址语句如x &#x3D; t + s\n三地址码如LD R1, x\n\n\n注意翻译的时候，运算结果要先用临时变量保存，然后才可以赋值\n\n中间码写法：\n\n四元式序列格式：\n\n三元式序列格式：\n\n注意，像a &#x3D; b + c这种语句，结果是用编号表示，即#0这种，不用写a\n但是像a &#x3D; d这种语句，要把a写出来。# 1: (&#x3D;, d, a)\n\n\n\n\n间接三元式序列写法：两张表：三元式表和间接码表\n\n三元式表：和前面的三元式表几乎一样，但是不要出现重复的语句\n间接码表：根据三元式表的编号选择性的引用。\n\n\n对于跳转的操作符：goto, ifTrue\n\n对于数组的操作符：\n\n[ ]：( [ ], b, t1, t2 )     &#x2F;&#x2F; t2 &#x3D; b[ j ]\n\n[ ]&#x3D;：( [ ]&#x3D;, a, t4, t3 )    &#x2F;&#x2F; a[ t4 ] &#x3D; t3\n\n\n静态单赋值（有题不会）\n\n\n\n一般来说while的头尾会有φ函数\n\n熟悉短路回填算法（Short-Circuit Backpatching）\n\n语句翻译（不会）：\n\n例题：\n先构造语法分析树：\n注意翻译要求，要求用这里的翻译方案，所以还是要乘width\n把每一步展开，在需要临时变量的地方做好标记\n每一个gen都代表一条三地址码语句，但是不用写在分析树上\n每一条规则都代表分析树上的一个信息\n\n\n例题：\n真值列表和假值列表怎么写？\n这两个表中装的是 goto 语句目标地址\n\n\n\n\n\n\n第八章\n三地址语句不是三地址码！！！\n\nriscv常见的操作符：\n\nbeq, bne, blt, bgt\nJAL rd, offset   # 跳转到 PC + offset，并将返回地址存入 rd（一般为 ra\nJALR rd, offset(rs1)\nlw t0, 4(sp) 或 lw t0, x\nsw t0, 4(sp) 或 sw t0, x\n\n\n图着色算法：\n\n思想：图着色算法\n\n先画出干扰图\n会同时生存的寄存器之间加一条边\n\n\n计算着色最少需要的颜色n\n若k&gt;&#x3D;n，即能够用k种颜色着色，则容易处理\n如果k&lt;n则spilling\n\n\n\n\nChaitin’s Algorithm（一个图着色算法）\n\n易知，若节点的度小于k，则容易用k色着色\n\n\n所以，我们先把度小于k的节点压栈，最后着色\n如果没有，则选择一个度最小的节点放入列表。\n若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。\n迭代第1、2、3条\n\n\nChaitin-Briggs Algorithm（前一个算法等等改进）\n\n思想是不急着spilling，减少spill code\n即使没有满足要求的节点，我们也尝试把一个节点压栈。\n不一定成功\n\n\n\n\n\n\n\n机器码\n\n如题：\ny &#x3D; *q\nLD R1 q\nLD R2 *R1\nST y R2\n\n\nq &#x3D; q + 4\nLD R1 q\nADD R1 R1 #4\nST q R1\n\n\n*p &#x3D; y\nLD R1 y\nLD R2 p \nST *R2 R1\n\n\n\n\n\n\n寄存器\n为什么要寄存器分配？\n\n在避免**溢出（spill）**的情况下，减少物理寄存器使用。\n\n\n什么是寄存器生命周期？\n\n从第一次使用，到最后一次使用之前\n\n\n![b99444ab4b23b65a81f1e3906549f76b](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\b99444ab4b23b65a81f1e3906549f76b.jpg)\n\n\n第4条已经解答\n2个。注意，不要简单的从左往右写，这样的话就要从头到尾保存a-1的值，没用。\n略\n\n\n\n![50304d832c5dcecacb25ff2c46c45764](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\50304d832c5dcecacb25ff2c46c45764.jpg)\n\n\n\nfalse。\n\n\n\n![27eb905b5102524f832632dd4a80b887](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\27eb905b5102524f832632dd4a80b887.jpg)\n\n![f16c9d6b485184730df0a5cc65dbe63c](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\f16c9d6b485184730df0a5cc65dbe63c.jpg)\n\n![a8247b709ef323d292ac02e78aec1289](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\a8247b709ef323d292ac02e78aec1289.jpg)\n\n\n画出生命周期图，看重叠部分，就是无溢出所需要的寄存器。然后画依赖图，只要同时存在就连边。\n\n\n\n![7c4f7ce31b032857b2dd3f88abe841f4](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\7c4f7ce31b032857b2dd3f88abe841f4.jpg)\n\n\n不用考虑控制流的问题，直接看行号。\n注意生命周期是到最后一次使用的前一行\n\n\n\n![f4142ea4341eeaf67c4317ef4b43721e](E:\\Documents\\Tencent Files\\2087179041\\nt_qq\\nt_data\\Pic\\2025-04\\Ori\\f4142ea4341eeaf67c4317ef4b43721e.jpg)\n\n\n要先画依赖图\n\n\n\n\n\n\n第九章支配 ***\n支配：\n\n\n\nA支配B：从入口开始进入B的所有路径一定经过A\nA后支配B：从B开始到出口的所有路径一定经过A\nA严格支配B：A支配B但是A不等于B。所有基本块都支配自己，但它们不会严格支配自己\nA立即支配B：A严格支配B，且不存在A严格支配C的同时C严格支配B\n\n\n支配树：支配树是一个有向树，其中每个节点的父节点是它的立即支配节点。支配树的根是控制流图的入口节点。\n\n图中边的类型（基于支配树的 DFS）\n假设我们从控制流图（CFG）入口出发进行 深度优先遍历（DFS），那么访问过程中，图的边可以被分类如下：\n1. 树边（Tree edge）\nDFS 过程中沿着尚未访问的子节点走的边。\n组成 DFS 树的主干结构。\n就是存在于支配树中的边\n\n2. 前进边（Forward edge）\n指向已访问过的“后代”节点（在 DFS 树中向下跳过中间层级）。\n\n3. 后退边（Back edge）\n指向已访问过的“祖先”节点（常表示循环结构，例如回跳到循环头）。\n\n4. 交叉边（Cross edge）\n指向非祖先也非后代的其他分支的节点。\n\n\n\n\n\n\n如何判断一个流图是可规约的？\n\n一个控制流图是可规约的，当且仅当：\n所有的后退边（Back Edges） X → Y 满足：\nY 是 X 的**支配者（dominator）&#96;，即所有的后退边都是回边\n\n\n**其余的边（非后退边）*构成的图是*无环的\n\n\n\n\n计算流图的深度：\n\n自然循环：\n\n只有一个入口header，且header要能支配循环中所有的节点\n最大的强联通分量（强联通分量：任意两个节点都可以到达）\n一个图可以有多个自然循环。可以通过抓回边来找\n\n\n若a dom c且b dom c，证明a, b之间有支配关系\n\n考虑支配数，a到c有边，b到c有边，求证ab之间有边\n\n\n在CFG（控制流图）中有$a\\to{b}$，证明idon(b) dom a。\n\n考虑反证法\n\n\n画支配树可以倒过来想，从最后开始找支配节点。因为节点可以有很多子节点，但是只有唯一的父节点。\n\n找支配前沿时，配合支配树更快\n\n\nch9-1\n流控制当中，要会worklist算法\n数据流方程\n能举例，什么是“可分配的控制流分析”。先分配再传递和先传递再分配结果相同，就是可分配。f(a v b) &#x3D; f(a) v f(b).\n会证明worklist算法的收敛性（可终止）：单调有界。\n\n\n\n一句话解释什么是数据流分析\nThe Lazy Code Motion Problem是什么（3点），怎么办（4点）\n\n三大经典DFA ***\nreaching definition\n\n\n\nAvailable Expressions\n\ngen中这些表达式都在本块中被明确计算，并且在到达前、计算后，没有变量被重新赋值影响它们。换言之，凡是包含重新定义的表达式都是kill\n注意这里的表达式都是‘&#x3D;’右边的式子\n\n\nLive Variable Analysis\n\n\n\n\nch9-2\n复习加法器原理，考试可能考在PL或FOL上\n\n优化方法解释：\n\n消除公共⼦表达式：顾名思义\n\n对归纳变量进⾏强度消减：\n\n将计算代价高的运算（如乘法、除法）转换为计算代价低的运算（如加法、移位），前提是语义不变。\n\n\n\n消除归纳变量：\n\n归纳变量是指在循环中线性变化的变量（如 i = i + 1, j = j + 2, x = x - 3）。\n\n如果一个归纳变量能被另一个归纳变量线性表示，就可以消除冗余变量，减少空间&#x2F;计算。\n\n\n\n\n\n\n复制传播和死代码消除：\n\n常量折叠\n\n代码移动\n\n\n\n\n符号执行1.2. Tseitin Transformation：\n\nTseitin Transformation 是一种将命题逻辑公式转换为合取范式（CNF）的方法，同时保持可满足性不变，即转换后的公式与原公式等可满足\n步骤：\n把原来的每个节点全部用新的符号代替，然后把\n\n\n\n第十章\n依赖图\n\n\n第十二章\nIFDS问题。画图1. \n\nCS-DDA\n\n\n\nAndersen算法和图\n\n如何根据程序表示集合关系，如何画图，\n\n\n\n复习重点前端part1 · Regex，NFA，DFA\n正则语言是指能够被NFA接受的语言\n掌握正则到NFA到（min）DFA的转换\n$正则\\to{NFA}$\n$NFA\\to{DAF}$：子集构造法\n$DFA\\to{(min)DFA}$\n\n\n掌握正则语言\n\npart2 · CFG and Parsing\n一个上下文无关语言是一个四元组：G &#x3D; ( N, T, S, P )\n\nN：非终结符集合\nT：终结符集合\nS：起始符号（S ∈ N）\nP：产生式规则集合\n\n\n\n\n递归下降\n\n左递归问题\n直接左递归：用公式\n间接左递归：怎么消？\n带入消除\n\n对于B的部分就可以不用管了，因为打破了间接循环依赖\n\n\n\n\n\n\n回溯问题\nLL(1)文法：\n特征：\n无左递归\n无二义性\n最左推导\n除此之外要注意：一次只看一个符号\n\n\n建立预测表\n栈是要推导的文法，而输入是待匹配的字符串\n左侧非终结符是栈顶符号，输入字符就是下一个待匹配的字符\n\n\n计算First，Follow：\nFirst(A)：A的展开式中最左的终结符集合。若A为终结符，则就是它本身\nFirst(A)要么是终结符，要么是𝜖\n\n\nFollow(A)：A后面紧跟的终结符集合，不包含A。注意，Follow只对非终结符有效。对于终结符不用写。\n理解：\nFollow(A)要么是终结符，要么是$。\nS是开头，$是结尾\n不能有𝜖\n\n\n计算：\nFollow(S) &#x3D; {$}\n若$A\\to{BD}$，则把First(D) \\ {𝜖}加入Follow(B)\n若$A\\to{aB}$，注意，此时A的follow一定是B的follow，换言之Follow(A)是Follow(B)的子集。\n\n\n\n\n\n\n如何构建预测表：\n\n若对应位置已有内容，不要覆盖\n\n\n\n\n\n\n\n\n\npart3 · IR Generation\n三地址码\n注意t &#x3D; a [ p ]不用手动乘元素大小\n快排\n\n\nSSA\n特征\n每个变量只有一次定义\n用φ合并\n\n\n\n\n支配树\n支配的相关概念：\n立即支配：Immediate dominance – A strict-dom B, but there’s no C, such that A strict-dom C, C strict-dom B\n\n\n什么是支配树，或者说如何构建支配树\n支配树是一个有向树结构，反映了控制流图中所有基本快之间的支配关系\n支配树中的父节点立即支配子节点\n\n\n证明支配树为什么是树，即证明表示支配关系的图一定是树？\n要证明一个图是树，就要证明三点：\n除了根节点之外，每个节点只有一个父节点\n图是连通的\n无环\n\n\n要证明立即支配图是树结构，也是从这三点下手\n唯一父节点：显然，根节点就是入口节点。除此之外，所有节点的立即支配节点是唯一的。\n反证法：假设节点A有两个立即支配节点B, C，作为两个同时支配A的节点，他们之间一定有支配关系。但是这违反了立即支配的定义，所以假设不成立。\n\n\n图是连通的：显然。\n图是无环的：\n反证法：假设存在环路，则可以推导出 A 立即支配 A 本身，立即支配是严格支配，则说明A !&#x3D; A，矛盾。\n\n\n\n\n\n\n支配前沿（DF）\n定义：\n给定控制流图（CFG）中的基本块 D，它的**支配前沿（DF）**是所有满足以下条件的基本块 X 的集合：\nD 支配 X 的某个前驱（predecessor） P（即 D dom P），\n但 D 不严格支配 X（即 D 不是 X 的最近支配者，或者说 X 不在 D 的支配树子树中）。\n\n\n\n\n迭代支配前沿（IDF）\n\n\n\n\n\n\n\n\n中端part1 · Data Flow Analysis\n三大数据流分析\n\nreaching definition\n\n\n\nAvailable Expressions\n\ngen中这些表达式都在本块中被明确计算，并且在到达前、计算后，没有变量被重新赋值影响它们。换言之，凡是包含重新定义的表达式都是kill\n注意这里的表达式都是‘&#x3D;’右边的式子\n注意是取交集\n注意kill要检查的表达式包括块内使用的和 IN 中的表达式。都要检查\n\n\nLive Variable Analysis\n\n注意是逆向分析\n\n\n\n\nworklist算法\n\n大意：\n\n\n初始化所有 basic block 的 IN[B] &#x2F; OUT[B]；\n把所有 block 加入工作列表；\nwhile 工作列表非空：\n从列表中取出一个 block；\n用 transfer function 和 meet operator 更新 OUT[B] 或 IN[B]；\n如果值变化了，则把它的前驱&#x2F;后继加入列表。\n\n\n\n\n证明该算法的收敛性：\n\n有限性：数据流值域是有限集合的半格。数据流框架中的每个变量取值都是从某个有限集中选出的，n个元素最多有2^n^个集合。\n单调性：每次更新一个节点的 IN&#x2F;OUT 时，都是在偏序半格上“下降”（如求交 ∩）或“上升”（如求并 ∪）\n单调有限则收敛\n\n\n\n\n\npart2 · Symbolic Execution\n分类：\n\nPath Sensitivity：分析会区分程序中的不同执行路径（如 if-else 分支），并分别处理每条路径上可能的状态。\nFlow Sensitivity：分析考虑程序中指令执行的顺序，即变量值随时间变化的过程。\nContext Sensitivity：分析考虑函数调用时的上下文，即不同调用点会分别分析函数的行为。\n\n\n掌握三类的定义，要送分\n\n三个问题：\n\nPath Explosion（路径爆炸）：指程序中可执行路径数量呈指数级增长，随着分支语句（如 if、switch）增加，分析工具必须探索的路径数迅速变得难以控制。\nConstraint Solving（约束求解）：将路径条件转化为逻辑公式，并使用约束求解器（如 SMT solver）判断是否可满足（satisfiable），从而验证路径是否可行或生成满足条件的输入。\nExternal Function Call（外部函数调用）：指程序中调用了无法深入分析的函数，例如库函数、系统调用、动态链接函数，分析工具无法查看其内部实现。\n\n\n路径约束求解（Solving Path Constraints）\n\n命题逻辑（PL）\n\n定义：\n只处理布尔变量（True &#x2F; False），不包含量词、变量、函数或算术。\n表达式例子：(A ∨ B) ∧ ¬C\n用于最基础的SAT（可满足性）问题\n\n\n\n\n\n一阶逻辑（FOL）\n\n定义：\n\n引入变量、函数、谓词、量词（如 ∀x, ∃x）\n表达能力远高于命题逻辑，可表达整数、结构体、指针等\n示例：∀x. (x &gt; 0 → P(x))\n\n\nFOL 的可满足性是不可判定的，但很多子逻辑可以处理。\n\n\n转换为PL\n\n\n\nSatisfiability Modulo Theories (SMT)：\n\n定义：SMT（Satisfiability Modulo Theories） 是指判断带理论支持的一阶逻辑公式是否可满足（satisfiable）\n简单说：SMT &#x3D; 一阶逻辑 + 理论（如整数、数组、位运算）\n解决步骤：\nWord-Level Preprocessing（字级预处理）\n例：(x &amp; 0xFF) | 0x00 直接简化为 x &amp; 0xFF\n似乎就是化简\n\n\nBit-Blasting（位爆破）\n把位向量逻辑公式 从一阶逻辑（FOL）转换成命题逻辑（PL）\n将每个位向量变量展开成单个位（bit）变量的集合\n将位操作转换成对应的位层级逻辑门表达式\n例如：一个 8 位向量变量变成 8 个布尔变量\n这样公式就变成纯布尔公式，便于 SAT 求解器处理\n\n\n使用DPLL或CDCL\n\n\n例子：\n假设我们有下面的位向量公式：\n(x &amp; 0b1111) &#x3D; 0b1010\n\n\nstep 1：没有可以简化的了，跳过\nstep 2：\nstep 3：用算法\n\n\n\n\nBit Vector Theory\n\nBit Vector Theory 是 SMT（Satisfiability Modulo Theories）中专门用于处理固定宽度二进制整数（bit vectors）及其操作的理论。\n简单说，它让 SMT 求解器能像 CPU 那样准确处理溢出、移位、按位操作等底层行为。\n\n\n\n\nSAT问题\n\n步骤:\n通过tseitin转换为CNF\n用DPLL算法\n\n\n\n\n什么是CNF, DNF, NNF\n\nNNF（否定范式）：NNF 是一种逻辑表达式的形式，其中所有否定操作（NOT）仅应用于变量，而不是子表达式。\nCNF（合取范式）：CNF 是一种逻辑表达式的形式，其中整个表达式是一个合取（AND）的子句集合，每个子句是一个析取（OR）的原子命题（变量或其否定）集合。\nDNF（析取范式）：DNF 是一种逻辑表达式的形式，其中整个表达式是一个析取（OR）的子句集合，每个子句是一个合取（AND）的原子命题（变量或其否定）集合。\n\n\n逻辑推导：\n\n蕴含：\n否定：\n分配律：\n\n\nDPLL算法：\n\n理解：就是不断地假设变量的值，使得表达式最终为真。如果推出矛盾，就回溯。如果穷举了所有可能性都没有满足的赋值，则说明不可满足。\n\n\nCDCL算法：\n\n理解：是对DPLL算法的改进。每次假设时要记录，并且推导时要画图\n如上图的冲突图，假设x1&#x3D;0，就新建一个入度为零的节点\n如果推出矛盾，就要分析矛盾原因。本例中就是$x_3&#x3D;1,x_7&#x3D;1,x_8&#x3D;0$导致冲突，那就说明这三个条件不能同时满足，那就把$¬x_3 ∨ ¬x_7 ∨ x_8$加入到前面，并且回溯到x3前面重新假设\n\n\nTseitin Transformation（特斯林变换）\n\n基本思想：\n对原公式中每个子公式，引入一个新的布尔变量，代表该子公式的值。\n用约束子句表达这个变量和子公式的等价关系。\n最后，主变量（代表整个公式）也被引入，最后的 CNF 是这些约束和主变量的合取。\n\n\n\n\n\npart3 · Pointer Analysis\nAndersen Alg. &amp; Steensgaard Alg.\n注意：\n这是求解缺数的表格\npts(p)代表p可能指向的所有对象的集合\nx, y这些变量的本质是指针，是地址\n\n\n\n\nAndersen算法:\n目标：静态分析程序中指针变量的 指向关系（points-to set），即找出每个指针可能指向的所有变量或内存对象。\n核心思想：\n初始化 所有指针的 pts 集合为空\n扫描程序所有语句，生成约束 根据上面规则，将语句转为集合包含约束和元素添加约束\n约束传播 不断迭代求解这些约束，更新 pts 集合直到不再变化（达到固定点）\n结果 最终每个指针变量的 pts 集合就是它的可能指向集合\n\n\n\n\n\nSteensgaard算法：\n把集合包含变成等价合并\n\n\n\npart4 · Datalog-Based Analysis\nDatalog-based analysis 就是把静态分析的规则用 Datalog 写出来，交给逻辑引擎去执行，从而实现自动、高效的程序分析。\n\n\n到达定义的DataLog表示法\n三个谓词\n\ndef(B, N, X)：在 基本块 B（Block B） 中，第 N 条语句（statement N） 定义了变量 X。\nsucc(B, N, C)：按照PPT的说法，基本块C是基本块B的后继，且B有N条语句。\nrd(B, N, C, M, X)：变量 X 在基本块 C 的第 M 条语句中被定义，该定义 可以在控制流图中传播到 基本块 B 的第 N 条语句。\n\n\n三个规则\n\n“:-”的意思是从右向左推导，如果右边成立，那么左边就成立\n\n\n定义即到达：\nrd(B, N, B, N, X) :- def(B, N, X)\n定义可以到达它自己\n\n\n语句内部前向传播（顺序语句）\nrd(B, N, C, M, X) :- rd(B, N-1, C, M, X), def(B, N, Y), X≠Y\n如果定义 X 到达了语句 N-1，并且语句 N 没有重定义 X，那么 X 的定义也能到达语句 N。\n\n\n跨基本块传播\nrd(B, 0, C, M, X) :- rd(D, N, C, M, X), succ(D, N, B)\n如果 X 的定义在 (C, M) 能到达基本块 D 的语句 N，并且 D 的语句 N 有控制流边到达基本块 B，那么我们认为这个定义在 B 的“开始处”（第 0 行）可达。\n第 0 行是一个虚拟位置，代表基本块入口；\n\n\n\n\n用法：“我们只定义规则和事实，分析过程有Datalog引擎自动完成”\n\n考的比较灵活，要理解。考试中可能出现新定义的谓词和规则\n\n\n\n\n后端part1 · Instruction Selection\n三地址指令变机器码\n\n指令：写一些伪指令就好了：\n\n注意寻址模式（How we compute the addr）：\n\n假设R2的内容是x\n\n\nLD R1, a(R2)：addr &#x3D; x + a\nLD R1, 100(R2)：addr &#x3D; x + 100\nLD R1, #100（立即数）：R1 &#x3D; 100 \nLD R1, *R2：addr &#x3D; MEM[ x ]\nLD R1, *100(R2)：addr &#x3D; MEM[ x + 100 ]\n\n\n\n\n对于跳转的操作符：goto, ifTrue\n\n对于数组的操作符：\n\n[ ]：( [ ], b, t1, t2 )     &#x2F;&#x2F; t2 &#x3D; b[ j ]\n\n[ ]&#x3D;：( [ ]&#x3D;, a, t4, t3 )    &#x2F;&#x2F; a[ t4 ] &#x3D; t3\n\n\n\n\n\n\npart2 · Register Allocation\n局部寄存器分配\n\n线性扫描\n\n\n全局寄存器分配\n\n图着色算法Chaitin’s Algorithm：\n\n步骤：\n\n易知，若节点的度小于k，则容易用k色着色\n\n\n所以，我们先把度小于k的节点压栈，最后着色\n如果没有，则选择一个度最小的节点放入列表。\n若表不为空，表中的节点要spilling，即插入load,store指令。然后重新画图。\n迭代第1、2、3条\n\n\n什么时候压栈，什么时候溢出\n\n压栈：找到度数小于k的\n溢出：度数都不小于k\n着色：所有节点都入栈或溢出\n\n\n\n\nChaitin-Briggs Algorithm（前一个算法的改进）\n\n思想是不急着spilling，减少spill code\n即使没有满足要求的节点，我们也尝试把一个节点压栈。\n不一定成功\n\n\n\n\n为什么需要指令调度？\n\n从硬件的角度说，尽量利用并行性\n从软件的角度说，把并行度高的排在一起，以便硬件并行操作\n\n\n\npart3 · Instruction Scheduling\n为什么要调度？\n\n现代高性能处理器每个时钟周期可以执行多个操作\n\n\n为什么编译器很重要？\n\n硬件只能执行已经取出的指令。\n\n处理器只能对“已经被取指单元抓取到的指令”进行操作。\n如果下一条指令因为数据依赖、缓存未命中等原因卡住了，硬件就会停下来等，效率降低。\n\n\n硬件缓冲资源有限\n\n这些缓冲区空间非常有限，一旦塞满，就不得不停止取指、停止执行\n\n\n编译器可以通过指令调度提升效率\n\n译器分析指令之间的依赖关系，可以把无依赖的指令排在一起，尽量避免空等。\n这使得处理器可以在一个周期里执行多个指令，提高硬件利用率\n\n\n\n\n跨块调度不考\n\n块内调度要考：\n\n真假依赖\n真：写后读\n假：写后写，读后写\n\n\n依赖图：\n\n要先消除假依赖\n标记时钟周期（深度）\n\n\nList Scheduling 算法\n只能先调度没有依赖的指令\n优先调度深度大的\n指令结束后从依赖图中删去\n如果有空操作，用NOP（no operation）填充\n迭代\n\n\n\n\n\npart4 · Exercises\n\n\n为什么需要寄存器分配？\n\nSpeed: Registers &gt; Memory\nPhysical machines have limited number of registers\nRegister allocation: ∞ virtual registers ➞ k physical registers\n\n\n最少需要几个寄存器？\n\n2个\n\n\nLD R1, b\nLD R2, c\nADD R1, R1, R2\nDIV R1, R1, #3\nLD R2, d\nADD R1, R2\nLD R2, a\nSUB R2, #1\nMUL R1, R1, R2\n2. ![image-20250618203504267](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250618203504267.png)   1. 注意要在寄存器的视角下考虑共存，不能在代码基本块的视角上看3. “重中之重”![image-20250618203535253](C:\\Users\\HUAWEI\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250618203535253.png)   1. 注意每行出现的寄存器，仔细考虑## 笔记1. 快排写为三地址码：   1. 快排：      1. ```c++         procedure quicksort(A, low, high)         &#123;             if (low &lt; high)             &#123;                 pivot = partition(A, low, high)                 quicksort(A, low, pivot)                 quicksort(A, pivot + 1, high)             &#125;         &#125;                  procedure partition(A, low, high)         &#123;             pivot = A[low]               // 选择第一个元素作为枢轴             i = low - 1             j = high + 1                      while (true)             &#123;                 // 从左向右找第一个 &gt;= pivot 的元素                 repeat                     i = i + 1                 until A[i] &gt;= pivot                          // 从右向左找第一个 &lt;= pivot 的元素                 repeat                     j = j - 1                 until A[j] &lt;= pivot                          // 两指针相遇则分区完成，返回右指针 j                 if (i &gt;= j)                     return j                          swap A[i] and A[j]        // 交换左右两边不符合顺序的元素             &#125;         &#125;         \n\n\n三地址码：\n\nt1 = low            // i = low - 1; 但Hoare的i初始化为low - 1，稍改成low - 1\nt2 = t1 - 1\ni = t2\n\nt3 = high           // j = high + 1\nt4 = t3 + 1\nj = t4\n\nt5 = A[low]         // pivot = A[low]\npivot = t5\n\nLABEL_PARTITION_LOOP:\n  // 从左往右找第一个 A[i] &gt;= pivot\nLABEL_SCAN_I:\n  t6 = i + 1\n  i = t6\n  t7 = A[i]\n  t8 = t7 &lt; pivot\n  if t8 == true goto LABEL_SCAN_I\n\n  // 从右往左找第一个 A[j] &lt;= pivot\nLABEL_SCAN_J:\n  t9 = j - 1\n  j = t9\n  t10 = A[j]\n  t11 = t10 &gt; pivot\n  if t11 == true goto LABEL_SCAN_J\n\n  // 如果i &gt;= j跳出循环\n  t12 = i &gt;= j\n  if t12 == true goto LABEL_RETURN_J\n\n  // 交换 A[i] 和 A[j]\n  t13 = A[i]\n  t14 = A[j]\n  A[i] = t14\n  A[j] = t13\n\n  goto LABEL_PARTITION_LOOP\n\nLABEL_RETURN_J:\nreturn j\n\n\n\n\n\n\n\n\n考试\n开卷考试。把复习内容整理好，打印下来。\n有三十分是概念题\n第一题是词法分析\n第二题是语法分析\n\n","categories":["课业"]},{"title":"互联网计算","url":"/2024/12/04/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/","content":"第零章 · 计算机网络及其参考模型名词解释\nLAN（局域网，Local Area Networks）\nWLAN（无线局域网， Wireless Local Area Networks)\nWAN（广域网，Wide Area Networks）\nNAP（网络接入点，network access point）\nISP  (互联网服务提供商，Internet Service Provider)\nModem（调制解调器） 调制解调器用于将数字信号和模拟信号之间相互转换。它在数字设备（如计算机）与模拟通信线路（如电话线）之间充当桥梁。\nCSU &#x2F; DSU（通道服务单元 &#x2F; 数据服务单元）：CSU&#x2F;DSU设备用于将局域网与广域网连接，通常用于专用数据线路（如T1、E1线路）。它在数字信号和物理线路之间进行信号匹配。\nTA &#x2F; NT1（终端适配器 &#x2F; 网络终端1）：TA&#x2F;NT1是ISDN（综合业务数字网）中的设备，用于连接ISDN终端设备（如电话、计算机）与ISDN网络。\nEthernet（以太网）\nISDN（综合业务数字网）：ISDN提供数字传输服务，能够同时传输语音、视频和数据。\nRFC：RFC（Request for Comments）文档是一系列正式的文档，用于描述互联网技术和协议的标准、建议、方法和创新。\nTCP(传输控制协议，Transmission Control Protocol) ***\nUDP（用户数据报协议，Uesr Datagram Protocol）\nIP（互联网协议，Internet Protocol) ***\nHTTP （超文本传输协议，Hypertext  Transfer Protocol）***\nSMTP （简单邮件传输协议，Simple Mail  Transfer protocol ）***\nDNS （域名系统，Domain Name  System）***\nTFTP （简单文件传输协议，Trivial File Transfer Protocol）***\n\n互联网发展的三个阶段\n从单个网络ARPAnet向互联网发展。\n1969年ARPAnet诞生\n1983年TCP&#x2F;IP协议成为ARPAnet的标准协议。这使得所有使用TCP&#x2F;IP协议的计算机都可以通过互联网通信。\n1983年互联网诞生\n\n\n\n\n建成三级结构的互联网\n1986年围绕六个大型计算机中心建设计算机网络，即NSFnet\n分为主干网，地区网和校园网（或企业网）\n1990年ARPAnet退役\n\n\n形成多层次ISP结构的互联网\n\n基于ISP的三层结构 ***主干ISP &lt;–&gt; 第二层ISP &lt;–&gt; 本地ISP &lt;–&gt; 主机\nOSI模型的七个层次 ***\n物理层（Physical Layer）\n功能: 定义硬件设备和传输介质的物理特性，如电缆、网络接口、信号电平等。\n例子: 以太网电缆、光纤、无线电波。\n\n\n数据链路层（Data Link Layer）\n功能: 负责在物理层之上建立、维护和断开物理链路（介质访问控制？），处理帧的错误检测和纠正。\n例子: 以太网协议（Ethernet）、Wi-Fi协议（IEEE 802.11）。\n\n\n网络层（Network Layer）\n功能: 负责数据包的路由和转发（跨链路的），选择数据传输的路径（由中间设备处理），处理逻辑地址（如IP地址）。\n例子: IP协议（Internet Protocol）、ICMP协议（Internet Control Message Protocol）。\n\n\n传输层（Transport Layer）\n功能: 提供端到端的通信服务，确保数据的可靠性和完整性（由终端判断可靠性），处理数据的分段和重组。\n例子: TCP协议（Transmission Control Protocol）、UDP协议（User Datagram Protocol）。\n\n\n会话层（Session Layer）\n功能: 管理应用程序之间的会话，处理会话的建立、管理和终止，支持会话恢复和同步。\n例子: 会话恢复协议（Session Initiation Protocol, SIP）。\n\n\n表示层（Presentation Layer）\n功能: 负责数据的格式化和转换，确保不同系统之间的数据能够被正确解释和显示。\n例子: 数据加密（如SSL&#x2F;TLS）、数据压缩。\n\n\n应用层（Application Layer）\n功能: 提供网络服务和应用程序之间的接口，处理用户直接交互的数据。\n例子: HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）。\n\n\n\nOSI模型的作用\n标准化: 提供一个标准化的框架，使不同设备和系统能够通过通用的协议进行互操作。\n分层管理: 通过分层结构，简化了网络通信的复杂性，使得问题的排查和协议的开发变得更加容易。\n协议互通: 各层协议可以独立开发和更新，而不影响其他层的功能。\n\nOSI模型帮助网络工程师和开发人员理解和设计网络系统，使得网络协议和设备的互操作性得以实现。\nLAN（局域网）&#x2F; WAN（广域网）\n局域网（LANs）\n在本地操作（覆盖小范围区域）\n支持多用户访问\n预期具有较高的速度（可达Gbps&#x2F;10Gbps）\n错误率容易控制\n\n\n广域网（WANs）\n在更大范围内操作\n通过串行链路、光纤链路等进行访问\n传统上速度较低\n错误率不易控制\n\n\n\nLAN Device\n集线器（hub）\n\n功能: 集线器是最简单的网络连接设备，用于将多台设备（如计算机、打印机等）连接在一起，形成一个局域网。\n\n工作方式: 它在物理层（OSI模型第1层）工作，将接收到的数据广播到所有连接的端口，而不区分目标设备。\n\n\n\n网桥（Bridge）\n\n功能: 网桥用于将两个或多个局域网连接起来，并对数据流进行过滤和转发。它能分隔网络，减少冲突域。\n\n工作方式: 在数据链路层（OSI模型第2层）工作，根据设备的MAC地址表转发数据包，从而减少不必要的数据广播。\n\n\n\n交换机（Switch）\n\n功能: 交换机是高级的集线器，用于在多个设备之间高效地转发数据。它是局域网的核心设备。\n\n工作方式: 在数据链路层（OSI模型第2层）工作，利用MAC地址表智能地将数据帧发送到目标设备的端口。高端交换机也支持网络层（第3层）功能，如VLAN和路由。\n\n\n\n路由器（Router）\n\n功能: 路由器用于连接不同的网络（如LAN与WAN），并在它们之间转发数据包。它是互联网连接的核心设备。\n\n工作方式: 在网络层（OSI模型第3层）工作，根据IP地址进行数据包的路由选择。可以执行更复杂的任务，如NAT（网络地址转换）、防火墙功能和VPN支持。\n\n\n\n\n\n注：高层设备可以识别底层设备的信号（数据逻辑），反之不行。\n\nData Packets\n为了传输，计算机数据通常被分割成小且易于传输的单元。在OSI模型中，这些单元可以被称为数据包、帧或段。（赛博快递）\n\n为什么使用数据包？\n\n计算机可以轮流发送数据包。\n如果数据包丢失，只需重新传输少量数据。\n数据可以通过不同的路径传输。\n\n\n段放在包中，包放在帧中（段&lt;包&lt;帧）\n\n数据包（Packets）\n\n\n\n所在层: 网络层（第3层）\n作用: 数据包是在网络层处理的数据单元，用于在网络间进行路由和传输。它们包含网络层的头部信息，包括源和目的IP地址，用于决定数据的传输路径。\n组成:\n头部（Header）: 包含源IP地址、目的IP地址和其他路由信息。\n数据（Payload）: 传输的数据内容，可能是从传输层传递下来的段。\n\n\n\n\n帧（Frames）\n\n\n所在层: 数据链路层（第2层）\n作用: 帧是数据链路层的基本传输单元，负责在局域网内的物理传输，包括错误检测和帧的同步。帧通过链路层协议，如以太网，进行局部网络的通信。\n组成:\n头部（Header）: 包含源MAC地址、目的MAC地址等信息，用于确定帧在局域网中的传输路径。\n数据（Payload）: 包含来自网络层的数据包。\n尾部（Trailer）: 包含错误检测信息（如CRC），用于确保数据的完整性。\n\n\n\n\n段（Segments）\n\n\n所在层: 传输层（第4层）\n作用: 段是在传输层处理的数据单元，用于端到端的传输控制。段负责分割应用层的数据，确保数据的可靠性、顺序和流量控制。\n组成:\n头部（Header）: 包含源端口号、目的端口号、序列号和确认号等信息，用于传输控制。\n数据（Payload）: 包含来自应用层的数据。\n\n\n\nBandwidth &amp; Throughput\nBandwidth（带宽）：\n\n带宽是指网络连接或传输介质的最大数据传输能力，即在单位时间内能够传输的最大数据量。\n\n带宽通常以比特每秒（bps）、千比特每秒（Kbps）、兆比特每秒（Mbps）、千兆比特每秒（Gbps）等单位来表示。\n\n可以比喻为高速公路的宽度，决定了能同时通过的车辆（数据包）的最大数量。\n\nThroughput（吞吐量）：\n\n\n吞吐量是指实际传输的有效数据量，即单位时间内成功传输的数据量。\n\n吞吐量受多种因素的影响，如网络延迟、丢包率、网络拥塞、协议开销等。\n\n可以比喻为高速公路上实际行驶的车辆数量，往往低于带宽，特别是在存在网络干扰或其他瓶颈时。\n\n\n\n关系：\n\n\n理论上，吞吐量不应超过带宽，它是带宽的实际利用率。\n吞吐量受到带宽的限制，但不会等于带宽。即使带宽很高，如果网络条件不好，如高延迟、丢包、网络拥堵等，吞吐量可能会显著低于带宽。\n\n\n\n一个功能的标准化过程个人草案 –&gt; 工作组草案 –&gt; 成为标准\nTCP&#x2F;IP模型 ***\nTCP&#x2F;IP模型只有四层\nApplication\n\n负责处理特定的网络应用程序数据。\n包含许多协议，如HTTP（用于网页浏览）、FTP（文件传输）、SMTP（电子邮件传输）、DNS（域名解析）等。\n直接与用户进行交互，提供应用服务。\n\n\nTransport\n\n负责数据传输可靠性，数据流控制，纠错。\n主要协议是TCP（传输控制协议）和UDP（用户数据报协议）。\n把Application Layer的数据打包为segments(段)。\n\n\nInternet\n\n负责跨网络传输数据包，负责最佳路径和数据包交换。\n使用IP协议（例如IPv4或IPv6）来处理路由和寻址。\n主要协议：IP\n\n\nNetwork Access\n\n也被称为 host-to-network layer.\n\n负责在本地网络中传输数据。\n\n包含物理网络接口，如以太网、Wi-Fi等。\n\n处理数据帧的发送和接收，并管理MAC地址。\n\n\n\n\n\n\n拓扑结构 ***\n定义了互联网的结构类型\n物理拓扑：如bus（总线型）, star（星型）, ring（环形）, extended star（拓展星型）, hierarchical（分层拓扑）, mesh（网型）\n\n终端设备 ***第一层\nMedia\n\n即介质（线路）。把零一序列转化为介质的信号来传输。\n\nRepeater\n\n中继器。\n一对一的\n\nhub\n\n集线器。广播型的\n\n物理上是星型，逻辑上是总线型\n放大型号并转发，和中继器相比就是能连接多个端口\n因为逻辑上是总线型，就可能会产生冲突。把冲突的区域称为冲突域。但是冲突域的管理不由hub管理。\n\n第二层特点：能够把比特流结构化成帧。流量的管理与控制工作。\n\nNIC\n\n作用：把host连接至网络\n每个NIC都有一个MAC地址\n计算机中母线是并行通讯，网线却是串行通讯。NIC要切换信息的并串型。\nNIC不仅在终端上有，线路上也会有。\n“只要是把信息接入介质，都需要网卡\n\n\nMAC\n\n\nMAC（Media Access Control，媒体访问控制）地址是用于标识网络设备的硬件地址。它是网络接口卡（NIC）在链路层使用的唯一标识符，常用于局域网（LAN）中的数据链路层通信。\n\nbridges\n\n有两个端口，会根据设备的mac地址把网络分为两个分段，生成地址表（MacTable)。如果发现目的地址不在本端，就会转发信号，反之不会。\n\n把网络分成了两个冲突域。\n\n\n\nswitch\n\n结合了hub和bridge的功能。\n\n可以隔离冲突域(collision)，不能隔离广播域(broadcast)\n\n当一台主机发送消息到交换机上的另一台主机时，交换机将接受并解码帧，以读取消息的物理 (MAC) 地址部分。\n\n\n交换机上含有一个 MAC 地址表，其中列出了包含所有活动端口以及与交换机相连主机的 MAC 地址。当消息在主机之间发送时，交换机将检查该表中是否存在目的 MAC 地址。\n\n如果存在，交换机就会在源端口与目的端口之间创建一个临时连接，称为电路、虚电。这一新电路为两台主机的通信提供一个专用通道。\n\n如果目的 MAC 地址不在表中，交换机就没有创建电路所需的信息。当交换机无法确定目的主机的位置时，就会采用“泛洪”处理方式将消息转发到所有连接的主机。\n\n\n\n新主机的 MAC 地址如何进入 MAC 地址表？交换机检查主机之间发送的每个帧的源 MAC 地址，然后创建 MAC 地址表。当新主机发送消息或响应“泛洪”式消息时，交换机就会立即获取其 MAC 地址及其连接的端口。交换机每次读取新的源 MAC 地址时，地址表都会自动更新。\n\n对于每一个端口来说，交换机的功能和网桥是一样的。\n\n\n\n\n第三层\nrouter\n基于IP地址做网段分逻辑划分。路由器可以做\n报文识别，路径选择，报文转发。\n\n\n\n第一章 · 物理层名词解释\nSTP &#x2F; UTP(有屏蔽双绞线Shielded Twisted Pair &#x2F; 无屏蔽双绞线Unshielded Twisted Pair)\ncoaxial\nfiber-optics\n\n\nType of Network\n多路复用，共享介质（Multiple Access, Shared Media)\n点对点(Point-to-Point)\n\nLAN Media传输方式：\n\n电信号\n光信号\n电磁波\n\n有线传输\nUTP（无屏蔽双绞线，Unshielded Twisted Pair)：\n八根子线，两个一对。\n优点：\n易部署\n低成本\n\n\n缺点：\n容易受到电磁波干扰\n电信号损失快，传输距离较短。一般认为传输距离是100米。\n\n\n\n\nCoaxial(同轴电缆)：\n结构：从内向外是铜线，绝缘膜，金属网，塑料套。\n传输距离一般认为是500米。\n成本介于双绞线和光缆之间。\n\n\nFiber-Optics(光缆)\n结构：从内向外是二氧化硅，塑料套。接口分为两部分，一个接收，一个发送。\n传输距离为公里级，但是成本高。\n分类\nSingle Mode(单模)：\n光导体很细，可以认为光在其中几乎没有反射，所以损失较慢，传输距离远。一般用于广域网。\n\n\nMultimode(多模)：\n光导体较粗，可以根据射入角度不同，同时传输多路信号。信号损失较快。\n\n\n\n\n\n\n\n无线传输分类：陆生（利用基站），卫星（如GPS）。\n\n激光：通讯双方约定好通讯方案和频率范围。中间要求无遮挡。\n红外：成本较低，不能跨障碍物。\n无线电波：可以衍射（跨障碍物）。易受干扰（如在雨天，大功率设备旁）。\n\nCategory of UTP\n一到七类线加超五类线。\n从三类线开始出现以太网\n从五类线开始以太网达到百兆\n五类线相比于三类线具有更高的绞合度\n\n\n超五类线达到千兆，现在很常用\n六类线性能高于超五类线\n\nCatrgory og Cable\nStaight Cable(直通线)\n有八根子线，每根子线有不同颜色，不同规格标准的配色不同。(记住颜色，配对和型号)\n![屏幕截图 2024-09-23 222304](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-23 222304.png)\n\nT568A和T568B的区别在于pair2和pair3换位置了。\n\n\n如果一根线的两段都是T568A或都是T568B，则为直通线。\n\n路由器和交换机，交换机和终端之间用直通线连接。\n\n\n\nRollover Cable(反转线)：\n别名：console cable\n两段的子线排列是反的。1对8，2对7，等等。\n路由器如果和终端直接连接，则用反转线。\n\n\nCross-over Cable（交叉线）：\n两个相同的设备之间用交叉线。\n特点是一端是T568A，另一端是T568B。和直通线相对。\n\n\n\n信号传输的问题\n一般\n\n衰竭\n反射\n电磁干扰（噪声）\n散射\n抖动（不同步）\n延时\n\n\n冲突和冲突域\n\n冲突会影响数据传输\nrepeater和hub会使得冲突域变大\nbridge和switch和router能控制冲突域。\nbridge和switch虽然将网络分段，不代表分成多个局域网。router才可以划分局域网。\n\n\n\n数据传输基本术语\n信号：数据的电气或电磁的表现。\n模拟的：参数的取值是连续的。模拟信号是随时间变化而平稳变化的连续波形式\n数字的：参数的取值是离散的，包含了有限种可能的预设值。\n\n\n码元：在使用时间域（或称时域）的波形表示数字信号时，代表不同离数值的基本波形。\n理解：用波形来表示信息。想要在一个时域内传输3个bit，码元就应该为2^3 &#x3D; 8。每个波形表示一种取值。\n\n\n电平数量指信号所支持的电平数，即逻辑状态的种类。\n\n理论基础\n信号分类\n\n简单信号：正（余）弦波\n复合信号的分解：傅里叶分析\n\n\n信号处理\n\n数字信号通常在传输介质上表现为方波。可以用无穷多个谐波来拟合。\n\n码元传输速率越高，传输距离越远，信号畸变越严重\n\n传输速率的理论上限（无噪声干扰）：$$C&#x3D;W·log_2L （W为带宽（单位：Hz），L为信号电平数量）$$\n\n噪声信道的最高传输速率（香农公式）：$$C&#x3D;W·log_2(1+\\frac{S}{N})（W为带宽，S为信号的平均功率，N为平均高斯噪声功率）$$\n\n带宽和信噪比越大，极限越高\n注意，即使带宽、信噪比和码元速率已经确定，仍然可以提高信号传输速率，依靠编码让每个码元的识别率更大，从而携带更多的比特数。\n\n\n\n\n波特率和比特率\n\n波特率：每秒波形的变化次数\n比特率：每秒传送的二进制位数\n\n\n数据通信系统的模型\n![屏幕截图 2024-09-23 225726](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-23 225726.png)\n\n\n编码（encoding）***\n把数字信号转换成物理信号的过程。\n基带：基本频带，之传输变换前所占用的频带，是原始信号所固有的频带。数字信号一般属于基带信号。基带信号往往具有低频成分，甚至有直流成分，导致许多信道不能直接传输的，需要调频。\n调制：把数字信号转换到模拟信号。\n\n\n单极性编码 ***\n\n原理：用0电平表示“0”，用正电平表示“1”。\n缺点：\n难以分辨每个信号的开始和结束\n必须时钟同步\n若信号中“0”或“1”连续出现，信号直流分量将累加，直流问题严重\n\n\n结论：容易产生传播错误\n\n\n极化编码——不归零制码（NRZ）\n\n不归零电平编码\n\n原理：负电平表示“0”，正电平表示“1”\n\n缺点：和单极性编码一样\n\n\n\n不归零反相编码\n\n原理：电平翻转表示“1”，不变化表示“0”\n稍微缓解了电荷累加导致直流的问题\n\n\n\n\n极化编码——归零编码（RZ）\n\n原理：负电平表示“0”，正电平表示“1”，比特中位跳变到零电平。\n\n\n极化编码——曼彻斯特码 ***\n\n原理：每一位中间都会有一个跳变，从低到高表示“0”，从高到低表示“1”\n\n优势：\n\n每一位中间的跳变既可以作为数据，又可以作为时钟，能够自同步。\n\n只采用两个电平，跳变相对于RZ码少，效率更高\n\n每次跳变都自中和，不会导致电荷积累。\n\n\n\n\n\n极化编码——差分曼彻斯特码 ***![屏幕截图 2024-12-11 172227](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-12-11 172227.png)\n\n原理：\n每一位中间跳变：表示时钟\n每一位位前跳变：表示数据\n有跳变表示“0”，无跳变表示“1”\n\n\n\n\n优势：\n时钟和数据分离，便于提取\n\n\n\n\n双极性编码——双极性传号交替反转码（AMI）\n\n原理：采用三个电平：零电平表示“0”，正负电平的跃迁表示“1”，实现对“1”电平的交替反转。\n优点：\n“1”的正负交替，使得直流分量为零。\n虽然连续的“0”不能同步，但连续的“1”可以同步\n\n\n\n\n\n多路复用\n由于一条传输路线的能力远远超过传输一个用户信号所需的能力，为了提高线路利用率，经常让多个信号共用一条物理线路\n信号 –&gt; 复用器 –&gt; 信道 –&gt; 分解器 –&gt; 信号\n注：频率带宽和速度带宽\n频率带宽‌：主要描述的是信号的频率范围，即信号中所包含的最高频率和最低频率之间的差异。在通信领域，频率带宽指的是信道能够传输的频率范围，这个范围越大，信道的容量越大，意味着可以传输更多的信息。\n速度带宽‌：更多关联于数据的传输速率，即单位时间内能够传输的数据量。在数字设备中，带宽通常用bps（bits per second）来表示，即每秒可传输的位数。速度带宽可以理解为网络的传输速度，即网络中信号从发送节点到达接收节点的速度，或者网络的每秒中能传输的数据位的能力‌。\n频率带宽关注的是信号的频率响应能力，而速度带宽关注的是数据的传输速率‌。\n\n\n\n\n时分复用（TDM，Time DIvision Multiplexing)\n\n原理： \n\n将时间等分为时分复用帧，每个用户在每个TDM帧中占用固定序号的时隙。\n每个用户所占用的时隙周期性出现\n所有用户在不同时间占用同样的频带宽度\n\n\n缺点：造成浪费。可能某个用户在某个时隙里没有数据。\n\n改进：统计时分复用（STDM，Statistic TDM）：\n\n不再固定的把时间分出去，而是谁先来就先服务谁。\n\n因为时隙不固定，所以每个子帧必须带有自己的身份信息。\n\n效率降低了，但是资源利用率提高了\n\n\n\n\n\n频分复用（FDM，Frrquency Division Multiplexing）\n\n原理：\n用户在分到一定的频带后，就使用占用这个频带\n所有用户在1相同时间占用不同的带宽资源（带宽指频率带宽）\n\n\n\n\n波分复用（WDM，Wavelength D M）\n\n实际上就是频分复用的光传输场景\n把光分为不同波长\n\n\n码分复用（CDM，Code D M)\n\n又称码分多址\n原理：传输信号时采用相同的频率，不同的编码。各用户使用挑选过的不同码型，要求编码相互正交，也就是互不影响。\n优势：\n抗干扰能力强\n频谱类似于白噪音，不易被敌人发现。\n\n\n\n\n\n第二章 · 数据链路层概述\n形成数据帧，对上层提供的数据封装，然后传输。\n能够校验帧是否正确。\n不能跨链路。\n在数据链路层，”procedure” &#x3D; “protocol”\n主要任务：\n校验，即错误识别\n网络拓扑控制\n节点之间流的控制\n\n\n与物理层的区别：\nLayer 1不能与上层交流；Layer 2 通过LLC(Logical Link Control)与上层交流\n如果是总线拓扑，Layer 1 无法识别主机和接受机，Layer 2 通过MAC(Media Access Control)控制\nLayer 1 不能组织发出的数据，Layer 2 组织为帧\n\n\n\n第二层提供的服务\n通讯之前没有确认连接关系，而且通讯无确认（数据发出去就不管了），应用场景：\n多用在局域网\n可靠的链路\n对于实时的任务\n\n\n通讯之前没有确认连接关系，且通讯有确认。可用于不太可靠的链接，如无线网络。这样做效率降低了，因为需要确认。\n面向连接的，需要确认连接关系，且通讯要确认。如蓝牙连接。\n\nMAC（介质访问控制）的标准类型\nEthernet（以太网）：逻辑上是总线型，物理上是星型或拓展星型。\nToken Ring：逻辑上是环形，物理上是星型。\nFDDI：逻辑上是环形，物理上是双环形。\n\n分类\nDeterministic——taking turns：Token Ring 和 FDDI。终端形成令牌环网，依次获得令牌。发送数据，有顺序发送。\nNon-deterministic——first come, first served：Ethernet。无顺序，谁先到谁先用。\nCSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection）*** ：用这个解决方案来避免冲突。\n\n\n\n局域网通讯的分类\n单播（unicast)：点对点\n组播（multicast）：一个节点发给一组特定的节点。\n广播（broadcast）：一个节点给所有节点\n\n以太网规范局域网标准\n任务：\n局域网由一个单位控制，决定了物理介质来无线组网并控制连接。\n定义了数据链路层帧的规范\n第二层约定如何利用介质来传输数据，同时避免冲突\n第二层开始对上层服务，处理上层的要求\n\n\n两个子层的方案：\nMedia Access Control(MAC)：不同介质，不同网线的访问\nLogic Link Control(LLC)：有关链路服务\n\n\n\n帧结构规范（MAC子层）\n以字节为单位做帧的表述\n结构：\n前导码(Preamble)（8字节）：给一个缓冲，让接收方知道有一个帧要过来了。前导码为10101011。\nMAC地址(Dest.add. Source add.)(6+6&#x3D;12字节)：\n6字节目的地址，后接6字节发送地址。\n目的方可能是单播，组播和广播（111111），发送方总是单播\n\n\n长度(Length)（2字节）：\n数据段的长度，2字节。\n要求Length的范围是46~1500字节，保证整个帧除了前导段的长度最小为64，最长为1518.\n在以太网二(Ethernet 2)种，用类型（Type）替代长度，Type可以指定数据类型是IP还是IPX，所以这样也可以确认长度。\n\n\n数据(Data)\nFCS(循环冗余校验)（FCS（Frame Check Sequence）是循环冗余校验（CRC））（4字节）：接收方用于校验\n\n\n\n![屏幕截图 2024-09-30 091038](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-30 091038.png)\nLLC子层![屏幕截图 2024-09-30 091749](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-30 091749.png)\n\nLLC放在帧的数据部分，放在包的前面\n基于SAP（Service Access Point）识别地址\n\nCSMA&#x2F;CD\nMAC地址：48位标准，烧在网卡芯片上的。用十二个十六进制位表示\nOUI标准下，第一位有意义：0代表单播，1代表组播或广播\n第二位：0代表全球唯一设备，1表示地区唯一地址\n广播地址为全一，即12个F。\n\n\n以太网操作原理\n拓扑方式：总线拓扑。\n传输的一些细节：\n所以当A发送信号给D时，B,C都会收到电信号。此时会检查信号的MAC地址，若不是自己的，则丢弃。\n监听信号，避免冲突\n若发生冲突，接收方会广播一个Jam Signal，全一信号，这样会让其他准备发送数据的设备回退一个时间\n\n\n流程：![屏幕截图 2024-09-30 094626](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-09-30 094626.png)\n\n\n\n无线局域网\n分类：\n有基础固定设施的无线网络：预先设下基站，覆盖一定范围，有距离限制\n无基础设施的拓扑网络：自组网络（？）\n\n\n无线通讯是有确认的\n\n标准\nIEEE 802.11\n拓扑方式：星型拓扑，以基站为中心节点\n直接序列扩频技术（DSSS，Direct Sequence Spread Spectrum）\n又叫Wi-Fi\n\n\nIEEE 802.11b\n速度可达11Mbps\n工作频率在2.4GHz\n\n\nIEEE 802.11a\n正交频率复用技术\n工作功率在5GHz\n\n\nIEEE 802.11g\nIEEE 802.11n\n速度可达500Mbps\n\n\n\n结构\n有基础设施的无线网络结构![屏幕截图 2024-10-11 024154](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-11 024154.png)\n星型拓扑\n基本服务集（BSS）：主机和AP的连接。服务于多个无线网设备，每个AP都有一个IP\n扩展服务集（ESS）：多个BSS通过分配系统（DS）相连，组成ESS。\nscanning：\n一个移动客户端要加入BSS就要和AP建立连接关系，即”associate”，需要建立虚拟连接线路。有两种做法：\nActive Scanning：\n设备发出请求帧。请求帧包含SSID信息。\nAP收到SSID的信息后，AP进行————\n身份确认后建立连接\n\n\nPassive Scanning：\nAP周期性地发送信标帧，包含SSID信息\n移动设备可以选择加入以建立连接关系\n\n\n\n\n\n\n\n\n\n无线局域网的帧\n与Ether的802.3不一样，WLAN用的802.11\n有三种帧：\n控制帧\n管理帧\n数据帧\n\n\n一个Ether的帧不能超过1518字节，但是WLAN的帧上限可以达到2346字节。\n结构：![屏幕截图 2024-10-11 030557](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-11 030557.png)\n帧控制（2字节）：16位继续分段，各有意义。\n持续期（2字节）\n地址1,2,3（6*3&#x3D;18字节）：有基础设施链接时用。\n序号控制（2字节）：无线连接是有确认的，用这个字段来控制。\n地址4（6字节）：用于自组网络（无线设备之间直接连接）\n帧主体\nFCS（4字节）\n![屏幕截图 2024-10-11 031402](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-11 031402.png)\n\n\n\nCSMA&#x2F;CA\n为什么不用CSMA&#x2F;CD：\n\nHidden Station Problem：基站只能服务周围的设备，监听不到远处的信号，可能导致两个基站的信息同时到达某个设备，造成冲突。\nExposed Station Probilem：当A,B在基站X内，B,C在基站Y内，当X向A发送时，Y为了避免冲突就不向C发送信息了。但事实上本是不会冲突的。\n\n\nEther和WLAN的多路复用机制对比：\n\nEther所有节点都可以收到线路上的信号，WLAN不行，有距离限制。\n\nEther通过发送节点信息来监听冲突，WLAN做不到\n\nEther同时只能有一路信号传输，WLAN有多路\n\n\n\nCSMA&#x2F;CA\n\n时间控制来避免冲突\n发送站点在发送数据前，以控制短帧刺激接受站点发送应答短帧，使接受站点周围的站点监听到该帧，从而在一定时间内避免数据发送\n过程：\nA向B发送RTS（Request To Send）帧，A周围的站点在一定时间内部发送数据，以保证CTS帧返回给A\nB向A发送CTS（Clear To Send）帧，B周围的站点在一定时间内不发送数据，以保证A发送完整数据。\nA开始发送\n若RTS或CTS发生冲突，采用二进制质数后退算法等待随机事件，再重新开始。\n\n\n\n\n\n\n\n![屏幕截图 2024-10-14 084317](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-14 084317.png)\n\n问题：\n由于有应答过程，实际带宽是理想带宽的50%。\n\n\n\n第二层设备\n网卡\n网桥：\n工作原理补充\n计时与刷新：网桥每个一段时间就会刷新一次，重新看看连接的MAC地址，以适应动态网络拓扑。\n\n\n限制：\n收到一个没被记录的MAC地址，则会把它广播到全局。可能导致网络延时，传输降速，资源浪费，性能下降\n\n\n\n\n交换机\n功能\n帧转发\nMAC表的生成和维护，包括MAC回路的处理\n冲突域的隔离\n\n\n\n\n\n第三章 · 网络层概述\n用IP地址定位主机\n功能：\n不同网段（广播域）的通讯\n有层次的地址逻辑，和第二层的MAC地址相对\n流量控制\n屏蔽了的二层的不同帧的类型，统一用IP形成数据报\n\n\n设备：路由器\n连接不同网段\n基于IP地址划分\n选择最佳路线\n\n\n\nIP和数据报\nIP是报文里的一部分，每个IP占32bit\n\n\n报文结构：注意这里的单位是bit，不是字节![屏幕截图 2024-10-18 024313](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-18 024313.png)\n\n首部：报文一定有首部，首部还分为固定部分和可变部分。主要解释固定部分：\n版本（IPv4为4位）\n首部长度（4位）：最多表示15个单位长度，一个单位为4字节，所以首部最长为60字节\n服务类型（8位）\n总长度（16位）：理论上数据报的最大长度为65535字节，但是我们要把数据报放在帧里，所以一般不超过1500字节.\n标识（16位）：传输时可能要把报文拆开，为了能够再和上，用标识来确认身份。\n标志位（3位）：最高位（DF位）为零表示可以分配，MF为零表示这是最后一个分片\n片偏移（13位）：传输不一定是按顺序的，为了合并时顺序不乱，有了片偏移。以8字节为单位计算。所以同时要求子报文的分段要是8的倍数。\n生存时间（TTL，Time To Live，8位）：表示报文能通过的路由器数的最大值。\n协议（8位）：决定用那种协议处理数据，指出应该将数据交给那个进程去处理。\n首部地址校验和（16位）：反码算数求和运算。智能校验首部内容。在接收端的结果为0则保留。\nIP地址（32*2&#x3D;64位）：源地址和目的地址。\n\n\n\n\nIP地址：\n\n结构\n\n32位\n\n写成四个字节分开的形式\n\n分为网络ID和主机ID，一般前面是网络，后面是主机，但不一定是平分\n\n分类\n\n用第一个字节的取值范围来区分（实际上就是A类以0开头，B类以10开头，C类是110开头，等）\n\n\nA类地址：四个字节为NHHH（N代表网络地址，H代表主机地址）\nB类：NNHH\nC类：NNNH\n\n\n规范：\n\n主机地址若为全0串，表示网络地址\n主机地址若为全1串，表示广播地址\n使得每个类型的可表示主机数量应该减2.\n保留网段：只会在局域网内部使用，不会转发到互联网\n10.xxx.xxx.xxx\n172.16.xxx.xxx\n192.168.xxx.xxx\n\n\n172.16.2.1&#x2F;23：后面的&#x2F;23是子网掩码，表示前23位全1。\n\n\n\n\n\n\n\n子网\n概述\n\n从host段中借出几位来作为子网段\n\n子网之间也是不同的网段，和网络地址一个标准。即使在同一个网段，之间不能广播。\n\n借位：\n\n最少2位。因为子网段也不能全1或全0。\n\n\nA类：最多22位\nB类：最多14位\nC类：最多6位\n\n\n子网划分的优缺点：优点是增加了划分的灵活性，缺点是会有浪费\n\n\n\n掩码：\n\n和母网的掩码不一样，母网的主机地址部分全零，但是子网不是。\n把掩码和IP地址做与运算，可以得到对应的网络地址\n\n\n\n路由转发\n路由器每个端口都有网卡，要配一个和端口相同网络地址的地址。不同端口是不同网段。\nA1向B5发送报文，报文中的目的地址IP是B5的，但是形成的帧的目的地址却是路由器的A端口。因为A1和B5不在同一个网段，B5的MAC地址对A!来说是无意义的。同理，B5收到的帧的源地址是B端口的地址。\n其实就是默认网关\n\n\n地址分配：\n静态地址分配：\n动态地址分配：DHCP、RARP\n\n\n\nARP协议、网关\n知道IP地址，但是不知道MAC地址。\n\n\nAPR缓存\n主机或设备都会在RAM中存储IP地址，称为ARP Table。但是如果长时间不刷新、激活的话，会被删除。如果目的地在ARP Table中，则转发数据，否则，进入ARP Request。\n\n\nAPR Request\n流程：\nrequest：A把目的MAC设为全一（广播地址），发给所有设备。\nChecking：接收方检查报文中的IP地址，若不是自己就丢弃，若是则进入下一步。\nReply：目的主机B发送一个报文给发送方A。因为帧中包含了源地址，所以让A知道了B的MAC地址。\nCaching：把B的地址写入ARP缓存。然后发送数据。\n\n\n如果目的主机不在同网段内呢？\nDefault Gateway：默认网关\n如果没有配网关，则不能跨网段交流。\n默认网关就是所连路由器的端口的IP地址。\n\n\nARP代理（Proxy ARP）\n在路由器上启动\n主机不必配置默认网关\n\n\n\n\n\n\n\n网络层服务\n面向连接的网络服务vs虚电路交换\n在发送数据之前，要先建立连接\n虚电路交换：建立连接后就完全在这条电路上传输信息，要强于面向连接的，传输更加可靠，保证传输先后关系。\n\n\n无连接VS.报文交换\n无连接（Connectionless）：\n不需要事先建立连接\n把每个数据包分开传输\n不用维护上下文\nIP就是一个无连接系统\n\n\n报文交换（Packet switching）\n把原始报文分成多个报文，每个报文独立发送，可以走不同路径，乱序到达。\n当某个数据包传输失败，只需要重传这个数据包就好了\n\n\n\n\n\n网络协议操作\nRouted protocol 被动可路由协议：\n为网络层提供支持的协议称为路由协议或可路由协议。\nIP是网络层协议，因此，它可以通过互联网络进行路由。\n\n\nNon-routable protocol 不可路由协议\n不可路由协议是不支持第3层的协议。\n这些不可路由协议中最常见的是NetBEUI。\n直接根据目的方的地址在局域网中进行生成定位\n这个协议不支持第三层，也就是跨局域网是不可以的。\nNetBEUI是一种小型，快速且高效的协议，仅限于在一个网段上运行\n\n\n\n\n被动可路由的寻址\n路由器连接三个网段(列出来的是网络号)\n将目的主机和掩码进行逻辑AND操作，得到对应的网段\n然后请求路由表可以发现E2端口为目的网段\n再次将报文封装转发给对应的主机\n路由表是存储在内存中的\n\n\n路由协议的分类\n静态路由：网络管理员在路由器中手动输入路由信息。\n动态路由\n路由器可以在运行过程中互相学习信息。\n使用路由协议更新路由信息。\nRIP, IGRP, EIGRP, OSPF …\n人工维护的代价比较大\n\n\n区别：\n静态路由\n用于隐藏部分网络。安全(不必进行路由表的交换)\n测试网络中的特定链接。\n用于仅在到达目标网络的路径时维护路由表。\n\n\n动态路由\n维护路由表。\n以路由更新的形式及时分发信息。\n依靠路由协议共享知识。\n路由器可以调整以适应不断变化的网络状况。\n打开后会启动进程，按照不同的协议，和网上的不同设备学习信息，然后根据算法生成路由表\n\n\n\n\nRouting protocol 主动路由协议(Routing)\n路由协议确定路由协议遵循的到达目的地的路径。\n是用来构建路由表的，所以叫做routing\n公平、简单、适应变化等特点\n\n\n\n\n\nRouted  and Routing Proyocal\nRouted：在路由器之间运作，保证连接，完成转发\nRouting：在路由器之间制路由表，并且路由器彼此之间交换信息，以此实现Routed\n路由表：\n动态路由分类\n自治系统：一个逻辑划分出来的系统。\nIGP（内部网关协议）：一个自治系统下统一的网络管理规范\nDVP（距离矢量协议，Distance Vector Protocal）：\n特点\n基于邻居的视角获得网络获得拓扑信息。\n基于跳数作为选择路径的评判标准\n定时交换Routing Table\n会生成路由回路\n\n\n代表：\nRIP（Route Info Prot）\n最受欢迎。(实现算法简单，更加靠谱)\n最远可达跳数为15\n唯一的指标是跳数。\n每30秒广播以更新\n产生大量的网络流量。\n\n\nIGRP\n思科知识产权的。\n基于距离矢量的内部网关协议。\nIGRP最大跳数为255。\n每90秒更新一次。\nEIGRP是IGRP的高级版本，它是混合路由协议(不全是根据跳数来计算)。\n\n\n\n\n\n\nLSP（链路状态协议，Link State Protocal）\n特性：\n基于全局，使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树\n基于带宽来计算代价，根据代价来判断路径\n触发事件更新信息，链路改变时会更新信息\n\n\n代表：\nOSPF(Open Shortest Path First)\n最短路径优先协议，是基于链路状态的内部网关协议，消耗CPU和内存。\n指标由带宽，速度，流量，可靠性和安全性组成，本科阶段只考虑带宽的。\n\n\n\n\n\n\n\n\nEGP（BGP）（外部网关协议）：用于在自治系统之间路由数据包。\n\n\n\n\nRouting protocals dtermine how routed protocals are routed.\n\n可变长度子网掩码VLSM(Variable Length Subnet Mask)\n经典路由(Classful routing) 无子网掩码\n有类的路由协议要求单个网络使用相同的子网掩码。\n例如：网络192.168.187.0必须仅使用一个子网掩码，例如255.255.255.0。\n会造成网络号的浪费(为了规格一致，为了保证标准一致，会浪费一些网络号)，比如路由器之间的网络没有必要给很多的hostID。\n特定的情况:将路由器端口的掩码作为目的网络的掩码，可以进一步完成细化\n\n\nVLSM\n作用\nVLSM只是一项功能，它允许单个自治系统的网络具有不同的子网掩码。\n有效的解决网络号浪费的问题\n使用VLSM，网络管理员可以在主机少的网络上使用长掩码，而在主机多的子网上使用短掩码。(提供了很高的灵活性)\n如果路由协议允许VLSM\n在路由网络连接上使用30位子网掩码255.255.255.252\n用户网络的24位掩码255.255.255.0\n或者，对于最多1000个用户的网络，甚至是22位掩码255.255.252.0。(保留10位)\n\n\n在CIDR的基础上发展的，报文中包含有子网掩码\n实施VLSM通常被称为”子网划分”，可用于最大化寻址效率。\nVLSM是有助于缩小IPv4和IPv6之间差距的修改(modifications)之一。\n\n\n优点：\n高效使用IP地址\n更好的路由聚合(aggregation):构建超网\n\n\n缺点：\n会导致地址空间的浪费:广播地址和网络号都无法被使用。\n\n\n划分流程：\n先划分大的子网，再划分小的子网。每次划分会剩下一些没有用到的子网，留给后面用。\n如果使用了子网中的任何地址，则该子网不能再进行子网划分。\n\n\n路由聚集(Route Aggregation)\n使用无类域间路由(CIDR，Classless InterDomain Routing)和VLSM不仅可以防止地址浪费，而且还可以促进路由聚合或汇总。\n多个路由条目汇聚成小的路由条目\n比如如下图就是讲3个&#x2F;24的子网合并成一个&#x2F;16的网络高速远端\n优点:聚集之后我们只需要知道一个网段就可以，也就是远端的路由表就会变少\n例子：多层聚集\n做法：在网络地址中找到尽可能多的前置位数，作为新的网络位，从必须有差异的地方开始，作为新的主机位\n优点：\n减少路由表条目的数量。\n可用于隔离拓扑更改(聚集之后，只能得到大的网段的信息，因为小的网段的拓扑变化会比较频繁，导致路由表进行不断地计算，只公告比较高聚集后的路由的网段信息)\n\n\n注意：\n为了使聚合正常工作，请以分层方式(hierarchical fashion)仔细分配地址，以便汇总的地址将共享相同的高位。\nVLSM允许路由聚合，并且通过将聚合完全基于左侧共享的高阶位来灵活地增加，即使网络不连续也是如此。\n路由聚集需要严谨，不能让A和B两个端口的聚集后的网络号相同\nVLSM是不做连续性检验的，也就是就算不连续也会进行聚集\n全0子网会在题目中说是否可用\n全1子网尽量不要使用\n\n\n\n\n\n\n\n因特网控制报文协议 ICMP\n概述：\n\nICMP (Internet Control Message Protocol)：为了提高 IP 数据报交付成功的机会(消息管理和协商)\nICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告\nICMP 只是IP层的协议\nICMP 报文作为IP层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去\n一般路由器在丢弃报文的时候(处理之前已经提到的情况)，都会返回一个ICMP差错报文。\n\n\n格式：\n\n\n前四个字节是一样的(格式化的)\n后面都是个根据类型\n\n\n两种ICMP报文\n\n差错报告报文:一般这种类型会多一些\n目的站不可达：\n网络不可到达(net unreachable)\n主机不可到达(host unreachable)\n协议不可到达(protocol unreachable)\n端口不可到达(port unreachable)\n源路由选择不能完成(source route failed)\n目的网络不可知(unknown destination network)\n目的主机不可知(unknown destination host)\n不可知是完全不可以解析，不可达是可以解析但是不可以到达\n\n\n差错报告报文数据部分的格式\n一般会把原始的IP数据报文的数据报首部 + 8字节(数据的，可能会包含端口信息)作为ICMP的数据部分\nICMP的前8个字节的是确定的(前4个字节是类型，校验位，后面四个字节是确定的)\n然后添加一个首部作为IP数据报进行发送。\n\n\n\n\n查询报文：一般这种情况不是很多\n\n\n不应发送ICMP差错报文的情况\n\n对 ICMP 差错报告报文不再发送 ICMP 差错报告报文\n对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文(就是每次传送只要发送一次就够了)\n对具有多播地址的数据报都不发送 ICMP 差错报告报文\n对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送 ICMP 差错报告报文\n127.0.0.0:逻辑回路地址\n0.0.0.0:确认路由地址\n\n\n\n\nPING (Packet InterNet Groper)\n\nPING 是用ICMP的”Echo request”和”Echo reply”消息来实现的\nPING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING不通，不仅仅是发送不过去，有可能是应答不回来。\nPING 使用了ICMP回送请求与回送回答报文\nPING 是应用层直接使用网络层ICMP的例子，它没有通过运输层的TCP或UDP\n\n\n\n第四章 · 运输层概述\n第4层执行多项功能：\n分割上层应用程序数据(新的数据单元-数据段)\n建立端到端(end to end)的运营\n从一个终端主机向另一个终端主机发送段(第三层和第二层不进行可靠性检验，第四层完成可靠性检验，接受方认为数据错误，在第四层进行要求重传)\n流量控制和可靠性\n可以比喻为与外国人交谈:通常，您会要求外国人重复他&#x2F;她的话(可靠性)并慢声说话(流量控制)\n双方主机的网络的处理能力不同，缓存能力不同\n\n\n\n\n两个特别重要的第4层协议：\n传输控制协议(TCP, Transmission Control Protocol)\n用户数据报协议(UDP, User Datagram Protocol)\n\n\n将传出邮件分成多个部分,在目标站重新组合消息\nTCP: 可靠(效率比较低，早期网络应用少，需要可靠性)\n面向连接，使用确认机制，提供流量控制\n软件检查细分\n重新发送丢失或错误的任何内容\n\n\nUDP: 不可靠\n无连接，不使用确认，不进行流量控制\n不提供用于细分的软件检查\n直接丢弃错误的报文，而不进行其他操作。\n\n\nSCTP(Stream Control Transmission Protocol)：流控制传输协议，为了进行视频和音频的传输\n\n服务模型（Service Model）\nTCP和UDP都使用**端口（port）**来跟踪(track)同时穿越网络的不同会话\n端口分配规范\n低于255的端口号(0-255)保留给TCP和UDP公共应用程序使用。(端口号0-255是public的，不可以随意分给其他的进程，如果分发则不符合规范)\n0-1023是熟知端口，有分发的规范，不应当被随意使用\n1024-49151的端口号进行登记使用，有的是应用程序已经的使用端口号，避免冲突\n基于端口号的不同，进行不同的包的分发\n\n\n\n传输控制协议TCP\n要解决的问题\n\n可靠传输\n流传输\n滑动窗口(窗口进行通信，一次数据传输是有上限发的，缓存问题，拥塞问题)\n避免拥塞\n\n\n连接控制\n建立连接:三次握手\n断开连接:四次握手\n\n\n\n\nTCP数据段的格式\n\n\n固定首部长度位20字节\n\n源端口和目的端口（各16位）\n\n端口是运输层与应用层的服务接口\n运输层的复用和分用功能都要通过端口才能实现\n\n\n序号（32位）(4G &#x3D; 2^32^ bit的地址空间)：\n\nTCP 传送的数据流中的每一个字节都编上一个序号\n序号字段的值指本报文段所发送的数据的第一个字节的序号\n通过序号字段做可靠传输的保证，指示的是一个TCP传输的bit编码，而不是地址。\n我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。\n\n\n确认号（32位）：是期望收到对方的下一个报文段的数据的第一个字节的序号\n\n确认对方的数据号(发送同时对上一次传输进行确认)\n体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701\n\n\n数据偏移（4位）\n\n指出 TCP 报文段的数据起始处距 TCP 报文段的起始处的长度(Data部分从什么地方开始算)\n单位是 32 位字(以 4 字节为计算单位)\n不满足的话使用填充位保证为4字节的整数倍(保证对齐问题)\n\n\n保留字段（6位）\n\n标记位（共6位）\n\nURG（紧急位）：为1时表示紧急，优先传送\nACK（有效位）：为1时表示确认号有效\nPSH（推送位）：\n接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将缓存所有部分都传输，而并不是只将这个报文段的信息进行传输。\nTCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送\n\n\nRST（复位位）：ReSeT &#x3D; 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接\nSYN（同步位）：同步 SYN &#x3D; 1:表示这是一个连接请求或连接接受报文(初始的时候才出现)\nFIN（终止位）：用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了)\n\n\n窗口（16位）：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。表示可以进行传输的窗口大小是多少。\n\n检验和（16位）\n\n紧急指针（16位）：指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)\n\n\n\n可变部分\n\n选项\nTCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)\nMSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节\n数据字段加上 TCP 首部才等于整个的 TCP 报文段\n\n\n填充字段：这是为了使整个首部长度是 4 字节的整数倍。\n\n\n\n\nTCP协议\n\n概述\n\n主机使用网段(TPDU)交换数据\n每个段都有：\n标头为20个字节(可选部分除外)\n0或更多数据字节(请求连接的时候)\n\n\n段的大小必须与IP数据包匹配，并且还必须满足底层的需求\n例如，以太网的MTU(最大传输单位)为1500字节\n是面向字节的传输。\n\n\n每个字节都有一个32位序号\n通讯中商定初识序号，确认到每一位\n面向字节:TCP传输的数据块和上层数据给的数据块的大小可以不对应(通过商量解决)\n根据网络条件，对每一个字节进行确认\n\n\n\n\n三次握手（可靠连接）：\n\n红蓝两军问题：无论通信多少次，都不能确定一个完全可信的时间。\n\n建立过程：\n\n第一次握手：\n\n服务器等待，客户端请求\n\n\n服务器：执行LISTEN和ACCEPT原语，并进行被动监视\n客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求\n\n\n第二次握手：服务器检查是否存在监视端口的服务进程\n\n如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段\n如果存在进程，则决定拒绝或接受请求\n如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段\n\n\n第三次握手：\n\n客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接\n为了避免出现延时之类的情况，执行第三次握手(如果只有两次会浪费服务器资源)\n\n\n通知上层应用，准备传输数据\n\n\n\n\n\n停止等待协议\n\n发送段后，暂时保留备份\n在发送后没有收到确认的时候，要保存备份来重传\n收到确认的时候，抛弃备份\n超时计时器:如果对方的应答超过一定时间后则直接进行重发(时间要比正常往返时间稍微长一点)\n\n\n每个网段和ACK必须具有ID\n重新发送时间必须大于平均传输时间 * 2\n停止等待协议是一个简单的协议，但是效率很低\n实施控制，来进行错误处理\n丢失确认，确认延迟：\n发过去没有应答或者丢失:进行重传\n应答超时，有收到请求立即重传\n晚到的应答直接丢弃(不做处理)\n\n\n\n\n可靠通信：\n\nARQ (Automatic Repeat reQuest) 自动重传请求：这表示”重新发送请求”为自动发送并且接收方无需请求发送方重新发送错误段\n\n\n连续ARQ协议\n多个数据同时发送过去(一次发送多个)\n窗口大小是双方协商的，通过TCP报文中的窗口字段表示\n例子： \n\n\n\n\n释放链接（四次握手）： \n\n为什么B最后要等待2倍最大等待时间（2MSL，Max Seg Livetime）？\n第三次挥手发过去再收到回复，两个过程的最长时间为2MSL\n如果2MSL之后还没有收到回复，B就重发\n目的是为了确保A发送的最后一个ACK可以到达B，确保AB断开连接，连接上的所有段均已消失\n\n\n\n\nTCP中的计时器\n\n重传计时器:多长时间进行重传\n坚持计时器:避免死锁(WIN &#x3D; 0的时候修改WIN但是没有办法发送过去)：收到WIN &#x3D; 0 的时候，开始进行计时，到时间主动询问\n保持计时器:\n发送数据段后，刷新\n如果到达一定的时间，则再次询问是不是还要保持连接。\n\n\n时间等待计时器\n\n\n\n\n\n用户数据报协议UDP\n概况：\n\n为什么我们需要UDP？\n没有建立连接(避免延时)\n简单：发送方，接收方无连接状态\n小段标题\n没有拥塞控制：UDP可以按照期望的速度传输\n\n\n无连接：没有复杂控制，头部简单\nUDP发送方，接收方之间没有握手(HandShake，包含进程等信息的)\n每个UDP段都独立处理\n\n\n常用于流媒体(Stream)多媒体(multimedia)应用\n容忍损失:无非就是降低帧率\n这类应用是速率敏感的应用，而不一定是质量敏感的应用。\n\n\nUDP用于：\nRIP:定期发送路由信息(periodically)\nDNS:避免延迟建立TCP连接(DNS需要快速找到)\nSNMP：拥塞时(congestion)，SNMP必须仍然可运行。在没有拥塞和可靠性控制机制的情况下，UDP在这种情况下的性能要优于TCP。(主播和多播，大量信息传输)\n其他协议包括TFTP，DHCP\n\n\n必要时增加应用层的可靠性\n流媒体就算有数据丢失也问题不大(对屏幕进行模糊化处理就行),但是发送速率是很重要的！(就算丢包了，也可以模糊处理)\n\n\nUDP数据帧格式\n\n\nUDP的数据段很简单\nUDP只有8个字节的首部\n源端口、目的端口、长度、校验(data)、Data\n校验也要对data一并校验，如果出现错误，直接丢弃。\n应用层进行数据切片，决定如何进行发送，UDP直接发送\n\n\n\n\nTCP和UDP的不同点\nTCP：\n不是立即交给上层校验，而是需要先和对方沟通\n缓存满了才统一交付。\n\n\nUDP：\n直接转发报文，保留报文边界（不做合并）\nIP进行划分\n应用程序会发送比较合适的UDP报文大小进行发送\n\n\n\n\n相同点：校验是相同的。\n\nNAT (Network Address Translation)\nNAT，是在IP数据包头中将一个地址交换为另一个地址的过程\n\n网络地址转换(映射)\n是网络地址即将用完的解决方案\n\n\n实际上，NAT用于允许私下寻址的主机访问Internet。\n\nIP地址耗尽的解决方案之一\n\n保留注册(合法)地址\n连接到Internet时增加灵活性\n\n\n作用：\n\nNAT需要一个路由器来实现\n左侧是一个局域网\n在NAT 路由器将局部地址 转换成 网络上的地址(双向转换，有一个NAT表)\n\n\n类型：\n\n静态NAT：构建一张静态NAT表。这样是不能新增地址的。\n动态NAT：指定一个地址池，在池内的地址可以上网。上网时建立临时记录。先来先服务，满了只能等。\nPAT：第一个是IP。可以有不同的端口。同样的出口IP\n\n\nNAT地址类型：\n\n内部本地地址(Inside Local address)：内网IP\n内部全局地址(Inside Global address)：注册IP，是对外展示的IP地址\n外部全局地址(Outside Global adress)：由主机所有者分配的IP地址。通常是注册地址\n\n\nPAT\n\n\n本地内部地址的各个主机IP不同，端口号可以相同或不同。\n转换成内部全局地址，IP都一样了，端口号不同\n\n\n\n第五章 · 会话层，展示层，应用层第五层：会话层职责\n基于令牌进行交互发言，通过数据同步保证数据完整性(应用逻辑)\n进行数据分段、拼接，保证传输的有效。\n同步技术，保证故障恢复。\n\n服务\n双向同步通讯？\n全双工通信\n半双工通信\n单工通信\n\n\n双向交替控制？\n会话连接、活动开始、数据校验(同步)\n令牌转换等\n\n\n是否同步了您的会话的主题？\n**同步点(CheckPoint)**用于分隔会话的各个部分，以前称为对话(dialogues)\n同步点:发送一定数据后设置同步点\n次同步点:作为同步点的一个子集，进行数据校验\n主同步点:按照主同步点进行校验确认\n如果错误，恢复到上次都已经同步的主同步点\n\n\n对话分离(Seperation)是通信的有序启动，终止和管理\n尽量保证了通话的效率和可靠性。\n\n\n\n第六层：表示层概述\n表示层负责以接收\n设备可以理解\n的形式表示数据。\n\n传送语法协商\n接受语法协商\n\n\n表示层具有3个主要功能：\n\n数据格式(format)\n数据压缩(compression):早期网络比较慢，倾向于先压缩在发送\n数据加密(encryption)\n\n\n协商编码方式可以在会话层中实现\n\n数据编码格式\n\n图形文件格式\n\n多媒体文件格式\n\n数据加密和压缩\n\n\n第七层：应用层概述\n上图中各层的一些协议和使用：对端口进行管理\n应用程序层(最接近用户)支持应用程序的通信组件\n\n职责\n定并确定预期的通信合作伙伴的可用性\n同步合作的应用程序\n同步协作的应用\n建立有关错误恢复程序的协议\n控制数据完整性\n通过网络应用(network applications)为OSI模型的其余部分提供一个直接接口，或是通过独立应用提供非直接接口，如文字处理，电子表格，演示管理器(presentation managers)，网络重定向器\n不同应用不同情况\n\n超文本传输协议 (HTTP，HyperText Transfer Protocol)\n概述\n\n和电视的播放比较类似，通过浏览器界面切换内容，通过URL切换\n多源点传输，内容规范\n如何实现URL的转发:HTTP\n如何完成界面:html\n如何整合和查询:搜索引擎\n\n\n统一资源定位符 URL(Uniform Resource Locator)\n\n&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\n\n\n访问方式:协议HTTPS 或者 HTTP\n主机:域名的方式\n端口对应进程\n路径对应具体的文件\n\n\n\n\nHTTP\n\nHTTP 是面向事务的客户服务器协议。\nHTTP 1.0 协议是无状态的(stateless)。\n每一次请求是独立的，不记录上一次请求信息。\nCookie是征求同意的存储(维持登录状态)，可以保证在多个应用之间维持登录状态。\n\n\nHTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。\n万维网浏览器就是一个 HTTP 客户，而在万维网服务器等待 HTTP 请求的进程常称为HTTP daemon， 有的文献将它缩写为 HTTPD。\nHTTP daemon 在收到 HTTP 客户的请求后，把所需的文件返回给 HTTP 客户。\n\n\n报文结构\n\n\n报文由三个部分组成，即开始行、首部行和实体主体。\n在请求报文中，开始行就是请求行。\n请求报文和应答报文的应答结构都是一样的\n应答码：\n2xx:成功\n3xx:重定向\n4xx:错误\n5xx:服务器内部错误\n\n\n\n\n\nFTP（File Transfer Protocol） 和 TFTP（Trivial File Transfer Protocol）\n概述\nFTP是一种可靠的，面向连接的服务，它使用TCP传输文件。\nFTP首先在客户端和服务器(端口21)之间建立控制连接\n然后，建立第二个连接，这是计算机之间通过其传输数据的链接。(端口20)\n有安全认证\n\n\nTFTP是使用UDP的无连接服务(简化的FTP)\n体积小，易于实施。更加方便\n例如： TFTP在路由器上用于传输配置文件和Cisco IOS映像\n不支持交互，没有目录浏览功能\n\n\n互联网早期的时候，文件传输量是很大的。\n\n\n主进程工作步骤\n打开熟知端口(端口号为 21)，使客户进程能够连接上。(可以修改熟知端口)\n等待客户进程发出连接请求。\n启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。\n控制连接\n数据连接:数据通信\n需要建立上面两个连接才能完成传输\n\n\n回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。\n\n\n\nTelnet协议远程登录：Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能。用服务器运行本地输入的指令。\nSMTP和POP3\n电子邮件服务器使用SMTP发送和POP接收邮件相互通信。\nSMTP (Simple Mail Transfer Protocol) 邮件发送，登录发送等操作\nPOP3 (Post Office Protocol version 3) 邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。\n\n\nMIME（Multipurpose Internet Mail Extensions）\nMIME标准扩充了SMTP标准\n很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如下图\n\n\n\n简单网络管理协议（SNMP，Simple Network Management Protocol）\n简单网络管理协议(SNMP)是一种应用程序层协议，可简化网络设备之间的管理信息交换。\nNMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)\n通过管理数据库(MIB)进行信息交流\n使用UDP通过广播进行实现。\n\n域名系统(DNS, Domain Name System)\n概述：域名系统(DNS)是网络上的服务，该服务管理域名并响应客户端将域名转换为关联IP地址的请求。早期是用IP地址以及Host文件来进行访问\n域名：\n概述：\n使用.将字符串进行分隔开，字符串不应该太长\n越靠后域名级别越高\nwww就是对应到主机群\n\n\n顶级域TLD（Top Level Domain）\n国家TLD(nTLD)\n.cn(CHINA) 中国\n\n\n通用TLD(gTLD)，最早的域包括：\n.com Enterprises and companies 企业和公司\n.edu Educational facilities 教育机构\n\n\nInfrastructure domain 基础设施领域\nOnly one: arpa, for resolving domain names reversely 仅一个：arpa，用于反向解析域名\n\n\nRecently, new TLD domain added\n\n\n域名服务器（Domain Name System）\n顶级域名底下的域名就是由顶级域名下面进行管理\n根域名服务器存储位置，所以子服务器知道根服务器的地址即可\n\n\n结合域名服务器查找IP地址\nDNS系统以层次(hierarchy)结构设置，该层次结构创建不同级别的DNS服务器。\n此级别的DNS服务器判断其自身是否能够将域名转换为关联的IP地址：\n如果可以，则将结果返回给客户端\n如果没有，它将请求发送到更高级别。(向上级请求)\n请求分为两种:\n能够应答\n不能够应答\n\n\n从主机的视角看，这是一个递归的过程：先问本地DNS，本地DNS若不知道再问其他的\n从本地DNS的视角看，这是一个迭代的过程：先访问根DNS，得到顶级域的位置，再去问顶级域，得到二级域的位置，等等。\n\n\n\n\n\n\n\n\n\n沟通的方式\n无上下文，请求后就断开：\n当浏览器打开时，它将连接到默认页面，并且该页面的文件将传输到客户端。\n处理完成后，连接断开\n\n\n有上下文：\n作为Telnet和FTP，建立与服务器的连接并保持该连接，直到执行所有处理。\n当用户确定他&#x2F;她已完成时，客户端将终止连接。\n\n\n所有的交流活动都属于这两类之一\n\n动态主机配置协议（DHCP，Dynamic Host Configuration Protocol）\n概述：\n\n一个协议软件在使用之前先作正确协议配置，具体配置内容取决于协议。\n接到因特网的计算机的协议软件需要配置的项目包括：\nIP 地址\n子网掩码\n默认路由器的 IP 地址\n域名服务器的 IP 地址\n\n\nDynamic Host Configuration Protocol可以高效地分配IP地址\n局域网的网络协议\n使用UDP来实现\n\n\n目前一般都是自动获取IP地址，而不需要手动去获取IP地址等信息\n\n\nDHCP工作过程\n\n\n发现阶段\n\n广播携带地址是MAC地址\n\n\n响应阶段\n\n选择阶段\n\n租约确认阶段\n\n租期续约：在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP 参数更新自己的配置，IP租用更新完成\n\n租期释放：\n\n当DHCP Client不再需要使用分配IP地址时，就会主动向 DHCP Server发送Release报文，告知不再需要分配IP地址，DHCP Server会释放被绑定的租约\n\n到时间后，Server会主动询问，如果没有应答会自动释放\n\n\n\n\n\nDHCP报文结构\n\n报文类型\n\nDHCP Discover：发现\nDHCP Offer：提供\nDHCP Request：告知决定\nDHCP ACK：租约确认\nDHCP NAK：租约不确认\nDHCP Release：释放租约\nDHCP Decline:收到Ack后，Client告诉服务器不接受\nDHCP Inform:客户端向服务器端请求详细信息\n\n\nDHCP欺骗与防范\n\n欺骗\n客户端以广播的方式来寻找服务器，并且只接收第一个到达的服务器提供的网络配置参数。\n非授权的DHCP服务器先应答，客户端最后获得的网络参数即是非授权的，客户端即被欺骗。(恶意服务器把自己作为默认网关)\n在实际应用DHCP的网络中，基本上都会采用DHCP中继，因此本网络的非授权DHCP服务器一般都会先于其余网络的授权DHCP服务器的应答(由于网络传输的延迟)，在这样的应用中，DHCP欺骗更容易完成。\n\n\n防范\n在交换机上启用DHCP Snooping功能 DHCP Snooping技术通过建立和维护DHCP Snooping绑定表过滤不可信任的DHCP信息:比如B的DHCP不能通过认证，交换机拒绝进行转发\n在交换机的全局配置模式中启用DHCP Snooping:switch (config)# ip dncp snooping\n在交换机的全局配置模式中开启需要启用DHCP Snooping 的VLAN”:switch (config)# ip dhcp snooping vlan vlan号\n在端口配置子模式中将授权DHCP服务器所连的端口设为信任端口(缺省都是非信任的端口):就是连接到DHCP Server的端口:switch (config-if)# ip dhcp snooping trust\n\n\n\n\n\n\n\n第六章 · 路由器和网络路由器基础\n内部组件\n\n特殊组件的计算机\nconsole口进行具体的调试\n辅助口(Auxiliary):一般不用，但是可能会用到\n\n\nRAM（随机存取存储器）\n路由器配置文件的临时存储，一般做为内存使用\n断电或重新启动时RAM内容丢失\n存储:\n路由表\nARP缓存\n快速切换缓存\n报文缓存:可能前面有正在处理的，需要等待\n数据包保留队列\n\n\n根据地址位就可以读到地址内容(访问比较快)\n\n\n非易失随机存取存储器(NVRAM, Non-volatile RAM)\n存储备份(backup)&#x2F;启动(startup)配置文件\n路由器掉电或重启时内容不会丢失。\n内置电池的方式来保证不断电，这一部分可以整体单独拿出来\n保证快速访问，但是存储空间有限。\n\n\nFlash (相当于台式机硬盘)\n电子可擦可编程只读存储器(EEPROM, Electronically Erasable Programmable Read-Only Memory)\n存储了Cisco IOS(互联网操作系统)\n允许更新软件而无需更换闪存芯片\n可以存储多个版本的IOS\n断电保持\n\n\n只读存储器(ROM, Read-Only Memory)\n包含POST(开机自检):PC也有，开机的时候，读取一些参数进行对比，如果一样则保证硬件是正常的。\n引导程序(加载Cisco IOS)\n作系统软件\nIOS的备份，精简(trimmed down)版本\n升级需要安装新的芯片组\n\n\n\n\n\n\n接口\n\n数据包通过其进入和离开路由器的网络连接口\n附在主板(motherboard)上或作为单独的模块。\n大部分是网口，主要是用来支持网络的\n0&#x2F;0第一个，串口接口可能还分多个\n\n\n\n路由器启动(startup)步骤\n系统启动程序\n执行开机自检(POST)：在此自检期间，路由器从所有硬件模块上的ROM执行诊断：如果有问题导致操作系统无法重启，那么我们就需要对硬件进行检查\n验证CPU，内存和网络接口端口的基本操作。\n软件初始化。\n\n\n软件启动程序\n步骤1:ROM中的通用引导加载程序(bootstrap)在CPU卡上执行。\n步骤2:可以在以下几个位置之一找到操作系统(Cisco IOS)。该位置在配置寄存器的引导字段中公开。\n步骤3:加载操作系统映像。\n先从Flash找，也就只有一个image文件，将image导入内存\n如果image找不到，则到TFTP Server，如果能找到则下载下拉一个image\n如果TFTP也没有配置，则去ROM中导出IOS\n\n\n步骤4:将保存在NVRAM中的配置文件加载到主存储器中，并一次执行一行。\n先看NVRAM中有没有配置(start.config)\n然后看TFTP Server有没有配置，如果有则下载一个\n如果都没有，用console进行配置\n\n\n步骤5-如果NVRAM中没有有效的配置文件，则执行问题驱动(question-driven)的初始配置例程，该例程称为系统配置对话框，也称为设置模式。\n\n\n查看和修改基本的路由器配置\n\n路由和配置\n使用网络寻址进行路由\n\n路由器通常使用两个基本功能(路径确定功能和交换功能)将数据包从一条数据链路中继(relay)到另一条数据链路。\n交换功能允许路由器在一个接口上接受数据包并通过第二个接口转发。\n路径确定功能使路由器能够选择最合适的接口来转发数据包。\n\n\n路由器使用地址的网络部分进行路径选择，以将数据包传递到下一个路由器\n地址的节点部分由直接连接到目标网络的路由器使用，以将数据包传递到正确的主机。\n\n\n静态路由\n\n尽管(whereas)动态路由倾向于显示(reveal)有关互联网络的所有已知信息，但是出于安全原因，您可能希望隐藏互联网络的某些部分。\n当只有一条路径可访问网络时，到网络的静态路由就足够了。(默认路由，将B所有不知道位置的全部交给A，由A去进行访问)\n这种只有一个出口的网络分区称为末节网络(Stub Network)\n\n\n管理距离\n\n**管理距离(administrative distance)**是路由信息源的可信赖性的等级，表示为从0到255的数值。(管理距离)\n数字越大，可信度(trustworthiness)越低。\n因此静态路由的管理距离通常很短(默认值为1)\n管理距离是0的路由是直连网段，是最可信的，比静态路由还高\n\n\n动态路由\n\n动态路由协议还可以重定向网络中不同路径之间的流量(或负载分担(loadshare))\n往往网络是冗余的，保证连通性\n静态路由的问题:如果指定的路径中出现故障就会出问题，而动态路由就避免了这个问题。\n\n\n收敛时间\n\n收敛时间:\n从刚启动到网络达到稳定的时间\n从发生变化到再次稳定的时间\n\n\n收敛时间越短，路由协议越强，需要路由器的基本硬件支持。\n\n\n动态路由协议\n\n分类\n距离矢量(DV,Distance Vector)\n链路状态(LS,Link State)\n混合路由(HR,Hybird Routing)\n\n\n距离矢量协议（DVP）\n协议内容\n距离矢量算法不允许路由器知道互联网络的确切拓扑\n基于距离矢量的路由算法(也称为Bellman-Ford算法)在路由器之间传递路由表的周期性副本。\n大家交换Routing Table\n只知道可达，但是不知道怎么可达(知道where,但是不知道how)，不知道整个网路的具体拓扑\n\n\n\n\n路由回路问题：\n是DV的缺陷\n例子：\n稳定之后,如果NetWork1不可到达\nB发现不可达，但是告知C的时候比较晚，C已经将信息告诉了D，D就以为可以通过C到达，这样子就可能循环下去，然后不收敛。\n\n\n解决方案\n定义最大值(Maximum）：设置最大跳数，比如最多转发15跳，16跳以上为不可达\n路由中毒(Route Poisoning)\n当网络5发生故障时，路由器E通过将网络5的表条目设置为16或不可访问来启动路由中毒。(而不是删除条目)\n、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。\n最终所有的路由器都知道不可达\n路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了\n\n\n水平分割(Split Horizon)\n从某个端口收到的报文信息，不能再从端口发送回去\n比如A发送给B和D，之后B和D又把之后的报文还给A，这时候就不接受B和D的。也即使A只接受B的\n如果B和D接收到一个到达目的网段1的更好的路径，A是会接收的\n有名词解释题目\n\n\n计时器(Hold-Down Timers)\n我收到网络信息不可以到达的信息的时候，启动计时器，开始计时(这个信息包含请计时信息)\n如果有任何一个计时的设备收到了一个比原来更好的达到路径，则会修改对应记录，但是如果更差不会记录。\n计时器结束后，删除掉对应的条目，避免出现问题\n每一条路由表的记录都有有效时间\n\n\n\n\n阻止发送路由更新\n接受路由表的更新，但是不发送报文出去\n\n\n\n\n\n\n链路状态协议(LSP, Link-state Protocol)\n内容\n基于链接状态的路由算法也称为SPF(最短路径优先)算法，维护复杂的拓扑信息数据库:对树处理路由表，没有环路问题\n链接状态路由使用：\n链接状态广告(LSAs):告诉你我有这个链路(每一个网段都是相同性质链路，链路上有唯一的NetID、带宽、连接拓扑关系、网段、链路类型等属性，我们优化属性后，进行LSA，告知对方主Key，如果再需要的话，再给具体信息)\n拓扑数据库(有LSA组成，每个结点都持有)\n根据SPF(shortest path first)算法生成的SPF树(Tree会不一样，因为每一个路由都是以自己为根的)\n每个网络的路径和端口的路由表\n\n\nRFC 1583包含对OSPF链路状态概念和操作的描述。\n\n\n问题：\n处理和存储要求\n在大多数情况下，运行链路状态路由协议要求路由器比距离矢量路由协议使用更多的内存并执行更多的处理：需要CPU进行计算\n\n\n带宽要求\n在初始链路状态数据包泛洪(flooding)期间，所有使用链路状态路由协议的路由器会将LSA数据包发送到所有其他路由器。 随着路由器对带宽的需求增加，此操作将淹没互联网，并暂时减少可用于承载用户数据的路由流量的带宽。\n一开始的时候报文会比较频繁多(所以告知LSA而不是LS，减小压力)\n注：初期消耗大，之后消耗小，稳定之后是根据事务触发更新\n\n\n\n\n\n\n比较DV和LS：\nDV:距离矢量\n视野窄，代价小\n基于跳数\n定期交换路由表，收敛慢\n交换路由表\n\n\nLS:链路状态\n视野宽，有一定代价\n基于带宽\n初期充分交换，收敛快\n交换Linked State的数据库\n\n\n\n\n混合协议(Hybrid Protocols)\n\n\n主动路由协议\n\nIP主动路由协议的示例包括：\n\n\n\n\n英文缩写\n英文解释\n中文解释\n备注\n\n\n\nRIP\na distance-vector routing protocol\n距离矢量协议\nDV\n\n\nIGRP\nCisco’s distance-vector routing protocol IGRP\n思科的距离矢量路由协议\nDV，基本启用\n\n\nOSPF\nOpen Shortest Path First\n开放式最短路径优先\nLSP\n\n\nEIGRP\n-\n平衡的混合路由协议\n杂合\n\n\n\n工作在第三层\n\n\n\n主动路由协议RIPOSPF\n其他内容详见实验笔记\n\nOSPF具有七个状态。简而言之，它们是：\n\nInit, 2Way, Ex Start, Exchange, Loading, Full\n初始化，双向操作，预先启动，交换，加载，完成\n\n\n环回接口：是一个虚拟接口。可以看做是路由器背后的一台PC，可以通过任意端口访问到。\n\nDR，BDR\n\nDR是DR的备份，其他路由器之间就不用通信了\n如果有DR则需要至少4条连接，DR和BDR之间必然有连接\n\n\n\n只有多路复用的实现方式需要DR和BDR\n\n\n然后，每个路由器与DR和BDR形成邻接关系\n对于所有OSPF路由器，DR使用224.0.0.5(自己的IP)的主播地址向该网段上的所有其他路由器发送链接状态信息。\n为确保DR&#x2F;BDR看到所有路由器在网段上发送的链接状态，使用了所有DR&#x2F;BDR的多播地址224.0.0.6。(DR和BDR之间)\n选举\n优先级+路由器ID，最大的是DR，第二大的是BDR。\n优先级：1-255，默认值:1\n路由器ID\n环回IP地址(逻辑端口)，避免端口宕机出现问题。(3中描述的问题)，需要手动配置\n如果没有环回IP地址，则物理接口IP为最高值地址(Active的端口上的IP作为参考)\n如果接口出现故障，则路由器必须重新建立邻接关系并重新转换(readvertising)LSA\n\n\n\n\n\n\n报文\n\nOSPF只有5个类型的报文\n\n\n\nDBD:LSA,发现没有发送LSR\n由于传输要求比较高，所以设计了LSAck\n\n\nOSPF Hello协议\n\n路由器在接口上启动OSPF路由过程时，将发送hello数据包，并继续以固定的时间间隔(intervals)发送hello。\n控制(govern)OSPF hello数据包交换的规则称为Hello协议。\nHello数据包的地址为224.0.0.5。\n默认情况下，广播多路访问和点对点网络上每10秒发送一次Hello报文。\n在连接到NBMA网络的接口(例如帧中继)上，默认时间是30秒。\n保持心跳，确定还活着。Hello几乎是空报文，给所有跑OSPF的路由器发送\nHello报文的Type字段设置为1\n\n\nOSPF操作的完整步骤\n\n\n\n一开始的状态是Down State\n然后发送Hello报文(Init State)\nB收到A的报文(收到报文一定是邻居):Hello报文的TTL是1，所以不会跨路由器传播，收到即丢弃。\n收到后，B也会发送自己的Hello，然后A收到后进入Two Way状态\n\n\n\n准备交换数据库(Exstart Starts)\n首先确认主方(发送方)、从方(接受方)，保证数据有序，简单就是谁的Router ID高\nRouter ID高的(主方)发送自己DBD报文，从方对主方发送的DBD接受处理并发送\n\n\n\n交换完成后，各自检查自己是不是有全部的信息\n如果有完整的信息，则发送LSAck\n如果发现有没有的，则发送LSR，等待LSU(整个链路的详细信息，不是LSA)来进行学习，之后收到完成后发送LSAck\n\n\n\n\n\n\n工作步骤\n\n步骤1：建立路由器邻接\n路由器每隔一段时间发送一次hello数据包,Hello报文的TTL是1，表明不会跨路由传播。\n如果邻居被发现了：将邻居添加到邻居数据库\n发现网络类型\n如果是多路复用网络，进入DR&#x2F;BDR选举过程，然后进入步骤2。\n如果是点对点或点对多点网络，则不会举行DR&#x2F;BDR选举过程，并跳过步骤2。\n如果hello数据包标头中的DR&#x2F;BDR字段已被占用(即DR &#x2F; BDR对已经存在)，则不会进行DR&#x2F;BDR选举，并跳过步骤2。\n\n\n如果对方的DP&#x2F;BDP优于我的DP&#x2F;BDP，则接受对方的。\n\n\n\nHello Interval:如果不同不能建立关系,Hello报文包含了DR信息在内的必要的参数\n\n2.13.2. 步骤2：选举DR和BDR\n如果没有其他路由器联机，则该路由器将成为DR。下一个要”启动”的路由器将是BDR。\n如果多个路由器(两个或更多)同时联机，则\n优先级最高的路由器成为DR：优先级为零表示”从不DR”\n如果存在平局，则具有最高路由器ID的路由器将成为DR：路由器ID是最高的环回或接口IP地址\n具有第二高优先级或路由器ID的路由器成为BDR\n\n\n如果DR无效，则BDR变为DR。\n然而\n如果新的OSPF路由器以更高的优先级或路由器ID加入网络，则当前的DR和BDR不会更改。\n仅当当前DR失败时，它才成为新的BDR；或者仅当当前DR和BDR失败时，才成为新的DR。\n\n\n\n2.13.3. 步骤3：发现路线\n这一步从Ex Start状态转换到完整状态\n路由器确定”主&#x2F;从(master&#x2F;slave)”关系\n多路复用网络中的DR&#x2F;BDR交换LSA，并且所有其他DR将其Type 2 DBD发送给DR&#x2F;BDR。\n如有必要，路由器可以通过发送请求更多信息的LSR进入负载状态:所有路由器必须在”加载状态”中等待，直到完全更新请求的路由器。\n路由器现在进入完整状态\n\n2.13.4. 步骤4：选择适当的路线\n现在，将与网络上的所有其他路由器并行地计算SPF算法。\n切记：在发生这种情况之前，所有路由器必须具有相同的链接状态数据库。\nSPF使用Cost作为指标\nSPF将从其自身到目的地的每条路径的成本相加，并以路由器为根来构建树\nOSPF然后在路由表中安装成本最低的路径：最多将安装4条等价路径以进行负载共享\n\n\n\n2.13.5. 步骤5:维护路由信息\n常规的Hello交换是OSPF用于检测新邻居或故障(downed)邻居的机制。\n根据网络的类型，Hello数据包以不同的默认间隔发送。(确定对方是不是还好)\n对于速度为T1(1.544 Mbps)或更高的链接，每10秒：广播多路访问和点对点链接\n对于小于T1的链接，每30秒：非广播多路访问链接\n“死间隔”是问候间隔的四倍。(如果在这样子对方还没有成功则对方死了)\n\n\n\n2.13.6. 链路状态变化出现\n\nRouter A tells all OSPF DRs on 224.0.0.6\nEvent触发交换:比如A连接的网段断掉了\nA使用LSU告知DR\n\n\n\nDR tells others on 224.0.0.5\nDR 通过LSU告知所有的路由器\n\n\n\n如果B连接了别的Area，则继续进行交换\n\n\n\n所有的路由信息交换完毕后，同时更新路由表。\n\n\n\n\n配置OSPF\n\n在路由器上启动OSPF\nRouter (config)# router ospf process-id\n进程号:process-id\n取值: 1 ~ 65535\n在一台路由器上识别多个OSPF进程\n通常在整个AS(自治系统)中保持相同的进程ID\n\n\n\n\n在路由器上识别IP网络\nRouter (config-router) # network address wildcardmask area area-id\n网络地址可以是整个网络，子网或接口的地址。\naddress:IP地址\n\n\n\n\n\n只有一个Area，则为0\nWild-card Mask和子网掩码相反:子网掩码是255.255.255.0，则Wild-card Address就是0.0.0.255\n写IP和写网段最后都是一样的\n\n\n\n第七章 · 局域网交换与VLAN交换机\n基本功能：\n根据MAC地址建立和维护交换表(类似于网桥表)\n将帧切换出接口到目标\n\n\n对称交换\n对称交换可在具有相同带宽(10&#x2F;10 Mbps或100&#x2F;100 Mbps)的端口之间提供交换连接\n多个用户尝试某个服务器时，可能会导致瓶颈(对称交换可能会导致带宽不足)。因为多个客户端向服务器访问的话，服务器端口流量会比较阻塞(在对称切换中，双端的带宽是完全对称的)，这是一个瓶颈。\n\n\n非对称交换\n通过将带有服务器的网段连接到更高带宽的端口(100 Mbps)，非对称交换(asymmetric switching)减少了服务器上潜在瓶颈的可能性\n非对称交换需要在交换器中进行内存缓冲\n非对称交换端口解决对称交换端口中的对称阻塞问题(进一步保证了服务器的稳定实现)\n\n\n内存缓冲：\n交换机中存储目标和传输数据的内存区域，直到可以将其切换出正确的端口为止。\n基于端口(Port)的内存缓冲\n数据包存储在每个端口的队列中\n由于目标端口繁忙，一个数据包可能会延迟其他数据包的传输\n其他端口存在不均衡的问题。\n\n\n共享(Shared)内存缓冲\n所有端口共享的公用内存缓冲\n允许将数据包在一个端口上接收并在另一个端口上发送出去，而无需将其更改为其他队列。\n需要自己记录端口的信息\n\n\n\n\n发生阻塞的时候，根据情况按照端口或者内存将包缓存下来\n\n\n交换方式\n储存转发（Store-and-Forward）\n交换机接收整个帧，最后将其计算为CRC，然后再将其发送到目的地\n接收后，校验，正确再发送\n效率比较低\n\n\nCut-through 直通\n转发会增加延迟:通过使用直通切换方法可以减少它\n快速转发切换:仅在立即转发帧之前检查目标MAC(只看到帧的目的地址就转发，而不看帧的后面的部分)\n\n\nSegment-free Switching 无碎片转发\n碎片释放:在转发帧之前读取前64个字节以减少错误:避免碰撞和帧碎\n若前64个字节是正常的，说明没有碰撞问题\n\n\n三个方法查看到的位置如下\n\n\n多层交换机\n二层交换机\n大规模集成电路,保证链路效率,低时延,低成本\n有一个MAC地址\n\n\n三层交换机\n基于硬件的帧转发机制，较高的帧转发性能，低时延\n较高速的计算\n每一个端口的代价低\n流控制\n安全性更高\n对数据流进行路由，生成MAC和IP的映射\nMAC地址过来的时候直接根据表从二层进行通过\n与路由器不同的是，路由表是通过软件的方式生成路由表，而第三层交换机通过硬件生成MAC和IP的映射表。而且，而且MAC地址在通过时，走第二层而不是路由。\n\n\n第四层交换机\n数据段在数据报里面，数据报在数据帧里面\n只要交换机可以看到数据帧的数据部分的首部\n可以根据端口主机的应用特点进行一定的流量控制\n和Net OS是不一样的,没有那么智能\n识别到前80个字节的数据报长度，对指定应用进行管理\n\n\n总结\n一般我们只是用二层交换机\n交换机可以简单识别第三层和第四层信息\n\n\n\n\n\n生成树协议（STP）\n概述\n\n桥回路\n出于各种原因，网络中可能会出现环路。\n通常，网络中的环路是故意(deliberate)提供冗余的结果。\n也可能由于配置错误而发生:在桥接网络中，环路可能是绝对灾难性的两个主要原因：\n广播回路(广播风暴)，没有TTL\n路由表的错误\n\n\n\n\n往往是第二层交换机的冗余导致的桥回路。\n接入层到核心层的接入往往要有冗余，这个区域是主干网(backbone)\n设备通过backbone和远端设备进行链接\n\n\n第二层路由回路\n广播和第2层循环可能是危险的组合。\n以太网帧没有TTL字段\n以太网帧开始循环后，它可能会继续下去，直到有人关闭其中一台交换机或断开链路为止(外部条件)\n交换机将抖动(flip flop)主机A的桥接表条目(创建极高的CPU利用率)。\n消耗CPU和内存\n例子：泛洪单播帧\n过一段时间CAT-1和CAT-2没有收到Host-B的信息，删除表中的对应记录\n在这之后，Host A发送给Host B信息，然后在CAT-1和CAT-2之间进行循环\n\n\n\n\n综述\n桥协议数据单元-BPDU\n生成树协议的元素\n主要功能：在交换&#x2F;桥接网络中允许冗余路径，而不会因环路的影响而引起延迟。\nSTP通过计算稳定的生成树网络拓扑来防止环路\n生成树帧(称为桥协议数据单元-BPDU)用于确定生成树拓扑\n\n\n在正常情况下禁用一些端口来防止出现冗余综述\n\n\n\n\nSTP决策顺序\n\n生成树始终使用相同的四步决策序列：\n\n选举根交换机：在拓扑里面最低的root BID(网桥标识)作为根交换机\n找到 Root bridgh的最低路径成本\n每个路径都会选择一个最低BID的sender 这个是针对一个链路的，详见例子\n选举根端口：对于每个非根交换机，每个路径再指定一个最低的ID端口\n\n\n如果觉得上边的工作步骤不好理解，可以看下面的三个步骤：\n\n选举根交换机\n选举根端口，就是到根交换机代价最小的端口\n选举指定端口并且阻塞备用端口：\n根端口的对端一定是另一个交换机的指定端口\n根交换机的端口都是指定端口\n每个网段一定有一个指定端口，计算从哪边发BPDU到根交换机的路径成本最小\n若都相同，则找ID小的\n剩下的都是备用端口，要阻塞\n\n\n\n\nBPDUs(Bridge Protocol Data Unit)\n\n注意，与OSPF不同的是，STP不是以自己为根，而是以选举出来的BID为根\n\n\nBPDU是交换机之间的流量；它们不承载最终用户(end-user)流量。\nSTP建立一个称为根网桥的根节点，生成的树源自根桥。\n不属于最短路径树的冗余连接将被阻止。(block 端口，不转发，但是接收)\n在阻塞的链接上收到的数据帧将被丢弃。\n交换机发送的允许形成无环逻辑拓扑的消息是BPDU\n\n\n\n\n五个状态：\n\n通过根据策略配置每个端口来建立状态\n然后，STP根据流量模式(traffic Patterns)和潜在环路(Protential Loops)修改状态\nSTP状态的默认顺序为：\n阻塞:没有转发帧，听到了BPDU\n监听:不转发任何帧，监听数据帧(确定自己可以参加的交换)，也会发送一些数据帧表示自己状态变了\n学习:不转发帧，学习地址\n转发:转发帧，学习地址\n禁用:没有转发帧，没有听到BPDU\n\n\n\n\n\nSTP过程:Blocking -&gt; 20s Listening -&gt; 15s Learning -&gt; 15s Fowarding或者Disabled\n\n\n\n2s可以调整\n老化时间:保存的时间\n\n\n初始STP收敛\n\n步骤1：根交换机决定\n\n布自己为根\n检查端口上收到的所有BPDU以及将在该端口上发送的BPDU\n对于每个到达的BPDU，如果其值小于为端口保存的现有BPDU\n旧值被替换\nBPDU的发送者被接受为新的根\n\n\n\nBC收到后将根修改为A\n比如在BC链路中，B的MAC地址比较小，作为链路的Sender BID，这个port是指定端口\n\n\n\n\n\nVLAN\n骨干网\n\nVLAN配置需要支持互连的路由器和交换机之间的骨干数据传输。\n骨干网是用于VLAN间通信的区域\n骨干网应该是高速链路，通常为100Mbps或更高\nBackBone可以跑多个VLAN，是骨干网\n\n\n帧的使用：\n\n交换机根据帧中的数据做出过滤和转发决策。\n\n使用了两种技术\n\n帧过滤：检查有关每个帧的特定信息(MAC地址或第3层协议类型),特定的VLAN记录或者映射\n帧标记：在整个网络骨干网中转发时，在每个帧的标题中放置一个唯一的标识符\n\n\n帧过滤\n\n收到帧转发后，发现都不在一个LAN上，然后通过Backbone转发\nFrame Table在交换机上传输\n\n\n帧标记\n\n帧标记实施过程：\n在整个网络骨干网中转发时，在每个帧的标题中放置一个VLAN标识符。\n每个开关都可以理解和检查标识符。\n当帧离开网络骨干网时，交换机会在帧发送到目标终端站之前删除标识符。只和端口绑定，而不影响主机\n\n\n帧标记在第2层起作用，并且几乎不需要处理或管理开销。\n\n\n\n从主机到了交换机端口，交换机端口进行标记，然后进行转发。\n\n\n\n\nVLAN到实现\n\n概述：\n\n实现VLAN的两种方法\n静态的\n动态的\n\n\n每一个端口绑定给一个VLAN\n确保不共享同一VLAN的端口不共享广播。\n确保共享相同VLAN的端口将共享广播。\n\n\n实现途径:\n基于端口的虚拟局域网\n基于MAC地址的虚拟局域网\n基于IP地址的虚拟局域网\n基于上层协议的虚拟局域网\n\n\n\n\n静态VLAN\n\n定义：静态VLAN是指将交换机上的端口管理性地分配给VLAN的时间\n\n优点：\n\n安全，易于配置和监控\n在控制移动的网络中效果很好\n\n\n端口是写死在交换机的端口上的\n\n\n\n动态VLAN\n\n由服务器配置VLAN信息\n交换机通过MAC地址或者哪一个协议，指定是哪一个VLAN\n当工作站最初连接到未分配的端口时，交换机会检查表中的条目，并使用正确的VLAN动态配置端口\n优点\n添加或移动用户时减少管理(更多前期工作)\n集中通知未授权用户\n\n\n\n\n以端口为中心的VLAN\n\n\n实际的网络是有层次的\nstatic的物理的接入层(physical Layer)\n不同电脑在一个房间内\n不同房间的不同电脑组成一个VLAN\n路由器网关来处理\n优点：\n同一VLAN中的所有节点都连接到同一路由器接口\n使管理更容易，因为…\n通过路由器端口分配用户\nVLAN易于管理。\n提供更高的安全性\n数据包不会”泄漏”到其他域\n\n\n\n\n\n\n两种链路\n\n访问链接Access：\n\n访问连接是仅作为一个VLAN成员的交换机上的连接。\n此VLAN被称为端口的本机VLAN，连接到端口的任何设备都完全不知道VLAN存在\n\n\n主干链路：\n\n主干链路能够支持多个VLAN。\n主干链路通常用于将交换机连接到其他交换机或路由器。\n交换机在快速以太网和千兆位以太网端口上都支持骨干链路。\n也存在访问和骨干链接\n一般Trunk就是BackBone\n\n\n\n\n在局域网之间的路由\n\n每个端口连接一个VLAN，每个IP和一个VLAN连接，就需要很多线，浪费了\n我们可以使用串口线，物理上是一个接口，逻辑划分成多个IP和子接口，就相当于trunk线\n\n物理上一个，划分成Fa0&#x2F;1、Fa0&#x2F;2和Fa&#x2F;3\n涉及到的是单臂路由\n\n\n\n\n注意：\n\n同一VLAN中的两台主机可以跨越多台交换机\n必须是第三层及以上的交换机才能用来构建VLAN\n\n\n\n\n\n第八章 · 广域网WAN广域网技术和设备\n广域网服务\n\n定义:WAN是通过WAN服务提供商连接LAN的通信网络。\n一般不是一个单位来做，而是由运营商完成，而在运营商之间沟通好相互的接入问题。\nWAN在OSI的前三层运行，但主要集中在物理和数据链路层。\n广域网和局域网相比相对低效\n广域网位于物理层和数据链路层\n\n\n广域网的最小单位是公司\n\n物理结构\n\n\n\n涉及到具体一个公司的接入\n通过NetWork远程接入，通过WSP提供的CO Swtich来连接到中心局\nCPE:位于公司本地的设备(主要是接入设备)，可以向ISP购买或者租用，购买上网服务(猫)\nCPE和远端通过Local loop连接(最后一公里)，ISP做解决方案。\nDemarcation(分界点)：分界点一侧是ISP做解决方案，而另一侧是本地进行管理\n\n\n\n\n虚拟电路\n\n交换虚拟电路(SVC，Switched Virtual Circuits)是到目的地的WAN路径，可根据需要建立(established)和终止(terminated)。\n三个阶段\n电路建立–创建虚拟电路(逻辑确定)\n数据传输–发送和接收用户数据(含有虚电路号等)\n电路中断–拆除虚拟电路\n\n\n\n\n调制解调器\n\n通道服务单元 CSU,Channel Service Units&#x2F;数字服务单元 DSU,Digital Service Units\n与语音级(voice-grade)连接接口，以便将模拟信号转换为数字信号。\n\n\n\nCPE(左边的用户网关路由器，作为终端数据单元(DTE)):往往是路由器\nDCE:将信号转换成运营商可以接受的信号发送给远端。\n\n\n\n广域网和OSI模型\n广域网标准\n\nWAN标准主要描述OSI模型的哪些层？物理层和数据链路层，物理层提供电器标准，数据链路层封装到远程的部分:帧标准\n连接通信服务提供商提供的服务所需的电气、机械、操作和功能特性。\n描述DTE和DCE之间的接口\n\n\n物理层\n\n描述如何为WAN服务提供电气，机械，操作和功能连接的协议。\n这些服务通常是从WAN服务提供商，备用运营商，电话后和电报(PTT)机构获得的。\n描述数据终端设备(DTE, Data Terminal Equipment)和数据电路终端设备(DCE. Data Circuit-terminating Equipment)之间的接口。\n通常，DCE是服务提供商，而DTE是连接的设备。\n在此模型中，通过调制解调器或 CSU &#x2F; DSU 提供给DTE的服务。\n\n\n\n一般以用户路由器作为DTE，运营商提供的Modem做信号转换，作为DCE\n\n\n数据链路层的帧封装\n\nWAN数据链路层定义了如何封装数据以传输到远程站点\n点对点协议(PPP,Point-to-Point Protocol):由IETF开发。PPP包含用于识别网络层协议的协议字段(包含一个协议单元，指定网络协议)\n高级数据链路控制(HDLC, High-Level Data Link Control):ISO标准，不同供应商之间不兼容的HDLC，因为每个供应商都选择了实现方式。HDLC支持点对点&#x2F;多点配置(抽象规范和约束，各个厂商不同)\n帧中继(Frame Relay)：使用简化的封装，对高质量的数字设备不进行纠错。(比较高速)\nISDN：通过现有电话线传输语音和数据的一组数字服务。\n平衡的链路访问程序(LAPB, Link Access Procedure, Balanced)：用于在X.25堆栈的第2层封装数据包的数据包交换网络。 提供点对点的可靠性和流量控制。\n\n\n\n\n\n点对点协议(PPP,Point-to-Point Protocol) *** （本次考试重点）\n概述 ***\n\n点对点的标准\n以思科厂商为标准\n工作在串行链路上的\n如果都是同一个厂商的可以用HDLC，不然使用PPP\n\n\n串行线框字段\n\n两种最常见的点对点WAN封装是HDLC(High-level Data Protocol)和PPP(Point to Poing Protocol)\n所有串行线封装共享一个通用的帧格式，该格式具有以下字段\n\n\n\n封装协议的选择取决于WAN技术和通信设备\n\n\nPPP和HDLC\n\nPPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法。\n由IETF(The Internet Engineering Task)开发;取代SLIP(Serial Line Internet Protocol)\n包含标识网络层协议的字段\nPPP可以在建立连接期间检查链接质量\n通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证。\n\n\nHDLC是Cisco串行线的默认封装\n没有窗口或流量控制\n框架中插入了专有类型(所有权)代码，这意味着HDLC帧不能与其他供应商的设备互操作。\n当专用线路连接的两端是运行Cisco IOS的路由器时使用\n不做出窗口控制和流控制\n\n\n比较：\nHDLC是面向位的链路层协议，通常用于专有环境。\nHDLC不支持多协议封装，通常用于固定类型的网络。\nPPP相比HDLC更灵活，支持多种协议和认证功能，因此更适合异构网络。\n\n\n\n\n\nPPP点对点协议\n概述\n\n串行链路上使用最广泛的第2层协议\n从SLIP开发，\n仅支持IP协议\n不支持动态IP分配\n不支持身份验证\n不支持压缩\n不支持错误检测\n\n\nPPP提供以下功能\n网络协议多路复用\n动态分配IP地址\n验证：PAP，CHAP\n压缩\n错误检测\n\n\n\n\nPPP组件\n\n使用HDLC(ISO HDLC，而非Cisco HDLC)作为封装第3层数据报的基础\n实现LCP(链接控制协议)以：\n建立连接\n连接配置选项\n链接质量测试\n\n\n实施NCP(网络控制协议，Network Control Protocol)以选择和配置第3层协议。\n\n\nPPP帧格式\n\n数字的单位是字节\n\n\nFlag: 01111110，0x7E 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧\nAddress：11111111, 0xFF，广播地址\nControl：00000011, 0x03，用户数据作为无序帧传输\nProtocol: 数据字段中的协议类型\nData: 数据报，最大默认值为1500字节\nFCS: 2或者4字节，循环冗余校验位\n\n\nPPP会话建立&#x2F;终止\n\n为了通过点对点链路建立通信，PPP经历四个不同的阶段：\n步骤一: 链接建立和配置协商(negotiation)(链路控制协议，LCP)。\n步骤二: 链接质量测试。\n步骤三: 网络层协议配置(NCP)。\n步骤四: 链接终止。\n\n\n阶段一：连接建立\n建立链接是交换任何网络层数据报之前的第一阶段\n每个PPP设备发送LCP来打开连接\nLCP数据包包含一个配置选项字段，该字段允许设备协商选项的使用，例如压缩和身份验证协议等。\n如果LCP数据包中未包含配置选项，则采用该配置选项的默认值。\n当已发送和接收配置确认帧时，此阶段完成。\n\n\n在完成这个步骤前不会传输具体数据帧的。\n\n\n第二阶段：链路质量确定\n发送和接收LCP数据包以测量链路上的错误率(如果已配置)\n身份验证(如果使用)在网络层协议配置阶段开始之前进行。(可选)\nLCP可以延迟网络层协议信息的传输，直到完成此阶段。\n在这之前不能传输网络帧。\n\n\n第三阶段：网络层协议配置\n在此阶段，PPP设备发送NCP数据包以选择和配置一个或多个网络层协议(例如IP)。\n配置了每个选定的网络层协议后，可以通过链接发送来自每个网络层协议的数据报。\n\n\n第四阶段：链接终止\nLCP可以随时终止链接：\n应用户要求；(一方请求终止)\n链接质量\n超时\n\n\n当LCP关闭链接时，它将通知网络层协议，以便它们可以采取适当的措施。\n\n\n\n\n\nPAP安全认证协议\nPAP由一方向另一方发起请求，另一方选择是否接受，双方具有相同的用户名和密码,发起方可以多次尝试\n链接的发起方(Calling Side)输入身份验证信息，以帮助确保用户具有网络管理员的许可来进行连接。\n远程节点使用双向握手PAP建立其身份。\n远程节点重复发送用户名&#x2F;密码对，直到确认身份验证或连接终止\n密码以明文形式通过链接发送。\n在建立连接阶段之后，仅对远程节点进行一次身份验证。\n\nCHAP\n概述\n\n避免明文发送,三阶段握手,发起方是HQ，找一个时间来Challenge，然后由用户进行response，之后决定是否接受。密码密文发送比较安全，而且更加合理的设计。\n被叫方使用三向握手CHAP协议定期验证主叫方。\nCHAP不允许呼叫者在没有Challenge(随机数)的情况下尝试进行身份验证。(Challenge-&gt;随机数)\n主机(称为参与者)将质询消息发送到远程节点。\n远程节点以一个值(加密的值，包括：接收到的质询，其用户名和密码)进行响应:value是challenge和密钥生成的\n主机根据自己的价值检查响应\n如果值匹配，则确认身份验证\n否则，连接终止\n\n\n\n\n流程：\n\n挑战：\n\n\nRTB请求连接RTA\n他们都存储一个用户名密码，但是用户名不同，密码相同\nRTB发送一个连接请求\nRTA找一个时间来发起挑战\n挑战中内容:\n编号\nid是第几次挑战\nrandom:生成的随机数\nRTA:谁发起的挑战\n\n\n\n\n应答：\n\n\nRTB进行应答，\nRTB操作:pass + random 使用 MD5 算法 -&gt; 哈希值\n\n\n验证确认：\n\n\nRTA收到RTB的回复，然后比较是否相同\n\n\n\n\n\n\n\n综合数字服务网络(ISDN, Integrated Services Digital Networks)\n概述\n\n集成服务数字网络允许通过现有电话线传输数字信号:提供远程站点的连接\nISDN具有以下优点：\n可以携带语音，视频和数据\n使用带外D(或Delta)信道比调制解调器(有时&lt;1s)更快的呼叫建立\n使用B(或屏障)通道以64kps提供更快的数据传输\n\n\nISDN服务有两种：\nBRI(基本速率接口, Basic Rate Interface),用户虚拟电路数据传，HDLC,PPP\nPRI(主速率接口,Primary Rate Interface)，发送控制信息，LAPD\n\n\nISDN BRI服务提供两个B通道和一个D通道。\nISDN BRI将144kbps(2B + D &#x3D; 144kps)线路的总带宽传送到三个单独的通道中。\nBRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。\n第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。\nBRI和DRI都是基于电话信道的\n\n\n\nB信道传递HDLC和PPP数据帧\nD信道传递LAPD数据帧\n\n\nBRI\n\nISDN BRI服务提供两个B通道和一个D通道。\nBRI B信道服务以64 kbps的速率运行，旨在承载用户数据和语音流量。\n第三个通道，D通道，是一个16 kbps信令通道，用于承载指令，这些指令告诉电话网络如何处理每个B通道。\n\n\n\n非对称数字用户线路(ADSL,Asymmetric Digital Subscriber Line)\n概述\nxDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务\nDSL的前缀 x 表示在数字用户线上实现的不同宽带方案\n虽然标准模拟电话信号的频带限制在 300~3400kHz 范围内，但用户线本身实际可通过的信号频率仍超过 1 MHz\nxDSL 技术把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用\nDSL:数字用户线(Digital Subscriber Line)\n\n\nADSL 的极限传输距离：ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系(用户线越细，信号传输时的衰减就越大)\nADSL 的特点\n上行和下行带宽不对称:上行指从用户到 ISP，而下行指从 ISP 到用户\nADSL 在用户线(铜线)的两端各安装一个 ADSL 调制解调器。\n上行下行不对称，下行大于上行\n\n\n第二代 ADSL\n通过提高调制效率得到了更高的数据率。\n采用了无缝速率自适应技术 SRA (Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。\n改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。\n\n\n\nSONET\n同步数字系统的2种标准：同步光纤网SONET和同步数字系列SDH\n\n旧的数字传输系统存在着许多缺点。其中最主要的是以下两个方面：\n速率标准不统一：如果不对高次群的数字传输速率进行标准化，国际范围的高速数据传输就很难实现。\n不是同步传输： 在过去相当长的时间，为了节约经费，各国的数字网主要是采用准同步方式。\n\n\n同步光纤网 SONET\n\n同步光纤网 SONET (Synchronous Optical Network) 的各级时钟都来自一个非常精确的主时钟(铯原子钟，精度优于10-11秒)\n第 1 级同步传送信号 STS-1 (Synchronous Transport Signal)的传输速率是 51.84 Mb&#x2F;s。\n\n\n同步数字系列 SDH\n\nITU-T 以美国标准 SONET 为基础，制订出国际标准同步数字系列 SDH (Synchronous Digital Hierarchy)。\n一般可认为 SDH 与 SONET 是同义词。\nSDH 的基本速率为 155.52 Mb&#x2F;s，称为第 1 级同步传递模块 (Synchronous Transfer Module)，即 STM-1，相当于 SONET 体系中的 OC-3 速率。\n\n\nSONET 的 OC 级&#x2F;STS 级与 SDH 的 STM 级的对应关系\n\nSONET 的体系结构\n\nSDH也是光传输\n路径很长，分为一段一段的线路。\n线路中复用器和复用器之间分成段，使用转发器\n\n\n同步光纤网 SONET\n\nSONET 第 1 级同步传送信号 STS-1 ( Synchronous Transport Signal) 的传输速率为 51.84 Mb&#x2F;s，第 3 级同步传送信号 STS-3 传输速率是 STS-1 的3倍，为155.52 Mb&#x2F;s， …，等等，依此类推。\n\n\n\nSTS帧为时分复用幀，8000帧&#x2F;秒，每帧125 μS\n其对应的光信号则称为第 1 级光载波 OC-1 (OC表示 Optical Carrier)，第 3 级光载波 OC-3， …，等\n\n\nSONET 标准的四个光接口层\n\n光子层(Photonic Layer)：处理跨越光缆的比特传送。\n段层(Section Layer)：在光缆上传送 STS-N 帧。\n线路层(Line Layer)：负责路径层的同步和复用\n路径层(Path Layer)：处理路径端接设备 PTE (Path Terminating Element)之间的业务的传输。\n\n\n\n光纤同轴混合网HFC(Hybrid Fiber Coax)\n主要链路用光纤，到户用同轴电缆\n\n\n内容：\n\nHFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。\nHFC 网除可传送 CATV 外，还提供电话、数据和 其他宽带交互型业务。\n现有的 CATV 网是树形拓扑结构的同轴电缆网络， 它采用模拟技术的频分复用对电视节目进行单向传 输。而 HFC 网则需要对 CATV 网进行改造\n\n\nHFC 的主要特点\n\nHFC网的主干线路采用光纤\nHFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。\n在模拟光纤中采用光的振幅调制 AM，这比使用数字 光纤更为经济。\n模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。(光信号转换成点信号)到小区前是光传输，之后是电传输\n具有比 CATV 网更宽的频谱，且具有双向传输功能\n\n\n\n用户接口盒UIB (User Interface Box)\n\n每个家庭要安装一个用户接口盒\n用户接口盒要提供三种连接，即：\n使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。\n使用双绞线连接到用户的电话机。\n使用电缆调制解调器连接到用户的计算机。\n\n\n\n\n电缆调制解调器(Cable Modem)\n\n电缆调制解调器是为 HFC 网而使用的调制解调器。\n电缆调制解调器最大的特点就是传输速率高。其下行速率一般在 3∼10 Mb&#x2F;s之间，最高可达 30 Mb&#x2F;s，而上行速率一般为 0.2∼2 Mb&#x2F;s，最高可达 10 Mb&#x2F;s。\n电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。(远端是光，不是电）\n\n\nHFC 网的最大优点\n\n具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。\n要将现有的 450 MHz 单向传输的有线电视网络改造为 750 MHz 双向传输的 HFC 网(还要将所有的用户服务区互连起来而不是一个个 HFC 网的孤岛)， 也需要相当的资金和时间。\n在电信政策方面也有一些需要协调解决的问题。\n电信也在跨界到视频\n\n\nFTTx 技术\n\nFTTx(光纤到……)也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。\n光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。\n光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。\n光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。\n\n\n\n\n\n考试要求\n名词解释\nADSL意义、实现和B和D信道的带宽使用等\n\n第九章 · 网络安全概述\n计算机网络上的通信面临以下的四种威胁：\n\n\n\n\n威胁\n解释\n攻击类型\n\n\n\n截获\n从网络上窃听他人的通信内容。\n被动攻击\n\n\n中断\n有意中断他人在网络上的通信。\n主动攻击\n\n\n篡改\n故意篡改网络上传送的报文。\n主动攻击\n\n\n伪造\n伪造信息在网络上传送。\n主动攻击\n\n\n\n被动攻击\n截获信息的攻击称为被动攻击(并不改变通讯的过程)\n在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU而不干扰信息流。\n\n\n主动攻击\n更改信息和拒绝用户使用资源的攻击称为主动攻击。(修改了通信的构成)\n主动攻击是指攻击者对某个连接中通过的PDU进行各种处理(理解PDU后)\n更改报文流\n拒绝报文服务\n伪造连接初始化\n\n\n\n\n计算机网络通信安全的目标\n防止析出报文内容\n防止通信量分析(通信的习惯)\n检测更改报文流\n检测拒绝报文服务\n检测伪造初始化连接\n\n\n报文应该具有的性质\n保密性\n完整性\n可用性\n鉴别性\n不可否认(抵赖)性:确认是特定的发送方\n\n\n恶意程序(malicious program)\n计算机病毒:会”传染”其他程序的程序，“传染” 通过修改其他程序来把自身或其变种复制进去而完成。\n计算机蠕虫:通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。(特定场景才能使用，出现上商业行为)\n特洛伊木马:一种程序，它执行的功能超出所声称的功能（伪装成正常程序，但是留了后门）。运作木马获得特殊的权限\n逻辑程序:逻辑下载程序\n控制器程序:远程控制\n\n\n逻辑炸弹:一种当运行环境满足某种特定条件时执行其他特殊功能的程序。\n\n\n计算机网络安全的内容\n保密性\n安全协议的设计\n访问控制\n\n\n\n一般的数据加密模型\n概述：\n\n不确定有没有人修改:使用密文发送\n最早的是凯撒密码:\n加密：明文按照数字mod的值进行偏移，得到密文\n解密：密文反向偏移数字mod的值进行偏移，得到明文\n\n\n\n\n密码相关的重要概念\n密码编码学(cryptography)是密码体制的设计学(设计密码)\n密码分析学(cryptanalysis)则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学(cryptology)。\n如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为无条件安全的，或称为理论上是不可破的。\n如果密码体制中的密码不能被可使用的计算资源破译，则这一密码体制称为在计算上安全的。(目前一般的密码体系能够达到的标注)\n\n\n\n\n\n对称密钥和公钥密码体制\n对称密钥密码体系\n\n概述\n所谓常规密钥密码体制，即加密密钥与解密密钥是相同的密码体制。\n这种加密系统又称为对称密钥系统。\n\n\n数据加密标准 （DES Data Encryption Standard）\n数据加密标准DES属于常规密钥密码体制，是一种分组密码(对称加密算法)\n在加密前，先对整个明文进行分组。每一个组长为64位。\n然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。\n最后将各组密文串接起来，即得出整个的密文。\n使用的密钥为64位(实际密钥长度为56位，有8位用于奇偶校验)。\n对于64位密码有编排的过程，详细自己查找学习\n密钥长度不会太长，算法复杂度比较低\n\n\nDES 的保密性\nDES的保密性仅取决于对密钥的保密，而算法是公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。\nDES 是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献。\n目前较为严重的问题是DES的密钥的长度(算力提升)\n由于算力的提升，破解DES所需的时间进一步降低，不再是计算上安全的了。\n通过增加DES密钥的长度来提高安全性。\n\n\n现在已经设计出来搜索DES密钥的专用芯片(硬件层面的解决方案)\n\n\n\n\n公钥密码体制\n\n公钥密码体制使用\n不同的加密密钥与解密密钥\n，是一种”由已知加密密钥推导出解密密钥在\n计算上是不可行\n的”密码体制。(非对称密码体系)\n\n经典算法:密钥E和N，明文是一个数字，加密时用明文做E的指数次方之后mod N得到密文C，解密是D和N，密文C做D次方再mod N得到明文\n例子:密钥是7和187，明文88，88的7次方mod187 &#x3D; 11(密文)，解密密钥23和187，11的23次方mod187得到88(明文)\n\n\n\n88(明文)7 mod 187&#x3D;11(密文)88(明文)7 mod 187&#x3D;11(密文)11(密文)23 mod 187&#x3D;88(明文)11(密文)23 mod 187&#x3D;88(明文)\n\n公钥密码体制的产生主要是因为两个方面的原因，一是由于常规密钥密码体制的密钥分配问题，另一是由于对数字签名的需求。\n\n一个机构可以发送自己的公钥，保留自己的密钥。接收者受到密钥加密的就知道是谁发送的，保证机构可以发送安全认证，接受者使用公钥解密知道是谁发送的，做到密钥的分配\n私钥加密的是机构的签名，大量数据传输使用对称密钥体系传输，公钥发送比较少的数据，因为公钥密码体系算法复杂度比较高，加密的时候是很多位的明文，计算量太大。\n\n\n现有最著名的公钥密码体制是RSA体制，它基于数论中大数分解问题的体制，由美国三位科学家Rivest，Shamir和Adleman于1976年提出并在1978年正式发表。\n\n公钥算法的例子\n\n\n在公钥密码体制中，加密密钥(即公钥)PK是公开信息，而解密密钥(即私钥或秘钥)SK是需要保密的\n加密算法E和解密算法D也都是公开的\n虽然SK是由PK决定的，但却不能根据PK计算出SK(单向的)\n公钥和私钥是成对生成的\n\n\n公钥算法的特点\n\n发送者A用B的公钥\nPKBPKB\n对明文X加密(E运算)后，在接收者B用自己的私钥\nSKBSKB\n解密(D 运算)，即可恢复出明文：\n\nDSKB(Y)&#x3D;DSKB(EPKB(X))&#x3D;XDSKB(Y)&#x3D;DSKB(EPKB(X))&#x3D;X\n\n\n解密密钥是接收者专用的秘钥，对其他人都保密。\n\n加密密钥是公开的，但不能用它来解密，即\n\nDPKB(EPKB(X))≠XDPKB(EPKB(X))&#x3D;X\n\n\n加密和解密的运算可以对调，即(用私钥进行加密，意义有差别:这样子证明是B发送的，但是别人都知道公钥，相当于明文发送)\n\nEPKB(DSKB(X))&#x3D;DSKB(EPKB(X))&#x3D;XEPKB(DSKB(X))&#x3D;DSKB(EPKB(X))&#x3D;X\n\n\n在计算机上可容易地产生成对的PK和SK\n\n从已知的PK实际上不可能推导出SK，即从PK到SK是”计算上不可能的”\n\n加密和解密算法都是公开的\n\n\n\n应当注意：\n\n任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量\n在这方面，公钥密码体制并不比传统加密体制更加优越\n由于目前公钥加密算法的开销较大，在可见的将来还不会放弃传统的加密方法\n公钥需要密钥分配协议，具体的分配过程并不比采用传统加密方法时更简单\n\n\n\n\n\n数字签名\n概述：\n\n数字签名必须保证以下三点：\n报文鉴别:接收者能够核实发送者对报文的签名\n报文的完整性:发送者事后不能抵赖对报文的签名\n不可否认:接收者不能伪造对报文的签名\n\n\n现在已有多种实现各种数字签名的方法。但采用公钥算法更容易实现\n\n\n数字签名的实现\n\n\n因为除A外没有别人能具有A的私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的。\n若A要抵赖曾发送报文给B，B可将明文和对应的密文出示给第三者。第三者很容易用A的公钥去证实A确实发送X给B。\n反之，若B将X伪造成Y，则B不能在第三者前出示对应的密文。这样就证明了B伪造了报文。\n\n\n\n防火墙\n概述\n\n防火墙是由软件、硬件构成的系统，是一种特殊编程(ACL)的路由器，用来在两个网络之间实施接入控制策略。接入控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。\n防火墙内的网络称为可信赖的网络(trusted network)，而将外部的因特网称为不可信赖的网络(untrusted network)。\n防火墙可用来解决内联网和外联网的安全问题。\n\n\n防火墙在互连网络中的位置\n\n\n其实只用一个路由器就可以完成防火墙的划分。\n例子中:应用网关，可以内部外部进行访问过滤。\n优点:在防火墙中的外局域网和内局域网都可以放置一些服务器，由左侧过滤的路由器控制访问，而右侧的路由控制内部网络的访问，从而达成一个访问权限控制\n内网络安全也是一个问题\n\n\n防火墙的功能\n\n防火墙的功能有两个：阻止和允许。\n阻止就是阻止某种类型的通信量通过防火墙(从外部网络到内部网络，或反过来)：比如阻止内部的对迅雷的请求向外发送\n允许的功能与阻止恰好相反。\n\n\n防火墙必须能够识别通信量的各种类型。不过在大多数情况下防火墙的主要功能是阻止。\n\n\n防火墙技术一般分为两类\n\n网络级防火墙:用来防止整个网络出现外来非法的入侵。属于这类的有分组过滤和授权服务器\n前者检查所有流入本网络的信息，然后拒绝不符合事先制订好的一套准则的数据\n后者则检查用户的登录是否合法\n\n\n应用级防火墙:从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用，例如，可以只允许通过访问万维网的应用，而阻止FTP应用通过\n\n\n\nACL\n访问控制列表ACL(Access Control Lists)\n\nACL是指令列表，它告诉路由器允许或拒绝什么类型的数据包。\n如果要让路由器拒绝某些数据包，则必须配置ACL。否则，只要链路打开，路由器将接受并转发所有数据包\n您可以根据以下情况允许或拒绝数据包：\n源地址\n目的地址\n上层的协议，比如TCP或UDP端口\n\n\n为了确定是允许还是拒绝数据包，请按顺序对ACL语句进行测试。\n当一个语句”匹配”时，不再评估后面的语句。(前面的语句先匹配，处理掉)\n允许或拒绝该数据包。\n\n\n默认：ACL末尾有一个隐含的”deny any”语句:如果数据包与ACL中的任何语句都不匹配，则将其丢弃。\n\n\n路由器如何使用出站ACL\n\n检查数据包是否可路由。如果是这样，请在路由表中查找路由\n检查出站接口的ACL\n如果没有ACL，则将数据包切换出目标接口\n如果是ACL，请按照ACL语句顺序检查数据包-根据匹配的条件拒绝或允许。\n\n\n如果没有语句匹配，会发生什么？拒绝所有没有匹配的包\n\n\n出站标准ACL流程\n\n\n收到packet，确定路由表确认路由表看能够转发\n可以转发的话，进入ACL确认\n如果当前端口没有ACL配置，则直接进行转发\n如果当前端口有ACL配置，开始匹配source地址(标准的ACL，只能对原地址进行判断)\n语句满足条件，\ndeny\npremit\n\n\n语句不满足条件，看下一条，如果没有下一条，则默认deny\n\n\n\n\n\n\naccess-list-number参数\n\nACL有很多类型。访问列表号指定什么类型。\n下表显示了常见的访问列表类型。\n\n\n\n注意默认的取值(扩展ACL不仅仅局限于源地址)\n\n\ntest-condition参数\n\n在ACL的{test condition}部分中，大多数访问列表的共同点是源地址的IP掩码和通配符掩码。\n源地址可以是子网，地址范围或单个主机。由于通配符掩码使用源地址检查位，因此也称为ip掩码。\n通配符掩码告诉路由器要检查哪些位。\n\n\n\n\nIp mask:Ipv4的地址\nWilcard mask:和netmask是不同的，指示哪些位置被检查\n\n\n\n通配符掩码 Wildcard Mask\n\n编写通配符掩码以告知路由器地址中要匹配的位以及要忽略的位。\n0位表示检查该位位置\n表示忽略该位位置\n\n\n我们先前的192.5.5.10 0.0.0.0示例可以用二进制重写为：\n11000000.00000101.00000101.00001010 (Source address)\n00000000.00000000.00000000.00000000 (Wildcard mask)\n\n\n通配符掩码的例子\n编写一个IP掩码和通配符掩码以检查网络上的所有主机：192.5.5.0 255.255.255.0(检查这一个网段)\nAnswer: 192.5.5.0 0.0.0.255(和net mask是取反的)\n请注意，此通配符掩码是C类地址的默认子网掩码的镜像。\n警告：仅当查看整个网络或子网时，这才是有用的规则。\n\n\n编写一个IP掩码和通配符掩码以检查子网中的所有主机：192.5.5.32 255.255.255.224\nIf you answered 192.5.5.32 0.0.0.31\n0.0.0.31 是 255.255.255.224 的镜像地址\n二进制标识\n11111111.11111111.11111111.11100000 (255.255.255.224)\n00000000.00000000.00000000.00011111 (0.0.0.31)\n\n\n\n\n\n\n省时：any命令\n由于ACL末尾有一个隐含的”deny any”语句，因此您必须编写语句以允许其他人通过。\n使用我们前面的示例，如果学生被拒绝访问而所有其他学生都被允许访问，则您将编写以下两个语句：\nLab-A(config)#access-list 1 deny 192.5.5.0 0.0.0.127:拒绝一个\nLab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255\n由于最后一条语句通常用于覆盖”拒绝任何”，因此思科为您提供了一个选项-any命令：\nLab-A(config)#access-list 1 permit any &#x3D;&#x3D; Lab-A(config)#access-list 1 permit 0.0.0.0 255.255.255.255\n\n\n省时：主机名支持\n很多时候，网络管理员将需要编写ACL来允许特定主机(或拒绝主机)。该语句可以用两种方式编写。\nLab-A(config)#access-list 1 permit 192.5.5.10 0.0.0.0\nLab-A(config)#access-list 1 permit host 192.5.5.10(host 专指 192.5.5.10)\n\n\n\n\n\n\n标准ACL的配置位置\n\n标准ACL没有目标参数。因此，您将标准ACL放置在尽可能靠近目标的位置。\n要了解原因，请问自己，如果在Lab-A的E0上放置” deny 192.5.5.0 0.0.0.255”语句，将会对所有IP流量产生什么影响？\n\n\n\n\n如果放到Lab A的E0口则会导致无法访问Lab B&#x2F;C,应该放到Lab D的E0\n约定:将标准ACL放到与将要生效的主机越近越好，但是其实会对带宽有一定的损耗\n\n\n扩展ACL\n\n概述：\n\n扩展ACL的编号范围为100-199，并”扩展”了标准ACL的功能。\n扩展功能包括基于过滤流量的功能。\n目的地址\nip协议的部分(更加细分):您可以编写语句以仅拒绝”ICMP”等协议或”RIP”和”IGRP”之类的路由协议\n协议套件的上层\n您可以编写语句以仅拒绝诸如”TFTP”或”HTTP”之类的协议\n您可以使用eq，gt，lt和neq(等于，大于，小于和不等于)之类的操作数来指定如何处理特定协议。\n例如，如果您希望访问列表允许除http访问之外的所有流量，则可以使用” permit ip any neq 80”(允许来自任意源地址和目的地址的不是80端口的信息)\n\n\n\n\n\n\n端口号\n\n查看tcp和udp协议的各种端口号，并了解以下最常见的端口号。\n您还可以在{protocolspecific options}中键入名称(telnet)而不是数字(23)。\n\n\n\n配置扩展ACL的位置\n\n在下图中，我们要拒绝网络221.23.123.0访问服务器198.150.13.34\n\n。\n\n访问列表应应用于什么路由器和接口？\n将访问列表写在路由器C上，将其应用于E0，并在\n这将使网络不受221.23.123.0发往198.150.13.34的访问，但仍允许221.23.123.0访问Internet\n\n\n\n\n按照标准的原则，应该放置到Route A，而用扩展的放置的是Route C的E0上，放置对应的命令\n\n\n由于扩展的ACL具有目标信息，因此您希望将其放置在尽可能靠近源的位置。\n\n\n\n\n\n\n笔记 · 实验笔记05：动态 RIP\n目的：以跳数为依据，让路由器互联\n工作原理：\n跳数：直连网络为一，其他情况为中间的路由器数加一。\n最大为15跳，16为不可达\n和谁交换信息？只和相邻路由器交换信息\n交换什么信息？路由表\n何时交换信息？周期性定期交换\n怎么更新信息？收到邻居路由器的路由表并且处理好跳数后，与现有路由表比较。\n到达相同网络，相同的下一跳，保留最小跳数。若相同，保留新消息\n到达相同网络，不同的下一跳，保留最小跳数。若相同，两个都要保留。\n\n\n\n\n\n06：配置单域 OSPF\n目的：动态地获得完整的网络拓扑结构\n关键概念：\nOSPF（Open Shortest Path First）：是一种常见的内部网关协议（IGP），用于在一个自治系统（AS）内的路由器之间交换路由信息。适用于复杂的网络拓扑。\ncost：指标由带宽，速度，流量，可靠性和安全性计算，本科阶段只考虑带宽因素。\nLSA（链路状态广告）**：一旦建立邻接，OSPF路由器就会交换链路状态广告（LSA），以便所有路由器了解网络拓扑。\nLSDB（链路状态数据库）： 每个路由器维护一个链路状态数据库（LSDB），该数据库包含了网络中所有LSA的副本，表示了当前网络拓扑。\nDR：指定路由器，只有在多路复用的情况下使用\nBDR：如果DR坏了，再次选举会出现问题，如果DR损坏，BDR立即成为DR\nHello Interval：发送hello报文的时间间隔\nDead Interval：能容忍的收到回复的最大时间间隔。一般是hello interval的4倍。\nRouter ID：选择所有环回接口中的IP地址最大的作为ID。若没有环回接口，则从当前活跃的物理接口中找到IP最大的作为ID。\n\n\n工作原理：\n每台路由器都有与自己直连的路由器的信息（邻居的信息），他们之间互相交换LSA，最终构建起整个网络的路由信息。\n为了避免大量重复的泛洪造成的资源浪费，会选举出DR和BDR。大家把信息全部发给DR，DR整合好之后再发还给其他路由器。BDR是DR的备份。\n为了减轻存储信息的压力，会对网络拓扑分区。\n区域0（Area 0）：OSPF的骨干区域，所有其他区域必须与区域0相连接。\n普通区域（Normal Area）：区域0之外的其他区域，可以包含普通路由信息。\n边界路由器：处于骨干区域边界的路由器，与骨干区域和其他区域都是相连的。要维护两个LSDB。\n一个Area中不能有超过50台路由器，否则会导致SPF算法产生的计算量和内存过大\n\n\n通过Hello报文互相打招呼，以确保维持链路。若没能受到回复，则认为它“死”了。\n\n\n工作步骤：\n步骤1：建立邻接关系\n步骤2：选择DR和BDR(如果需要):多路复用的时候才需要\n步骤3：发现路线\n步骤4：选择适当的路线\n步骤5：维护路线信息\n\n\n\n07：VLAN 间路由\n目的：隔离广播域\n关键概念：\nVLAN：虚拟局域网。是一种隔离广播域的技术。\n交换机不能隔离广播域，路由器天生就能够隔离广播域。\nAccess接口：只连接到单一VLAN\nTrunk链路：可以同时承载多个VLAN的流量\n\n\n\n08：NAT网络地址转换\n目的：让内部的私网可以通过转换变成公网来上网\n\n09：ACL 实验\n目的：筛选数据流\n关键概念：\nACL：访问控制列表\n\n\n要点：\n标准的ACL要放在靠近目标的位置，扩展到ACL要放在靠近源的位置\n对于 ACL，有个非常重要的特性， 他不能过滤本地数据流。即ACL所在的路由器不能控制过滤自己发出的信息。\n设置了 2 种 ACL，但是得到的效果却不一样。如果是使用了扩展的 ACL，那么它的提示是“% Destination unreachable; gateway or host down”,说明 23 号端口根本不可达。如果是使用了标准的 ACL 放置在 VTY 线路中，则提示“%  Connection refused by remote host”，说明的确是到达了 23 号端口，只不过被拒绝 了。在实际使用中最好使用扩展的 ACL，减少 23 号端口的负担。\n\n\n语句解释：\nline vty 0 4：在路由器或交换机上配置虚拟终端 (VTY) 线路，用于远程访问设备（例如，使用 Telnet 或 SSH）。通过配置 line vty，可以控制对设备的远程访问权限。配置 VTY 线路 0 至 4（即最多支持 5 个并发的远程连接）。\nip access-group 100 out ：是用来在 Cisco 设备上将访问控制列表 (ACL) 应用到接口的命令。这个命令的作用是将编号为 100 的访问控制列表应用到接口的 输出流量，即所有通过该接口发送出去的数据包。\n\n\n\n10：PPP 验证实验\n目的：为点对点连接提供一种可靠、灵活且标准化的通信方式。\n\n关键概念：\n\nPPP：点对点协议。PPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法。\nLCP：链路控制协议。可以动态地协商链路参数，管理链路的建立、维护和终止。可以看做是面向物理层的接口。\nNCP：网络控制协议。动态协商和分配IP地址。可以看做是面向网络层的接口。\nPAP：基于密码的简单认证协议（Password Authentication Protocol）。\nCHAP：动态加密挑战机制。更安全，采用动态加密挑战机制来验证身份，避免了密码在传输过程中的明文暴露。\n\n\n工作流程和状态\n\n静止状态：开始和结束状态都是静止状态，没有物理层链接\n\n建立状态：检测到载波信号，建立物理层链接，进入建立状态。然后LCP开始协商配置选项：\n\n配置选项：\n最大帧长\n鉴别协议\n无鉴别\nPAP\nCHAP\n\n\n\n\n\n\n协商成功，进入鉴别状态\n失败则回到静止状态\n\n\n鉴别状态：根据协议鉴别身份。\n\n若鉴别成功或无鉴别，则进入网络状态\n失败则进入终止状态\n\n\n网络状态：进行NCP配置。完成后进入打开状态。\n\n打开状态：可以进行数据传输。\n\n出现故障或收到终止请求，进入终止状态。\n\n\n终止状态：当载波停止后，回到静止状态。\n\n\n\n\n12：DHCP 欺诈保护\n概念：\n\nDHCP：动态主机配置协议(Dynamic Host Configuration Protocol)用于动态地为网络上的设备分配 IP 地址和其他网络配置（如子网掩码、网关和 DNS 服务器）。DHCP 使得设备能够在连接到网络时自动获取配置，避免了手动设置 IP 地址和其他参数的繁琐。\n\n\nDHCP工作原理：\n\n发现阶段：客户端设备在启动时会向网络发送一个 DHCP Discover 广播消息，表示其请求获取 IP 地址。这个消息在网络中广播，以便找到 DHCP 服务器。\n提供：网络中的 DHCP 服务器收到 Discover 消息后，会向客户端返回一个 DHCP Offer 消息，内含一个可用的 IP 地址、子网掩码、默认网关、DNS 等信息。此消息也会通过广播发送。\n选择并请求：客户端收到 DHCP 服务器的多个 Offer 后，会选择一个并发送 DHCP Request 消息，告诉 DHCP 服务器其选择的 IP 地址，并请求确认。此请求是广播的。\n确认：DHCP 服务器确认客户端的请求后，会向客户端发送 DHCP Ack 消息，正式确认分配给客户端的 IP 地址和其他配置信息。此时，客户端开始使用该 IP 地址。\n\n\n\n\n\n\n\n\n\n\n笔记 · 名词解释第一章：网络概述网络\n是一组相连接的系统，终端可以是物、人、设备。计算机网络终端是计算机，传输01序列，为了共享资源\n\nLAN\nlocal area network\n\n\n局域网，工作范围较小，采用广播式的传输方式，多个用户同时复用一个链路介质，提高效率\n设备：集线器（hub）、网桥（bridge）、交换机（switch）、路由器（router）\n\nWAN\nwide area network\n\n\n广域网，工作范围大，采用点对点的传输方式，多单位合作实现与维护\n设备：路由器（router）、调制解调器（modem）\n\ninternet\n互联网，有若干个网络连接而成的网络\n\nInternet\n因特网，世界上最大的互联网。采用TCP&#x2F;IP协议为通信规则，前身是美国的ARPANET\n\nISP\nInternet Service Providers，网络服务供应商。ISP从因特网管理机构申请多个IP地址、通信线路和路由器等设备。机构或个人通过ISP接入因特网。\nISP分为三层，在低层ISP可以解决的问题不会进入上层ISP，以此来进行流量分流\n\nNAP\nnetwork access point，网络接入点。向各ISP提供交换设备，使他们能够互相通信\n\ndata packet\n数据报文，为了传输，数据总是被分解为小、易于传输的单元。OSI模型中称为报文、帧或段\n优点：1. 可以发呢还是偏处理不同进程的报文；2. 即使链路故障，只需要重传小部分报文；3. 可以走不同路径最有到达\n\nbandwidth &amp; throughout\n带宽：给定时间可传输的数据量\n吞吐量：实际的数据量\n\nOSI参考模型\nopen system interconnection，开放系统互联基本参考模型。由国际标准化组织ISO提出，使得不同体系结构的计算机能够互连\n七层简述：\n物理层（physical）：解决二进制传输问题——信号与介质的规范——只传递信号，不做正确性判断\n数据链路层（data link）：帧和介质访问控制——点对点的一个链路——确保可靠传输\n网络层（network）：路径选择与最佳路径——基于ip地址逻辑定位设备、多个链路——可达传输，不做复杂校验\n传输层（transport）：终端与终端之间的连接——可靠性、流控制、错误校正\n会话层（session）：内部host的对话与交流——会话管理、同步校验\n表示层（presentation）：数据加密与显示——通用格式、数据结构与传输语法的协商\n应用层（application）：用户界面——浏览器、面向用户\n\n\n\n\nTCP&#x2F;IP参考模型\nTransmission Control Protocol&#x2F;Internet Protocol\n由美国防部DoD创建，希望数据报任何情况下都能从一个点传输到另一个点\n四层简述：\n网络接口层（network access）：相当于OSI物理层+数据链路层\n互联网层（internet）：相当于OSI网络层\n传输层（transport）：相当于OSI传输层\n应用层（application）：相当于OSI会话层、表示层、应用层\n\n\n\n各层网络设备\n第一层：介质（media）、集线器（hub）、中继器（repeater）、网卡（NIC）\n第二层：网卡（NIC）、交换机（switch）、网桥（bridge）\n第三层：路由器（router）\n\nNIC网卡\nnetwork interface controller，网路终端设备\n拥有一个MAC地址，表明主机身份，帮助主机接入网络\n成帧：打包比特流进行传输\nLLC+MAC\n控制数据流（接受和发送数据）、实现串行信号（用于发送）与并行信号（电脑产生）的转化\n\nRepeater中继器\n网络中间设备，用于延长网络的长度。整理、放大、重发信号，不做逻辑过滤，不划分冲突域\n\nHub集线器\n网络中间设备，多端口的中继器\n\nBridge网桥\n网络中间设备。\n过滤信息，划分冲突域\n通过MAC地址实现多个LAN之间设备的连接（接两个不同局域网）\n\nSwitch交换机\n网络中间设备，多端口的网桥\n可以隔离冲突域，但不能隔离广播域\n\nRouter路由器\n网络中间设备，进行网段的划分，选择路径并转发报文到最佳路径\n路由器的每个端口都有一个网卡，我们给路由器的每一个端口也分配一个IP地址，使其可以通过IP协议栈与网段中其他设备通信\n\n\n第二章：物理层UTP\n\nUnshielded Twisted Pair，无屏蔽双绞线。八根子线，两两一组（抵消彼此电磁影响和外部电磁波干扰），每组为Twisted Pair\n比**STP（有屏蔽双绞线）**便宜，容易部署；但是抗干扰能力弱于STP\n\nCoaxial\n\n同轴电缆，传输距离比UTP远，成本略高但小于光纤\n中间为铜导线（传输电信号），外包绝缘膜（减少干扰），外包一层金属网（一定程度屏蔽外界电磁干扰），最外层塑胶套（保护内部不受侵蚀）\n\nFiber-Optic\n\n光纤，中间光导体（二氧化硅），外包塑料套（包装与保护），不受电磁干扰，更远效率更高，更贵\n单模：用于广域网，直径更小，传播距离更长；多模：用于局域网，入射角度区分，同时传多路光线\n\nWireless Communication\n无线通讯，通过频率区分不同电磁波\n无线传输方法：\n激光通信（lasers）——军用，受雨雾干扰影响大：电磁波频率相同\n红外通信（infrared）——遥控器，实现漫反射：不能透过不透明物体\n无线电通信（radio）——民用，受雨雾干扰影响小 携带可以穿墙的数据信号 陆地和卫星无线电技术\n\n\n\n双绞线类型\n\nStraight cable，直通线（用于同类设备）：两端标准相同\nrollover cable，反转线（用于控制台端口与与PC串口连接）：两端标准相同，但插脚对应反过来\ncrossover cable，交叉线（连接集线器、交换机）：两端标准相反（T568-A、T568-B）\n\n比特率与波特率\n波特率(baud)和比特率(bit)\n波特率(调制速率)：波信号每秒钟变化的次数\n比特率：每秒钟传送的二进制位数\n\n\n波特率与比特率的关系取决于信号值与比特位的关系\n例：每个信号值表示为3位，则比特率是波特率的3倍； 每个信号值表示为1位，则比特率和波特率相同\n对于比特率为a bps的信道，发送8位所需的时间为 8&#x2F;a秒，若8位为一个周期Ｔ，则一次谐波的频率是：f &#x3D; a&#x2F;8 Hz\n\n\n\n多路复用 （Multiplexing）\nTDM：时分复用（time division）：将时间划分为一段段等长的时分复用帧，每个用户占用固定序号的时隙\n\n\n\nTDM会造成线路资源的浪费，对此统计时分复用STDM一旦充足就组织发送，不以时间区分用户所以需要每个帧携带自己用户的信息\n\n\nFDM：频分复用（frequency division）：用户分配一定频带后，始终占用这个频带\n\nWDM：波分复用（wavelength division）：光的频分复用\n\nCDM：码分复用（code division）：用户使用经过特殊挑选的不同码型，不会彼此干扰\n\n\n通信方式\n单工（simplex）：信号单向传输\n半双工（half-duplex）：可双向传输，但不可同时\n全双工（full-duplex）：可同时双向传输\n\n\n第三章：数据链路层MAC（控制）\nmedia access control，局域网的介质访问控制，用来确定共享介质环境中哪个计算机允许传输数据的协议\n三种常见MAC\n以太网（Ethernet）：逻辑总线拓扑，物理星型或扩展星型拓扑\n令牌环（token ring）：逻辑环形拓扑，物理星型拓扑\n光纤分布式数据接口（FDDI）：逻辑环形拓扑，物理双环\n\n\n分为两类控制方法：\n确定性轮流（deterministic），通过令牌决定能否发送——令牌环、FDDI\n争用式（non-deterministic），先来先服务——以太网\n即：CSMA&#x2F;CD，见下\n\n\n\n\n\nLLC &amp; MAC（子层）\nIEEE标准将数据链路层分为两子层：\nMAC（meida access control）介质访问控制，定义帧如何在物理层传输\nLLC（logical link control）逻辑链路控制\n获取网络协议数据（packet），并添加更多控制信息来帮助包到达目的地，后交给MAC子层\n向网络层提供服务（有无应答、有无连接，三种）\n可以对应不同MAC子层\n\n\n\n\n\nSAP &amp; DSAP &amp; SSAP\n这三个是LLC子层的寻址组件\nSAP：service access point，服务接入点\nDSAP：destination SAP，目的服务接入点\nSSAP：Source SAP，源服务接入点\n\nMAC地址（地址）\n48位，始终表示12个十六进制数\n前6位十六进制数表示制造商、供应商，并包含组织唯一标识符\n其余六位包括接口序列号，由特定供应商管理\n广播地址（全1，FFFF.FFFF.FFFF）\n\nCSMA&#x2F;CD\nCarrier Sense Multiple Access with Collision Detection 带冲突检测的载波侦听多路访问\n用于有线网络\n\n\n首先设备要发送数据\n开始侦听链路是否忙，如果忙，则过一阵来再看看\n如果不忙，则开始准备发送\n如果有错误，表示有冲突发生，广播一个jam sighnal，把自己尝试的次数 + 1（重发有一定限度）\n尝试次数过多，会向上层协议传输网络不可用\n尝试次数还可，则计算一个回退时间，来再次尝试，回退时间单位，会保证时间差能保证第一个人已经用完电路来避免冲突。\n\n\n如果没有错误，则一直传输到结束为止\n\nCSMA&#x2F;MA\nCarrier Sense Multiple Access with Collision Avoidance\n用于无线网络\n带冲突避免的载波侦听多路访问。由于无线局域网只能知道边上站点的传输情况，所以只能避免冲突没不能想CSMA&#x2F;CD一样检测冲突。\n发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送\n\nBSS &amp; BS &amp; AP &amp; SSID &amp; ESS\nBSS：Basic service set，基本服务集，包含一个基站BS（Basic Station）和若干无线主机\n所有主机都可以在本地BSS中借助基站直接相互通信\n基站范围内其他两个主机之间是不互相连接的，只能借助基站通信\n\n\n当一个接入点AP（access point）安装后，一个服务集标识SSID（service set Identifier）和一个通道就会被分配到该接入点\n一个基本服务集BSS可以通过分布式系统DS（distribution system）和其他BSS连接构建一个扩展服务集ESS\n\n无线局域网的CSMA&#x2F;CA\nCarrier Sense Multiple Access with Collision Avoidance 带冲突避免的载波侦听多路访问\n\n为什么无线局域网（WLAN）使用CSMA&#x2F;CA而不是CSMA&#x2F;CD？\n\n无线局域网站只能知道边上站的传输情况，不知道其他站，所以只能“避免”，无法“检测”\n\n\n两个问题\n\n\n\n隐藏站问题：当A将数据传输到B时，C无法检测到A和B之间的传输，因此C可能会决定将数据传输到B并导致B发生冲突（听不到应该听到的信息）\n暴露站问题：当B将数据传输到A时，C可以检测到传输，因此C不会将数据传输到D。但这是一个错误。(听到不应该听到的信号)\n\n\n发送站点在发送数据前，以控制短帧刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送\n\n基本过程\n\nA向B发送RTS（Request To Send，请求发送）帧，A周围的站点在一定时间内不发送数据，以保证CTS帧返回给A；\nB向A回答CTS（Clear To Send，清除发送）帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据；\nA开始发送\n若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始。（A和C同时发送RTS）\n\n\n\n透明网桥\n“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。透明网桥是一种即插即用设备，是目前以太网中使用得最多的网桥\n\n\n第四章：网络层IP地址\n32位，网络号（network ID）+主机号（host ID）\n\n网络号由ARIN（american registry for internet numbers分配）\n\n划分（第一个字节）与格式\n\n\n\n0-127：A类地址\n128-191：B类地址\n192-223：C类地址\n\n\n注意：每个网段中，有两个地址不能划分给主机\n\n全0保留用于网络地址\n全1保留用于广播地址\n\n\n专用地址空间（用作局域网的内部网段）\n\nA：10.0.0.0 - 10.255.255.255\nB：172.16.0.0 - 172.31.255.255\nC：192.168.0.0 - 192.168.255.255\n\n\nIP地址耗尽的解决办法\n\nNAT，即使用私有IP地址（见运输层）\nCIDR，无类域间选路\nIPv6，长期解决办法\n\n\n\n子网划分\n从host为中借几位用于单位内部划分子网，减少冲突域\n是逻辑上的，到达本地路由器之后再根据子网号交付\n可借位数：2 ~ host位数-2\n子网划分会带来地址浪费（本来只有两个不能划分，现在每个子网里都有两个不能划分，另外子网全0全1也不能使用）\n\n路由转发过程\n\n\nA5主机发送报文给B5主机，这个报文的IP地址是B5所在的IP地址，形成帧（这个帧的目的地址是A1端口），然后放到总线上\n路由器收到帧，然后进行理解，看到报文，知道目的地是B5(解封装)\n路由器检查自己的路由表，找到对应的端口B1，形成新的帧（这个帧的源地址为B1端口，目的址是B1的MAC地址）\n\nIP地址动态分配（RARP、BOOTP、DHCP）\nRARP：reverse address resolution protocol，反向地址解析协议\nBOOTP：BOOTstrap protocol，BOOTstrap协议\nDHCP：dynamic host configuration，动态主机配置协议\n\nDefault gateway 默认网关\n默认网关是路由器上连接到源主机所在网段的接口的IP地址\n为了使设备能与另一网络上的设备通信，则必须为其提供默认网关，源设备将数据发送到默认网关\n\nARP\naddress resolution protocol，地址解析协议，根据IP地址信息来获取MAC地址\n\n过程：\n\n查找本地ARP table有无相关条目（条目具有时效性）\n\n如果没有：\n\n发出广播，向目的方请求MAC地址\n\n\n各主机接受帧，解析报文内容，若主机发现IP地址与自己匹配，则根据帧中发送方的IP地址与MAC地址准备应答，同时更新自己的ARP table\n\n\n目标主机把自己的MAC地址填入后，进行回复\n\n\n请求方接受到回复后，更新ARP table，并发出正常数据帧\n\n\n\n\n\n上述过程使用了广播操作，而广播操作只能在本网段内进行，如果需要跨网段则通过默认网关或ARP代理来实现\n\n默认网关：发送报文到另一个网段，需要路由器把对应端口的网关的MAC告诉你，然后通过网关进行转发\nARP代理（Proxy ARP）：中间设备（比如路由器）代表目的端发送一个ARP应答给发送请求的主机。\nARP代理的应用场景是源主机未配置默认网关，在本网段广播时，路由器返回自己端口的MAC地址，是的源主机能够通过网关转发\n\n\n\nRouted protocol &amp; Routing protocol\nRouted protocol，被动路由协议，用于路由器之间基于路由表进行转发判断\nRouting protocol，路由协议，用于路由器之间，用作于彼此交换信息，进行各自路由表的生成\n\nStatic routes &amp; Dynamic routes\nStatic routes，静态路由，网络管理员手动输入路由信息\nDynamic routes，动态路由，使用路由协议自动更新路由信息\n\n自治系统\n自治系统是一个主管部门下的路由器网络，例如公司、学校、政府机构等网络。自治系统内部的路由器了解内部全部网络的路由信息\n\nIGP &amp; EGP\n是动态路由协议的两类\nIGP（interior gateway protocol）内部网关协议，自治系统内部\nEGP（exterior gateway protocol）外部网关协议，自治系统之间\n\nDVP &amp; LSP\n是内部网关协议的两类\nDVP（distance vector protocol）距离矢量协议，基于邻居获取网络拓扑信息\n以跳数为评判依据，只知道到达一个网段的最少跳数；定期更新\n\n\nLSP（link state protocol）链路状态协议，基于全局获取网络拓扑通用视图\n基于cost 最小生成树；一开始就交换信息形成拓扑图们稳定后事件触发更新\n\n\n\nRIP\nRouting information protocol，路由信息协议，DV的代表\n是基于距离矢量的内部网关协议，以跳数为唯一指标，最大跳数为15，30更新一次\n由于其简单、靠谱，广收欢迎\n\nIGRP\nInterior Gateway Routing Protocol\n是基于距离矢量的内部网关协议，思科知识产权的，最大跳数为255，90秒更新一次\n\nEIGRP\nEnhanced IGRP\n高级版本，混合路由协议（由带宽、负载、延迟、可靠性等加权得到评判标准）\n\nOSPF\nOpen Shortest Path First，开放最短路径优先\n是基于链路状态的内部网关协议\n指标由带宽，速度，流量，可靠性和安全性组成\n\nVLSM\nVariable Length Subnet Mask，可变长度子网掩码\n经典路由会造成网络号的浪费，VLSM允许不同子网用不同长度的子网掩码，可以保证子网的划分效率\nVLSM 提高了灵活性，可以更为高效地使用IP地址，进行更好的路由聚集\n\n路由聚集\n\n\n将尽可能多的相同位进行聚集，作为net位，一定有差异的位将其从网络位变为host位\n可以减少路由表的条目数，隔离拓扑变化\n用的是SIDR记法，异曲同工\n\nICMP\nInternet control message protocol，因特网控制报文协议\n为提高IP数据报交付成功的机会，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告\nICMP数据报的组成：数据报首部+IP数据报的数据\n一般路由器在丢弃报文时，会返回一个ICMP差错报文\n不发送的几种情况：\n对差错报文不再发送差错报文\n对第一个分片的后续报文后不发送（每次传输值发送一次）\n对多播数据报和具有特殊地址的数据报不发送\n\n\n\nTTL\nTime To Live，生存时间（更像跳数？）\n\n\n第五章：运输层port\n端口，用于一个主机传输多个进程数据时区分不同的进程，可以认为是一个指示符\n0-255：public，保留给TCP和UDP公共应用程序\n0-1023：熟知端口\n\nSocket\n套接字\n指电脑联网的一个连接口，表示为（IP address，port）。一个连接表示为（socket_sourse,socket_des)。\n表示为(IP_address, port)\n套接字对(socket source, socket destination)，是一个点对点的全双工通道\n通讯被认为是一个socket和另一个socket的连接\n\nTCP\nTransmission Control protocol，传输控制协议\n是面向连接的，带有确认机制，提供流量控制\n重传所有丢失的或出错的报文\n提供流控制\n\nUDP\nUser datagram protocol，用户数据报协议\n是无连接，不使用确认的，不进行流量控制\n直接丢弃错误报文\n\nTCP的三次握手建立连接\n第一次握手\n\n\n服务器：执行LISTEN和ACCEPT原语，并进行被动监视\n客户端：执行CONNECT原语，生成SYN &#x3D; 1和ACK &#x3D; 0的TCP段，代表连接请求\n\n\n第二次握手\n\n\n服务器检查是否存在监视端口的服务进程\n如果没有任何进程，请使用RST &#x3D; 1回答一个TCP段\n如果存在进程，则决定拒绝或接受请求\n如果接受连接请求，则发送SYN &#x3D; 1和ACK &#x3D; 1的网段\n\n\n\n\n第三次握手\n\n\n客户端发送一个SYN &#x3D; 0和ACK &#x3D; 1的段以确认连接\n为了避免出现延时之类的情况（如果只有两次会浪费服务器资源）\n\n\n通知上层应用，准备数据传输\n\n\n服务器收到确认后，会通知上层应用程序\n\n\n\n\n默认三次握手就认为可靠了，之后就进行数据传输\n有时候我们会选择，第三次握手的时候同时携带数据。\n\n\n\nARQ\nAutomatic Repeat reQuest，自动重传请求：是一种在OSI模型中数据链路层和传输层使用的错误纠正协议\n\n\nTCP的四次握手释放连接\n\n\n第一次：客户端 → 服务器， FIN &#x3D; 1\n第二次：服务器 → 客户端， ACK &#x3D; 1\n第三次：服务器 → 客户端， FIN &#x3D; 1， ACK &#x3D; 1\n第四次：客户端 → 服务器， ACK &#x3D; 1\n\nNAT\nnetwork address translation，网络地址转换\n是在IP数据包头中将一个地址交换为另一地址的过程，允许了私有地址（192.168.……）访问因特网，是IP地址耗尽的解决方法之一\n需要一个路由器：通过NAT表将局部地址与网络上的地址进行双向转换\n静态与动态\n静态NAT表一开始将内部地址与注册地址写死\n动态NAT以先到先得的方式动态进行\n\n\n可以使用少量全局唯一地址池服务大量私有寻址主机，但仍然是一一映射，同时接入有限\n\nPAT\nport address translation，端口地址转换\n采用端口多路复用方式，内部网络的所有主机均可共享一个合法外部 IP 地址实现对 Internet 的访问，从而可以最大限度地节约 IP 地址资源。\n同时，又可隐藏网络内部的所有主机，有效避免来自 internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式\n\n\n补充OSI\n（Open System Interconnect），开放式系统互连。\n\nFCS\nFCS（Frame Check Sequence）帧检测序列，俗称帧尾。\n在MAC最后4字节，采用是循环冗余校验（CRC）\n\nflow control\n流控制，对数据的传输进行控制、检查，发现出错后的处理\n\nRARP\nReverse Address Resolution Protocol，反向地址解析协议\n发出要反向解析的MAC地址并希望返回其对应的IP地址\n\nCIDR\nClassless Inter-Domain Routing，无类域间路由\n消除了传统ABC类地址以及划分子网的概念，可以将多个IP网络结合在一起，减少路由表中条目\n可以更有效的分配IPv4地址\nCIDR与路由汇总两者的功能的都是为了减少路由条目，将多个网络汇总为一个路由条目，但路由汇总一般是在主类网络的边界内进行,而CIDR可以合并多个网络,CIDR没有类的的概念,它是个纯数字概念。\nCIDR记法：在IPv4地址后面加斜杠，斜杠后跟网络前缀的位数。即：192.168.1.0 &#x2F; 24.这就是SIDR记法\n可读作“side r”\n与之相关的还有VLSM，路由聚集\n\nsplit horizon\n水平分割，避免Routing loops环路问题的方法之一，指从某个端口收到的报文信息，不能再从该端口发送回去。但如果告知一条更好的到达路径，是会接受的\n\nRouting Poisioning\n路由毒化，避免Routing loops环路的方法之一。如果不可达，则将条目置为16（大于最大跳数）跳到达，而非删除条目，之后在讲信息公布出去，使相邻路由器得知这条路由无效\n与之相关还有Hold-Down Timers\n详细：\n路由中毒(Route Poisoning)\n当网络5发生故障时，路由器E通过将网络5的表条目设置为16或不可访问来启动路由中毒。(而不是删除条目)\n、当路由器C从路由器E接收到路由中毒时，它会将更新(称为毒性逆转，poison reverse)发送回路由器E。这确保网段上的所有路由器都已接收到中毒的路由信息。\n最终所有的路由器都知道不可达\n路由毒害，由信息在路由表中失效的时候，把该表项的的度量值(metric)设为无穷大16，而不是马上从路由表中删掉这条路由信息，再将其信息发布出去，这样相邻的路由器就得知这条路由已无效了\n\n\n\nHold-Down Timers\n抑制定时器，一条路由信息无效后，一段时间内该路由处于抑制状态（不接收关于同一目的地址的路由更新），计时结束后一起删除该条目\n\nDNS\ndomain name system，域名系统。\n是因特网上作为域名和IP地址相互映射的一个分布式数据库。\n分为三级域名、二级域名和顶级域名。通过DNS服务器将域名转换为IP地址，然后访问\n\nHTTP\nHyperText Transfer Protocol，超文本传输协议，面向事务的无状态、无连接客户服务器协议\n“超文本”意味着更为丰富的内容\n和电视播放相似，通过浏览器界面显示内容，通过URL（统一资源定位符）进行切换\n\nURL\nUniform resource Locator，统一资源定位符，是对可以从因特网上得到的资源位置和访问方式的一种简洁表示。相当于一个文件名在网络范围的扩展&lt;URL的访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;\n\nHTML\nHyper Text Markup Language，超文本标记语言，定义了许多用于排版的命令，浏览器针对HTML文档中的各种标签，根据显示器尺寸与分辨率，重新排版并恢复所读取页面\n\nFTP\nFile Transfer Protocol，基于TCP实现的可靠的面向连接的文件传输服务\n\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。\nSMTP\nsimple mail transfer protocol，简单邮件传输协议，进行连接、登陆与发送邮件等操作\n\nDHCP\ndynamic host configuration protocol，动态主机配置协议。基于UDP实现的，可以高效分配IP地址\n过程：\nAB是两个Server\nClient先Discover去搜索\nServer返回一个Offer报文\nClient选择优先返回的Offer来优先服务\nClient进行广播，告知到底服务了谁\n然后B返回一个Ack报文\n到了时间之后，选择release或者续租\nAB的信息不对称不同步(局域网的地址B分配完成了但是A不知道，广播里面会携带分配的地址信息，告知A进行同步)\n\n\n\nSTP\nspanning tree protocol，生成树协议，该协议可应用于在网络中建立树形拓扑，消除网络中的环路，并且可以通过一定的方法实现路径冗余，但不是一定可以实现路径冗余\n\nPPP\npoint-to-point protocol，点对点协议。是一种标准的串行线路封装方式\n由IETF开发，用来替代SLIP，能在连接建立时检查链路质量，通过PAP（密码验证协议）和CHAP（询问握手验证协议）提供认证\nPAP（Password Authentication Protocol）：一方向另一方发送请求，另一方选择是否接受，双方有相同用户名和密码，发送方可多次尝试；密码明文发送\nCHAP（Challenge Handshake Authentication Protocol）：链路建立阶段结束之后，认证者向对端点发送“challenge”消息；对端点用经过单向哈希函数计算出来的值做应答；认证者根据它自己计算的哈希值来检查应答，如果值匹配，认证得到承认，否则连接应该终止；避免明文发送，密码密文发送比较安全，而且更加合理的设计\n\n\nPPP会话的建立：\n链接建立和配置协商（每个PPP设备发送LCP数据包）\n链接质量测试\n网络层协议配置（PPP设备发送NCP数据包来选择和配置网络层协议）\n链接终止（可以随时终止，并通知网络层协议）\n\n\n\nISDN\nIntegrated Service Digital Networks，综合服务数字网络，允许现有电话线传输数字信号，提供远程端点的连接。\nISDN BRI （Basic Rate Interface）端口用于 ISDN 线路通过路由器实现与 Internet 或其他远程网络的连接。\nISDN BRI 的三个通道总带宽为 144 kbps\n其中两个通道称为B（荷载 Bearer）通道，速率为 64 kbps，用于承载声音、影像和数据通信\n第三个通道是D（数据）通道，是16 kbps 信号通道，用于告诉公用交换电话网如何处理每个B通道\n\n\n\n\n\n\n\nADSL\nAsymmetric Digital Subscriber Line，非对称数字用户线路。\nxDSL是对模拟电话数据线进行改造，使其能承受宽带业务。ADSL——非对称用户数字线，上行（用户到ISP）和下行（ISP到用户）带宽不对等\n意义：使用户可以使用模拟电话线承受宽带业务\n\nVLAN\nvirtual LAN，虚拟局域网络，进行逻辑的网络设备或用户分组，来产生单一的广播域\n\n病毒\n病毒，编制或者在计算机程序中插入的破坏计算机功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码\n与之相关的还有\n计算机蠕虫（通过网络通信将自身从一节点发送到另一节点并启动）\n特洛伊木马（权限比声明高）\n逻辑炸弹（特定条件触发特殊功能）\n\n\n\nSMTP和POP3\n电子邮件服务器使用SMTP发送和POP接收邮件相互通信。\nSMTP (Simple Mail Transfer Protocol) SMTP(简单邮件传输协议)邮件发送，登录发送等操作\nPOP3 (Post Office Protocol version 3) 邮局协议版本3，邮件接收，邮件到达邮件服务端，由客户端和服务端联系接收邮件。\n\n\n\nMIME\nMultipurpose Internet Mail Extensions，多用途互联网邮件扩展类型\nMIME标准扩充了SMTP标准\n很多的文件(附件)并不是ASCII码的，我们需要用MIME将对应的文件进行转换(扩充)。过程如下图\n\nSNMP\n简单网络管理协议(SNMP，Simple Network Management Protocol)是一种应用程序层协议，可简化网络设备之间的管理信息交换。\nNMS(Network Management System):网管,通过下发请求对上网的所有的主机关于流量等等信息进行管理(监控)\n通过管理数据库(MIB)进行信息交流\n使用UDP通过广播进行实现。\n\nIGMP组管理协议称为IGMP协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。\nfirewall\n防火墙，是由硬件和软件构成的系统，是一种特殊编程的路由器，用于两个网络之间实施接入控制策略\n\nACL\naccess control list，访问控制列表，一些告诉路由哪些包该拒绝那些包能通过的序列集\n标准ACL放置在目的地路由（1-99以及1300-1999）；扩展ACL放在离江北拒绝数据流信源尽可能近的地方\n\nLSA\nLink-State Advertisement，链路状态通告。\n是链接状态协议使用的一个分组，它包括有关邻居和通道成本的信息。\n\n笔记 · 计网各类数据格式一、以太网的MAC帧结构（数据链路层MAC子层）\n1.1 preamble 前导码（8字节）\n固定为（7 * “10101010” + “10101011”）\n告知接受方有帧来了（缓冲作用）\n\n1.2 Dest add &amp; Source add 目标和源物理地址（各6字节）\n先放目的地址，目的地址可以是单播、组播、广播地址\n\n1.3 Length 长度（2字节）\n早期以太网标准：整个帧的长度\n以太网二代标准：曼彻斯特编码（有信号的时候有电平）使得接收方可以确定长度，所以这两个字节使用“Type”，标明后面的数据是哪个协议的要求\n\n1.4 Data数据1.5 FCS（4字节）\nframe check sequence，帧校验序列，用于循环冗余校验\n\n\n二、无线局域网的MAC帧结构\nad hoc(无基础设施)用地址4，有基础设施用的是地址1、2、3\n\n例子\n\n\n\n\n三、IPv4报文格式（网络层）报文结构：注意这里的单位是bit，不是字节![屏幕截图 2024-10-18 024313](C:\\Users\\HUAWEI\\Pictures\\Screenshots\\屏幕截图 2024-10-18 024313.png)\n\n首部部分分为固定部分和可变长部分，下主要讨论首部\n首部每4个字节（32bit）为一行，最大值为60字节，即15行\n\n3.1 版本号（4bit）\n值IP协议的版本号，目前IP协议版本号为4，即IPv4\n\n3.2 首部长度（4bit）\n4位：0~15，每单位为4字节，所以一次IP的首部长度最大为60字节\n首部长不定，所以需要标识\n\n3.3 服务类型（8bit）\n现在用于区分服务\n\n3.4 总长度（16bit）\n指首部和数据部分的长度之和\n\n3.5 标识（16bit）\n计数器，用于做报文分片，接受方依据此合并报文\n\n3.6 标志（3bit）\n最高位为0\nDF（Don’t fragement？）：是否允许做分片，0允许做分片，1不允许做分片\nMF（More fragment？）：MF为0表示最后一个分片,1是指后面还有分片\n\n3.7 片偏移（13bit）\n相同标识号的报文，根据片偏移进行重排，偏移小的靠前\n偏移以字节为单位\n\n3.8 生存时间（8bit）\n记为TTL（time to live），标识可通过路由器的最大值\n路由器每转发一次，就会对TTL-1，小于0则丢弃并告知发送方\n避免回路问题\n\n3.9 协议（8bit）\n指出此数据报携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个处理过程\n\n3.10 首部检验和（16bit）\n只检验首部\n\n3.11  源地址与目的地址（各4字节）\n四、TCP数据段格式\n一行共计4个字节，段首在前，固定首部长度为20字节\n\n4.1 源端口和目的端口（2字节）\n端口是运输层与应用层的服务接口\n运输层的复用和分用功能都要通过端口才能实现\n\n4.2 序号（4字节）\nTCP 传送的数据流中的每一个字节都编上一个序号\n序号字段的值指本报文段所发送的数据的第一个字节的序号\n通过序号字段做可靠传输的保证，指示的是一个TCP传输的bit编码，而不是地址。\n我们从小向大进行使用，如果使用到最大之后，我们会从小再次重新开始分配。\n\n4.3 确认号（4字节）\n是期望收到对方的下一个报文段的数据的第一个字节的序号\n确认对方的数据号(发送同时对上一次传输进行确认)\n体现出了全双工通信的优点，比如上回收到最后序号是700，那么确认号就是701\n\n4.4 数据偏移（4位）\n指出TCP报文段的数据起始处距TCP报文段的起始处的长度（Data部分从什么地方开始算）\n单位是32位字（以4字节为计算单位）\n不满足的话使用填充位保证为4字节的整数倍（保证对齐问题）\n\n4.5 保留字段（6位）\n保留为今后使用，目前置 0，说截止到现在也没有使用这部分的字段\n\n4.6 URG（urgent）\n紧急 URG &#x3D; 1时，表明紧急指针字段有效\n告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）\n\n4.7 ACK（acknowledge）\nACK &#x3D; 1 时确认号字段有效\nACK &#x3D; 0 时确认号字段无效\n正常连接以后一般都置1\n\n4.8 PSH（push）\n推送PSH（PuSH）——接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付，此时将缓存所有部分都传输，而并不是只将这个报文段的信息进行传输。\nTCP在正常条件下并不是立马传输的，首先要缓存满了才发送，其次还有就是要保证网络可信的时候才发送\n\n4.9 RST（ReSeT）\nReSeT &#x3D; 1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接\n就是重新来过，如果请求方发送的请求，如果应答方不想连接则将ReSet置为1\n\n4.10 SYN（synchronize）\n同步 SYN &#x3D; 1:表示这是一个连接请求或连接接受报文（初始的时候才出现）\n\n4.11 FIN（FINis）\n用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。(发送方没有传输数据了)\n\n4.12 窗口（2字节）\n用来让对方设置发送窗口的依据，单位为字节。\n\n表示可以进行传输的窗口大小是多少。\n\n（告诉接收方最多能发给我多长的数据）\n\n\n4.13 检验和（2字节）\n检验和字段检验的范围包括首部和数据这两部分\nIP报文中的地址等伪首部进行校验\n\n4.14 紧急指针（2字节）\n指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)\n\n4.15 选项（长度可变）\nTCP 最初只有一种选项，即最大报文段长度 MSS(Maximum Segment Size)\nMSS 告诉对方缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节\n数据字段加上 TCP 首部才等于整个的 TCP 报文段\n\n4.16 填充字段\n为使整个首部长度是4字节的整数倍\n\n五、UDP数据段格式\n\n\n8字节首部\n源端口、目的端口、长度、校验(data)、Data\n校验也要对data一并校验，如果出现错误，直接丢弃。\n计算检验和时，添加12位的伪首部（伪首部既不下传也不向上递交）\n伪首部包含源和目的的IP地址，表示UDP类型的字节、长度\n\n\n怎么判断是客户端发的还是服务端发的：\n看端口号的大小，0-255是保留的一般是服务端\n\n\n\n六、PPP帧格式PPP帧格式\n\n数字的单位是字节\n\n\nFlag: 01111110，0x7E 标记：帧的开头或结尾，01111110，一位可能会连续接受到多个帧\nAddress：11111111, 0xFF，广播地址\nControl：00000011, 0x03，用户数据作为无序帧传输\nProtocol: 数据字段中的协议类型\nData: 数据报，最大默认值为1500字节\nFCS: 2或者4字节，循环冗余校验位\n\n笔记 · 错题本\n三种交换方式\n\n电路交换\n电话交换机接通电话线的方式就是电路交换\n交换就是按照某种方式动态的分配传输线路资源\n电路交换的三个步骤\n建立连接（分配通信资源）\n通话（一直占用通信资源）\n释放链接（归还通信资源）\n\n\n缺点：当使用电路交换来传送计算机数据时，效率很低\n\n\n分组交换\n报文交换\n\n\n在STP中，10Mbps对应的cost为100\n\nsocket套接字：可以看做是网络通讯的接口，是应用层与TCP&#x2F;IP协议簇的中间层，允许两台设备之间通讯。常见的协议有TCP，UDP。\n\n三次握手，要注意每次发送的报文的关键位\n\n常见的使用TCP的协议：\n\nHTTP（超文本传输协议）\nHTTPS（安全的HTTP）\nFTP（文件传输协议）\nSMTP（简单邮件传输协议）\nPOP3（邮局协议版本3）\nTelnet（远程登录协议）\n\n\n常见使用 UDP 的协议：\n\nDNS（域名系统）\nDHCP（动态主机配置协议）\nTFTP（简易文件传输协议）\nSNMP（简单网络管理协议）\n\n\n\n2020年\n当用户在浏览器中首次输入网址并请求显示主页时，浏览器会经历一系列的步骤以获取并显示该页面。以下是简要描述这个过程的8个主要步骤：\n\n1. 域名解析 (DNS 查询)：\n用户输入的网址（例如 www.example.com）是一个域名，需要解析为服务器的 IP 地址。\n浏览器首先检查本地 DNS 缓存中是否已有该域名的 IP 地址。如果没有，它会向配置的 DNS 服务器发送查询请求，询问该域名对应的 IP 地址。\nDNS 服务器返回相应的 IP 地址，浏览器使用这个地址来与目标服务器建立连接。\n\n2. 建立 TCP 连接 (三次握手)：\n使用获得的 IP 地址，浏览器通过 TCP 协议与目标服务器建立连接。为了确保可靠性，TCP 使用三次握手过程：\n浏览器发送一个 SYN 请求，表示希望建立连接。\n服务器收到 SYN 请求后，发送 SYN-ACK 响应，表示同意建立连接。\n浏览器收到 SYN-ACK 后，发送 ACK 响应，连接建立成功。\n\n\n\n3. 发送 HTTP 请求：\n一旦 TCP 连接建立，浏览器通过 HTTP 协议向服务器发送请求，通常是一个 GET 请求，要求获取主页内容（如 GET / HTTP/1.1）。\n请求中包括一些头信息（如浏览器类型、语言偏好、缓存控制等）以及可能的 Cookies 信息。\n\n4. 服务器处理请求：\n服务器接收到请求后，处理请求并生成响应。这可能包括：\n查找请求的网页文件（例如 HTML 文件）。\n运行服务器端代码（如 PHP、Node.js 等）以动态生成网页内容。\n查询数据库等资源，生成最终的 HTML 内容。\n\n\n\n5. 服务器返回 HTTP 响应：\n服务器将生成的网页内容封装在 HTTP 响应中返回给浏览器。响应头包含状态码（如 200 表示成功），以及其他信息（如响应类型、内容长度等）。\n响应体部分包含网页的 HTML 代码。\n\n6. 浏览器解析 HTML 内容：\n浏览器接收到 HTTP 响应后，开始解析响应体中的 HTML 内容。浏览器会根据 HTML 标签结构逐步构建页面的 DOM（文档对象模型）树。\n同时，浏览器会解析页面中的外部资源（如 CSS 文件、JavaScript 文件、图片等）。\n\n7. 请求并加载外部资源：\n如果 HTML 内容中引用了外部资源（如 CSS 文件、JS 文件、图片等），浏览器会发出额外的 HTTP 请求，获取这些资源。\n每个外部资源的加载也需要通过 TCP 连接进行传输。\n\n8. 页面渲染与显示：\n当所有的资源都加载完毕，浏览器开始渲染页面。浏览器会结合 DOM 和 CSSOM（CSS对象模型）树，生成渲染树，并计算布局和样式，最后绘制到屏幕上。\n如果页面包含 JavaScript，浏览器还会执行 JavaScript 代码，这可能会修改 DOM 和样式，进而影响页面的呈现。\n\n\n\n\n可以从UDP帧的头部的端口号区分客户端和服务端\n\n消息是由客户端还是服务器发送的？通常情况下，端口号 53 是用于 DNS（域名系统）服务，用于查询域名。端口号 53 是 DNS 服务器监听的端口号。\n\n源端口号是 1586，而端口号 1586 通常不是 DNS 服务器的默认端口，因此可以推测消息是 由客户端发送，它向 DNS 服务器（目标端口号 53）发送请求。\n\n所以，消息是 由客户端发送的。\n\n消息涉及的网络服务类型？从目标端口号 53 可以推断，这个消息涉及到 DNS（域名系统）服务。DNS 使用 UDP 协议，通常用于解析域名和 IP 地址之间的映射。\n因此，消息涉及的网络服务是 DNS。\n\n\n\nTCP&#x2F;IP模型中的网络层协议提供的是？\n\n答案： A. 无连接且不可靠的分组服务解释：网络层（特别是IP）是无连接的且不可靠的。\n\n\n以下协议不属于网络层的是？\n\n答案： D. DHCP解释：DHCP（动态主机配置协议）属于应用层，而ICMP、IGMP和ARP都属于网络层。\n\n\n哪种网络地址转换（NAT）可以使一个IP地址允许多个用户连接到全球互联网？\n\n答案： D. PAT解释：端口地址转换（PAT）允许多个用户共享一个公共IP地址。\n\n\n什么组成了一个套接字？\n\n答案： B. IP地址和端口号\n\n\n以下哪个选项不是使用静态路由的优势？\n\n答案： A. 快速收敛（Fast convergence）解释：静态路由的收敛速度较慢，相比动态路由，静态路由通常不会自动调整。\n\n\n为什么交换机永远不会学习广播地址？\n\n答案： C. 广播地址永远不会是帧的源地址。解释：广播地址是发送给所有主机的，而不是特定的主机，因此交换机不会学习广播地址。\n\n\n哪种拓扑具有最高的可靠性？\n\n答案： D. 网状拓扑（  mesh topology）解释：网状拓扑通过多个冗余路径提供最高的可靠性。\n\n\n以下哪些陈述是正确的？\n\n\n\n答案： A、B、D解释：MAC地址是48位的，交换机使用MAC地址过滤流量，端口号可以在TCP段和UDP段的头部找到。\n\n\n指令ip route 172.16.3.0 255.255.255.0 192.168.2.4，注意：\n\n它建立了一条指向 172.16.3.0 网络的静态路由\n它使用默认的管理距离：静态路由的默认管理距离为 1。\n静态路由通常具有 最小的管理距离（1），如果有多个路由指向同一目的地，路由器会优先使用静态路由，除非有更具体的匹配。\n\n\nWAN操作的OSI模型层次是哪些？\n\n答案： E、F解释：WAN操作涉及到OSI模型的数据链路层和物理层。\n\n\n以下哪些服务使用TCP协议？\n\n答案： B、C、E解释：SMTP、HTTP和FTP使用TCP协议，而DHCP和TFTP使用UDP协议。\n\n\n一些熟知端口：\n\nHTTP\n\n端口号： 80\n协议： TCP\n说明： 用于网页浏览（Hypertext Transfer Protocol）。\n\nFTP（文件传输协议）\n\n端口号： 20（控制）&#x2F; 21（数据）\n协议： TCP\n说明： 用于文件传输（File Transfer Protocol），使用端口21来建立控制连接。\n\nTelnet\n\n端口号： 23\n协议： TCP\n说明： 远程登录协议，用于远程访问命令行界面。\n\nSMTP（简单邮件传输协议）\n\n端口号： 25\n协议： TCP\n说明： 用于发送电子邮件（Simple Mail Transfer Protocol）。\n\nDNS（域名系统）\n\n端口号： 53\n协议： TCP&#x2F;UDP\n说明： 用于解析域名到IP地址。\n\nDHCP（动态主机配置协议）\n\n端口号： 67（服务器端） &#x2F; 68（客户端）\n协议： UDP\n说明： 用于动态分配IP地址给客户端。\n\nTFTP（简单文件传输协议）\n\n端口号： 69\n**协议：**UDP\n说明： 提供简单的无连接的文件传输服务\n\n\n\n\n\n2019年\nIPv4为32位，IPv6为128 位。\nsocket的结构不单单只有IP地址和port端口。\n热点名词解释：\nPPP：\n点对点协议\nPPP是一种标准的串行线路封装方法，为点对点链路各种协议数据报提供了一个标准方法。\n通过密码认证协议(PAP)和质询握手认证协议(CHAP)提供认证。\n\n\nCSMA&#x2F;CD：\n带有冲突检测的载波侦听多路存取\n用于有线网络\n在主机发送数据前会检测总线是否有数据正在传输，若有则等一段时间后再来\n\n\nSMTP\n简单邮件传输协议\n负责邮件发送，将邮件从发送方传输到接收方的邮件服务器\n\n\nCHAP\n挑战握手认证协议\n通过三次握手周期性的校验对端的身份，在初始链路建立时完成，可以在链路建立之后的任何时候重复进行\n\n\nICMP\n因特网控制报文协议\n用于在IP主机、路由器之间传递控制消息。\n为了提高 IP 数据报交付成功的机会，允许主机或路由器报告差错情况和提供有关异常情况的报告\n\n\nTDM\n时分复用\n将时间等分为时分复用帧，每个用户在每个TDM帧中占用固定序号的时隙。\n每个用户所占用的时隙周期性出现\n所有用户在不同时间占用同样的频带宽度\n\n\nARP\n地址解析协议\n根据IP地址信息来获取MAC地址\n\n\nHTTP\n超文本传输协议\nHTTP 是面向事务的客户服务器协议。\n它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。\n\n\nHTML\n超文本标记语言\n定义了许多用于排版的命令，浏览器针对HTML文档中的各种标签，根据显示器尺寸与分辨率，重新排版并恢复所读取页面\n\n\nCIDR\n无类域间路由\n消除了传统ABC类地址以及划分子网的概念，可以将多个IP网络结合在一起，减少路由表中条目\n可以更有效的分配IPv4地址\n\n\nISP\n网络服务供应商\nISP从因特网管理机构申请多个IP地址、通信线路和路由器等设备。机构或个人通过ISP接入因特网。\nISP分为三层，在低层ISP可以解决的问题不会进入上层ISP，以此来进行流量分流\n\n\nURL\n统一资源定位符\n是因特网的万维网服务程序上用于指定信息位置的表示方法。\n\n\nMAC\n介质访问控制\nMAC子层负责决定哪一个设备可以在共享的通信介质（例如以太网或Wi-Fi）上发送数据。\n\n\n\n\nRIP表的更新\n描述通过透明网关访问 Web 站点的过程（以太网环境），也就是ARP或者RARP的过程。\nPC给路由器，路由器转发。\n注意，不同的帧的目的和源IP、MAC不一样\n未知的MAC用广播：FF;FF;FF;FF;FF;FF\n\n\n\n2010年***\nOSI各层协议：详见名词解释\n\nRouter和Switch\n\nRouter的组成部分，启动过程\nSwitch\n\n\nrouting and routed：记住IP是routed，（包括IPv4，IPv6，IPX），其他都是routing\n\n802.11a, 802.11b, 802.3\n\n802.11a\n类型: 无线局域网 (WLAN) 标准\n\n频段: 5 GHz\n\n最大速率: 54 Mbps\n\n信道带宽: 20 MHz\n\n特点\n:\n\n使用 5 GHz 频段，干扰较少，但穿透能力较弱。\n适用于对速度要求较高、干扰较少的环境。\n信号范围较短，适合小型室内环境。\n\n\n\n\n2. 802.11b\n类型: 无线局域网 (WLAN) 标准\n频段: 2.4 GHz\n最大速率: 11 Mbps\n信道带宽: 22 MHz\n特点:\n使用 2.4 GHz 频段，穿透能力较强，但易受干扰（如微波炉、蓝牙设备）。\n数据速率较低，但覆盖范围较广。\n是早期广泛使用的无线网络标准。\n\n\n\n\n3. 802.3\n类型: 有线局域网 (LAN) 标准\n频段: 不适用（有线）\n最大速率: 多种速率：\n10 Mbps（早期版本）\n100 Mbps (Fast Ethernet)\n1 Gbps (Gigabit Ethernet)\n10 Gbps 及以上（现代版本）\n\n\n传输介质: 双绞线、电缆或光纤\n特点:\n基于 CSMA&#x2F;CD (载波监听多路访问&#x2F;碰撞检测) 媒体访问控制机制。\n提供稳定、低延迟的有线网络连接。\n主要用于固定设备的高速网络连接。\n\n\n\n\n\n\n在交换机或路由器上，同一网段的两个端口可以是不同的冲突域.\n\n数冲突域和广播域的时候，数端口就好\n\nremote是主叫方，cenetral是被叫方。PAP是主叫方给出信息，CHAP是被叫方发起挑战\n\n\n小测\nAP的作用：让无线设备连接上无线网\n私有地址：\n10.开头所有\n172.16.0.0 ~ 172.31.255.255\n192.168.开头所有\n\n\n多播地址（组播地址）：224.0.0.0 ~ 239.255.255.255\nOSPF 中的 Type 1 LSA（Router LSA）是由每台路由器生成的，而 Router ID 就是用来标识该 LSA 来源的唯一标识符。\nOSPF端口选择：优先选择环回接口，然后选择IP大的逻辑端口。\n注意，在STP中是选择IP小的\n\n\nOSPF 路由器之间必须属于同一个子网（即 IP 地址和子网掩码匹配）。\n\n","categories":["课业"]},{"title":"计算机网络八股","url":"/2025/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/","content":"体系结构OSI七层模型\n\n\n层数\n名称\n中文名\n主要功能\n\n\n\n7\nApplication Layer\n应用层\n直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）\n\n\n6\nPresentation Layer\n表示层\n数据格式转换、加密、解密、压缩、解压缩\n\n\n5\nSession Layer\n会话层\n建立、管理和终止会话（通信连接）\n\n\n4\nTransport Layer\n传输层\n提供端到端的可靠传输（如 TCP、UDP，负责端口、分段、流量控制）\n\n\n3\nNetwork Layer\n网络层\n负责数据路由和转发（如 IP 协议，决定数据怎么走到目的地）\n\n\n2\nData Link Layer\n数据链路层\n负责相邻节点间可靠传输（如以太网，MAC 地址，帧同步）\n\n\n1\nPhysical Layer\n物理层\n物理介质上的比特流传输（如电缆、光纤、网卡、信号）\n\n\nTCP&#x2F;IP模型\n\n\n层数\n层名称（中文）\n层名称（英文）\n说明\n\n\n\n4\n应用层\nApplication Layer\n直接面向用户，提供各种网络应用服务，如网页、邮件、文件传输等\n\n\n3\n传输层\nTransport Layer\n提供端到端的通信服务，如可靠传输（TCP）或快速传输（UDP）\n\n\n2\n网络层\nInternet Layer\n负责数据包的路由和寻址，让数据包跨网络找到目的地，核心协议是 IP\n\n\n1\n网络接口层（或链路层&#x2F;物理层）\nNetwork Interface Layer（或 Link Layer）\n负责在物理网络上传输数据帧，如以太网、WiFi、ARP 等\n\n\n常见协议\n第1层：网络接口层（Network Interface Layer）\n\n主要功能：\n\n负责 数据在物理网络上的传输，比如通过 网线、光纤、无线信号（WiFi） 等。\n处理 MAC 地址（物理地址）、数据帧的封装与解封装、错误检测。\n包括 局域网技术（如以太网 Ethernet）、无线技术（如 Wi-Fi 802.11）、ARP（地址解析协议） 等。\n\n\n常见协议 &#x2F; 技术：\n\nEthernet（以太网）\nWi-Fi（802.11）\nARP（Address Resolution Protocol，地址解析协议）：将 IP 地址转换为 MAC 地址\nPPP（Point-to-Point Protocol，点对点协议）\n物理层相关：网卡、光纤、双绞线、信号调制等\n\n\n\n\n🔧 这一层关注的是：数据如何在具体的物理网络介质上传输。\n\n\n第2层：网络层（Internet Layer）\n\n主要功能：\n\n负责 数据包的路由与转发，让数据从源主机跨越多个网络，最终到达目标主机。\n使用 逻辑地址（IP 地址） 来标识设备。\n核心任务是：IP 寻址、路由选择、分组转发。\n\n\n常见协议：\n\nIP（Internet Protocol）：最核心的协议，包括 IPv4 和 IPv6\nICMP（Internet Control Message Protocol）：用于网络诊断，比如 ping命令就用了 ICMP\nIGMP（Internet Group Management Protocol）：用于组播管理\nARP（Address Resolution Protocol）：有时也被归入这一层，用于 IP → MAC 的映射\n\n\n\n\n\n\n IP 协议让数据包找到了“去哪里”，但不保证一定能送到或按顺序到达。\n\n\n第3层：传输层（Transport Layer）\n主要功能：\n提供 端到端（End-to-End）的通信服务，确保数据可靠传输或高效传输。\n负责 端口管理、数据分段、流量控制、错误恢复。\n区分不同应用程序的数据（比如浏览器和邮件软件同时运行）。\n\n\n常见协议：\nTCP（Transmission Control Protocol）：可靠的、面向连接的传输协议用于：网页（HTTP）、文件传输（FTP）、邮件（SMTP）、远程登录（SSH）等需要可靠性的场景特点：三次握手、流量控制、重传机制、保证顺序\nUDP（User Datagram Protocol）：不可靠的、无连接的传输协议用于：视频流、语音通话（VoIP）、在线游戏、DNS 查询等对实时性要求高、允许少量丢包的场景特点：无连接、速度快、不保证顺序和可靠\n\n\n\n\n\n\n🎯 传输层是真正实现“端口到端口通信”的地方，是应用层与网络层之间的桥梁。\n\n\n第4层：应用层（Application Layer）\n主要功能：\n直接面向用户或应用程序，提供各种网络服务和应用协议。\n负责处理 用户数据格式、用户接口、应用逻辑。\n包括我们日常使用的各种网络应用协议，如浏览网页、发送邮件、文件共享等。\n\n\n常见协议：\nHTTP &#x2F; HTTPS：用于网页浏览（HTTPS 是加密的 HTTP）\nFTP（File Transfer Protocol）：文件传输\nSMTP &#x2F; POP3 &#x2F; IMAP：电子邮件相关协议\nDNS（Domain Name System）：域名解析（比如把 www.baidu.com转成 IP 地址）\nTelnet &#x2F; SSH：远程登录协议（SSH 更安全）\nDHCP：动态主机配置协议（自动分配 IP 地址）\nSNMP：网络管理协议\n\n\n\n\n\n应用层HTTP\n是什么\n\nHTTP（HyperText Transfer Protocol），即 超文本传输协议。\n它是互联网上应用最广泛的一种 应用层协议，用来在 客户端（如浏览器）和服务器之间传输数据，主要是网页内容（如 HTML、图片、CSS、JS 等）。\n规定浏览器（客户端）和网站服务器之间如何“请求”和“响应”数据。\n\n\n工作原理\n\nHTTP 是基于 请求与响应（Request&#x2F;Response）模型 的：\n\n客户端（通常是浏览器） 发送一个 HTTP 请求（Request） 给服务器。\n服务器 收到请求后，处理并返回一个 HTTP 响应（Response） 给客户端。\n客户端接收响应并展示内容（比如显示网页）。\n\n\n这个过程是 无状态的（Stateless），也就是说，每次请求都是独立的，服务器默认不会记住你之前的请求（除非用 Cookie、Session 等机制）。\n\n\n\n\n工作流程\n\n浏览器通过 TCP 协议 与服务器建立连接（默认端口是 80）。\n\n浏览器发送一个 HTTP 请求，例如：\nGET /index.html HTTP/1.1Host: www.example.com\n\n意思是：请给我 /index.html这个页面，使用的是 HTTP 1.1 协议。\n\n服务器收到请求后，返回一个 HTTP 响应，例如：\nHTTP/1.1 200 OKContent-Type: text/html&lt;html&gt;...这里是网页内容...&lt;/html&gt;\n\n表示请求成功（状态码 200），并返回了 HTML 内容。\n\n浏览器接收到响应后，将 HTML 渲染成可视化的网页。\n\n\n\n特点\n1. \n\n\n\n\n特点\n说明\n\n\n\n无状态（Stateless）\n每次请求互相独立，服务器不记录之前的交互（除非使用 Cookie&#x2F;Session）\n\n\n基于请求-响应模型\n客户端发起请求，服务器返回响应\n\n\n简单、灵活\n易于实现，支持多种数据类型（文本、图片、视频等）\n\n\n明文传输（不加密）\n数据以 明文形式在网络中传输，容易被窃听或篡改 ⚠️\n\n\n默认端口是 80\n当你访问 http://xxx时，一般使用 80 端口通信\n\n\n\n\n\n\nHTTPS\n是什么\n\nHTTPS（HyperText Transfer Protocol Secure） 是 HTTP 的安全版本，它在 HTTP 的基础上加入了 SSL&#x2F;TLS 协议，通过 加密、身份认证和数据完整性校验 来保护客户端与服务器之间的通信。\n\n\n解决了什么问题\n\n在传统的 HTTP 通信中，主要存在以下三大安全隐患：\n**窃听风险（Confidentiality）**数据在传输过程中可能被第三方监听，比如密码、个人信息等。\n**篡改风险（Integrity）**数据在传输途中可能被恶意修改，而通信双方无法察觉。\n**冒充风险（Authentication）**客户端可能连接到假的服务器（如钓鱼网站），服务器也可能被冒充。\n\n\nHTTPS 通过 SSL&#x2F;TLS 协议解决了这三个问题：\n加密通信内容，防止窃听；\n使用消息认证码（MAC）等机制保证数据完整性；\n通过数字证书验证通信双方的身份。\n\n\n\n\n核心技术\n\n对称加密（Symmetric Encryption）\n加密和解密使用同一个密钥，效率高，互信安全。\n但是如果对所有客户端都用同一个Key，就没用了；如果都唯一生成Key，服务端保存不了\n\n\n非对称加密（Asymmetric Encryption）\n使用一对密钥：公钥（public key）和私钥（private key）。\n公钥加密的内容只能用私钥解密，反之亦然。用于安全地交换对称密钥，或进行身份验证。\n非对称加密代价高\n\n\n数字证书（Digital Certificate）\n由权威的 CA（Certificate Authority，证书授权机构） 颁发。证明服务器的身份，包含服务器的公钥及身份信息，并经过 CA 私钥签名。客户端通过验证证书来确认服务器是否可信。用以解决中间人问题。\n\n\nSSL&#x2F;TLS 协议是 HTTPS 的核心，负责加密通信的建立过程（握手）、密钥交换、数据加密传输等。\n\n\n工作流程\n\n步骤 1：TCP 三次握手\n\n客户端与服务器先建立普通的 TCP 连接（这是所有应用层协议的基础）。\n\n\n步骤 2：TLS （Transport Layer Security，传输层安全协议）握手（核心步骤）\n\n目标是先用非对称加密协商出一个对称加密密钥，并验证对方身份。\n\n\nClient Hello：客户端向服务器发起请求，告知：\n支持的 TLS 版本\n支持的加密算法（Cipher Suites）\n随机数 Client Random\n\n\nServer Hello：服务器回应：\n选择的 TLS 版本和加密算法\n随机数 Server Random\n数字证书（含服务器公钥）\n（可选）服务器也可能会要求客户端证书（双向认证）\n\n\n客户端验证证书：客户端用 CA 的公钥（预装在操作系统&#x2F;浏览器中） 验证服务器证书的合法性：\n证书是否过期\n是否被吊销\n是否由受信任的 CA 签发域名\n是否匹配\n如果证书合法，提取出服务器的公钥。\n\n\n生成 Pre-Master Secret：客户端生成一个随机数：Pre-Master Secret，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。\n双方计算对称密钥：客户端和服务器根据以下三个随机数：Client Random，Server Random，Pre-Master Secret通过特定算法（如 PRF）计算得出相同的 对称密钥（Session Key），用于后续通信的加密。\n握手完成双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。\n\n\n🎯 为什么不用非对称加密传输全部数据？\n非对称加密计算开销大，效率低。对称加密速度快，适合大量数据传输。因此 HTTPS 利用非对称加密安全地传递对称密钥，之后用对称加密传输数据。\n\n\n\n\n\n传输层TLS\n是什么\n\nTLS（Transport Layer Security，传输层安全协议）是一种加密通信协议，用于在互联网上安全地传输数据，防止数据被窃听、篡改或冒充。它为像 HTTP 这样的应用层协议提供了加密、身份认证和数据完整性保护。\n\n\n背景\n\nSSL（Secure Sockets Layer，安全套接层） 是 TLS 的前身，最早由网景公司（Netscape）在1990年代初期提出，用于保护 Web 通信。\n后来由于安全漏洞等问题，SSL 的多个版本（如 SSL 2.0、SSL 3.0）陆续被废弃。\nTLS 1.0 于 1999 年作为 SSL 3.0 的升级替代版 被提出，之后发展出：TLS 1.1（2006年）TLS 1.2（2008年，目前广泛使用）TLS 1.3（2018年，最新、最安全、性能最好，强烈推荐）\n\n\n 现在应该避免使用 SSL，因为它已被证明是不安全的。我们现在说的“SSL”，很多其实指的是 TLS，比如“SSL 证书”其实就是“TLS 证书”。\n\n\n核心作用\n\n\n\n\n功能\n说明\n为什么重要\n\n\n\n加密（Encryption）\n对传输的数据进行加密，防止被第三方窃听\n保护隐私，比如密码、银行卡号等敏感信息\n\n\n身份认证（Authentication）\n通过数字证书验证通信双方的身份，防止中间人冒充\n确保你连接的是真正的网站，而不是钓鱼网站\n\n\n数据完整性（Integrity）\n确保传输的数据没有被篡改\n防止数据在传输过程中被恶意修改\n\n\n\n\n\n工作流程\n\n步骤 1：客户端发起 Hello\n客户端告诉服务器：\n\n我支持哪些 TLS 版本\n我支持哪些加密算法\n我生成了一个随机数（Client Random）\n\n\n步骤 2：服务器回应 Hello\n服务器选择：\n\n一个 TLS 版本\n一组加密算法\n返回自己的随机数（Server Random）\n自己的数字证书（含公钥）\n\n\n步骤 3：客户端验证证书\n\n客户端用本地信任的 CA（证书颁发机构）公钥，验证服务器证书是否合法，提取公钥。\n\n\n步骤 4：生成对称密钥\n\n客户端生成一个“预备主密钥”（Pre-Master Secret），用服务器的公钥加密后传给服务器。\n然后双方根据 Client Random、Server Random 和 Pre-Master Secret，计算出相同的对称密钥（Session Key）。\n\n\n步骤 5：通信加密\n\n握手完成后，双方使用对称密钥加密实际传输的数据（如 HTTP 请求和响应），通信正式开始，安全又高效 ✅\n\n\n\n\n为什么不一直用非对称加密？因为非对称加密很慢，对称加密快，适合大数据量传输。\n\n\n\n哈希算法\n是什么：哈希算法（Hash Algorithm）是一种将任意长度的输入数据，通过特定计算，生成一个固定长度的、唯一性标识（通常称为“哈希值”或“摘要”）的算法。\n\n关键特性：\n\n\n\n\n\n特性\n说明\n\n\n\n确定性\n相同的输入，总是产生相同的哈希值\n\n\n快速计算\n输入数据后，可以快速计算出哈希值\n\n\n不可逆性（单向性）\n你无法从哈希值反推出原始数据\n\n\n雪崩效应\n输入数据的微小变化，会导致哈希值发生巨大改变\n\n\n固定长度输出\n不管输入是 1bit 还是 1GB，输出的哈希值长度固定（如 256 位）\n\n\n数字签名\n为了保证获得服务端公钥的正确性，服务端公钥需要由CA证书认证。\n为了保证CA公钥的正确性，需要由根证书认证\n为了保证根证书的正确性，直接安装在操作系统中。\n\nTCPUDP网络层IP\n是什么\nIP 协议（Internet Protocol，互联网协议）是 TCP&#x2F;IP 协议簇中最重要的网络层协议，它负责在互联网上为数据包提供逻辑寻址（IP 地址）、路由选择和跨网络传输，是实现主机之间互联互通的基础。\n\n\n主要功能\n逻辑寻址（Logical Addressing）\n每台联网设备都会分配一个 IP 地址，用于在网络中唯一标识该设备。\nIP 地址让数据包知道 “要发给谁”（哪个网络中的哪台设备）。\n\n\n路由与转发（Routing &amp; Forwarding）\n当数据包需要跨网络传输时（比如从你家到某个网站服务器），IP 协议会决定数据包该经过哪些 路由器（Router），最终到达目标。\n每个路由器根据 IP 地址 做出转发决策，选择最优路径。\n\n\n分组传输（Packet Switching）\nIP 协议将数据分割成一个个小的数据单元，称为 IP 数据包（或 IP 包 &#x2F; 数据报），每个包都包含：源 IP 地址目标 IP 地址其他控制信息\n这些包可以 独立地在网络中传输，并在终点重新组装。\n\n\n跨网络通信（Inter-network Communication）\nIP 协议使得不同类型的物理网络（如以太网、WiFi、光纤）能够互相连接，组成一个统一的互联网。\n\n\n\n\n\n\n\n\n项目\nIP 地址\nMAC 地址\n\n\n\n全称\nInternet Protocol Address\nMedia Access Control Address\n\n\n作用\n用于在 网络层 标识设备，用于跨网络寻址\n用于在 数据链路层（局域网） 标识设备，用于直接通信\n\n\n类型\n逻辑地址（可变，可配置）\n物理地址（固化在网卡中，全球唯一）\n\n\n格式\n点分十进制，如 192.168.1.1\n16 进制，如 00:1A:2B:3C:4D:5E\n\n\n工作范围\n跨网络（互联网）\n局域网内（如家庭、公司网络）\n\n\n谁管理\n由网络管理员或 DHCP 分配\n由网卡厂商固化，全球唯一\n\n\nARP\n是什么\nARP（Address Resolution Protocol，地址解析协议）是一个用于将 IP 地址解析为 MAC 地址的通信协议，它工作在 TCP&#x2F;IP 模型的 网络接口层（或数据链路层），是实现局域网内设备互相通信的重要基础协议。\n\n\n为什么需要ARP\n你访问 www.baidu.com，其实是访问它的 IP 地址\n但数据包在 局域网中传输时，并不是通过 IP 地址直接找到对方，而是通过 MAC 地址\n\n\n工作原理\nARP 的工作原理\n场景：主机 A 想给同一局域网内的 主机 B（IP 已知）发送数据\n主机 A 检查自己的 ARP 缓存表。如果已经缓存了 目标 IP对应的 MAC 地址，那就直接使用，不用再问。\n如果缓存中没有该 IP 的 MAC 地址，主机 A 就会发送一个 ARP 请求广播包：内容大致是：“请问，IP 地址是 192.168.1.100 的设备，你的 MAC 地址是多少？”这个 ARP 请求是以 广播形式 发送到当前局域网内的 所有设备。\n局域网中的所有设备都会收到这个 ARP 请求，但只有 IP 地址匹配的设备（主机 B）会响应：主机 B 回复一个 ARP 响应包 给主机 A，内容是：“我的 IP 是 192.168.1.100，我的 MAC 地址是 00:1A:2B:3C:4D:5E”。\n主机 A 收到响应后，就把这个 IP ↔ MAC 的对应关系保存到自己的 ARP 缓存表中，下次再访问这个 IP 时，就不用再问了。\n然后主机 A 就可以使用这个 MAC 地址，将数据包正确地发送到主机 B。\n\n\n\n\n\n八股体系结构简述OSI七层模型简述TCP&#x2F;IP四层模型简述五层模型计算机综合浏览器输入URL到渲染主页的过程\nURL 解析\nDNS解析：将域名转换为IP地址。\nTCP连接：与服务器建立TCP三次握手连接（HTTPS还需TLS握手）。\nTLS链接（如果是HTTPS）\n发送HTTP请求：浏览器发送请求报文到服务器。\n服务器处理：服务器返回HTML响应。\n渲染页面：浏览器解析HTML，构建DOM树，加载CSS&#x2F;JS，渲染布局和绘制。\n\nDNS解析过程\n全流程\n\n本地电脑：用户输入域名 → 检查本地缓存 → 本地无缓存 → ↓|  向配置的DNS服务器（如8.8.8.8）发起查询 // 递归查询↓本地DNS服务器↓|  向其他DNS服务器发起查询  // 迭代查询↓根DNS服务器（.）→ 返回 .com TLD 服务器地址 ↓.com TLD 服务器 → 返回 example.com 权威DNS地址 ↓权威DNS服务器 → 返回 www.example.com 的IP ↓浏览器拿到IP，发起TCP连接访问网站！\n\n\n递归查询（Recursive Query）\n\n定义：\n\n客户端（或本地DNS服务器）只发起一次请求，由DNS服务器（通常是递归DNS服务器）负责完成整个查询过程，并返回最终结果。\n适用于普通用户（如你的电脑向ISP的DNS服务器查询）。\n\n\n流程（以用户查询 www.example.com为例）：\n\n你的电脑向 本地DNS服务器（如ISP的DNS或8.8.8.8）发起 递归查询（请求：请帮我查 www.example.com 的IP）。\n本地DNS服务器接到请求后，自己负责去根DNS、TLD、权威DNS逐层查询，直到拿到最终IP。\n本地DNS服务器把 最终IP返回给你的电脑，你的电脑 不需要再做其他查询。\n\n\n特点：\n\n\n\n用户只需发起一次请求，DNS服务器负责全部查询。\n\n适用于普通用户（如家庭宽带、手机上网）。\n\n递归DNS服务器（如8.8.8.8、114.114.114.114）通常提供递归查询服务。\n\n\n\n\n迭代查询（Iterative Query）\n\n定义：\nDNS服务器不会直接返回最终结果，而是返回下一个可能知道答案的DNS服务器地址，由客户端（或上一级DNS）继续查询。\n适用于DNS服务器之间的查询（如根DNS、TLD、权威DNS之间的交互）。\n\n\n\n\n流程（以本地DNS服务器查询 www.example.com为例）：\n\n你的本地DNS服务器向 根DNS服务器查询 www.example.com。根DNS服务器不知道具体IP，但知道 .comTLD服务器的地址，于是 返回 .comTLD服务器的IP。\n本地DNS服务器再向 .comTLD服务器查询 www.example.com。.comTLD服务器不知道具体IP，但知道 example.com的权威DNS服务器地址，于是 返回 example.com权威DNS的IP。\n本地DNS服务器再向 example.com权威DNS服务器查询 www.example.com。权威DNS服务器直接返回 www.example.com的IP。\n最终，本地DNS服务器把IP返回给你的电脑。\n\n\n特点：\n\nDNS服务器之间互相“踢皮球”，每一步只返回下一个可能知道的服务器。\n适用于DNS服务器之间的查询（如根→TLD→权威）。\n你的电脑通常不直接使用迭代查询，而是依赖递归DNS服务器（如8.8.8.8）帮你完成。\n\n\n\nIP协议简述IP协议作用负责网络层数据传输，提供：\n\n逻辑寻址（通过IP地址定位设备）。\n路由选择（指导数据包跨网络传输路径）。\n无连接、不可靠的数据包交付（不保证顺序或到达，依赖上层协议如TCP）。\n\n简述ARP工作流程地址解析协议（ARP）用于将IP地址映射为MAC地址：\n\n主机广播ARP请求（询问“谁是IP X？请回复MAC”）。\n目标主机收到后单播回复自己的MAC地址。\n发送方缓存该映射（ARP表），后续直接使用。（注：同一局域网内有效，跨网段需通过网关。）\n\nHTTP（S）协议GET和POST的区别\n\n\n对比项\nGET\nPOST\n\n\n\n请求方式\n从服务器 获取数据（幂等）\n向服务器 提交数据（非幂等）\n\n\n数据位置\n数据放在 URL 参数（?key=value）\n数据放在 请求体（Body）\n\n\n数据可见性\n可见（URL 可见，可被缓存、历史记录保存）\n不可见（Body 不直接暴露）\n\n\n数据大小限制\n较小（通常 ≤ 2KB~8KB，取决于浏览器&#x2F;服务器）\n较大（理论上无限制，但服务器可配置）\n\n\n缓存\n可被缓存（浏览器、代理服务器可缓存）\n默认不被缓存\n\n\n安全性\n较低（参数暴露在 URL）\n相对较高（但 HTTPS 才是真正安全的）\n\n\n用途\n获取数据（如搜索、加载页面）\n提交数据（如登录、表单提交）\n\n\nHTTP报文结构\nHTTP 报文分为 **请求报文（Request）**和 响应报文（Response），基本结构类似：\n\n\n请求报文（Request）\n\nGET /index.html HTTP/1.1      // 请求行（方法 + URL + 协议版本）Host: www.example.com         // 请求头（Header）User-Agent: Mozilla/5.0Accept: text/htmlCookie: sessionid=123（空行）（可选请求体 Body，如 POST 数据）\n\n\n组成部分：\n\n请求行（Request Line）：方法（GET/POST） + URL + HTTP版本。注意，URL不包含域名。\n\n请求头（Headers）：键值对\n\n** Host（目标服务器）**\n\n意义：\n\n提供访问域名\n\n没有 Host，服务器不知道你要访问哪个域名（比如 example.com还是 api.example.com）。\n\n\n\n例子：\n\n\nGET / HTTP/1.1Host: www.example.com  # 告诉服务器你要访问哪个网站\n\n\n\n** User-Agent（浏览器&#x2F;设备信息）**\n\n意义：\n\n服务器可以根据 浏览器类型、操作系统、设备返回不同的内容（比如移动端适配）。\n用于 统计分析（如 Google Analytics 统计用户使用的浏览器）。\n\n\n例子：\n\n\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X)  # 表示是 iPhone 浏览器\n\n\n\n** Accept（接受的响应类型）**\n\n意义：\n\n客户端告诉服务器 它能处理哪些格式（如 text/html、application/json）。\n服务器可以据此 返回最适合的数据格式（比如 API 可以返回 JSON 而不是 HTML）。\n\n\n例子：\n\n\nAccept: application/json  # 客户端希望服务器返回 JSON\n\n\n\n** Cookie（发送会话信息）**\n\n意义：\n\n客户端把 之前服务器设置的 Cookie发回去，用于 维持登录状态、用户偏好。\n是 **会话管理（Session）**的关键机制。\n\n\n例子：\n\n\nCookie: sessionid=abc123; user_prefs=dark_mode  # 携带会话 ID 和用户偏好\n\n\n\nAuthorization（身份认证）\n\n意义：\n\n用于 登录、API 访问控制（如 Bearer Token、Basic Auth）。\n服务器验证后决定是否允许访问。\n\n\n例子：\n\n\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # JWT Token 认证\n\n\n空行（CRLF）：分隔头部和 Body\n\n请求体（Body）（可选）：POST&#x2F;PUT 等方法携带的数据\n\n\n\n\n\n\n响应报文（Response）\n\nHTTP/1.1 200 OK               // 状态行（协议版本 + 状态码 + 状态文本）Content-Type: text/html       // 响应头（Header）Content-Length: 1234Set-Cookie: sessionid=456（空行）&lt;html&gt;...（响应体 Body）&lt;/html&gt;\n\n组成部分：\n\n状态行（Status Line）：HTTP版本 + 状态码（200/404/500） + 状态文本\n响应头（Headers）：键值对（如 Content-Type, Set-Cookie）\n空行（CRLF）：分隔头部和 Body\n响应体（Body）：返回的 HTML、JSON 等数据\n\nHTTPS工作流程***\n主要介绍TCL连接流程\n\n目标是先用非对称加密协商出一个对称加密密钥，并验证对方身份。\n\n\n\nClient Hello：客户端向服务器发起请求，告知：\n支持的 TLS 版本\n支持的加密算法（Cipher Suites）\n随机数 Client Random\n\n\nServer Hello：服务器回应：\n选择的 TLS 版本和加密算法\n随机数 Server Random\n数字证书（含服务器公钥）\n（可选）服务器也可能会要求客户端证书（双向认证）\n\n\n客户端验证证书：客户端用 CA 的公钥（预装在操作系统&#x2F;浏览器中） 验证服务器证书的合法性：\n证书是否过期\n是否被吊销\n是否由受信任的 CA 签发域名\n是否匹配\n如果证书合法，提取出服务器的公钥。\n\n\n生成 Pre-Master Secret：客户端生成一个随机数：Pre-Master Secret，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。\n双方计算对称密钥：客户端和服务器根据以下三个随机数：Client Random，Server Random，Pre-Master Secret通过特定算法（如 PRF）计算得出相同的 对称密钥（Session Key），用于后续通信的加密。\n握手完成双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。\n\nSession和Cookie\n基本概念\nCookie（客户端存储）\n是什么：服务器通过 Set-Cookie响应头让浏览器存储的小段数据（通常 ≤ 4KB）。\n存储位置：浏览器（客户端）（每次请求自动发送）。\n用途：记住登录状态（如 sessionid=123）。用户偏好（如语言、主题）。\n特点：明文存储。可设置过期时间。默认不安全。\n\n\nSession（服务器存储）\n是什么：服务器存储的用户会话数据（如 session_id → 用户信息）。\n存储位置：服务器（如内存、Redis、数据库）。\n用途：维持登录状态。存储临时数据。\n特点：更安全（敏感数据在服务器）。依赖 Cookie 或 URL 传递 session_id（如 PHPSESSID=abc123）。服务器需管理生命周期（过期清理）。\n\n\n\n\n\n状态码\n\n\n类别\n第一位数字\n含义\n常见场景\n\n\n\n1xx\n100-199\n信息性状态码\n请求已接收，继续处理（较少使用）\n\n\n2xx\n200-299\n成功状态码\n请求成功，服务器正常处理\n\n\n3xx\n300-399\n重定向状态码\n需要客户端进一步操作（如跳转）\n\n\n4xx\n400-499\n客户端错误\n请求有误（如 404 找不到页面）\n\n\n5xx\n500-599\n服务器错误\n服务器处理请求时出错\n\n\n\n4xx（客户端错误）\n\n\n\n\n状态码\n名称\n含义\n常见原因\n\n\n\n400 Bad Request\n错误请求\n请求语法错误（如参数缺失、格式不对）\nJSON 格式错误、缺少必填字段\n\n\n401 Unauthorized\n未授权\n需要登录（未提供有效的身份验证）\n未带 Token 或 Cookie\n\n\n403 Forbidden\n禁止访问\n有权限问题（登录了但无权访问）\n普通用户访问管理员页面\n\n\n404 Not Found\n未找到\n请求的资源不存在\n访问不存在的页面（如 /nonexistent）\n\n\n429 Too Many Requests\n请求过多\n限流（短时间内发送太多请求）\nAPI 调用频率超限\n\n\n\n5xx（服务器错误）\n\n\n\n\n状态码\n名称\n含义\n常见原因\n\n\n\n500 Internal Server Error\n服务器内部错误\n服务器代码出错（如 Python&#x2F;Java 异常）\n后端代码崩溃\n\n\n502 Bad Gateway\n网关错误\n代理服务器（如 Nginx）收到无效响应\n后端服务（如 Tomcat）崩溃\n\n\n503 Service Unavailable\n服务不可用\n服务器暂时过载或维护\n网站维护中\n\n\n504 Gateway Timeout\n网关超时\n代理服务器等待后端响应超时\n后端处理太慢\n\n\nTCP &#x2F; UDPTCP和UDP区别\n\n\n对比项\nTCP（传输控制协议）\nUDP（用户数据报协议）\n\n\n\n协议类型\n面向连接（可靠传输）\n无连接（不可靠传输）\n\n\n连接方式\n三次握手建立连接，四次挥手断开\n直接发送数据，无需连接\n\n\n可靠性\n可靠（确保数据完整、有序到达）\n不可靠（可能丢包、乱序）\n\n\n数据顺序\n保证顺序（按发送顺序到达）\n不保证顺序（可能乱序）\n\n\n流量控制\n有（避免发送过快导致接收方缓冲区溢出）\n无\n\n\n拥塞控制\n有（动态调整发送速率）\n无\n\n\n传输速度\n较慢（因握手、确认、重传等机制）\n较快（无额外控制机制）\n\n\n头部大小\n20~60字节（较复杂）\n8字节（非常轻量）\n\n\n适用场景\n需要可靠传输的应用（如网页、文件传输、邮件）\n实时性要求高的应用（如视频、语音、游戏）\n\n\n典型协议&#x2F;应用\nHTTP、HTTPS、FTP、SSH、Email\nDNS、视频会议（Zoom）、在线游戏、VoIP（Skype）\n\n\nUDP如何保证消息不丢失\nUDP不保证消息不丢失。\n如果希望UDP可靠，可以在应用层实现\n\n三次握手，为什么不是两次或四次握手\n为什么不是两次？\n\n本质是考虑数据报的丢失\n假设：TCP 只用两次握手（客户端 SYN → 服务器 SYN-ACK）\n问题：无法防止“历史连接”导致的资源浪费！\n*场景：\n客户端之前发送了一个连接请求，但由于 网络延迟，这个包 很久才到达服务器。\n客户端早就 放弃了这次连接（超时重传或主动关闭），但 服务器现在才收到这个旧的 SYN。\n如果只有两次握手：服务器收到 SYN 后，会 直接认为这是一个新连接，并分配资源（如内存、端口）。服务器回复 SYN-ACK，然后等待客户端的 ACK（但客户端根本不会回复，因为它已经放弃了）。\n结果：服务器一直等待，浪费资源（内存、端口、CPU），形成 “半连接”。\n\n\n三次握手如何解决？\n第三次握手（客户端 → 服务器 ACK）是 客户端对服务器 SYN 的确认。\n如果客户端不发送第三次握手（说明它根本不想要这个连接），服务器 不会真正建立连接，避免资源浪费。\n只有双方都确认了对方的初始序列号，连接才算真正建立。\n\n\n结论：\n\n\n两次握手无法防止“历史无效连接”占用服务器资源。\n三次握手确保双方都“真心想连接”，避免无效连接占用系统资源。\n\n\n为什么不是四次\n\n假设：TCP 用四次握手\n\n问题：第三次握手已经足够，第四次是多余的！\n\n三次握手已经完成的任务：\n\n客户端 → 服务器 SYN（客户端说：“我想连接，我的序号是 x。”）。\n服务器 → 客户端 SYN-ACK（服务器说：“我同意，我的序号是 y，我收到了你的 x。”）。\n客户端 → 服务器 ACK（客户端说：“我收到了你的 y，我准备好了。”）。\n\n\n此时：\n\n双方都已经确认了对方的初始序列号（ISN）。\n\n连接已经可以安全传输数据。\n\n\n\n\n\n第四次握手的作用？\n\n服务器再发一个 ACK 给客户端？→ 完全没必要，因为客户端已经确认了服务器的 SYN（第三次握手）。\n这样只会增加 1 个 RTT（往返时间），降低连接效率。\n\n\n结论：\n\n三次握手已经足够保证可靠性，四次握手不会带来额外好处，反而降低效率。\n\n\n\n\n\n为什么需要四次挥手\n回顾一下四次挥手的过程就知道了。本质还是考虑数据报的丢失。\n客户端请求断开连接时，服务端可能还在发送数据。必须要等他发送完。\n服务端如果不等待客户端的确认，可能导致客户端的半连接。\n\n为什么要等待2MSL，才进入CLOSE\nMSL（Maximum Segment Lifetime）是指一个TCP报文段在网络中最长可以存活的时间。超过这个时间，该报文段就会被网络丢弃。\n在 第四次挥手后，客户端不会立刻关闭连接，而是进入 TIME_WAIT状态（等待 2MSL）\n防止服务端没有收到断开确认\n\n\n如果服务端没有收到断开确认，会在一定时间后重发FIN报文。客户端就是要等待这个报文。\n如果不等，但是服务端又没有收到断开确认，会导致断开失败。\n如果服务器在这个期间挂了怎么办？\n一般情况下，不会对客户端产生实质性的负面影响，客户端仍然会正常结束 TIME_WAIT 状态。\n既然服务端挂了，就不会重发FIN了，客户端就会在2MSL自然断开连接\n\n\n\nTCP如何保证可靠性\n\n\n机制\n作用\n解决的问题\n\n\n\n确认应答（ACK）\n接收方通知发送方数据已收到\n防止数据丢失，确保送达\n\n\n超时重传\n没收到ACK就重发数据\n应对丢包\n\n\n序列号\n给每个字节编号，用于排序和去重\n保证顺序、去重\n\n\n确认号\n告诉发送方下一次该发哪个字节\n精准控制发送\n\n\n滑动窗口\n动态控制发送速率，匹配接收能力\n流量控制，防止接收方过载\n\n\n拥塞控制\n根据网络状况调整发送速率\n避免网络拥堵，提高整体性能\n\n\n校验和\n检测数据在传输中是否损坏\n数据完整性保护\n\n\n\n确认应答机制（ACK - Acknowledgement）\n\n原理：发送方每发送一段数据，接收方收到后都会返回一个 ACK（确认报文），表示已经成功收到该数据。\n作用：发送方通过是否收到 ACK 来判断数据是否成功到达对端。如果没有收到 ACK，发送方会认为数据可能丢失，进而重传。\n\n\n超时重传机制（Retransmission Timeout, RTO）\n\n原理：发送方在发出数据后，会启动一个定时器，如果在规定时间内（超时时间，RTO）没有收到对应的ACK，就认为该数据包可能丢失了，于是重新发送该数据。\n\n\n序列号机制（Sequence Number）\n\n原理：TCP 会给每个字节都分配一个唯一的编号，称为 序列号（Sequence Number），而不是针对每个数据包。\n\n\n确认号机制（Acknowledgement Number）\n\n\n\n原理：接收方在回复 ACK 时，会告诉发送方：“我已经成功收到了序号 X 之前的所有数据，你下一个可以发送序号 X 的数据”。\n作用：让发送方知道哪些数据已经被成功接收，从而避免不必要的重传，提高效率。\n\n\n流量控制（Flow Control）——滑动窗口机制\n\n问题：接收方的处理能力有限，如果发送方发送得太快，接收方缓冲区可能会溢出。\n解决方案：使用滑动窗口（Sliding Window）机制来进行流量控制。接收方会通过 TCP 报文中的 窗口大小字段告诉发送方：“我当前还能接收多少数据”。发送方根据这个窗口大小来调整自己的发送速率，避免淹没接收方。\n\n滑动窗口让发送和接收双方能够动态协调发送速率，既高效又不会出错。\n\n拥塞控制（Congestion Control）\n\n问题：不仅是接收方，整个网络的承载能力也是有限的，如果发送方不顾网络拥堵而疯狂发包，会导致丢包、延迟剧增，甚至网络瘫痪。\n解决方案：TCP 实现了多种拥塞控制算法，比如：慢启动（Slow Start）拥塞避免（Congestion Avoidance）快速重传（Fast Retransmit）快速恢复（Fast Recovery）\n\n\n这些算法让发送方根据网络的实时状态（比如是否出现丢包）来动态调整发送窗口大小，从而避免网络过度拥挤，提升整体通信质量与稳定性。\n\n 拥塞控制关注的是“整个网络的负载情况”，而流量控制关注的是“接收方的能力”。两者共同作用，保证发送既高效又可靠。\n\n校验和（Checksum）\n\n原理：TCP 报文头部包含一个校验和字段，用于校验报文在传输过程中是否发生了错误（比如比特翻转）。\n作用：接收方收到数据后，会重新计算校验和并与报文中的校验和比对，如果不匹配，说明数据可能损坏，直接丢弃该报文，等待重传。\n\n\n\nTCP流量控制\n为什么需要流量控制？\n\nTCP 是全双工、基于字节流的协议，数据在发送时是连续不断的。但如果发送方不顾接收方的处理能力，疯狂地发数据，接收方的接收缓冲区（Receive Buffer）可能会被填满，导致错误。\n\n\n如何实现？—— 滑动窗口（Sliding Window）机制\n\n接收窗口（RWND, Receive Window）\n接收方在自己的 TCP 报文头部中，通过 **窗口大小字段（Window Size）**告诉发送方：“我当前还能接收多少字节的数据”。\n这个值就是接收窗口（RWND），代表接收方缓冲区中剩余可用的空间大小。\n\n\n发送方根据接收窗口调整发送速率\n发送方根据接收方通告的窗口大小，决定自己一次可以发送多少数据，而不会超过接收方的处理能力。\n当接收方处理了一些数据，并腾出了缓冲区空间后，会再次通告一个更大的窗口，发送方就可以继续多发数据。\n\n\n滑动窗口动态调整\n接收窗口的值是动态变化的，随着接收方应用程序读取数据的速度而改变。\n发送方维护一个发送窗口，只有在窗口允许的范围内才能发送数据，从而实现“边发边等确认”的高效可靠传输。\n\n\n\n\n\nTCP拥塞控制\n是什么？\n\n拥塞控制是 TCP 用来感知并应对网络中的拥塞状况，动态调整发送速率，以避免网络过载和丢包的一种机制。\n简单来说：发送方根据网络的拥堵程度，自动调整自己发多少数据，以免把网络“堵死”。\n\n\n为什么需要拥塞控制？\n\n网络中的带宽是共享的、有限的，如果多个设备同时大量发包，或者某一发送方发得过快，就可能导致：\n路由器&#x2F;交换机队列满\n网络丢包（数据包被丢弃）\n延迟急剧上升\n吞吐量反而下降（越快越堵）\n\n\n\n如果不加以控制，发送方“自顾自地快速发包”，不仅影响自己，还会影响整个网络的通信质量。\n\n如何实现\n\nTCP 拥塞控制的核心是：通过维护一个“拥塞窗口（cwnd, Congestion Window）”来限制发送方在单位时间内可以发送的数据量，并且这个窗口大小会根据网络状况动态调整。\n\n\n新建连接 → 慢启动（指数增长）→ 达到 ssthresh → 拥塞避免（线性增长）                     ↓                出现丢包或 3 个 Dup ACK                     ↓           快速重传 → （可能进入）快速恢复 → 拥塞避免                     ↓                拥塞后重置 cwnd = 1，重新慢启动\n\n\n慢启动（Slow Start）\n\n**初始状态：**连接刚建立时，发送方不知道网络状况，不敢发太多。\n**策略：**从小窗口开始，每收到一个 ACK，cwnd 就指数级增长（翻倍），即“慢慢提速”。\n**触发条件：**刚开始发送，或网络发生丢包后重置。\n**停止条件：**当 cwnd 达到一个阈值（ssthresh，慢启动阈值）时，进入拥塞避免阶段。\n\n\n拥塞避免（Congestion Avoidance）\n\n策略：当 cwnd 达到 ssthresh 后，不再指数增长，而是每 RTT（往返时间）只增加 1 MSS（最大报文段长度），即线性增长，更稳、更温和。\n**目标：**尽量利用网络带宽，但避免触发拥塞。\n\n\n快速重传（Fast Retransmit）\n\n触发条件：发送方连续收到 3 个重复的 ACK（说明某个数据包可能丢了，但网络还没完全拥塞）。\n**行为：**不等超时，立刻重传那个丢失的数据包，而不必等到超时重传。\n**效果：**更快恢复，避免等待超时带来的延迟。\n\n\n快速恢复（Fast Recovery）（部分实现，如 Reno）\n\n**触发条件：**在快速重传之后，进入此状态。\n策略：不直接回到慢启动，而是将 ssthresh 设为当前 cwnd 的一半，cwnd 也适当减小，然后进入拥塞避免。\n**目标：**快速恢复传输，同时避免网络再次拥塞。\n\n\n\n\n\n","categories":["技术"]}]