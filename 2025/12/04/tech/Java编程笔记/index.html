<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"98f8cddec87decff88b20807b414767528f9bec3","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="基础Java生命周期 编码阶段（Writing Code）   开发者编写源代码，文件后缀为 .java。比如：HelloWorld.java。 源代码中包含类（class）、方法（method）等，使用 Java 语法。    编译阶段（Compiling）   使用 Java 编译器 javac 将 .java 文件编译成 字节码文件（.class）。 1javac HelloWorld.ja">
<meta property="og:type" content="article">
<meta property="og:title" content="Java与JVM">
<meta property="og:url" content="https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:description" content="基础Java生命周期 编码阶段（Writing Code）   开发者编写源代码，文件后缀为 .java。比如：HelloWorld.java。 源代码中包含类（class）、方法（method）等，使用 Java 语法。    编译阶段（Compiling）   使用 Java 编译器 javac 将 .java 文件编译成 字节码文件（.class）。 1javac HelloWorld.ja">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250901205835254.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902091103805.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902092704232.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902103942756.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902204154065.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902204333558.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250903172751771.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250909104920937.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251025144006035.png">
<meta property="article:published_time" content="2025-12-04T06:30:00.000Z">
<meta property="article:modified_time" content="2025-12-03T09:38:18.461Z">
<meta property="article:author" content="mukongshan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250901205835254.png">


<link rel="canonical" href="https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/","path":"2025/12/04/tech/Java编程笔记/","title":"Java与JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java与JVM | kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">kongshan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Java生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-JRE-JDK%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.</span> <span class="nav-text">JVM, JRE, JDK的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">2.</span> <span class="nav-text">编译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88-class%E6%96%87%E4%BB%B6%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">字节码（.class文件）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cp-info"><span class="nav-number">2.1.2.</span> <span class="nav-text">cp_info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#field-info"><span class="nav-number">2.1.3.</span> <span class="nav-text">field_info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#method-info"><span class="nav-number">2.1.4.</span> <span class="nav-text">method_info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.1.5.</span> <span class="nav-text">描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attributes"><span class="nav-number">2.1.6.</span> <span class="nav-text">attributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0code%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.7.</span> <span class="nav-text">函数code中的指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.2.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.2.3.</span> <span class="nav-text">字符串常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">2.3.</span> <span class="nav-text">}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9A100A-init123"><span class="nav-number">2.4.</span> <span class="nav-text">输出结果：100A init123</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.4.1.</span> <span class="nav-text">双端队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">2.4.2.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">2.4.3.</span> <span class="nav-text">B+树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">2.5.1.</span> <span class="nav-text">异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="nav-number">2.5.2.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">2.5.3.</span> <span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">2.6.</span> <span class="nav-text">泛型和多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E5%86%99%E8%BF%99%E6%A0%B7%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">2.6.1.</span> <span class="nav-text">你写这样的泛型代码：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%86%E5%9C%A8%E7%BC%96%E8%AF%91%E5%90%8E%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%89%EF%BC%8C%E5%AE%83%E5%AE%9E%E9%99%85%E4%B8%8A%E5%8F%98%E6%88%90%E4%BA%86%EF%BC%9A"><span class="nav-number">2.6.2.</span> <span class="nav-text">但在编译后（字节码层面），它实际上变成了：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">2.7.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">2.7.2.</span> <span class="nav-text">同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">2.7.2.5.</span> <span class="nav-text">Semaphore</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.8.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">2.8.1.</span> <span class="nav-text">基本的通信架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP"><span class="nav-number">2.8.2.</span> <span class="nav-text">IP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InetAddress"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">InetAddress</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Port"><span class="nav-number">2.8.3.</span> <span class="nav-text">Port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.8.4.</span> <span class="nav-text">通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">UDP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">TCP协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="nav-number">2.9.</span> <span class="nav-text">UDP通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DatagramSocket-%E3%80%81DatagramPacket"><span class="nav-number">2.9.1.</span> <span class="nav-text">DatagramSocket 、DatagramPacket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-net-Socket"><span class="nav-number">2.9.2.</span> <span class="nav-text">java.net.Socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-net-ServerSocket"><span class="nav-number">2.9.3.</span> <span class="nav-text">java.net.ServerSocket</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java与JVM | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java与JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:30:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:30:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java生命周期"><a href="#Java生命周期" class="headerlink" title="Java生命周期"></a>Java生命周期</h2><ol>
<li>编码阶段（Writing Code）</li>
</ol>
<ul>
<li><strong>开发者编写源代码</strong>，文件后缀为 <code>.java</code>。<br>比如：<code>HelloWorld.java</code>。</li>
<li>源代码中包含类（<code>class</code>）、方法（<code>method</code>）等，使用 <strong>Java 语法</strong>。</li>
</ul>
<hr>
<ol start="2">
<li>编译阶段（Compiling）</li>
</ol>
<ul>
<li><p>使用 <strong>Java 编译器 <code>javac</code></strong> 将 <code>.java</code> 文件编译成 <strong>字节码文件</strong>（<code>.class</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>

</li>
<li><p>编译后生成 <code>HelloWorld.class</code> 文件。</p>
</li>
<li><p>注意：字节码不是机器码，而是一种中间形式，跨平台。</p>
</li>
</ul>
<hr>
<ol start="3">
<li>类加载阶段（Class Loading）</li>
</ol>
<ul>
<li>当运行程序时（<code>java HelloWorld</code>），<strong>类加载器（ClassLoader）</strong> 会把需要的 <code>.class</code> 文件加载进内存。</li>
<li>类加载过程分为三个小步骤：<ol>
<li><strong>加载（Loading）</strong>：把字节码读到内存。</li>
<li><strong>连接（Linking）</strong>：包括验证（验证字节码合法性）、准备（为静态变量分配内存）、解析（符号引用替换为直接引用）。</li>
<li><strong>初始化（Initialization）</strong>：执行静态代码块、给静态变量赋初值。</li>
</ol>
</li>
</ul>
<hr>
<ol start="4">
<li>字节码执行阶段（Execution）</li>
</ol>
<ul>
<li><p><strong>Java 虚拟机（JVM）解释执行字节码</strong>，也可能使用 <strong>JIT（即时编译器）</strong> 把热点代码编译成本地机器码，以提高运行效率。</p>
</li>
<li><p>执行的起点是程序入口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ol start="5">
<li>程序运行时（Runtime）</li>
</ol>
<ul>
<li>JVM 在运行时会：<ul>
<li><strong>内存管理</strong>：使用 <strong>堆、栈、方法区、运行时常量池</strong> 等。</li>
<li><strong>垃圾回收（GC）</strong>：回收不再使用的对象内存。</li>
<li><strong>异常处理</strong>：执行过程中出现异常时，JVM 按照异常机制处理。</li>
</ul>
</li>
</ul>
<hr>
<ol start="6">
<li>程序终止（Termination）</li>
</ol>
<ul>
<li>当 <code>main</code> 方法执行完毕，且所有非守护线程（non-daemon thread）都结束时，JVM 退出。</li>
<li>在退出前，可能会执行 <code>finally</code> 块、<code>shutdown hook</code>（关闭钩子）。</li>
</ul>
<span id="more"></span>

<ol>
<li>程序生命</li>
</ol>
<p>$$<br>.java(源码) \underset{\text{decompile}}{\overset{\text{compile}}{\longleftrightarrow}} .class(字节码)\xrightarrow{\text{load}}class类\xrightarrow{\text{execution}}机器码\xrightarrow{\text{run}}结果<br>$$</p>
<h2 id="JVM-JRE-JDK的关系"><a href="#JVM-JRE-JDK的关系" class="headerlink" title="JVM, JRE, JDK的关系"></a>JVM, JRE, JDK的关系</h2><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250901205835254.png" alt="image-20250901205835254"></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">全称</th>
<th align="left">作用</th>
<th align="left">是否包含编译器</th>
<th align="left">是否必需开发 Java 程序</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JVM</strong></td>
<td align="left">Java Virtual Machine（Java 虚拟机）</td>
<td align="left"><strong>运行 Java 字节码的虚拟计算机</strong>，负责加载字节码并执行</td>
<td align="left">❌ 不包含</td>
<td align="left">❌ 不单独用于开发</td>
<td align="left">是运行 Java 程序的“引擎”</td>
</tr>
<tr>
<td align="left"><strong>JRE</strong></td>
<td align="left">Java Runtime Environment（Java 运行时环境）</td>
<td align="left"><strong>运行 Java 程序所需的环境，包含 JVM + 核心类库</strong></td>
<td align="left">❌ 不包含</td>
<td align="left">❌ 仅能运行，不能开发</td>
<td align="left">如果你只需要运行 Java 程序（比如别人的软件），安装 JRE 就够了</td>
</tr>
<tr>
<td align="left"><strong>JDK</strong></td>
<td align="left">Java Development Kit（Java 开发工具包）</td>
<td align="left"><strong>开发 Java 程序所需的完整工具包，包含 JRE + 编译器（javac） + 调试工具等</strong></td>
<td align="left">✅ 包含（javac）</td>
<td align="left">✅ 必需</td>
<td align="left">开发 Java 程序必须安装 JDK</td>
</tr>
</tbody></table>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="字节码（-class文件）"><a href="#字节码（-class文件）" class="headerlink" title="字节码（.class文件）"></a>字节码（.class文件）</h2><ul>
<li><code>.class</code>文件是 <strong>Java 源代码（.java）经过 <code>javac</code>编译后生成的字节码文件</strong>，它是 <strong>平台无关的中间代码</strong>，不能直接被操作系统执行，但可以被 <strong>Java 虚拟机（JVM）加载和执行</strong>。</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">// 魔数CAFEBABY，仅代表这个文件是java文件，没有其他作用</span></span><br><span class="line">    u2             minor_version; <span class="comment">// 副版本号</span></span><br><span class="line">    u2             major_version; <span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;         <span class="comment">// 常量池大小</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">// 常量池</span></span><br><span class="line">    u2             access_flags;                <span class="comment">// 访问标志(public, private)</span></span><br><span class="line">    u2             this_class; <span class="comment">// 指向当前类，是cp_info的下标</span></span><br><span class="line">    u2             super_class; <span class="comment">// 指向父类</span></span><br><span class="line">    u2             interfaces_count; </span><br><span class="line">    u2             interfaces[interfaces_count]; <span class="comment">// 接口信息</span></span><br><span class="line">    u2             fields_count;                 </span><br><span class="line">    field_info     fields[fields_count]; <span class="comment">// 字段信息</span></span><br><span class="line">    u2             methods_count;               </span><br><span class="line">    method_info    methods[methods_count]; <span class="comment">// 方法信息</span></span><br><span class="line">    u2             attributes_count;            </span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="comment">// 属性信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="cp-info"><a href="#cp-info" class="headerlink" title="cp_info"></a>cp_info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info&#123;</span><br><span class="line">	u1 tag;</span><br><span class="line">	u1 info[]; <span class="comment">// 大小是可变的。例如Integer就是u4 byte, String就是u2 length, u1 byte[length]。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>tag的取值表：<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902091103805.png" alt="image-20250902091103805"></li>
<li>this_class指向CONSTANT_Class_Info，后者又指向一个字符串(name)。</li>
</ol>
<h3 id="field-info"><a href="#field-info" class="headerlink" title="field_info"></a>field_info</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index; <span class="comment">// 本质是个下标，指向常量池</span></span><br><span class="line">    u2             descriptor_index;</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>access_flag的取值：字段可以叠加，Value取或<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902092704232.png" alt="image-20250902092704232"></li>
</ol>
<h3 id="method-info"><a href="#method-info" class="headerlink" title="method_info"></a>method_info</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             name_index;</span><br><span class="line">    u2             descriptor_index;</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><ol>
<li><p>规范：前缀+类完整名（包含分号）（如果不是以下的基本类型）</p>
</li>
<li><p>前缀：</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">Java 类型</th>
<th align="left">描述符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>B</code></td>
<td align="left">8-bit 整数</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left"><code>C</code></td>
<td align="left">16-bit Unicode 字符</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left"><code>D</code></td>
<td align="left">64-bit 双精度浮点数</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>F</code></td>
<td align="left">32-bit 单精度浮点数</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>I</code></td>
<td align="left">32-bit 整数</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>J</code></td>
<td align="left">64-bit 整数</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>S</code></td>
<td align="left">16-bit 整数</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><code>Z</code></td>
<td align="left">布尔类型（true&#x2F;false）</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left"><code>V</code></td>
<td align="left">仅用于返回类型，表示无返回</td>
</tr>
<tr>
<td align="left">array</td>
<td align="left">[</td>
<td align="left">表示返回数组</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>入参的表示：用小括号包裹。</p>
</li>
<li><p>例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int func(String s) --&gt; &lt;(Ljava/lang/String;)I&gt;,   void func() --&gt; &lt;()V&gt;,  float func(double[] d ) --&gt; &lt;([D)F&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><ul>
<li>属性太多了，这里仅介绍几个常见的</li>
</ul>
<ol>
<li><code>ConstantValue</code>：只针对常量<code>static final</code>的<code>基础类型或字符串</code>的属性，在编译器赋值，而不是运行时，提高效率。</li>
<li><code>Code</code>：函数体的内容，这个是非常重要的，尤其是后面学习<code>ASM</code>指令，一个类主要承载的功能，都反应在了<code>method</code>的<code>code</code>里。</li>
<li><code>Exception</code>：函数中声明的抛出的异常，可以有多个。注意这里是声明的抛出的异常，不包含一些运行时的异常。<ol>
<li>区分<code>Code异常表</code>和<code>Exception</code>属性：通过<code>try-catch</code>的异常会出现在<code>code异常表</code>。</li>
</ol>
</li>
<li><code>LineNumberTable</code></li>
<li><code>LocalVariableTable</code></li>
<li><code>Signature</code>：与泛型密切相关</li>
</ol>
<h3 id="函数code中的指令"><a href="#函数code中的指令" class="headerlink" title="函数code中的指令"></a>函数code中的指令</h3><ol>
<li><p>load &#x2F; push</p>
<ol>
<li><code>load</code>的形式有很多种，比如我们可以把<code>本地变量load</code>到栈顶<ul>
<li><code>iload_{y}</code>按照<code>int</code>或<code>byte</code>或<code>char</code>或<code>boolean</code>或<code>short</code>类型，加载第y个变量。</li>
<li><code>lload_{y}</code>按照<code>long</code>类型加载第y个变量。</li>
<li><code>fload_{y}</code>按照<code>float</code>类型加载第y个变量。</li>
<li><code>dload_{y}</code>按照<code>double</code>类型加载第y个变量。</li>
<li><code>aload_{y}</code>按照对象类型加载第y个变量，<code>aload_0</code>加载this，默认第0个位置是<code>this</code>或者<code>常量load</code>到栈顶</li>
</ul>
</li>
<li><code>bipush</code>针对byte范围的int值的load</li>
<li><code>sipush</code>针对short范围的int值的load</li>
</ol>
</li>
<li><p>store：理同load</p>
</li>
<li><p>return：</p>
<ol>
<li><p><code>return</code>之后需要保证栈是空的，不然编译会验证不通过。</p>
<ul>
<li><code>return</code>等于代码return，不消耗栈顶</li>
<li><code>ireturn</code>消耗栈顶一帧，返回一个<code>int</code>或<code>byte</code>或<code>char</code>或<code>boolean</code>或<code>short</code>类型</li>
<li><code>freturn</code>消耗栈顶一帧返回一个float</li>
<li><code>lreturn</code>消耗栈顶2帧返回一个long</li>
<li><code>dreturn</code>消耗栈顶2帧返回一个double</li>
<li><code>areturn</code>消耗栈顶一帧返回一个地址，即返回一个对象类型的内存地址</li>
</ul>
<p>注意：<code>return</code>不一定是代码结束的地方，可能有判断分支有多个<code>return</code>语句，而且还有可能是<code>athrow</code>抛出异常。</p>
</li>
</ol>
</li>
<li><p>pop &#x2F; dup &#x2F; new</p>
<ol>
<li>pop：如果一个栈上的操作数，想要直接消耗掉，则直接用<code>pop</code>指令消耗一个栈帧，比如运行了一个函数操作后，直接忽略函数的返回值就可以<code>pop</code>消耗掉，如果返回值是<code>long/double</code>可以<code>pop</code>两次，或者<code>pop2</code>指令消耗。</li>
<li>dup：复制栈顶栈帧。用法同pop。这经常用于<code>new</code>一个对象。</li>
<li>new的过程：对应字节码，如下<code>new</code>指令作用是，创建一个对象会在堆上分配内存，并将内存的地址放到操作数栈上；注意这里有个<code>dup</code>把地址复制了一份，这是<code>new</code>对象的一个固定操作，因为<code>invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;</code>这个构造方法与普通非静态方法一样，会消耗掉一个操作数作为<code>this</code>。所以需要提前把地址备份一下，不然<code>new</code>完地址就丢了，下面会说<code>invoke</code>相关指令。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902103942756.png" alt="image-20250902103942756"></li>
</ol>
</li>
<li><p>invoke</p>
<ol>
<li><code>invoke</code>是函数调用的指令，他主要有5种，<ul>
<li><code>invokevirtual</code>普通的可访问的方法，需要依次把<code>对象</code>，<code>参数从左到右</code>放到栈顶。</li>
<li><code>invokestatic</code>静态方法，需要依次把<code>参数从左到右</code>放到栈顶。</li>
<li><code>invokespecial</code>特殊方法，构造方法，私有方法，父类中的方法，接口的default实现等，根据情况参考上面的操作数顺序。</li>
<li><code>invokeinterface</code>接口方法，栈顶操作数顺序参考上面。</li>
<li><code>invokedynamic</code>动态方法，一般是lambda表达式，栈顶操作数顺序参考上面。</li>
</ul>
</li>
</ol>
</li>
<li><p>跳转</p>
<ol>
<li>注意，long &#x2F; double占两个局部变量</li>
<li>其实<code>try-catch</code>是专门记录到<code>code</code>的异常表中的，上面提到过异常表和异常属性的区别。</li>
</ol>
</li>
</ol>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>常量池（Constant Pool）是 Java <code>.class</code>文件中的一个重要组成部分，它是一个<strong>结构化的、预定义的常量表</strong>，用于存储：字面量（如字符串、数字等），符号引用（如类名、方法名、字段名、方法描述符等），其他在程序运行时或类加载时可能需要引用的常量信息。</li>
<li>它不是程序运行时动态生成的，也不是只在编译期间临时存在的东西。</li>
<li><strong>字面量（Literal）</strong><br>如 <code>int a = 1;</code> 里的 <code>1</code>，或者 <code>&quot;Hello&quot;</code> 这样的字符串。</li>
<li><strong>符号引用（Symbolic Reference）</strong><ul>
<li>类和接口的全限定名（例如 <code>java/lang/String</code>）</li>
<li>字段名和描述符</li>
<li>方法名和描述符</li>
</ul>
</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p><strong>静态常量池（Class File Constant Pool）</strong></p>
<ul>
<li>位置：位于 <code>.class</code> 文件中。</li>
<li>生成时机：<strong>编译</strong>阶段由编译器写入。</li>
<li>内容：<ol>
<li>字面量（Literal）<ul>
<li>基本类型常量（如 <code>1.2f</code>, <code>100</code>）</li>
<li>字符串字面量（如 <code>&quot;Hello&quot;</code>）</li>
<li><code>final</code> 常量（编译期可确定的值）</li>
</ul>
</li>
<li>符号引用（Symbolic Reference）<ul>
<li>类和接口的全限定名（如 <code>java/lang/String</code>）</li>
<li>字段名和描述符</li>
<li>方法名和方法描述符</li>
</ul>
</li>
</ol>
</li>
<li>作用：为类加载时提供原始数据。</li>
</ul>
<p><strong>注意：静态常量池是“死”的，只存在于 <code>.class</code> 文件里，不会变化。</strong></p>
<hr>
<ol start="2">
<li><strong>运行时常量池（Runtime Constant Pool）</strong></li>
</ol>
<ul>
<li><p>位置：方法区的一部分（JDK 8 之后是元空间 Metaspace 中）。</p>
</li>
<li><p>生成时机：类加载的 <strong>加载 → 链接</strong> 过程中，JVM 会把 <code>.class</code> 文件中的静态常量池信息拷贝到运行时常量池。</p>
</li>
<li><p>内容：</p>
<ul>
<li>解析后的字面量（真正的 int、float、String 对象引用）。</li>
<li>符号引用在 <strong>解析（Resolution）阶段</strong> 转换为 <strong>直接引用</strong>（比如指向方法区中某个方法的指针）。</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>是动态的，可以在运行时产生新的常量，比如 <code>String.intern()</code> 会把字符串放到运行时常量池。</li>
<li>不仅包含编译期的常量，还包含运行期解析出来的引用。</li>
</ul>
</li>
<li><p><strong>字符串常量池（String Constant Pool）</strong></p>
<ul>
<li><strong>属于运行时常量池的一部分。但是在堆区中。即逻辑上属于运行时常量池，但是物理上不在一个区。</strong></li>
<li>专门存放字符串字面量的池子。</li>
<li>早期（JDK 6 及之前）在方法区，JDK 7 后移到了堆中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><ol>
<li><p>字符串常量池在堆中，可能存在在E区、S区、O区。在讲解时默认在E区</p>
</li>
<li><p>如果通过字面量赋值，则字符串对象直接出现在常量池中。</p>
<ol>
<li><p>String s &#x3D; “lizhi”;</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902204154065.png" alt="image-20250902204154065"></p>
</li>
<li><p>String s &#x3D; new String(“lizhi”);</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902204333558.png" alt="image-20250902204333558"></p>
</li>
<li><pre><code>String a = &quot;lizhi&quot;;
String b = new String(&quot;lizhi&quot;);
String c = &quot;li&quot; + new String(&quot;zhi&quot;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">      ![image-20250902205758484](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902205758484.png)</span><br><span class="line"></span><br><span class="line">3. intern（）方法</span><br><span class="line"></span><br><span class="line">   1. 从注释中可以比较清楚地看到，当调用intern()方法时，会判断字符串常量池中是否有该对象的引用，通过equal()方法判断，如果存在就返回字符串常量池中的对象引用。如果不存在，就把当前字符串对象直接添加到字符串常量池中，**注意这里说的把该字符串对象添加到常量池池，是指把堆中对象的引用添加到常量池，并不是在常量池中再创建一个该字符串的对象**，然后返回该对象的引用。![image-20250902205439336](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902205439336.png)</span><br><span class="line"></span><br><span class="line"># 类加载</span><br><span class="line"></span><br><span class="line">## 类加载过程</span><br><span class="line"></span><br><span class="line">### 加载</span><br><span class="line"></span><br><span class="line">1. 将类的字节码载入**方法区**，并创建.class对象。</span><br><span class="line">   1. JVM 找到并加载类的二进制字节流。</span><br><span class="line">   2. 常见来源：class 文件、JAR 包、网络、甚至动态生成（如 `ASM`、`CGLIB`）。</span><br><span class="line">   3. JVM 为这个类生成一个 `Class` 对象，作为方法区/元空间中该类的访问入口。</span><br><span class="line">   4. 如果此类的父类没有加载，先加载父类</span><br><span class="line">   5. 加载是懒惰执行</span><br><span class="line">      1. 懒惰执行：需要用到的时候才执行</span><br><span class="line"></span><br><span class="line">### 链接</span><br><span class="line"></span><br><span class="line">1. 验证：验证类是否符合class规范，做合法性、安全性检查</span><br><span class="line"></span><br><span class="line">2. 准备：为**静态变量**分配空间，设置**默认值**</span><br><span class="line"></span><br><span class="line">   &gt; *可以理解为，为了安全性必须赋初始值*</span><br><span class="line"></span><br><span class="line">3. 解析：将常量池的符号引用解析为直接引用。例如方法调用时，编译期只知道方法的符号引用（静态常量池），解析阶段才会绑定到真正的方法地址。</span><br><span class="line"></span><br><span class="line">   &gt; *这里很形象，原本只是符号引用，但是解析之后就用指针把调用链串起来了。很有“链接”的意思*</span><br><span class="line"></span><br><span class="line">### 初始化</span><br><span class="line"></span><br><span class="line">1. **执行静态代码块**与**非final静态变量的赋值**</span><br><span class="line"></span><br><span class="line">   1. 执行类构造器 `&lt;clinit&gt;()` 方法（编译器自动生成），对静态变量赋值、执行静态代码块。</span><br><span class="line"></span><br><span class="line">   2. 初始化是类加载的 最后一步，也是程序员能控制的阶段。</span><br><span class="line"></span><br><span class="line">      `&lt;clinit&gt;()` 方法由编译器收集：</span><br><span class="line"></span><br><span class="line">      - 所有 **静态变量的显式赋值**</span><br><span class="line">      - 所有 **静态代码块**按照源码中的顺序合并。</span><br><span class="line"></span><br><span class="line">2. 初始化时懒惰执行</span><br><span class="line"></span><br><span class="line">## 触发时机</span><br><span class="line"></span><br><span class="line">1. 只会加载 / 链接，不会初始化的情况：</span><br><span class="line"></span><br><span class="line">   1. 引用一个 `static final` </span><br><span class="line"></span><br><span class="line">      &gt; 常量会在编译期被放入调用类的常量池，也就是说，运行时根本没有去访问类，只是直接用常量池里的值。</span><br><span class="line"></span><br><span class="line">   2. 获取类的 `Class` 对象（如 `String.class`）。</span><br><span class="line"></span><br><span class="line">      &gt; JVM 只需要返回一个指向 **类元信息的引用**</span><br><span class="line"></span><br><span class="line">2. 必须初始化的情况</span><br><span class="line"></span><br><span class="line">   1. `new` 一个对象。</span><br><span class="line"></span><br><span class="line">      &gt; 在创建对象前，需要保证该类的 **静态变量、静态方法、父类状态** 都处于可用的、已知的状态。</span><br><span class="line"></span><br><span class="line">   2. 访问类的静态变量或调用静态方法（非常量）。</span><br><span class="line"></span><br><span class="line">   3. 反射调用 `Class.forName()`。</span><br><span class="line"></span><br><span class="line">   4. 初始化一个类时，若其父类还没初始化，会先初始化父类。</span><br><span class="line"></span><br><span class="line">   5. JVM 启动时，执行 `main` 方法所在的类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<p>例子：<br>class A {<br>    static {<br>        System.out.println(“A init”);<br>    }<br>    public static final int X &#x3D; 100;   &#x2F;&#x2F; 编译期常量<br>    public static final int Y &#x3D; new java.util.Random().nextInt(10); &#x2F;&#x2F; 运行期常量<br>}</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(A.X); &#x2F;&#x2F; 访问 X<br>        System.out.println(A.Y); &#x2F;&#x2F; 访问 Y<br>    }</p>
<h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="输出结果：100A-init123"><a href="#输出结果：100A-init123" class="headerlink" title="输出结果：100A init123"></a>输出结果：<br>100<br>A init<br>123</h2><p>Q1：为什么访问 X 不会触发初始化？<br>A1：<br>	X &#x3D; 100 是 编译期可确定的常量（字面量）。<br>	Java 编译器在编译 Test 类的时候，就把 A.X 直接替换为字面量 100，并存到 Test 的常量池 中。<br>	也就是说，运行时根本没有去访问 A 类，只是直接用常量池里的值。<br>	所以不会触发 A 的初始化。<br>	这就是所谓的 常量传播&#x2F;常量折叠优化。</p>
<p>Q2：为什么访问 Y 会触发初始化？<br>A2：<br>	Y 的值依赖于 new Random().nextInt(10)，这是运行时才能确定的。<br>	编译器无法在编译期把它折叠进常量池。<br>	所以，运行时访问 A.Y 时，必须先执行类的 <clinit>() 方法来初始化 Y。<br>	这就会触发 A 的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 类加载器</span><br><span class="line"></span><br><span class="line">### 分类</span><br><span class="line"></span><br><span class="line">在 JVM 中，类的加载是由类加载器完成的。常见的三层体系：</span><br><span class="line"></span><br><span class="line">1. 启动类加载器（Bootstrap ClassLoader）</span><br><span class="line">   - C++ 实现，JVM 自带，不是 Java 类。</span><br><span class="line">   - 负责加载核心类库（`rt.jar`，Java 9 之后是 `java.base` 模块），即`%JAVA_HOME%/lib`</span><br><span class="line">2. 扩展类加载器（Extension ClassLoader / Platform ClassLoader）</span><br><span class="line">   - 负责加载 `JAVA_HOME/jre/lib/ext` 或 `java.ext.dirs` 下的类库，即即`%JAVA_HOME%/lib/etc`</span><br><span class="line">   - Java 9 之后改为 Platform ClassLoader。</span><br><span class="line">3. 应用类加载器（AppClassLoader）</span><br><span class="line">   - 负责加载 classpath 下的类（我们写的应用代码）。</span><br><span class="line"></span><br><span class="line">另外，还可以有 自定义类加载器，一般继承 `ClassLoader`。</span><br><span class="line"></span><br><span class="line">### 特性</span><br><span class="line"></span><br><span class="line">1. 用来确定类的唯一性</span><br><span class="line"></span><br><span class="line">   1. 一个类在 JVM 内存中只能有一个唯一的定义，由**类加载器 + 类的全限定名**唯一确定。二元组&lt;N（全限定名）, L（类加载器）&gt;。</span><br><span class="line">   1. **一个类由哪个类加载器真正加载了，那么它的 `getClassLoader()`方法返回的就是那个类加载器。**</span><br><span class="line"></span><br><span class="line">2. 传递性</span><br><span class="line"></span><br><span class="line">   ![image-20250902154447055](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902154447055.png)</span><br><span class="line"></span><br><span class="line">   1. 如果类A是由L0加载的，那么A所依赖的类也要通过L0加载。</span><br><span class="line">   2. 即使是核心类库中的类，也要通过L0加载，但是会被委派到Bootstrap ClassLoader加载</span><br><span class="line"></span><br><span class="line">3. 可见性</span><br><span class="line"></span><br><span class="line">   ![image-20250902154812128](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902154812128.png)</span><br><span class="line"></span><br><span class="line">   1. 我们说类B对于类A可见，含义是：加载A的加载器L，也可以直接或委派间接加载B</span><br><span class="line">   1. 在 Java 中，一个类加载器只能看到它自身以及它的 父类加载器（Parent ClassLoader）所加载的类，但看不到它的 子类加载器（Child ClassLoader） 所加载的类。</span><br><span class="line"></span><br><span class="line">## 双亲委派机制</span><br><span class="line"></span><br><span class="line">### 概述</span><br><span class="line"></span><br><span class="line">1. 为什么要双亲委派？</span><br><span class="line">   1. 避免重复加载（保证类的唯一性）：**如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。**</span><br><span class="line">   2. 保证核心类库的安全性（比如 `java.lang.String` 不会被随便篡改）。</span><br><span class="line">2. 什么时候打破？</span><br><span class="line">   1. 一般出现在一些 **特殊场景** 下，尤其是框架 / 容器需要加载用户自定义类、插件类，或者隔离不同模块时：</span><br><span class="line">      1. 自定义类加载器加载应用类/插件类</span><br><span class="line">         - 典型例子：**Tomcat、Jetty 等 Web 容器**</span><br><span class="line">         - 它们需要加载不同 Web 应用的类，避免不同应用之间互相干扰（类隔离）。</span><br><span class="line">         - Tomcat 会自己实现类加载器，不完全遵循双亲委派。</span><br><span class="line">      2. 实现热加载（Hot Deployment）</span><br><span class="line">         - 开发工具（如 IDEA、Eclipse）、Spring Boot DevTools 热部署功能，需要在运行时重新加载类。</span><br><span class="line">         - 如果走双亲委派，父加载器一旦加载过，就无法替换，需要自己写类加载器打破机制。</span><br><span class="line">      3. SPI（Service Provider Interface）机制：**顶层加载器需要调用应用类加载器**。顶层提供接口，底层实现</span><br><span class="line">         - Java 自带的 `ServiceLoader` 需要加载厂商提供的实现类（通常在 `META-INF/services` 里）。</span><br><span class="line">         - 这些实现类不能放在 JDK 的核心类加载器里，只能由 **线程上下文类加载器（Thread Context ClassLoader）** 去加载，突破双亲委派。</span><br><span class="line">      4. 模块/插件化系统</span><br><span class="line">         - 比如 OSGi、各种插件化框架，需要动态加载第三方 jar 包，并且允许卸载/升级插件。</span><br><span class="line">         - 通常需要定制自己的类加载逻辑，不完全依赖父加载器。</span><br><span class="line">      5. 字节码增强 / 动态代理</span><br><span class="line">         - 一些框架（Spring、MyBatis、JVM Agent、字节码增强工具 ASM/CGLIB）在运行时生成代理类。</span><br><span class="line">         - 这些类需要在运行时被加载进 JVM，往往会使用自定义类加载器绕过双亲委派。</span><br><span class="line"></span><br><span class="line">### 机制内容</span><br><span class="line"></span><br><span class="line">![image-20250902153715595](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902153715595.png)![image-20250902153959633](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902153959633.png)</span><br><span class="line"></span><br><span class="line">1. 工作过程</span><br><span class="line">   1. 当应用类加载器要加载一个类时，比如 `java.lang.String`。</span><br><span class="line">   2. 它不会自己去尝试加载，而是先 **委托给父加载器（Platform ClassLoader）**。</span><br><span class="line">   3. Platform ClassLoader 又委托给 Bootstrap ClassLoader</span><br><span class="line">   4. Bootstrap ClassLoader 如果能加载（发现 String 在核心库里），就直接返回。</span><br><span class="line">   5. 如果父加载器都没找到，才由子加载器自己去加载。</span><br><span class="line">2. 作用核心目的就是 **安全性和一致性**：</span><br><span class="line">   1. **保证核心类库不会被篡改**</span><br><span class="line">      1. 假设你写了一个自定义的 `java.lang.String` 类，如果没有双亲委派，你的 `String` 可能会被应用类加载器加载并替代系统的核心类，这是极其危险的。</span><br><span class="line">      2. 但因为双亲委派，加载 `java.lang.String` 的请求会交给 Bootstrap ClassLoader，它会优先加载 JDK 自带的版本，从而保证安全。</span><br><span class="line">   2. **保证类的唯一性**</span><br><span class="line">      1. 一个类在 JVM 内存中只能有一个唯一的定义（由 **类加载器 + 类的全限定名** 唯一确定）。</span><br><span class="line">      2. 如果一个类已经被父加载器加载过了，子加载器就不会再加载一次，避免了同一个类被多次加载、导致类型不一致的问题。</span><br><span class="line"></span><br><span class="line">### 依赖冲突</span><br><span class="line"></span><br><span class="line">- 有一个典型的题目：有一个项目P，依赖于包B、C，这两个包又分别依赖A1.0、A2.0，且如果B用A2.0或者C用A1.0都会出错。此时如何让项目正常运行。</span><br><span class="line">  1. 一个类在JVM中的定义是由**&lt;类加载器+全限定名&gt;**决定的，如果在项目中用同一个类加载器加载了同一个路径下的A，就会导致冲突</span><br><span class="line">  2. 核心思路是让B、C分别依赖不同版本的包A，所以就要让他们依赖的A的类加载器或全限定名不一样。</span><br><span class="line">- 由此提出以下解决方案：</span><br><span class="line">  - 重构包名</span><br><span class="line">  - 打破双亲委派模型，使用自定义类加载器来实现类隔离</span><br><span class="line">  - 在Maven中显式指定依赖</span><br><span class="line">  - 使用兼容包</span><br><span class="line"></span><br><span class="line">### 打破双亲委派</span><br><span class="line"></span><br><span class="line">1. 重写ClassLoader中的loadClass方法</span><br><span class="line">2. 使用线程上下文加载器</span><br><span class="line">3. 为什么要打破双清委派？</span><br><span class="line">   1. **类隔离需求**：不同的框架、应用或模块可能需要加载 **同名但不同版本的类**，例如两个 Web 应用都用了不同版本的同一个库（如 Log4j）。如果都遵循双亲委派，所有类都由同一个类加载器加载，就会导致版本冲突。</span><br><span class="line">   2. **热部署 / 热加载**：在服务器环境中，我们可能希望在不重启整个 JVM 的情况下重新加载某个应用或模块，这就要求该模块的类能被独立加载和卸载，而双亲委派模型不利于这种灵活的类生命周期管理。</span><br><span class="line">   3. **框架/容器需要加载用户代码**：比如在 Web 容器中，容器本身和用户部署的 Web 应用可能都会用到一些公共的类（如 Servlet 相关类），但容器希望 **对这些类有统一的控制权**，同时又能让每个 Web 应用自己的类库相互隔离，避免互相干扰。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 数组类</span><br><span class="line"></span><br><span class="line">1. 所有数组实例都属于Object，每个数组实例都有自己的class</span><br><span class="line">2. 数组类本身不通过类加载器创建，而是通过JVM直接创建</span><br><span class="line">3. 数组类的元素需要类加载器创建</span><br><span class="line">4. 数组类也需要通过&lt;N, L&gt;唯一确定</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 运行</span><br><span class="line"></span><br><span class="line">## 垃圾回收</span><br><span class="line"></span><br><span class="line">![image-20250902111808844](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902111808844.png)</span><br><span class="line"></span><br><span class="line">1. GC（Garbage Collection）发生在堆区</span><br><span class="line">2. 过程：</span><br><span class="line">   1. new对象出生在E区。当E区快满了，触发youngGC。扫描young区所有类，如果某个对象没有引用了，就打个标记，最后删除。幸存的对象复制到S区</span><br><span class="line">   2. S0和S1交替使用</span><br><span class="line">   3. 每幸存一轮，对象age加一</span><br><span class="line">   4. 如果某个对象达到一定年龄（可以是6岁），则转移到O区。</span><br><span class="line">   5. O区存放**老年对象**或**大对象**。</span><br><span class="line">   6. 如果O区快满了，则触发oldGC，暂停程序，全力垃圾回收。</span><br><span class="line">3. E区比S0区为8:1</span><br><span class="line">4. 老年代比年轻代为2:1</span><br><span class="line"></span><br><span class="line">### 标记算法</span><br><span class="line"></span><br><span class="line">1. 引用计数算法：给每个对象记录一个引用计数属性，该属性为0则表示是垃圾。但是无法解决循环引用问题。</span><br><span class="line">2. 可达性算法：在内存中从根对象一直向下找引用，找不到的就是垃圾对象。</span><br><span class="line">   1. GC Roots 是一组特殊的引用起点，垃圾回收器从这些起点出发，遍历引用链，标记所有可达的对象。</span><br><span class="line">   2. 有多个根对象，但是只会选用一个。</span><br><span class="line">      1. 栈中引用的对象</span><br><span class="line">      2. 常量引用的对象</span><br><span class="line">      3. 类静态属性引用的对象</span><br><span class="line">      4. Native方法引用的对象</span><br><span class="line"></span><br><span class="line">### 回收算法</span><br><span class="line"></span><br><span class="line">1. **标记清除算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：从 GC Roots 出发，遍历所有可达对象，将这些对象 标记为存活。</span><br><span class="line">      2. 清除阶段（Sweep）：遍历整个堆，把 未被标记的对象（即垃圾）清理掉。</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 不需要移动对象，实现相对简单</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 内存碎片化严重</span><br><span class="line">      2. 效率问题</span><br><span class="line">2. **复制算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 将 堆内存分为两块（通常称为 From 区和 To 区，或者 S0 和 S1）</span><br><span class="line">      2. 每次只使用其中一块（如 From 区）来分配对象</span><br><span class="line">      3. 当这一块内存满了，就触发 GC：将存活的对象复制到另一块空闲内存区域（To 区）然后 一次性清空当前使用的内存块（From 区）</span><br><span class="line">      4. 交换角色：原来的 To 区成为新的 From 区，继续使用</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！</span><br><span class="line">      2. 分配效率高</span><br><span class="line">      3. 适合对象存活率低的场景</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 浪费了一半的内存空间</span><br><span class="line">      2. 不适合存活对象多的场景</span><br><span class="line">3. **标记压缩算法**</span><br><span class="line">   1. 基本思想</span><br><span class="line">      1. 标记阶段（Mark）：同 Mark-Sweep，从 GC Roots 出发，标记所有存活对象</span><br><span class="line">      2. 压缩阶段（Compact）：将所有 存活对象向堆的一端移动（通常是向左或向右紧凑排列）</span><br><span class="line">      3. 清理边界外内存：移动完成后，直接清理掉剩余的未使用内存空间</span><br><span class="line">   2. 优点</span><br><span class="line">      1. 没有内存碎片！（解决了 Mark-Sweep 的最大问题）</span><br><span class="line">      2. 内存利用率高，适合大对象和长期存活对象分配</span><br><span class="line">   3. 缺点</span><br><span class="line">      1. 移动对象成本高！</span><br><span class="line"></span><br><span class="line">### 垃圾回收器</span><br><span class="line"></span><br><span class="line">不是所有垃圾回收的阶段都会触发 STW，但 **很多关键阶段必须 STW**，以下是一些常见 GC 算法的 STW 情况：</span><br><span class="line"></span><br><span class="line">1. **Serial GC / Serial Old GC（单线程 GC）**</span><br><span class="line"></span><br><span class="line">- **特点：** 单线程，适合客户端应用或小内存环境</span><br><span class="line">- STW：标记阶段（标记存活对象）清除/整理阶段都是 STW 的！整个过程都会暂停所有应用线程</span><br><span class="line"></span><br><span class="line">&gt; ✅ 用户线程完全停止，卡顿感明显，不适合高并发服务端应用</span><br><span class="line"></span><br><span class="line">2. **Parallel GC（多线程版本的 Serial，也叫吞吐量优先 GC）**</span><br><span class="line"></span><br><span class="line">- **特点：** 多线程并行执行 GC，适合后台计算型任务</span><br><span class="line">- STW：标记、清除、压缩等阶段大多是 STW 的同样会暂停所有应用线程</span><br><span class="line"></span><br><span class="line">&gt; ✅ 吞吐量高，但停顿时间仍然较长</span><br><span class="line"></span><br><span class="line">3. **CMS（Concurrent Mark-Sweep，老年代 GC，并发标记清除）**</span><br><span class="line"></span><br><span class="line">- **特点：** 目的是 **减少 STW 时间**，适合对延迟敏感的应用</span><br><span class="line">- **STW 阶段：**</span><br><span class="line">  - 初始标记（Initial Mark）**：**STW，只标记 GC Roots **直接**关联的对象（很快）</span><br><span class="line">  - 并发标记（Concurrent Mark）**：**与应用线程并发执行，不 STW。存在错标、漏标。</span><br><span class="line">  - 重新标记（Remark）**：**STW**，修正并发标记期间用户线程修改的引用关系（关键！）**</span><br><span class="line">  - 并发清除（Concurrent Sweep）**：**不 STW</span><br><span class="line"></span><br><span class="line">&gt; ✅ **CMS 通过并发标记减少了 STW 时间，但仍有 2 次较短的 STW（初始标记和重新标记）**</span><br><span class="line"></span><br><span class="line">4. **G1 GC（Garbage First，JDK 9+ 默认 GC）**</span><br><span class="line"></span><br><span class="line">- **特点：** 面向服务端，将堆划分为多个 Region，目标是控制停顿时间</span><br><span class="line">- STW 阶段：</span><br><span class="line">  - 初始标记（Initial Mark）**：**STW并发标记</span><br><span class="line">  - 最终标记（Remark）**：**STW</span><br><span class="line">  - 筛选回收（Cleanup / Evacuation）：部分阶段 STW</span><br><span class="line"></span><br><span class="line">&gt; ✅ G1 通过分 Region 和并发/并行结合，进一步优化了 STW 时间，是 JDK 9 后的默认 GC</span><br><span class="line"></span><br><span class="line">- | 设计点                                                       | 说明                                                         |</span><br><span class="line">  | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">  | **1. 堆的逻辑结构改变：不再分“年轻代”“老年代”物理隔离**      | 而是将整个 Java 堆划分为多个大小相等的 **Region（区域）**，每个 Region 可以是 Eden、Survivor 或 Old 区，**动态分配角色** |</span><br><span class="line">  | **2. 可预测的停顿时间模型（Pause Prediction Model）**        | 你可以设置一个目标停顿时间（比如 200ms），G1 会尽量在每次 GC 时控制在这个范围内 |</span><br><span class="line">  | **3. 分 Region 回收，优先回收垃圾最多的 Region（Garbage First）** | G1 会优先选择 **垃圾比例最高（存活对象最少）的 Region** 进行回收，从而提高回收效率，这就是名字中 **“Garbage First”** 的来源 |</span><br><span class="line">  | **4. 并发与并行结合**                                        | - 并发标记（和应用线程一起运行） - 并行回收（STW，多线程加速） |</span><br><span class="line"></span><br><span class="line">5. **ZGC（Z Garbage Collector，JDK 11+ 实验性，JDK 17+ 生产可用） &amp; Shenandoah**</span><br><span class="line"></span><br><span class="line">- **特点：** **超低延迟 GC，目标 STW 时间不超过 10ms，甚至 1ms**</span><br><span class="line">- STW：极短，大部分阶段都是并发执行的只会在极少数关键阶段有非常短暂的 STW</span><br><span class="line"></span><br><span class="line">&gt; ✅ ZGC 是目前最先进的低延迟 GC，适合超大堆、超低延迟场景（如金融、游戏、实时系统）</span><br><span class="line"></span><br><span class="line"># 编程</span><br><span class="line"></span><br><span class="line">## JVM详解</span><br><span class="line"></span><br><span class="line">## 内存区</span><br><span class="line"></span><br><span class="line">![image-20250902110508883](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250902110508883.png)</span><br><span class="line"></span><br><span class="line">### 堆</span><br><span class="line"></span><br><span class="line">1. 是 JVM 中 最大的一块内存区域，用于存放**所有**对象实例和数组（即通过 `new`创建的对象）。</span><br><span class="line">2. 是 垃圾回收器（Garbage Collector, GC）主要管理的区域。</span><br><span class="line"></span><br><span class="line">### 栈（虚拟机栈）</span><br><span class="line"></span><br><span class="line">1. 每个线程运行时都会创建一个 **虚拟机栈**，用于存储 **栈帧（Stack Frame）**，每个栈帧对应一个方法调用。</span><br><span class="line">2. 栈帧中包含：</span><br><span class="line">   1. 局部变量表（Local Variables）：存储方法参数和局部变量</span><br><span class="line">   2. 操作数栈（Operand Stack）：用于计算</span><br><span class="line">   3. 动态链接（Dynamic Linking）</span><br><span class="line">   4. 方法返回地址（Return Address）</span><br><span class="line"></span><br><span class="line">### 方法区</span><br><span class="line"></span><br><span class="line">1. 作用：</span><br><span class="line"></span><br><span class="line">   - 用于存储 已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。</span><br><span class="line">   - 是 Java 类的“元数据”存储区域。</span><br><span class="line"></span><br><span class="line">2. 特点：</span><br><span class="line"></span><br><span class="line">   - 线程共享</span><br><span class="line">   - 存放内容：类的结构信息（如类名、方法、字段、父类、接口等）**静态变量（static 变量）常量池（运行时常量池）**JIT 编译后的代码</span><br><span class="line">   - 在 HotSpot 虚拟机中，方法区的实现叫 “永久代（PermGen，Java 7 及之前）” 或 “元空间（Metaspace，Java 8 及之后）”</span><br><span class="line"></span><br><span class="line">   &gt; ⚠️ 注意：方法区是 JVM 规范中定义的逻辑区域，而永久代 / 元空间 是 HotSpot 的具体实现。</span><br><span class="line"></span><br><span class="line">3. **运行时常量池（Runtime Constant Pool）【线程共享，属于方法区的一部分】**</span><br><span class="line"></span><br><span class="line">   - 是方法区的一部分，用于存放 **编译期间生成的各种字面量和符号引用**，如：字符串常量（如 `&quot;Hello&quot;`）final 常量类/方法/字段的符号引用</span><br><span class="line"></span><br><span class="line">### 本地方法栈</span><br><span class="line"></span><br><span class="line">1. 作用</span><br><span class="line">   - 为 JVM 调用的 **Native 方法（如 C/C++ 写的方法，通过 JNI 调用）** 服务</span><br><span class="line">   - 类似于 Java 虚拟机栈，但是服务于本地（非 Java）方法</span><br><span class="line"></span><br><span class="line">### 程序计数器</span><br><span class="line"></span><br><span class="line">1. 作用：</span><br><span class="line">   - 是一块较小的内存空间，是 **当前线程执行的字节码的行号指示器**</span><br><span class="line">   - 用于记录当前线程正在执行的字节码指令地址，线程切换时能恢复执行位置</span><br><span class="line">2. 特点：</span><br><span class="line">   - **线程私有**</span><br><span class="line">   - **唯一一个在 JVM 规范中没有任何 OutOfMemoryError 情况的区域**</span><br><span class="line">   - 如果线程执行的是 Java 方法，计数器记录的是正在执行的字节码指令地址；</span><br><span class="line">   - 如果执行的是 Native 方法，则计数器值为空（Undefined）</span><br><span class="line"></span><br><span class="line">## 数据结构</span><br><span class="line"></span><br><span class="line">### List</span><br><span class="line"></span><br><span class="line">#### ArrayList</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">   1. 是一种集合，底层基于 **可扩容数组**。</span><br><span class="line">   2. 底层通过数组实现，初始大小为10；</span><br><span class="line">   3. 扩容以1.5倍放大</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 分类      | 方法                    | 说明                 |</span><br><span class="line">      | --------- | ----------------------- | -------------------- |</span><br><span class="line">      | 增加      | `add(E e)`              | 在末尾添加           |</span><br><span class="line">      |           | `add(int index, E e)`   | 在指定位置插入       |</span><br><span class="line">      | 删除      | `remove(int index)`     | 删除指定下标的元素   |</span><br><span class="line">      |           | `remove(Object o)`      | 删除匹配的第一个元素 |</span><br><span class="line">      |           | `clear()`               | 清空列表             |</span><br><span class="line">      | 修改/获取 | `get(int index)`        | 获取指定下标元素     |</span><br><span class="line">      |           | `set(int index, E e)`   | 修改指定下标元素     |</span><br><span class="line">      |           | `size()`                | 返回大小             |</span><br><span class="line">      |           | `isEmpty()`             | 是否为空             |</span><br><span class="line">      | 查找      | `contains(Object o)`    | 是否包含元素         |</span><br><span class="line">      |           | `indexOf(Object o)`     | 返回第一个匹配下标   |</span><br><span class="line">      |           | `lastIndexOf(Object o)` | 返回最后一个匹配下标 |</span><br><span class="line"></span><br><span class="line">#### LinkeList</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 分类 | 方法                         | 说明                          |</span><br><span class="line">      | ---- | ---------------------------- | ----------------------------- |</span><br><span class="line">      | 增加 | `add(E e)`                   | 在末尾添加                    |</span><br><span class="line">      |      | `addFirst(E e)`              | 在头部添加                    |</span><br><span class="line">      |      | `addLast(E e)`               | 在尾部添加                    |</span><br><span class="line">      |      | `push(E e)`                  | 入栈（= addFirst）            |</span><br><span class="line">      | 删除 | `remove()` / `removeFirst()` | 删除并返回头部元素            |</span><br><span class="line">      |      | `removeLast()`               | 删除并返回尾部元素            |</span><br><span class="line">      |      | `remove(Object o)`           | 删除指定对象                  |</span><br><span class="line">      |      | `pop()`                      | 出栈（= removeFirst）         |</span><br><span class="line">      |      | `clear()`                    | 清空                          |</span><br><span class="line">      | 获取 | `get(int index)`             | 获取指定下标元素              |</span><br><span class="line">      |      | `getFirst()`                 | 获取头部元素（不删除）        |</span><br><span class="line">      |      | `getLast()`                  | 获取尾部元素（不删除）        |</span><br><span class="line">      |      | `peek()` / `peekFirst()`     | 查看头部元素，空时返回 `null` |</span><br><span class="line">      |      | `peekLast()`                 | 查看尾部元素，空时返回 `null` |</span><br><span class="line">      | 其他 | `size()`                     | 返回大小                      |</span><br><span class="line">      |      | `isEmpty()`                  | 是否为空                      |</span><br><span class="line"></span><br><span class="line">### CopyOnWriteArrayList</span><br><span class="line"></span><br><span class="line">1. CopyOnWriteArrayList 的核心原理 —— **写时复制（Copy-On-Write）**</span><br><span class="line"></span><br><span class="line">   什么是写时复制？</span><br><span class="line"></span><br><span class="line">   1. “写时复制” 的意思就是：当你要修改这个 List（比如 add / remove / set）时，不直接在原数组上修改，而是先复制一份新的数组，在新数组上进行修改，改完后再让内部的数组引用指向这个新数组。</span><br><span class="line">   2. 而对于读操作（如 get、iterator），始终是从原数组（可能是旧数组）上读取，不需要加锁，也不关心是否有写操作正在进行。</span><br><span class="line"></span><br><span class="line">2. `CopyOnWriteArrayList`是一个线程安全的 List，采用 “写时复制（Copy-On-Write）” 机制实现并发安全，适合读多写少的并发场景。</span><br><span class="line"></span><br><span class="line">### Map</span><br><span class="line"></span><br><span class="line">#### HashMap</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">   1. 底层是数组实现，大小必须是2的幂次</span><br><span class="line">   2. 哈希冲突会在对应位置生成链表（桶）</span><br><span class="line">   3. JDK8之后，链表达到一定长度后会变成红黑树</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 分类      | 方法                                       | 说明                         |</span><br><span class="line">      | --------- | ------------------------------------------ | ---------------------------- |</span><br><span class="line">      | 增加/修改 | `put(K key, V value)`                      | 插入键值对（若键存在则替换） |</span><br><span class="line">      |           | `putAll(Map m)`                            | 批量插入                     |</span><br><span class="line">      |           | `putIfAbsent(K key, V value)`              | 键不存在时才插入             |</span><br><span class="line">      | 删除      | `remove(Object key)`                       | 删除键并返回对应的值         |</span><br><span class="line">      |           | `remove(Object key, Object value)`         | 键和值都匹配时才删除         |</span><br><span class="line">      |           | `clear()`                                  | 清空                         |</span><br><span class="line">      | 获取      | `get(Object key)`                          | 获取值，不存在返回 `null`    |</span><br><span class="line">      |           | `getOrDefault(Object key, V defaultValue)` | 不存在时返回默认值           |</span><br><span class="line">      |           | `containsKey(Object key)`                  | 是否包含某个键               |</span><br><span class="line">      |           | `containsValue(Object value)`              | 是否包含某个值               |</span><br><span class="line">      | 遍历      | `keySet()`                                 | 返回所有键                   |</span><br><span class="line">      |           | `values()`                                 | 返回所有值                   |</span><br><span class="line">      |           | `entrySet()`                               | 返回键值对集合               |</span><br><span class="line">      | 其他      | `size()`                                   | 返回大小                     |</span><br><span class="line">      |           | `isEmpty()`                                | 是否为空                     |</span><br><span class="line">      |           | `replace(K key, V value)`                  | 替换指定键的值               |</span><br><span class="line">      |           | `replace(K key, V oldValue, V newValue)`   | 旧值匹配时才替换             |</span><br><span class="line"></span><br><span class="line">#### LinkedHashMap</span><br><span class="line"></span><br><span class="line">1. 底层实现几乎和HashMap一样</span><br><span class="line">2. 在每个元素中添加了一个链表，指向下一个插入的数据</span><br><span class="line"></span><br><span class="line">#### TreeMap</span><br><span class="line"></span><br><span class="line">1. 底层用红黑树实现</span><br><span class="line">2. 特点是按照Key进行排序</span><br><span class="line"></span><br><span class="line">#### HashTable</span><br><span class="line"></span><br><span class="line">1. 是线程安全的（并发安全）</span><br><span class="line">2. 进行写操作时会对整个HashTable上锁</span><br><span class="line"></span><br><span class="line">#### ConcurrentHashTable</span><br><span class="line"></span><br><span class="line">1. 和HashTable的区别就是只对桶上锁</span><br><span class="line"></span><br><span class="line">### Set</span><br><span class="line"></span><br><span class="line">1. 本身是通过Map实现的</span><br><span class="line">2. 把Value设置为null，只用Key</span><br><span class="line"></span><br><span class="line">| 方法签名                     | 说明                                                         | 示例                                        |</span><br><span class="line">| :--------------------------- | :----------------------------------------------------------- | :------------------------------------------ |</span><br><span class="line">| `boolean add(E e)`           | 添加元素到集合，如果集合中 **已存在该元素则不会重复添加，并返回 false** | `set.add(&quot;apple&quot;)`                          |</span><br><span class="line">| `boolean remove(Object o)`   | 移除指定元素，成功返回 true，否则返回 false                  | `set.remove(&quot;banana&quot;)`                      |</span><br><span class="line">| `boolean contains(Object o)` | 判断集合中是否包含某个元素                                   | `set.contains(&quot;apple&quot;)`→ true/false         |</span><br><span class="line">| `int size()`                 | 返回集合中元素的个数                                         | `set.size()`                                |</span><br><span class="line">| `boolean isEmpty()`          | 判断集合是否为空                                             | `set.isEmpty()`                             |</span><br><span class="line">| `void clear()`               | 清空集合中的所有元素                                         | `set.clear()`                               |</span><br><span class="line">| `Iterator&lt;E&gt; iterator()`     | 返回集合中元素的迭代器，用于遍历                             | `for (String s : set) &#123; ... &#125;`              |</span><br><span class="line">| `Object[] toArray()`         | 将集合转换为 Object 数组                                     | `Object[] arr = set.toArray()`              |</span><br><span class="line">| `&lt;T&gt; T[] toArray(T[] a)`     | 将集合转换为指定类型的数组                                   | `String[] arr = set.toArray(new String[0])` |</span><br><span class="line"></span><br><span class="line">### Queue</span><br><span class="line"></span><br><span class="line">| 分类         | 方法                 | 功能                   | 队列为空/满时的表现                     |</span><br><span class="line">| ------------ | -------------------- | ---------------------- | --------------------------------------- |</span><br><span class="line">| **插入**     | `add(E e)`           | 插入一个元素           | 队列满时抛异常 `IllegalStateException`  |</span><br><span class="line">|              | `offer(E e)`         | 插入一个元素           | 队列满时返回 `false`                    |</span><br><span class="line">| **查看队头** | `element()`          | 获取队头元素，但不删除 | 队列空时抛异常 `NoSuchElementException` |</span><br><span class="line">|              | `peek()`             | 获取队头元素，但不删除 | 队列空时返回 `null`                     |</span><br><span class="line">| **移除队头** | `remove()`           | 删除并返回队头元素     | 队列空时抛异常 `NoSuchElementException` |</span><br><span class="line">|              | `poll()`             | 删除并返回队头元素     | 队列空时返回 `null`                     |</span><br><span class="line">| **其他**     | `size()`             | 返回队列元素个数       | 0（如果队列空）                         |</span><br><span class="line">|              | `isEmpty()`          | 判断队列是否为空       | true/false                              |</span><br><span class="line">|              | `clear()`            | 清空队列               | 队列变空                                |</span><br><span class="line">|              | `contains(Object o)` | 判断是否包含某元素     | true/false                              |</span><br><span class="line"></span><br><span class="line">#### PriorityQueue</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">   1. `PriorityQueue&lt;E&gt;` 是 Java 提供的 **基于堆 (Heap)** 的优先队列实现类。</span><br><span class="line"></span><br><span class="line">      1. 插入元素：`O(log n)`</span><br><span class="line">      2. 删除堆顶：`O(log n)`</span><br><span class="line">      3. 获取堆顶：`O(1)`</span><br><span class="line">      4. 遍历 `PriorityQueue` 得到的结果 **不是排序好的**</span><br><span class="line">      5. **允许重复元素**，不允许 `null`。</span><br><span class="line"></span><br><span class="line">   2. 默认大小是11.</span><br><span class="line"></span><br><span class="line">      1. 当元素个数超过当前容量时，会 **自动扩容**。</span><br><span class="line"></span><br><span class="line">         扩容规则：</span><br><span class="line"></span><br><span class="line">         1. 如果旧容量 &lt; 64 → 新容量 = `(旧容量 * 2) + 2`</span><br><span class="line">            （比如 11 → 24 → 50 …）</span><br><span class="line">         2. 如果旧容量 ≥ 64 → 新容量 = `旧容量 + (旧容量 &gt;&gt; 1)`</span><br><span class="line">            （相当于 1.5 倍扩容，比如 64 → 96 → 144 …）</span><br><span class="line"></span><br><span class="line">   3. 默认是 **最小堆**：堆顶元素是“最小值”。</span><br><span class="line"></span><br><span class="line">   4. 如果要最大堆，需要自定义 **比较器 (Comparator)**。</span><br><span class="line"></span><br><span class="line">   5. 常见应用：**Top K 问题、任务调度、最短路径算法 (Dijkstra)、Huffman 编码** 等。</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. 构造方法</span><br><span class="line"></span><br><span class="line">      1. ```java</span><br><span class="line">         PriorityQueue&lt;Integer&gt; pq1 = new PriorityQueue&lt;&gt;();  </span><br><span class="line">         // 默认最小堆</span><br><span class="line">         </span><br><span class="line">         PriorityQueue&lt;Integer&gt; pq2 = new PriorityQueue&lt;&gt;(Collections.reverseOrder());  </span><br><span class="line">         // 最大堆</span><br><span class="line">         </span><br><span class="line">         PriorityQueue&lt;String&gt; pq3 = new PriorityQueue&lt;&gt;(Comparator.comparingInt(String::length));  </span><br><span class="line">         // 自定义比较规则：字符串长度</span><br><span class="line">         </span><br></pre></td></tr></table></figure>


<ol start="2">
<li>调用方法参考普通队列</li>
</ol>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><ol>
<li>构造：<code>Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();</code>。从中可以看出，其本质就是一个链表。只不过为了面向接口编程，这样定义不会误用其他方法。</li>
<li>用法：<ol>
<li>offerFirst、offerLast等等</li>
</ol>
</li>
</ol>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul>
<li>也是对树结构的平衡，但是和AVL树有区别<ul>
<li><strong>AVL 树</strong>（严格平衡，查找快）</li>
<li><strong>红黑树</strong>（相对平衡，插入&#x2F;删除更快，综合性能更好）</li>
</ul>
</li>
</ul>
<ol>
<li>五大原则<ol>
<li>每个节点要么是红色，要么是黑色。​​</li>
<li>根节点必须是黑色。</li>
<li>叶子节点（NIL &#x2F; 空节点）视为黑色。</li>
<li>红色节点的两个子节点都必须是黑色（即不能有两个连续的红色节点）。</li>
<li>从任意一个节点到其所有后代叶子节点的路径上，黑色节点的数量相同（称为<strong>黑高相同</strong>）。</li>
</ol>
</li>
</ol>
<blockquote>
<p>口诀：左根右（二叉搜索树），根叶黑，不红红，黑路同</p>
</blockquote>
<ol start="2">
<li><p>插入</p>
<ol>
<li>默认插入点（cur）节点是红色的</li>
<li>破坏了根叶黑：若插入节点是根节点，直接变黑</li>
<li>破坏了不红红：<ol>
<li>若插入节点的“叔叔”节点（父节点的兄弟节点）是<strong>红色</strong>，则叔父爷变色，cur指向爷爷，然后递归判定原则</li>
<li>若插入节点的叔叔节点是<strong>黑色</strong>，则进行旋转（同AVL树），然后旋转中心点和旋转点变色<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250903172751771.png" alt="image-20250903172751771"></li>
</ol>
</li>
</ol>
</li>
<li><p>删除：</p>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20250909104920937.png" alt="image-20250909104920937"></p>
<ol>
<li>理念：<ol>
<li>对于一般的二叉搜索树，删除都有三种情况：叶节点，有一个子树，有两个子树。但是有两个子树的情况最终是转换成前两种情况。所以针对红黑树，我们只需要研究前两种就好了</li>
<li>针对红黑树，只有一个子树时，子树一定只有一个节点。否则要么违反不红红，要么违反黑路同</li>
</ol>
</li>
<li>删除叶节点：<ol>
<li>红色：直接删除</li>
<li>黑色：我们把要调整的节点成为“双黑节点”，代表经过它的路径都少一个黑节点<ol>
<li>兄弟节点是黑色：<ol>
<li>兄弟节点至少有一个红色孩子：<ol>
<li>变色：兄弟节点、其红孩子和父节点都要集成对应的上级节点的颜色</li>
<li>旋转</li>
</ol>
</li>
<li>兄弟节点只有黑孩子：<ol>
<li>把兄弟节点变为红色，那么就恢复了局部的黑路同，双黑节点交给父节点</li>
<li>递归处理</li>
</ol>
</li>
</ol>
</li>
<li>兄弟是红节点：兄父变色，朝双黑旋转</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ol>
<li><p>和B树的区别</p>
<ol>
<li><p>很像。当我们要遍历树中元素时，对于B树，需要中序遍历，这要求指针来回跳跃，非常耗时。</p>
</li>
<li><p>而B+数则要求<strong>在叶节点上保存所有的元素</strong>，并且从小到大链接起来<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251025144006035.png" alt="image-20251025144006035"></p>
</li>
<li><p>对于非叶子结点，每个元素代表对应子节点的最大值。</p>
</li>
<li><p>非叶子节点相当于只是索引</p>
</li>
</ol>
</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><ol>
<li>所有异常都来自于顶级父类Throwable</li>
<li>Throwable下有两个子类：Exception, Error<ol>
<li>Error：表示非常严重的错误（JVM或系统级），程序无法解决。<ol>
<li>比如，OutOfMemoryError（内存不足，堆内存溢出），StackOverflowError，（栈溢出，比如无限递归）</li>
</ol>
</li>
<li>Exception：表示程序可以解决的异常。Exception一般又可以分为RuntimeException和Checked Exception（受检异常 &#x2F; 必检异常）。<ol>
<li>RuntimeException：运行时异常，一般为逻辑错误。</li>
<li>Checked Exception：检查异常，由编译器要求必须处理</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li><p>try-catch-finally</p>
<p>用于 <strong>捕获并处理异常</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理 IOException</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获其他异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否异常都会执行的代码（如关闭资源）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<ol start="2">
<li>throws（声明抛出）</li>
</ol>
<p>如果当前方法 不想处理某个受检异常，可以将其抛给调用者处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用者必须继续处理这个异常（catch 或继续 throws）。</p>
</li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol>
<li><p>你可以根据业务需求定义自己的异常类，通常继承自：</p>
<ul>
<li><strong>Exception</strong>（受检异常）</li>
<li><strong>RuntimeException</strong>（运行时异常）</li>
</ul>
<p>示例：自定义受检异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCheckedException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCheckedException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>示例：自定义运行时异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUncheckedException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUncheckedException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="泛型和多态"><a href="#泛型和多态" class="headerlink" title="泛型和多态"></a>泛型和多态</h2><ol>
<li><p>泛型的实现</p>
<ol>
<li><p><strong>泛型（Generics）是如何实现的？ → 核心机制：类型擦除（Type Erasure）</strong></p>
<hr>
<p>✅ 1. 泛型的本质：<strong>编译期的类型检查，运行时类型擦除</strong></p>
<blockquote>
<p><strong>Java 的泛型是通过 “类型擦除（Type Erasure）” 实现的，这意味着泛型信息只在编译阶段存在，用于类型检查，而在编译成字节码后，类型参数会被擦除，替换为默认类型（通常是 Object 或指定的边界类型）。</strong></p>
</blockquote>
<hr>
<p>✅ 2. 举个例子 👇</p>
<h3 id="你写这样的泛型代码："><a href="#你写这样的泛型代码：" class="headerlink" title="你写这样的泛型代码："></a>你写这样的泛型代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">String s = list.get(0); // 不需要强转</span><br></pre></td></tr></table></figure>


<h3 id="但在编译后（字节码层面），它实际上变成了："><a href="#但在编译后（字节码层面），它实际上变成了：" class="headerlink" title="但在编译后（字节码层面），它实际上变成了："></a>但在编译后（字节码层面），它实际上变成了：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList(); // 类型参数 &lt;String&gt; 被擦除了</span><br><span class="line">list.add(&quot;Hello&quot;);</span><br><span class="line">String s = (String) list.get(0); // 编译器自动插入了强制类型转换</span><br></pre></td></tr></table></figure>


<blockquote>
<p>✅ <strong>编译器在编译时保证了你只能放入 String，取出时也自动帮你转回 String，但运行时 JVM 看到的只是原始类型 List。</strong></p>
</blockquote>
<hr>
<p>✅ 3. 类型擦除的规则</p>
<table>
<thead>
<tr>
<th align="left">情况</th>
<th align="left">擦除后变成什么</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>List&lt;T&gt;</code></td>
<td align="left">擦除为 <code>List&lt;Object&gt;</code>（JDK 1.5 早期）或更准确地说是 <code>List</code>（原始类型）</td>
</tr>
<tr>
<td align="left"><code>List&lt;String&gt;</code></td>
<td align="left">擦除为 <code>List</code>，但编译器会做类型检查并插入强制转换</td>
</tr>
<tr>
<td align="left"><code>T extends Number</code>（比如 <code>List&lt;Integer&gt;</code>）</td>
<td align="left">擦除为 <code>Number</code>，即上限类型</td>
</tr>
<tr>
<td align="left"><code>T</code>没有指定边界</td>
<td align="left">擦除为 <code>Object</code></td>
</tr>
</tbody></table>
<hr>
<p>✅ 4. 为什么用类型擦除实现泛型？</p>
<ul>
<li><strong>历史原因</strong>：为了兼容 Java 5 之前的代码（非泛型代码），保证泛型引入后 <strong>旧代码依然能运行</strong>，不破坏二进制兼容性。</li>
<li><strong>JVM 层面没有泛型支持</strong>：Java 的虚拟机（JVM）本身并不直接认识泛型类型，它是基于原始类型运作的。</li>
</ul>
<blockquote>
<p>✅ <strong>总结：泛型是 Java 编译器层面的语法糖，它通过类型擦除在编译时提供类型安全，运行时则“擦除”掉具体类型信息。</strong></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">说明</th>
<th align="left">是否推荐</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1️⃣ 继承 <code>Thread</code>类</td>
<td align="left">自定义类继承 <code>Thread</code>，重写 <code>run()</code>方法</td>
<td align="left">⭐ 不推荐</td>
<td align="left">简单示例、学习线程基础</td>
</tr>
<tr>
<td align="left">2️⃣ 实现 <code>Runnable</code>接口</td>
<td align="left">实现 <code>Runnable</code>接口，实现 <code>run()</code>方法，传给 Thread 对象</td>
<td align="left">⭐⭐⭐⭐ 推荐</td>
<td align="left">大多数场景，灵活、面向接口</td>
</tr>
<tr>
<td align="left">3️⃣ 实现 <code>Callable&lt;V&gt;</code>接口 + <code>FutureTask</code></td>
<td align="left">类似 Runnable，但可以<strong>有返回值</strong>，能抛异常</td>
<td align="left">⭐⭐⭐ 推荐（需要返回值时）</td>
<td align="left">需要获取线程执行结果的场景</td>
</tr>
<tr>
<td align="left">4️⃣ 使用线程池（Executor 框架）</td>
<td align="left">通过线程池（如 <code>Executors</code>）管理线程的创建和执行</td>
<td align="left">⭐⭐⭐⭐⭐ 强烈推荐</td>
<td align="left">生产环境、高并发、线程复用</td>
</tr>
</tbody></table>
<ol>
<li><p>创建线程池参数</p>
<ol>
<li><pre><code class="language-java">public ThreadPoolExecutor(
    int corePoolSize,                  // 核心线程数
    int maximumPoolSize,               // 最大线程数
    long keepAliveTime,                // 空闲线程存活时间
    TimeUnit unit,                     // 时间单位
    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列
    ThreadFactory threadFactory,       // 线程工厂
    RejectedExecutionHandler handler   // 拒绝策略
)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 线程池</span><br><span class="line"></span><br><span class="line">1. 工作原理</span><br><span class="line">   1. 步骤 1：如果当前线程数 &lt; 核心线程数（corePoolSize）</span><br><span class="line">      - 线程池会 立即创建一个新线程 来执行这个任务</span><br><span class="line">      - 该线程执行完任务后 不会被销毁，而是进入线程池中 等待下一个任务</span><br><span class="line">   2. 步骤 2：如果线程数 ≥ 核心线程数，但任务队列未满</span><br><span class="line">      - 线程池 不会创建新线程</span><br><span class="line">      - 而是把任务放入 任务队列（workQueue）中等待</span><br><span class="line">      - 空闲的核心线程会 从队列中取出任务执行</span><br><span class="line">   3. 步骤 3：如果任务队列已满，但线程数 &lt; 最大线程数（maximumPoolSize）</span><br><span class="line">      - 线程池会 创建新的线程（非核心线程） 来执行这个任务</span><br><span class="line">      - 这些线程在完成任务后，如果 空闲时间超过 keepAliveTime，就会被销毁</span><br><span class="line">   4. 步骤 4：如果线程数已达最大线程数，且任务队列已满</span><br><span class="line">      - 线程池会触发 拒绝策略（RejectedExecutionHandler）比如抛出异常、丢弃任务、由调用线程自己执行等</span><br><span class="line">2. 注意，是等待队列满了之后才会创建新线程。</span><br><span class="line"></span><br><span class="line">### ThreadLocal</span><br><span class="line"></span><br><span class="line">1. 是什么？</span><br><span class="line"></span><br><span class="line">   1. `ThreadLocal`是 Java 中一个非常有特色的线程绑定机制，它提供了一种**线程本地存储**（Thread-local Storage）的方式，即 每个线程都有自己独立的变量副本，线程之间互不干扰，从而避免了多线程环境下的共享变量同步问题。</span><br><span class="line">   2. **ThreadLocal 本身是用来存储单个线程的单一变量（一个 ThreadLocal 对应一个值）**</span><br><span class="line"></span><br><span class="line">2. 应用场景</span><br><span class="line"></span><br><span class="line">   1. 线程上下文信息传递（如用户登录信息、请求上下文）</span><br><span class="line"></span><br><span class="line">      在 Web 应用或服务端程序中，一个请求往往由一个线程处理，我们经常需要在处理过程中传递一些上下文信息，比如：</span><br><span class="line"></span><br><span class="line">      - 当前登录用户信息（User）</span><br><span class="line">      - 请求 ID（traceId / requestId）</span><br><span class="line">      - 数据源信息</span><br><span class="line">      - 事务上下文</span><br><span class="line"></span><br><span class="line">      如果通过方法参数一层层传递，代码会非常冗余。使用 `ThreadLocal`可以优雅地解决这个问题，让这些信息**在当前线程中“全局可见”**</span><br><span class="line"></span><br><span class="line">   2. 数据库连接、Session 等线程隔离资源管理</span><br><span class="line"></span><br><span class="line">      1. 为了保证每个线程使用独立的数据库连接，避免多线程并发问题，会使用 `ThreadLocal`来保存当前线程的 Connection 或 Session。</span><br><span class="line"></span><br><span class="line">3. 底层原理</span><br><span class="line"></span><br><span class="line">   1. 每个 Thread 对象内部都有一个 ThreadLocalMap</span><br><span class="line"></span><br><span class="line">   2. 数据结构：ThreadLocalMap（类似简易的 HashMap）</span><br><span class="line"></span><br><span class="line">      - `ThreadLocalMap`是 ThreadLocal 的静态内部类</span><br><span class="line">      - 它的 **key 是 ThreadLocal 对象本身（弱引用）**</span><br><span class="line">      - value 是线程本地存储的实际值</span><br><span class="line">      - 它是一个 定制化的哈希表，专门为 ThreadLocal 服务</span><br><span class="line"></span><br><span class="line">   3. ```java</span><br><span class="line">      Thread</span><br><span class="line">      └── threadLocals: ThreadLocalMap</span><br><span class="line">             ├── key: ThreadLocal 对象1（弱引用） → value: 线程1的变量值1</span><br><span class="line">             ├── key: ThreadLocal 对象2（弱引用） → value: 线程1的变量值2</span><br><span class="line">             └── ...</span><br><span class="line">             </span><br><span class="line">      （每个线程都有自己的 threadLocals，彼此独立）</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>内存泄露问题</p>
<ol>
<li>Entry 的 key 是 ThreadLocal 对象的弱引用，但 value 是强引用</li>
<li>当你不再引用这个ThreadLocal，但是线程长期存活时，当遇到GC，key就会被回收（因为是弱引用），但是value没法回收。造成泄露。</li>
<li>一定要用threadLocal.remove()手动回收</li>
</ol>
</li>
</ol>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left"><strong>悲观锁（Pessimistic Locking）</strong></th>
<th align="left"><strong>乐观锁（Optimistic Locking）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left"><strong>“总会有人抢，先加锁，防止冲突”</strong></td>
<td align="left"><strong>“大家不一定会冲突，先尝试，冲突了再处理”</strong></td>
</tr>
<tr>
<td align="left"><strong>锁的获取</strong></td>
<td align="left"><strong>操作数据前先加锁，阻止其他人修改</strong></td>
<td align="left"><strong>操作数据前不加锁，提交时检查是否被修改过</strong></td>
</tr>
<tr>
<td align="left"><strong>并发性能</strong></td>
<td align="left"><strong>并发度低，线程会阻塞，上下文切换开销大</strong></td>
<td align="left"><strong>并发度高，无阻塞，靠重试或版本控制解决冲突</strong></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>冲突频繁，写多读少</strong>（如银行转账）</td>
<td align="left"><strong>冲突较少，读多写少</strong>（如计数器、浏览量）</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">synchronized、ReentrantLock、数据库行锁&#x2F;表锁等</td>
<td align="left">CAS、版本号（version）、时间戳等</td>
</tr>
<tr>
<td align="left"><strong>典型实现</strong></td>
<td align="left">synchronized、Lock 接口、数据库的 <code>SELECT ... FOR UPDATE</code></td>
<td align="left">CAS（Compare-And-Swap）、<code>version</code>字段、<code>AtomicXXX</code></td>
</tr>
<tr>
<td align="left"><strong>是否阻塞</strong></td>
<td align="left">是（线程会等待锁）</td>
<td align="left">否（线程不会阻塞，冲突时重试或失败）</td>
</tr>
</tbody></table>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>AQS 是什么</strong></td>
<td align="left">Java 并发包中实现锁和同步器的<strong>底层核心框架</strong>（如 ReentrantLock、Semaphore 的基础）</td>
</tr>
<tr>
<td align="left"><strong>核心功能</strong></td>
<td align="left">管理同步状态（state）、线程排队（CLH 队列）、阻塞与唤醒</td>
</tr>
<tr>
<td align="left"><strong>核心变量</strong></td>
<td align="left"><code>volatile int state</code>：表示同步状态（比如锁是否被占用、剩余许可数等）</td>
</tr>
<tr>
<td align="left"><strong>核心机制</strong></td>
<td align="left">线程获取资源失败时进入队列等待，资源可用时被唤醒</td>
</tr>
<tr>
<td align="left"><strong>两种模式</strong></td>
<td align="left">独占模式（如锁）、共享模式（如信号量、读锁）</td>
</tr>
<tr>
<td align="left"><strong>子类实现</strong></td>
<td align="left">开发者通过重写 <code>tryAcquire</code>&#x2F; <code>tryRelease</code>等方法，定义资源获取与释放逻辑</td>
</tr>
<tr>
<td align="left"><strong>应用广泛</strong></td>
<td align="left">是 Java 中大部分同步工具（如 Lock、Semaphore、CountDownLatch）的底层实现基础</td>
</tr>
</tbody></table>
<ol>
<li><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器） 是 Java 并发包（<code>java.util.concurrent</code>）中 最核心、最基础的<strong>同步框架</strong>，它是 构建锁和同步器（如 ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）的基石。</p>
</li>
<li><p>作用</p>
<ol>
<li>同步状态的管理（比如锁是否被占用、资源数是否足够）</li>
<li>线程的排队与阻塞（当资源不可用时，线程进入等待队列）</li>
<li>线程的唤醒与通知（当资源可用时，唤醒等待线程）</li>
</ol>
<p>它主要用于构建 锁（Lock）和同步器（Synchronizer），是 实现线程安全与并发控制的重要基础框架。</p>
</li>
<li><p>工作原理</p>
<ol>
<li><p>同步状态（State）</p>
<p>AQS 内部维护了一个 volatile int 类型的 state 变量，表示 同步状态，这个状态的意义取决于具体的同步器实现</p>
</li>
<li><p>线程的排队（CLH 队列）</p>
<p>当某个线程尝试获取资源（比如锁、许可）但 失败时（比如锁被占用、许可不足），AQS 会将该线程封装成一个 Node 节点，并加入到一个 FIFO（先进先出）的等待队列中，这个队列叫做 CLH 队列（Craig, Landin, and Hagersten 队列）。</p>
</li>
<li><p>阻塞与唤醒</p>
<ul>
<li>当线程获取资源失败时，AQS 会通过 LockSupport.park() 将线程阻塞（挂起）</li>
<li>当资源可用时（比如其他线程释放了锁或许可），AQS 会通过 LockSupport.unpark() 唤醒队列中的线程</li>
</ul>
</li>
</ol>
</li>
<li><p>AQS 底层数据结构 —— CLH 队列（简化理解）</p>
<ol>
<li>当线程获取资源失败时，AQS 会将线程封装成 <strong>Node 节点</strong>，并加入到一个 <strong>FIFO 队列（CLH 队列）</strong> 中等待。<ul>
<li>每个 Node 代表一个等待的线程</li>
<li>队列是 <strong>双向链表结构</strong></li>
<li>头节点一般是占用资源的线程，后续节点是排队等待的线程</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul>
<li>在 Java 中，当多个线程同时访问共享资源（比如一个变量、对象、集合等）时，如果没有合理的同步措施，就可能导致数据不一致、线程安全问题。</li>
</ul>
<ol>
<li><p>同步关键字 synchonized</p>
<ol>
<li><p><code>synchronized</code>是 Java 提供的最基本的线程同步机制，它基于 对象监视器（monitor），可以修饰 <strong>方法</strong> 或 <strong>代码块</strong>，保证同一时刻 只有一个线程能进入被 synchronized 保护的代码区域。</p>
</li>
<li><p>使用方法（只展示如何锁住代码块）：</p>
<ol>
<li><pre><code class="language-java">public class Counter {
    private int count = 0;
    private final Object lock = new Object(); // 任意对象，作为锁对象

    public void increment() {
        synchronized (lock) {  // 只锁定需要同步的代码块，不是整个方法
            count++;
        }
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 锁升级：</span><br><span class="line"></span><br><span class="line">   1. 根据线程竞争的情况，synchronized 锁会从 偏向锁 → 轻量级锁 → 重量级锁 逐步升级，尽量以最小的性能代价实现线程同步。</span><br><span class="line"></span><br><span class="line">   2. 三层锁状态</span><br><span class="line"></span><br><span class="line">      1. </span><br><span class="line"></span><br><span class="line">      2. | 锁状态                              | 说明                                                         | 适用场景                                        | 底层实现                                                  |</span><br><span class="line">         | :---------------------------------- | :----------------------------------------------------------- | :---------------------------------------------- | :-------------------------------------------------------- |</span><br><span class="line">         | **1. 偏向锁（Biased Lock）**        | 假设锁只会被 **一个线程访问**，不存在竞争，**加锁时几乎没有额外开销** | 单线程访问同步代码块的场景                      | 通过对象头 Mark Word 中记录偏向线程ID                     |</span><br><span class="line">         | **2. 轻量级锁（Lightweight Lock）** | 假设锁 **只有少量线程交替访问，竞争不激烈**，采用 **CAS 自旋方式获取锁，线程不阻塞** | 多线程交替执行，但 **没有或很少真正的并发争抢** | 通过 CAS 操作和栈帧中的 **Lock Record** 实现              |</span><br><span class="line">         | **3. 重量级锁（Heavyweight Lock）** | 当多个线程 **真正并发竞争锁时**，轻量级锁升级为重量级锁，线程会进入 **阻塞状态，由操作系统管理** | 高并发、多线程同时争抢锁                        | 基于操作系统 **Mutex Lock（互斥锁）**，涉及线程挂起与唤醒 |</span><br><span class="line"></span><br><span class="line">   3. 锁升级流程</span><br><span class="line"></span><br><span class="line">      1. ```java</span><br><span class="line">         无锁状态</span><br><span class="line">            ↓ （第一次被线程访问，且没有竞争）</span><br><span class="line">         偏向锁（Biased Lock）</span><br><span class="line">            ↓ （当有第二个线程尝试获取锁，发现不是自己）</span><br><span class="line">         轻量级锁（Lightweight Lock，通过 CAS 自旋）</span><br><span class="line">            ↓ （如果自旋超过阈值，或等待线程较多，竞争激烈）</span><br><span class="line">         重量级锁（Heavyweight Lock，线程进入阻塞，由 OS 管理）</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="language-java">线程1第一次获取锁
       ↓
     偏向锁（记录线程1的ID，几乎无开销）
       ↓
线程2来尝试获取锁（不是线程1）
       ↓
   偏向锁撤销，升级为轻量级锁
       ↓
线程1释放，线程2通过 CAS 获取锁（自旋）
       ↓
如果自旋多次仍失败，或竞争激烈
       ↓
     升级为重量级锁（线程阻塞，OS 管理）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   4. 自旋：</span><br><span class="line"></span><br><span class="line">      1. 当一个线程尝试获取某个资源（比如锁）失败时，它不会立即被阻塞（挂起）、让出 CPU，而是通过循环（忙等 / busy-waiting）的方式，不停地尝试重新获取锁，直到成功为止。</span><br><span class="line">      2. 简单来说就是：线程不放弃 CPU，而是“原地打转”，反复尝试，直到成功获取所需资源。</span><br><span class="line"></span><br><span class="line">#### ReentrantLock</span><br><span class="line"></span><br><span class="line">1. 用法</span><br><span class="line"></span><br><span class="line">   1. 创建：`private final Lock lock = new ReentrantLock();`</span><br><span class="line">   2. 在访问共享资源之前，调用 `lock.lock()`加锁。这个方法会阻塞线程，直到加到锁。</span><br><span class="line">   3. 执行你的临界区代码（操作共享资源）</span><br><span class="line">   4. **在 finally 块中调用 `lock.unlock()`释放锁**（⚠️ 必须做，防止遇到**异常**导致无法解锁）</span><br><span class="line">   5. `trylock()`会尝试枷锁，不会阻塞线程。加到锁返回true，否则返回false。</span><br><span class="line">   6. 例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">    // 加锁保证线程安全</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        lock.lock();      // 1. 加锁</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;      // 2. 临界区代码（操作共享资源）</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock(); // 3. 一定要在 finally 中解锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>作用范围是从lock到unlock的中间代码块</p>
</li>
</ol>
</li>
<li><p>公平锁和非公平锁</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>公平锁（Fair Lock）</strong></th>
<th align="left"><strong>非公平锁（Nonfair Lock）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">按照线程请求锁的 <strong>先后顺序</strong> 获取锁，先到先得</td>
<td align="left">线程获取锁时，<strong>不排队，直接尝试抢锁</strong>，谁抢到算谁的</td>
</tr>
<tr>
<td align="left"><strong>是否排队</strong></td>
<td align="left">✅ 按 FIFO（先进先出）顺序获取锁</td>
<td align="left">❌ 不保证顺序，允许插队</td>
</tr>
<tr>
<td align="left"><strong>可能导致饥饿</strong></td>
<td align="left">❌ 不会，所有线程最终都能获得锁</td>
<td align="left">✅ 可能，某些线程可能一直抢不到锁</td>
</tr>
<tr>
<td align="left"><strong>吞吐量（性能）</strong></td>
<td align="left">⬇️ 较低，因为要维护顺序</td>
<td align="left">⬆️ 较高，减少线程切换和等待</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">加锁前先检查是否有线程在排队</td>
<td align="left">直接尝试 CAS 抢锁，抢不到再排队</td>
</tr>
<tr>
<td align="left"><strong>创建方式</strong></td>
<td align="left"><code>new ReentrantLock(true)</code></td>
<td align="left"><code>new ReentrantLock(false)</code>或默认</td>
</tr>
</tbody></table>
</li>
<li><p>底层原理</p>
<ol>
<li><p><code>ReentrantLock</code>的公平与非公平实现，核心都依赖于 <strong>AQS（AbstractQueuedSynchronizer，抽象队列同步器）</strong>。</p>
</li>
<li><p>AQS 的核心机制</p>
<p>AQS 内部维护了一个 FIFO 等待队列（CLH 队列），以及一个 volatile 状态变量 state 表示锁的状态：</p>
<ul>
<li>state &#x3D; 0：表示锁未被占用</li>
<li>state &gt; 0：表示锁被占用，数值代表重入次数</li>
</ul>
<p>当线程尝试获取锁时：</p>
<ul>
<li>如果锁是空闲的（state &#x3D;&#x3D; 0），尝试通过 CAS（Compare And Swap） 抢锁</li>
<li>如果锁被占用，线程进入等待队列中排队</li>
</ul>
</li>
<li><p>非公平锁（Nonfair Lock）的实现原理</p>
<ol>
<li>获取锁时的逻辑（简化）：<ol>
<li>直接尝试 CAS 抢锁（不排队！）使用 CAS 将 state 从 0 改为 1，如果成功，当前线程获得锁</li>
<li>如果 CAS 失败（锁被占用），才进入 AQS 队列等待</li>
<li>唤醒后继续尝试抢锁</li>
</ol>
</li>
<li>优点：吞吐量高，减少线程挂起和切换，性能更好</li>
<li>缺点：可能导致某些线程一直抢不到锁（饥饿）</li>
</ol>
</li>
<li><p>公平锁（Fair Lock）的实现原理</p>
<ol>
<li>获取锁时的逻辑（简化）：<ol>
<li>先检查是否有线程在排队（hasQueuedPredecessors()）如果队列中 已经有其它线程在等待，那么当前线程 不去抢锁，直接进入队列排队</li>
<li>如果队列为空，才尝试 CAS 抢锁</li>
<li>如果 CAS 成功，获得锁；失败则进入队列</li>
</ol>
</li>
<li>优点：避免饥饿，每个线程最终都能获得锁，公平性好</li>
<li>缺点：性能较差，增加了线程切换和排队时间</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><ol>
<li>倒计时门闩：CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待，直到其他线程完成一组操作。你可以把它想象成一个“倒计时器”：主线程等待 N 个子线程完成各自任务后，再继续执行。</li>
<li>工作原理<ol>
<li><code>CountDownLatch</code>内部基于 AQS 实现</li>
<li>初始化时设置一个 state &#x3D; count（计数值）</li>
<li>每调用一次 <code>countDown()</code>，state 减 1（通过 CAS 操作）</li>
<li>调用 <code>await()</code>的线程会阻塞，直到 state &#x3D;&#x3D; 0</li>
<li><strong>CountDownLatch 只能用一次，计数归零后不能重置！</strong></li>
</ol>
</li>
</ol>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><ol>
<li>Semaphore 是一个计数信号量，用于控制同时访问某个资源的线程数量，常用于限流、资源池管理。</li>
<li>工作原理<ol>
<li><code>Semaphore</code>也基于 AQS 实现</li>
<li>内部维护了一组 可用的许可（permits），也就是 state 值</li>
<li>调用 <code>acquire()</code>时：如果还有许可（state &gt; 0），则 state 减 1，线程继续执行如果没有许可，则线程进入 AQS 队列等待</li>
<li>调用 <code>release()</code>时：state 加 1，唤醒等待队列中的一个线程</li>
<li>Semaphore 可以重复使用，许可可以动态获取和释放</li>
</ol>
</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="基本的通信架构"><a href="#基本的通信架构" class="headerlink" title="基本的通信架构"></a>基本的通信架构</h3><ol>
<li>CS架构（Client客户端 &#x2F; Server服务端）</li>
<li>BS架构（Browser浏览器 &#x2F; Server服务端）</li>
</ol>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><ul>
<li><p>是JAVA中的一个类，用于表示 <strong>IP 地址</strong>（可以是 IPv4 或 IPv6），并提供了与 IP 地址相关的一些常用操作，比如解析主机名、获取本机地址等</p>
</li>
<li><p>常用方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static InetAddress getByName(String host)</code></td>
<td align="left">根据主机名（如 <code>&quot;www.baidu.com&quot;</code>）或 IP 地址字符串（如 <code>&quot;14.215.177.39&quot;</code>）返回对应的 <code>InetAddress</code>实例。</td>
</tr>
<tr>
<td align="left"><code>static InetAddress[] getAllByName(String host)</code></td>
<td align="left">返回与给定主机名关联的所有 IP 地址（因为一个域名可能对应多个 IP）。返回的是一个数组。</td>
</tr>
<tr>
<td align="left"><code>static InetAddress getLocalHost()</code></td>
<td align="left">获取本机（localhost）的 <code>InetAddress</code>对象。</td>
</tr>
<tr>
<td align="left"><code>String getHostName()</code></td>
<td align="left">获取此 IP 地址对应的主机名。</td>
</tr>
<tr>
<td align="left"><code>String getHostAddress()</code></td>
<td align="left">获取该对象的 IP 地址字符串表示（如 <code>&quot;192.168.1.100&quot;</code>）。</td>
</tr>
<tr>
<td align="left"><code>boolean isReachable(int timeout)</code></td>
<td align="left">测试该地址是否可达（通过网络 ping），timeout 是超时时间（毫秒）。<strong>注意：这个方法不一定在所有环境下都有效，比如受防火墙限制。</strong></td>
</tr>
</tbody></table>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><ol>
<li>周知窗口：0-1023</li>
<li>注册端口：1024-49151</li>
<li>动态端口：49152-65535</li>
</ol>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><ol>
<li>特点：无连接，不可靠</li>
<li>不事先建立连接。发出去就不管了</li>
<li>每次把数据封装在包内（lim 64KB）</li>
</ol>
<h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><ol>
<li>面向连接，可靠通信</li>
<li>三次握手，四次挥手</li>
</ol>
<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><h3 id="DatagramSocket-、DatagramPacket"><a href="#DatagramSocket-、DatagramPacket" class="headerlink" title="DatagramSocket 、DatagramPacket"></a>DatagramSocket 、DatagramPacket</h3><ol>
<li><p>DatagramSocket用于收发数据报</p>
</li>
<li><p>DatagramPacket表示一个实际的数据包包括数据内容，目标IP和端口，来源IP和端口。</p>
</li>
<li><p>常用方法</p>
<ol>
<li><table>
<thead>
<tr>
<th><code>DatagramSocket()</code></th>
<th>创建一个 UDP 套接字，系统自动分配端口（常用于客户端）</th>
</tr>
</thead>
<tbody><tr>
<td><code>DatagramSocket(int port)</code></td>
<td>创建并绑定到指定端口（常用于服务端）</td>
</tr>
<tr>
<td><code>void send(DatagramPacket p)</code></td>
<td>发送一个数据报包</td>
</tr>
<tr>
<td><code>void receive(DatagramPacket p)</code></td>
<td>接收一个数据报包（阻塞）</td>
</tr>
<tr>
<td><code>void close()</code></td>
<td>关闭套接字，释放资源</td>
</tr>
<tr>
<td><code>void setSoTimeout(int timeout)</code></td>
<td>设置接收超时时间（毫秒）</td>
</tr>
<tr>
<td><code>int getLocalPort()</code></td>
<td>获取本地绑定的端口号</td>
</tr>
<tr>
<td><code>boolean isBound()</code></td>
<td>是否已绑定端口</td>
</tr>
<tr>
<td><code>boolean isClosed()</code></td>
<td>是否已关闭</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="java-net-Socket"><a href="#java-net-Socket" class="headerlink" title="java.net.Socket"></a>java.net.Socket</h3><ol>
<li><p>常用方法</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th><code>Socket(String host, int port)</code></th>
<th>创建 Socket 并连接到指定主机和端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>InputStream getInputStream()</code></td>
<td>获取输入流，用于读取服务器数据</td>
</tr>
<tr>
<td><code>OutputStream getOutputStream()</code></td>
<td>获取输出流，用于向服务器发送数据</td>
</tr>
<tr>
<td><code>void close()</code></td>
<td>关闭 Socket 和相关资源</td>
</tr>
<tr>
<td><code>void setSoTimeout(int timeout)</code></td>
<td>设置读取超时（毫秒）</td>
</tr>
<tr>
<td><code>InetAddress getInetAddress()</code></td>
<td>获取远程服务器 IP</td>
</tr>
<tr>
<td><code>int getPort()</code></td>
<td>获取远程服务器端口</td>
</tr>
<tr>
<td><code>boolean isConnected()</code></td>
<td>判断是否已连接</td>
</tr>
<tr>
<td><code>boolean isClosed()</code></td>
<td>判断是否已关闭</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="java-net-ServerSocket"><a href="#java-net-ServerSocket" class="headerlink" title="java.net.ServerSocket"></a>java.net.ServerSocket</h3>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag"># 后端</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/04/course/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="prev" title="机器学习">
                  <i class="fa fa-angle-left"></i> 机器学习
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/12/20/tech/Redis%E7%AC%94%E8%AE%B0/" rel="next" title="Redis笔记">
                  Redis笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
