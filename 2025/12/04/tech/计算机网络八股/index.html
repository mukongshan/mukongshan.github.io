<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"98f8cddec87decff88b20807b414767528f9bec3","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="体系结构OSI七层模型   层数 名称 中文名 主要功能    7 Application Layer 应用层 直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）   6 Presentation Layer 表示层 数据格式转换、加密、解密、压缩、解压缩   5 Session Layer 会话层 建立、管理和终止会话（通信连接）   4 Transport Layer 传输层">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络八股">
<meta property="og:url" content="https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:description" content="体系结构OSI七层模型   层数 名称 中文名 主要功能    7 Application Layer 应用层 直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）   6 Presentation Layer 表示层 数据格式转换、加密、解密、压缩、解压缩   5 Session Layer 会话层 建立、管理和终止会话（通信连接）   4 Transport Layer 传输层">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-03T17:00:00.000Z">
<meta property="article:modified_time" content="2025-12-03T09:38:18.485Z">
<meta property="article:author" content="mukongshan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/","path":"2025/12/04/tech/计算机网络八股/","title":"计算机网络八股"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机网络八股 | kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">kongshan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">TCP&#x2F;IP模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.1.</span> <span class="nav-text">常见协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">2.1.</span> <span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">2.2.</span> <span class="nav-text">HTTPS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TLS"><span class="nav-number">3.1.</span> <span class="nav-text">TLS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">哈希算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">3.1.2.</span> <span class="nav-text">数字签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">3.2.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-number">3.3.</span> <span class="nav-text">UDP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IP"><span class="nav-number">4.1.</span> <span class="nav-text">IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP"><span class="nav-number">4.2.</span> <span class="nav-text">ARP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E8%82%A1"><span class="nav-number">5.</span> <span class="nav-text">八股</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-1"><span class="nav-number">5.1.</span> <span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">简述OSI七层模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">简述TCP&#x2F;IP四层模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.3.</span> <span class="nav-text">简述五层模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88"><span class="nav-number">5.2.</span> <span class="nav-text">计算机综合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B8%B2%E6%9F%93%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">浏览器输入URL到渲染主页的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">DNS解析过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.3.</span> <span class="nav-text">IP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0IP%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8"><span class="nav-number">5.3.1.</span> <span class="nav-text">简述IP协议作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0ARP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">简述ARP工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%EF%BC%88S%EF%BC%89%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.4.</span> <span class="nav-text">HTTP（S）协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.4.1.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.2.</span> <span class="nav-text">HTTP报文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text">HTTPS工作流程***</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Session%E5%92%8CCookie"><span class="nav-number">5.4.4.</span> <span class="nav-text">Session和Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">5.4.5.</span> <span class="nav-text">状态码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-UDP"><span class="nav-number">5.5.</span> <span class="nav-text">TCP &#x2F; UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.1.</span> <span class="nav-text">TCP和UDP区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">5.5.2.</span> <span class="nav-text">UDP如何保证消息不丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">5.5.3.</span> <span class="nav-text">三次握手，为什么不是两次或四次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.5.4.</span> <span class="nav-text">为什么需要四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E5%BE%852MSL%EF%BC%8C%E6%89%8D%E8%BF%9B%E5%85%A5CLOSE"><span class="nav-number">5.5.5.</span> <span class="nav-text">为什么要等待2MSL，才进入CLOSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">5.5.6.</span> <span class="nav-text">TCP如何保证可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.7.</span> <span class="nav-text">TCP流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.5.8.</span> <span class="nav-text">TCP拥塞控制</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机网络八股 | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络八股
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 01:00:00" itemprop="dateCreated datePublished" datetime="2025-12-04T01:00:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-03 17:38:18" itemprop="dateModified" datetime="2025-12-03T17:38:18+08:00">2025-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">名称</th>
<th align="left">中文名</th>
<th align="left">主要功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>7</strong></td>
<td align="left">Application Layer</td>
<td align="left"><strong>应用层</strong></td>
<td align="left">直接面向用户，提供各种网络应用服务（如 HTTP、FTP、SMTP）</td>
</tr>
<tr>
<td align="left"><strong>6</strong></td>
<td align="left">Presentation Layer</td>
<td align="left"><strong>表示层</strong></td>
<td align="left">数据格式转换、加密、解密、压缩、解压缩</td>
</tr>
<tr>
<td align="left"><strong>5</strong></td>
<td align="left">Session Layer</td>
<td align="left"><strong>会话层</strong></td>
<td align="left">建立、管理和终止会话（通信连接）</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">Transport Layer</td>
<td align="left"><strong>传输层</strong></td>
<td align="left">提供端到端的可靠传输（如 TCP、UDP，负责端口、分段、流量控制）</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left">Network Layer</td>
<td align="left"><strong>网络层</strong></td>
<td align="left">负责数据路由和转发（如 IP 协议，决定数据怎么走到目的地）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Data Link Layer</td>
<td align="left"><strong>数据链路层</strong></td>
<td align="left">负责相邻节点间可靠传输（如以太网，MAC 地址，帧同步）</td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left">Physical Layer</td>
<td align="left"><strong>物理层</strong></td>
<td align="left">物理介质上的比特流传输（如电缆、光纤、网卡、信号）</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><table>
<thead>
<tr>
<th align="left">层数</th>
<th align="left">层名称（中文）</th>
<th align="left">层名称（英文）</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>4</strong></td>
<td align="left"><strong>应用层</strong></td>
<td align="left">Application Layer</td>
<td align="left">直接面向用户，提供各种网络应用服务，如网页、邮件、文件传输等</td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"><strong>传输层</strong></td>
<td align="left">Transport Layer</td>
<td align="left">提供端到端的通信服务，如可靠传输（TCP）或快速传输（UDP）</td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left"><strong>网络层</strong></td>
<td align="left">Internet Layer</td>
<td align="left">负责数据包的路由和寻址，让数据包跨网络找到目的地，核心协议是 <strong>IP</strong></td>
</tr>
<tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>网络接口层（或链路层&#x2F;物理层）</strong></td>
<td align="left">Network Interface Layer（或 Link Layer）</td>
<td align="left">负责在物理网络上传输数据帧，如以太网、WiFi、ARP 等</td>
</tr>
</tbody></table>
<h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><ol>
<li><p>第1层：网络接口层（Network Interface Layer）</p>
<ol>
<li><p>主要功能：</p>
<ol>
<li>负责 <strong>数据在物理网络上的传输</strong>，比如通过 <strong>网线、光纤、无线信号（WiFi）</strong> 等。</li>
<li>处理 <strong>MAC 地址（物理地址）</strong>、<strong>数据帧的封装与解封装</strong>、<strong>错误检测</strong>。</li>
<li>包括 <strong>局域网技术（如以太网 Ethernet）、无线技术（如 Wi-Fi 802.11）、ARP（地址解析协议）</strong> 等。</li>
</ol>
</li>
<li><p>常见协议 &#x2F; 技术：</p>
<ol>
<li><strong>Ethernet（以太网）</strong></li>
<li><strong>Wi-Fi（802.11）</strong></li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：将 IP 地址转换为 MAC 地址</li>
<li><strong>PPP（Point-to-Point Protocol，点对点协议）</strong></li>
<li><strong>物理层相关：网卡、光纤、双绞线、信号调制等</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>🔧 这一层关注的是：<strong>数据如何在具体的物理网络介质上传输。</strong></p>
</blockquote>
</li>
<li><p>第2层：网络层（Internet Layer）</p>
<ol>
<li><p>主要功能：</p>
<ol>
<li>负责 <strong>数据包的路由与转发</strong>，让数据从源主机跨越多个网络，最终到达目标主机。</li>
<li>使用 <strong>逻辑地址（IP 地址）</strong> 来标识设备。</li>
<li>核心任务是：<strong>IP 寻址、路由选择、分组转发</strong>。</li>
</ol>
</li>
<li><p>常见协议：</p>
<ol>
<li><strong>IP（Internet Protocol）</strong>：最核心的协议，包括 <strong>IPv4 和 IPv6</strong></li>
<li><strong>ICMP（Internet Control Message Protocol）</strong>：用于网络诊断，比如 <code>ping</code>命令就用了 ICMP</li>
<li><strong>IGMP（Internet Group Management Protocol）</strong>：用于组播管理</li>
<li><strong>ARP（Address Resolution Protocol）</strong>：有时也被归入这一层，用于 IP → MAC 的映射</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p> <strong>IP 协议让数据包找到了“去哪里”，但不保证一定能送到或按顺序到达。</strong></p>
</blockquote>
<ol start="3">
<li>第3层：传输层（Transport Layer）<ol>
<li>主要功能：<ol>
<li>提供 <strong>端到端（End-to-End）的通信服务</strong>，确保数据可靠传输或高效传输。</li>
<li>负责 <strong>端口管理、数据分段、流量控制、错误恢复</strong>。</li>
<li>区分不同应用程序的数据（比如浏览器和邮件软件同时运行）。</li>
</ol>
</li>
<li>常见协议：<ol>
<li><strong>TCP（Transmission Control Protocol）</strong>：<strong>可靠的、面向连接的传输协议</strong>用于：网页（HTTP）、文件传输（FTP）、邮件（SMTP）、远程登录（SSH）等需要可靠性的场景特点：三次握手、流量控制、重传机制、保证顺序</li>
<li><strong>UDP（User Datagram Protocol）</strong>：<strong>不可靠的、无连接的传输协议</strong>用于：视频流、语音通话（VoIP）、在线游戏、DNS 查询等对实时性要求高、允许少量丢包的场景特点：无连接、速度快、不保证顺序和可靠</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>🎯 <strong>传输层是真正实现“端口到端口通信”的地方，是应用层与网络层之间的桥梁。</strong></p>
</blockquote>
<ol start="4">
<li>第4层：应用层（Application Layer）<ol>
<li>主要功能：<ol>
<li><strong>直接面向用户或应用程序</strong>，提供各种网络服务和应用协议。</li>
<li>负责处理 <strong>用户数据格式、用户接口、应用逻辑</strong>。</li>
<li>包括我们日常使用的各种网络应用协议，如浏览网页、发送邮件、文件共享等。</li>
</ol>
</li>
<li>常见协议：<ol>
<li><strong>HTTP &#x2F; HTTPS</strong>：用于网页浏览（HTTPS 是加密的 HTTP）</li>
<li><strong>FTP（File Transfer Protocol）</strong>：文件传输</li>
<li><strong>SMTP &#x2F; POP3 &#x2F; IMAP</strong>：电子邮件相关协议</li>
<li><strong>DNS（Domain Name System）</strong>：域名解析（比如把 <a target="_blank" rel="noopener" href="http://www.baidu.com转成/">www.baidu.com转成</a> IP 地址）</li>
<li><strong>Telnet &#x2F; SSH</strong>：远程登录协议（SSH 更安全）</li>
<li><strong>DHCP</strong>：动态主机配置协议（自动分配 IP 地址）</li>
<li><strong>SNMP</strong>：网络管理协议</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol>
<li><p>是什么</p>
<ol>
<li>HTTP（HyperText Transfer Protocol），即 超文本传输协议。</li>
<li>它是互联网上应用最广泛的一种 <strong>应用层协议</strong>，用来在 客户端（如浏览器）和服务器之间传输数据，主要是网页内容（如 HTML、图片、CSS、JS 等）。</li>
<li><strong>规定浏览器（客户端）和网站服务器之间如何“请求”和“响应”数据。</strong></li>
</ol>
</li>
<li><p>工作原理</p>
<ol>
<li><p>HTTP 是基于 <strong>请求与响应（Request&#x2F;Response）模型</strong> 的：</p>
<ol>
<li>客户端（通常是浏览器） 发送一个 HTTP 请求（Request） 给服务器。</li>
<li>服务器 收到请求后，处理并返回一个 HTTP 响应（Response） 给客户端。</li>
<li>客户端接收响应并展示内容（比如显示网页）。</li>
</ol>
<ul>
<li>这个过程是 <strong>无状态的（Stateless）</strong>，也就是说，<strong>每次请求都是独立的，服务器默认不会记住你之前的请求</strong>（除非用 Cookie、Session 等机制）。</li>
</ul>
</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>浏览器通过 <strong>TCP 协议</strong> 与服务器建立连接（默认端口是 <strong>80</strong>）。</p>
</li>
<li><p>浏览器发送一个 HTTP 请求，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure>


<p>意思是：请给我 <code>/index.html</code>这个页面，使用的是 HTTP 1.1 协议。</p>
</li>
<li><p>服务器收到请求后，返回一个 HTTP 响应，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...这里是网页内容...&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p>表示请求成功（状态码 200），并返回了 HTML 内容。</p>
</li>
<li><p>浏览器接收到响应后，将 HTML 渲染成可视化的网页。</p>
</li>
</ol>
</li>
<li><p>特点</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>无状态（Stateless）</strong></td>
<td align="left">每次请求互相独立，服务器不记录之前的交互（除非使用 Cookie&#x2F;Session）</td>
</tr>
<tr>
<td align="left"><strong>基于请求-响应模型</strong></td>
<td align="left">客户端发起请求，服务器返回响应</td>
</tr>
<tr>
<td align="left"><strong>简单、灵活</strong></td>
<td align="left">易于实现，支持多种数据类型（文本、图片、视频等）</td>
</tr>
<tr>
<td align="left"><strong>明文传输（不加密）</strong></td>
<td align="left">数据以 <strong>明文形式在网络中传输</strong>，容易被窃听或篡改 ⚠️</td>
</tr>
<tr>
<td align="left"><strong>默认端口是 80</strong></td>
<td align="left">当你访问 <code>http://xxx</code>时，一般使用 80 端口通信</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ol>
<li><p>是什么</p>
<ol>
<li>HTTPS（HyperText Transfer Protocol Secure） 是 HTTP 的安全版本，它在 HTTP 的基础上加入了 <strong>SSL&#x2F;TLS 协议</strong>，通过 <strong>加密、身份认证和数据完整性校验</strong> 来保护客户端与服务器之间的通信。</li>
</ol>
</li>
<li><p>解决了什么问题</p>
<ol>
<li>在传统的 HTTP 通信中，主要存在以下三大安全隐患：<ol>
<li>**窃听风险（Confidentiality）**数据在传输过程中可能被第三方监听，比如密码、个人信息等。</li>
<li>**篡改风险（Integrity）**数据在传输途中可能被恶意修改，而通信双方无法察觉。</li>
<li>**冒充风险（Authentication）**客户端可能连接到假的服务器（如钓鱼网站），服务器也可能被冒充。</li>
</ol>
</li>
<li><strong>HTTPS 通过 SSL&#x2F;TLS 协议解决了这三个问题：</strong><ol>
<li>加密通信内容，防止窃听；</li>
<li>使用消息认证码（MAC）等机制保证数据完整性；</li>
<li>通过数字证书验证通信双方的身份。</li>
</ol>
</li>
</ol>
</li>
<li><p>核心技术</p>
<ol>
<li><strong>对称加密（Symmetric Encryption）</strong><ol>
<li>加密和解密使用同一个密钥，效率高，互信安全。</li>
<li>但是如果对所有客户端都用同一个Key，就没用了；如果都唯一生成Key，服务端保存不了</li>
</ol>
</li>
<li><strong>非对称加密（Asymmetric Encryption）</strong><ol>
<li>使用一对密钥：公钥（public key）和私钥（private key）。</li>
<li>公钥加密的内容只能用私钥解密，反之亦然。用于安全地交换对称密钥，或进行身份验证。</li>
<li>非对称加密代价高</li>
</ol>
</li>
<li><strong>数字证书（Digital Certificate）</strong><ol>
<li>由权威的 <strong>CA（Certificate Authority，证书授权机构）</strong> 颁发。证明服务器的身份，包含服务器的公钥及身份信息，并经过 CA 私钥签名。客户端通过验证证书来确认服务器是否可信。用以解决中间人问题。</li>
</ol>
</li>
<li><strong>SSL&#x2F;TLS 协议</strong>是 HTTPS 的核心，负责加密通信的建立过程（握手）、密钥交换、数据加密传输等。</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>步骤 1：TCP 三次握手</p>
<ul>
<li>客户端与服务器先建立普通的 TCP 连接（这是所有应用层协议的基础）。</li>
</ul>
</li>
<li><p>步骤 2：TLS （Transport Layer Security，传输层安全协议）握手（核心步骤）</p>
<ul>
<li>目标是先用<strong>非对称加密</strong>协商出一个<strong>对称加密密钥</strong>，并验证对方身份。</li>
</ul>
<ol>
<li><strong>Client Hello</strong>：客户端向服务器发起请求，告知：<ol>
<li>支持的 TLS 版本</li>
<li>支持的加密算法（Cipher Suites）</li>
<li>随机数 Client Random</li>
</ol>
</li>
<li><strong>Server Hello</strong>：服务器回应：<ol>
<li>选择的 TLS 版本和加密算法</li>
<li>随机数 Server Random</li>
<li><strong>数字证书（含服务器公钥）</strong></li>
<li>（可选）服务器也可能会要求客户端证书（双向认证）</li>
</ol>
</li>
<li><strong>客户端验证证书</strong>：客户端用 <strong>CA 的公钥（预装在操作系统&#x2F;浏览器中）</strong> 验证服务器证书的合法性：<ol>
<li>证书是否过期</li>
<li>是否被吊销</li>
<li>是否由受信任的 CA 签发域名</li>
<li>是否匹配</li>
<li>如果证书合法，提取出服务器的公钥。</li>
</ol>
</li>
<li><strong>生成 Pre-Master Secret</strong>：客户端生成一个随机数：<strong>Pre-Master Secret</strong>，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。</li>
<li><strong>双方计算对称密钥</strong>：客户端和服务器根据以下三个随机数：<code>Client Random，Server Random，Pre-Master Secret</code>通过特定算法（如 PRF）计算得出相同的 <strong>对称密钥（Session Key）</strong>，用于后续通信的加密。</li>
<li><strong>握手完成</strong>双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。</li>
</ol>
<blockquote>
<p>🎯 <strong>为什么不用非对称加密传输全部数据？</strong></p>
<p>非对称加密计算开销大，效率低。对称加密速度快，适合大量数据传输。因此 HTTPS 利用非对称加密安全地传递对称密钥，之后用对称加密传输数据。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><ol>
<li><p>是什么</p>
<ol>
<li>TLS（Transport Layer Security，传输层安全协议）是一种加密通信协议，用于在互联网上安全地传输数据，防止数据被窃听、篡改或冒充。它为像 HTTP 这样的应用层协议提供了加密、身份认证和数据完整性保护。</li>
</ol>
</li>
<li><p>背景</p>
<ol>
<li><strong>SSL（Secure Sockets Layer，安全套接层）</strong> 是 TLS 的前身，最早由网景公司（Netscape）在1990年代初期提出，用于保护 Web 通信。</li>
<li>后来由于安全漏洞等问题，SSL 的多个版本（如 SSL 2.0、SSL 3.0）陆续被废弃。</li>
<li><strong>TLS 1.0</strong> 于 1999 年作为 <strong>SSL 3.0 的升级替代版</strong> 被提出，之后发展出：<strong>TLS 1.1</strong>（2006年）<strong>TLS 1.2</strong>（2008年，目前广泛使用）<strong>TLS 1.3</strong>（2018年，最新、最安全、性能最好，强烈推荐）</li>
</ol>
<blockquote>
<p> 现在应该避免使用 SSL，因为它已被证明是不安全的。我们现在说的“SSL”，很多其实指的是 TLS，比如“SSL 证书”其实就是“TLS 证书”。</p>
</blockquote>
</li>
<li><p>核心作用</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">说明</th>
<th align="left">为什么重要</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加密（Encryption）</strong></td>
<td align="left">对传输的数据进行加密，防止被第三方窃听</td>
<td align="left">保护隐私，比如密码、银行卡号等敏感信息</td>
</tr>
<tr>
<td align="left"><strong>身份认证（Authentication）</strong></td>
<td align="left">通过数字证书验证通信双方的身份，防止中间人冒充</td>
<td align="left">确保你连接的是真正的网站，而不是钓鱼网站</td>
</tr>
<tr>
<td align="left"><strong>数据完整性（Integrity）</strong></td>
<td align="left">确保传输的数据没有被篡改</td>
<td align="left">防止数据在传输过程中被恶意修改</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>工作流程</p>
<ol>
<li><p>步骤 1：客户端发起 Hello</p>
<p>客户端告诉服务器：</p>
<ul>
<li>我支持哪些 TLS 版本</li>
<li>我支持哪些加密算法</li>
<li>我生成了一个随机数（Client Random）</li>
</ul>
</li>
<li><p>步骤 2：服务器回应 Hello</p>
<p>服务器选择：</p>
<ul>
<li>一个 TLS 版本</li>
<li>一组加密算法</li>
<li>返回自己的随机数（Server Random）</li>
<li><strong>自己的数字证书（含公钥）</strong></li>
</ul>
</li>
<li><p>步骤 3：客户端验证证书</p>
<ol>
<li>客户端用本地信任的 CA（证书颁发机构）公钥，验证服务器证书是否合法，提取公钥。</li>
</ol>
</li>
<li><p>步骤 4：生成对称密钥</p>
<ol>
<li>客户端生成一个“预备主密钥”（Pre-Master Secret），用服务器的公钥加密后传给服务器。</li>
<li>然后双方根据 Client Random、Server Random 和 Pre-Master Secret，<strong>计算出相同的对称密钥（Session Key）</strong>。</li>
</ol>
</li>
<li><p>步骤 5：通信加密</p>
<ol>
<li>握手完成后，双方使用对称密钥加密实际传输的数据（如 HTTP 请求和响应），通信正式开始，安全又高效 ✅</li>
</ol>
</li>
</ol>
<blockquote>
<p>为什么不一直用非对称加密？因为非对称加密很慢，对称加密快，适合大数据量传输。</p>
</blockquote>
</li>
</ol>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ol>
<li><p>是什么：哈希算法（Hash Algorithm）是一种将任意长度的输入数据，通过特定计算，生成一个固定长度的、唯一性标识（通常称为“哈希值”或“摘要”）的算法。</p>
</li>
<li><p><strong>关键特性</strong>：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>确定性</strong></td>
<td align="left">相同的输入，总是产生相同的哈希值</td>
</tr>
<tr>
<td align="left"><strong>快速计算</strong></td>
<td align="left">输入数据后，可以快速计算出哈希值</td>
</tr>
<tr>
<td align="left"><strong>不可逆性（单向性）</strong></td>
<td align="left">你无法从哈希值反推出原始数据</td>
</tr>
<tr>
<td align="left"><strong>雪崩效应</strong></td>
<td align="left">输入数据的微小变化，会导致哈希值发生巨大改变</td>
</tr>
<tr>
<td align="left"><strong>固定长度输出</strong></td>
<td align="left">不管输入是 1bit 还是 1GB，输出的哈希值长度固定（如 256 位）</td>
</tr>
</tbody></table>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ol>
<li>为了保证获得服务端公钥的正确性，服务端公钥需要由CA证书认证。</li>
<li>为了保证CA公钥的正确性，需要由根证书认证</li>
<li>为了保证根证书的正确性，直接安装在操作系统中。</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ol>
<li>是什么<ol>
<li>IP 协议（Internet Protocol，互联网协议）是 TCP&#x2F;IP 协议簇中最重要的网络层协议，它负责在互联网上为数据包提供逻辑寻址（IP 地址）、路由选择和跨网络传输，是实现主机之间互联互通的基础。</li>
</ol>
</li>
<li>主要功能<ol>
<li><strong>逻辑寻址（Logical Addressing）</strong><ul>
<li>每台联网设备都会分配一个 IP 地址，用于在网络中唯一标识该设备。</li>
<li>IP 地址让数据包知道 <strong>“要发给谁”（哪个网络中的哪台设备）</strong>。</li>
</ul>
</li>
<li><strong>路由与转发（Routing &amp; Forwarding）</strong><ul>
<li>当数据包需要跨网络传输时（比如从你家到某个网站服务器），IP 协议会决定数据包该经过哪些 <strong>路由器（Router）</strong>，最终到达目标。</li>
<li>每个路由器根据 <strong>IP 地址</strong> 做出转发决策，选择最优路径。</li>
</ul>
</li>
<li><strong>分组传输（Packet Switching）</strong><ul>
<li>IP 协议将数据分割成一个个小的数据单元，称为 <strong>IP 数据包（或 IP 包 &#x2F; 数据报）</strong>，每个包都包含：源 IP 地址目标 IP 地址其他控制信息</li>
<li>这些包可以 <strong>独立地在网络中传输，并在终点重新组装</strong>。</li>
</ul>
</li>
<li><strong>跨网络通信（Inter-network Communication）</strong><ul>
<li>IP 协议使得不同类型的物理网络（如以太网、WiFi、光纤）能够互相连接，组成一个统一的互联网。</li>
</ul>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">IP 地址</th>
<th align="left">MAC 地址</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>全称</strong></td>
<td align="left">Internet Protocol Address</td>
<td align="left">Media Access Control Address</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">用于在 <strong>网络层</strong> 标识设备，用于跨网络寻址</td>
<td align="left">用于在 <strong>数据链路层（局域网）</strong> 标识设备，用于直接通信</td>
</tr>
<tr>
<td align="left"><strong>类型</strong></td>
<td align="left">逻辑地址（可变，可配置）</td>
<td align="left">物理地址（固化在网卡中，全球唯一）</td>
</tr>
<tr>
<td align="left"><strong>格式</strong></td>
<td align="left">点分十进制，如 <code>192.168.1.1</code></td>
<td align="left">16 进制，如 <code>00:1A:2B:3C:4D:5E</code></td>
</tr>
<tr>
<td align="left"><strong>工作范围</strong></td>
<td align="left">跨网络（互联网）</td>
<td align="left">局域网内（如家庭、公司网络）</td>
</tr>
<tr>
<td align="left"><strong>谁管理</strong></td>
<td align="left">由网络管理员或 DHCP 分配</td>
<td align="left">由网卡厂商固化，全球唯一</td>
</tr>
</tbody></table>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><ol>
<li>是什么<ol>
<li>ARP（Address Resolution Protocol，地址解析协议）是一个用于将 IP 地址解析为 MAC 地址的通信协议，它工作在 TCP&#x2F;IP 模型的 网络接口层（或数据链路层），是实现局域网内设备互相通信的重要基础协议。</li>
</ol>
</li>
<li>为什么需要ARP<ol>
<li>你访问 <code>www.baidu.com</code>，其实是访问它的 <strong>IP 地址</strong></li>
<li>但数据包在 <strong>局域网</strong>中传输时，并不是通过 IP 地址直接找到对方，而是通过 <strong>MAC 地址</strong></li>
</ol>
</li>
<li>工作原理</li>
<li>ARP 的工作原理<ol>
<li>场景：主机 A 想给同一局域网内的 主机 B（IP 已知）发送数据<ol>
<li>主机 A 检查自己的 ARP 缓存表。如果已经缓存了 目标 IP对应的 MAC 地址，那就直接使用，不用再问。</li>
<li>如果缓存中没有该 IP 的 MAC 地址，主机 A 就会发送一个 ARP 请求广播包：内容大致是：“请问，IP 地址是 192.168.1.100 的设备，你的 MAC 地址是多少？”这个 ARP 请求是以 <strong>广播形式</strong> 发送到当前局域网内的 所有设备。</li>
<li>局域网中的所有设备都会收到这个 ARP 请求，但只有 IP 地址匹配的设备（主机 B）会响应：主机 B 回复一个 ARP 响应包 给主机 A，内容是：“我的 IP 是 192.168.1.100，我的 MAC 地址是 00:1A:2B:3C:4D:5E”。</li>
<li>主机 A 收到响应后，就把这个 IP ↔ MAC 的对应关系保存到自己的 ARP 缓存表中，下次再访问这个 IP 时，就不用再问了。</li>
<li>然后主机 A 就可以使用这个 MAC 地址，将数据包正确地发送到主机 B。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="体系结构-1"><a href="#体系结构-1" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="简述OSI七层模型"><a href="#简述OSI七层模型" class="headerlink" title="简述OSI七层模型"></a>简述OSI七层模型</h3><h3 id="简述TCP-IP四层模型"><a href="#简述TCP-IP四层模型" class="headerlink" title="简述TCP&#x2F;IP四层模型"></a>简述TCP&#x2F;IP四层模型</h3><h3 id="简述五层模型"><a href="#简述五层模型" class="headerlink" title="简述五层模型"></a>简述五层模型</h3><h2 id="计算机综合"><a href="#计算机综合" class="headerlink" title="计算机综合"></a>计算机综合</h2><h3 id="浏览器输入URL到渲染主页的过程"><a href="#浏览器输入URL到渲染主页的过程" class="headerlink" title="浏览器输入URL到渲染主页的过程"></a>浏览器输入URL到渲染主页的过程</h3><ol>
<li><strong>URL 解析</strong></li>
<li><strong>DNS解析</strong>：将域名转换为IP地址。</li>
<li><strong>TCP连接</strong>：与服务器建立TCP三次握手连接（HTTPS还需TLS握手）。</li>
<li><strong>TLS链接</strong>（如果是HTTPS）</li>
<li><strong>发送HTTP请求</strong>：浏览器发送请求报文到服务器。</li>
<li><strong>服务器处理</strong>：服务器返回HTML响应。</li>
<li><strong>渲染页面</strong>：浏览器解析HTML，构建DOM树，加载CSS&#x2F;JS，渲染布局和绘制。</li>
</ol>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><ol>
<li>全流程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">本地电脑：用户输入域名 → 检查本地缓存 → 本地无缓存 → </span><br><span class="line">↓</span><br><span class="line">|  向配置的DNS服务器（如<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>）发起查询 <span class="comment">// 递归查询</span></span><br><span class="line">↓</span><br><span class="line">本地DNS服务器</span><br><span class="line">↓</span><br><span class="line">|  向其他DNS服务器发起查询  <span class="comment">// 迭代查询</span></span><br><span class="line">↓</span><br><span class="line">根DNS服务器（.）→ 返回 .com TLD 服务器地址 </span><br><span class="line">↓</span><br><span class="line">.com TLD 服务器 → 返回 example.com 权威DNS地址 </span><br><span class="line">↓</span><br><span class="line">权威DNS服务器 → 返回 www.example.com 的IP </span><br><span class="line">↓</span><br><span class="line">浏览器拿到IP，发起TCP连接访问网站！</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p>递归查询（Recursive Query）</p>
<ol>
<li><p>定义：</p>
<ol>
<li>客户端（或本地DNS服务器）只发起一次请求，由DNS服务器（通常是递归DNS服务器）负责完成整个查询过程，并返回最终结果。</li>
<li>适用于普通用户（如你的电脑向ISP的DNS服务器查询）。</li>
</ol>
</li>
<li><p>流程（以用户查询 <code>www.example.com</code>为例）：</p>
<ol>
<li><strong>你的电脑</strong>向 <strong>本地DNS服务器</strong>（如ISP的DNS或8.8.8.8）发起 <strong>递归查询</strong>（请求：<code>请帮我查 www.example.com 的IP</code>）。</li>
<li>本地DNS服务器接到请求后，自己负责去根DNS、TLD、权威DNS逐层查询，直到拿到最终IP。</li>
<li>本地DNS服务器把 最终IP返回给你的电脑，你的电脑 不需要再做其他查询。</li>
</ol>
</li>
<li><p>特点：</p>
</li>
</ol>
<ul>
<li><p>用户只需发起一次请求，DNS服务器负责全部查询。</p>
</li>
<li><p>适用于普通用户（如家庭宽带、手机上网）。</p>
</li>
<li><p>递归DNS服务器（如8.8.8.8、114.114.114.114）通常提供递归查询服务。</p>
</li>
</ul>
<hr>
</li>
<li><p>迭代查询（Iterative Query）</p>
<ol>
<li>定义：<ol>
<li>DNS服务器不会直接返回最终结果，而是返回下一个可能知道答案的DNS服务器地址，由客户端（或上一级DNS）继续查询。</li>
<li><strong>适用于DNS服务器之间的查询</strong>（如根DNS、TLD、权威DNS之间的交互）。</li>
</ol>
</li>
</ol>
</li>
<li><p>流程（以本地DNS服务器查询 <code>www.example.com</code>为例）：</p>
<ol>
<li>你的本地DNS服务器向 根DNS服务器查询 <code>www.example.com</code>。根DNS服务器不知道具体IP，但知道 <code>.com</code>TLD服务器的地址，于是 返回 <code>.com</code>TLD服务器的IP。</li>
<li>本地DNS服务器再向 <code>.com</code>TLD服务器查询 <code>www.example.com</code>。<code>.com</code>TLD服务器不知道具体IP，但知道 <code>example.com</code>的权威DNS服务器地址，于是 返回 <code>example.com</code>权威DNS的IP。</li>
<li>本地DNS服务器再向 <code>example.com</code>权威DNS服务器查询 <code>www.example.com</code>。权威DNS服务器直接返回 <code>www.example.com</code>的IP。</li>
<li>最终，本地DNS服务器把IP返回给你的电脑。</li>
</ol>
</li>
<li><p>特点：</p>
<ol>
<li>DNS服务器之间互相“踢皮球”，每一步只返回下一个可能知道的服务器。</li>
<li>适用于DNS服务器之间的查询（如根→TLD→权威）。</li>
<li>你的电脑通常不直接使用迭代查询，而是依赖递归DNS服务器（如8.8.8.8）帮你完成。</li>
</ol>
</li>
</ol>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><h3 id="简述IP协议作用"><a href="#简述IP协议作用" class="headerlink" title="简述IP协议作用"></a>简述IP协议作用</h3><p>负责<strong>网络层数据传输</strong>，提供：</p>
<ul>
<li><strong>逻辑寻址</strong>（通过IP地址定位设备）。</li>
<li><strong>路由选择</strong>（指导数据包跨网络传输路径）。</li>
<li><strong>无连接、不可靠的数据包交付</strong>（不保证顺序或到达，依赖上层协议如TCP）。</li>
</ul>
<h3 id="简述ARP工作流程"><a href="#简述ARP工作流程" class="headerlink" title="简述ARP工作流程"></a>简述ARP工作流程</h3><p><strong>地址解析协议（ARP）<strong>用于将</strong>IP地址映射为MAC地址</strong>：</p>
<ol>
<li>主机广播ARP请求（询问“谁是IP X？请回复MAC”）。</li>
<li>目标主机收到后单播回复自己的MAC地址。</li>
<li>发送方缓存该映射（ARP表），后续直接使用。（<em>注：同一局域网内有效，跨网段需通过网关。</em>）</li>
</ol>
<h2 id="HTTP（S）协议"><a href="#HTTP（S）协议" class="headerlink" title="HTTP（S）协议"></a>HTTP（S）协议</h2><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong>GET</strong></th>
<th align="left"><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>请求方式</strong></td>
<td align="left">从服务器 <strong>获取数据</strong>（幂等）</td>
<td align="left">向服务器 <strong>提交数据</strong>（非幂等）</td>
</tr>
<tr>
<td align="left"><strong>数据位置</strong></td>
<td align="left">数据放在 <strong>URL 参数</strong>（<code>?key=value</code>）</td>
<td align="left">数据放在 <strong>请求体（Body）</strong></td>
</tr>
<tr>
<td align="left"><strong>数据可见性</strong></td>
<td align="left"><strong>可见</strong>（URL 可见，可被缓存、历史记录保存）</td>
<td align="left"><strong>不可见</strong>（Body 不直接暴露）</td>
</tr>
<tr>
<td align="left"><strong>数据大小限制</strong></td>
<td align="left"><strong>较小</strong>（通常 ≤ 2KB~8KB，取决于浏览器&#x2F;服务器）</td>
<td align="left"><strong>较大</strong>（理论上无限制，但服务器可配置）</td>
</tr>
<tr>
<td align="left"><strong>缓存</strong></td>
<td align="left"><strong>可被缓存</strong>（浏览器、代理服务器可缓存）</td>
<td align="left"><strong>默认不被缓存</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>较低</strong>（参数暴露在 URL）</td>
<td align="left"><strong>相对较高</strong>（但 HTTPS 才是真正安全的）</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left"><strong>获取数据</strong>（如搜索、加载页面）</td>
<td align="left"><strong>提交数据</strong>（如登录、表单提交）</td>
</tr>
</tbody></table>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><ul>
<li>HTTP 报文分为 **请求报文（Request）**和 <strong>响应报文（Response）</strong>，基本结构类似：</li>
</ul>
<ol>
<li><strong>请求报文（Request）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span>      <span class="comment">// 请求行（方法 + URL + 协议版本）</span></span><br><span class="line">Host: www.example.com         <span class="comment">// 请求头（Header）</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span></span><br><span class="line">Accept: text/html</span><br><span class="line">Cookie: sessionid=<span class="number">123</span></span><br><span class="line"></span><br><span class="line">（空行）</span><br><span class="line">（可选请求体 Body，如 POST 数据）</span><br></pre></td></tr></table></figure>


<ol>
<li><p><strong>组成部分</strong>：</p>
<ol>
<li><p><strong>请求行（Request Line）</strong>：<code>方法（GET/POST） + URL + HTTP版本</code>。注意，URL不包含域名。</p>
</li>
<li><p><strong>请求头（Headers）</strong>：键值对</p>
<ol>
<li><p>** <code>Host</code>（目标服务器）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ul>
<li><p>提供访问域名</p>
</li>
<li><p>没有 <code>Host</code>，服务器不知道你要访问哪个域名（比如 <code>example.com</code>还是 <code>api.example.com</code>）。</p>
</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com  # 告诉服务器你要访问哪个网站</span><br></pre></td></tr></table></figure>


<hr>
</li>
<li><p>** <code>User-Agent</code>（浏览器&#x2F;设备信息）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>服务器可以根据 <strong>浏览器类型、操作系统、设备</strong>返回不同的内容（比如移动端适配）。</li>
<li>用于 <strong>统计分析</strong>（如 Google Analytics 统计用户使用的浏览器）。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X)  # 表示是 iPhone 浏览器</span><br></pre></td></tr></table></figure>


<hr>
</li>
<li><p>** <code>Accept</code>（接受的响应类型）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>客户端告诉服务器 <strong>它能处理哪些格式</strong>（如 <code>text/html</code>、<code>application/json</code>）。</li>
<li>服务器可以据此 <strong>返回最适合的数据格式</strong>（比如 API 可以返回 JSON 而不是 HTML）。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/json  # 客户端希望服务器返回 JSON</span><br></pre></td></tr></table></figure>


<hr>
</li>
<li><p>** <code>Cookie</code>（发送会话信息）**</p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>客户端把 <strong>之前服务器设置的 Cookie</strong>发回去，用于 <strong>维持登录状态、用户偏好</strong>。</li>
<li>是 **会话管理（Session）**的关键机制。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: sessionid=abc123; user_prefs=dark_mode  # 携带会话 ID 和用户偏好</span><br></pre></td></tr></table></figure>


<hr>
</li>
<li><p><strong><code>Authorization</code>（身份认证）</strong></p>
<ol>
<li><p><strong>意义</strong>：</p>
<ol>
<li>用于 <strong>登录、API 访问控制</strong>（如 <code>Bearer Token</code>、<code>Basic Auth</code>）。</li>
<li>服务器验证后决定是否允许访问。</li>
</ol>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # JWT Token 认证</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>空行（CRLF）</strong>：分隔头部和 Body</p>
</li>
<li><p><strong>请求体（Body）</strong>（可选）：POST&#x2F;PUT 等方法携带的数据</p>
</li>
</ol>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>响应报文（Response）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK               <span class="comment">// 状态行（协议版本 + 状态码 + 状态文本）</span></span><br><span class="line">Content-Type: text/html       <span class="comment">// 响应头（Header）</span></span><br><span class="line">Content-Length: <span class="number">1234</span></span><br><span class="line">Set-Cookie: sessionid=<span class="number">456</span></span><br><span class="line"></span><br><span class="line">（空行）</span><br><span class="line">&lt;html&gt;...（响应体 Body）&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<p><strong>组成部分</strong>：</p>
<ul>
<li><strong>状态行（Status Line）</strong>：<code>HTTP版本 + 状态码（200/404/500） + 状态文本</code></li>
<li><strong>响应头（Headers）</strong>：键值对（如 <code>Content-Type</code>, <code>Set-Cookie</code>）</li>
<li><strong>空行（CRLF）</strong>：分隔头部和 Body</li>
<li><strong>响应体（Body）</strong>：返回的 HTML、JSON 等数据</li>
</ul>
<h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程***"></a>HTTPS工作流程***</h3><ul>
<li><p>主要介绍TCL连接流程</p>
</li>
<li><p>目标是先用<strong>非对称加密</strong>协商出一个<strong>对称加密密钥</strong>，并验证对方身份。</p>
</li>
</ul>
<ol>
<li><strong>Client Hello</strong>：客户端向服务器发起请求，告知：<ol>
<li>支持的 TLS 版本</li>
<li>支持的加密算法（Cipher Suites）</li>
<li><strong>随机数 Client Random</strong></li>
</ol>
</li>
<li><strong>Server Hello</strong>：服务器回应：<ol>
<li>选择的 TLS 版本和加密算法</li>
<li><strong>随机数 Server Random</strong></li>
<li><strong>数字证书（含服务器公钥）</strong></li>
<li>（可选）服务器也可能会要求客户端证书（双向认证）</li>
</ol>
</li>
<li><strong>客户端验证证书</strong>：客户端用 <strong>CA 的公钥（预装在操作系统&#x2F;浏览器中）</strong> 验证服务器证书的合法性：<ol>
<li>证书是否过期</li>
<li>是否被吊销</li>
<li>是否由受信任的 CA 签发域名</li>
<li>是否匹配</li>
<li>如果证书合法，提取出服务器的公钥。</li>
</ol>
</li>
<li><strong>生成 Pre-Master Secret</strong>：<strong>客户端</strong>生成一个随机数：<strong>Pre-Master Secret</strong>，并用服务器的公钥加密后发送给服务器。只有服务器能用其私钥解密，获得这个 Pre-Master Secret。</li>
<li><strong>双方计算对称密钥</strong>：客户端和服务器根据以下三个随机数：<code>Client Random，Server Random，Pre-Master Secret</code>通过特定算法（如 PRF）计算得出相同的 <strong>对称密钥（Session Key）</strong>，用于后续通信的加密。</li>
<li><strong>握手完成</strong>双方发送 “Finished” 消息，确认握手成功。后续通信都使用对称加密进行，效率高且安全。</li>
</ol>
<h3 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h3><ol>
<li>基本概念<ol>
<li>Cookie（客户端存储）<ul>
<li>是什么：服务器通过 <code>Set-Cookie</code>响应头让浏览器存储的小段数据（通常 ≤ 4KB）。</li>
<li>存储位置：<strong>浏览器（客户端）</strong>（每次请求自动发送）。</li>
<li>用途：记住登录状态（如 <code>sessionid=123</code>）。用户偏好（如语言、主题）。</li>
<li>特点：明文存储。可设置过期时间。默认不安全。</li>
</ul>
</li>
<li>Session（服务器存储）<ul>
<li>是什么：服务器存储的用户会话数据（如 <code>session_id → 用户信息</code>）。</li>
<li>存储位置：<strong>服务器</strong>（如内存、Redis、数据库）。</li>
<li>用途：维持登录状态。存储临时数据。</li>
<li>特点：更安全（敏感数据在服务器）。依赖 Cookie 或 URL 传递 <code>session_id</code>（如 <code>PHPSESSID=abc123</code>）。服务器需管理生命周期（过期清理）。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><table>
<thead>
<tr>
<th align="left"><strong>类别</strong></th>
<th align="left"><strong>第一位数字</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1xx</strong></td>
<td align="left"><code>100-199</code></td>
<td align="left"><strong>信息性状态码</strong></td>
<td align="left">请求已接收，继续处理（较少使用）</td>
</tr>
<tr>
<td align="left"><strong>2xx</strong></td>
<td align="left"><code>200-299</code></td>
<td align="left"><strong>成功状态码</strong></td>
<td align="left">请求成功，服务器正常处理</td>
</tr>
<tr>
<td align="left"><strong>3xx</strong></td>
<td align="left"><code>300-399</code></td>
<td align="left"><strong>重定向状态码</strong></td>
<td align="left">需要客户端进一步操作（如跳转）</td>
</tr>
<tr>
<td align="left"><strong>4xx</strong></td>
<td align="left"><code>400-499</code></td>
<td align="left"><strong>客户端错误</strong></td>
<td align="left">请求有误（如 404 找不到页面）</td>
</tr>
<tr>
<td align="left"><strong>5xx</strong></td>
<td align="left"><code>500-599</code></td>
<td align="left"><strong>服务器错误</strong></td>
<td align="left">服务器处理请求时出错</td>
</tr>
</tbody></table>
<ol>
<li>4xx（客户端错误）</li>
</ol>
<table>
<thead>
<tr>
<th align="left"><strong>状态码</strong></th>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>400 Bad Request</strong></td>
<td align="left">错误请求</td>
<td align="left">请求语法错误（如参数缺失、格式不对）</td>
<td align="left">JSON 格式错误、缺少必填字段</td>
</tr>
<tr>
<td align="left"><strong>401 Unauthorized</strong></td>
<td align="left">未授权</td>
<td align="left"><strong>需要登录</strong>（未提供有效的身份验证）</td>
<td align="left">未带 Token 或 Cookie</td>
</tr>
<tr>
<td align="left"><strong>403 Forbidden</strong></td>
<td align="left">禁止访问</td>
<td align="left"><strong>有权限问题</strong>（登录了但无权访问）</td>
<td align="left">普通用户访问管理员页面</td>
</tr>
<tr>
<td align="left"><strong>404 Not Found</strong></td>
<td align="left">未找到</td>
<td align="left"><strong>请求的资源不存在</strong></td>
<td align="left">访问不存在的页面（如 <code>/nonexistent</code>）</td>
</tr>
<tr>
<td align="left"><strong>429 Too Many Requests</strong></td>
<td align="left">请求过多</td>
<td align="left"><strong>限流</strong>（短时间内发送太多请求）</td>
<td align="left">API 调用频率超限</td>
</tr>
</tbody></table>
<ol start="2">
<li>5xx（服务器错误）</li>
</ol>
<table>
<thead>
<tr>
<th align="left"><strong>状态码</strong></th>
<th align="left"><strong>名称</strong></th>
<th align="left"><strong>含义</strong></th>
<th align="left"><strong>常见原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>500 Internal Server Error</strong></td>
<td align="left">服务器内部错误</td>
<td align="left"><strong>服务器代码出错</strong>（如 Python&#x2F;Java 异常）</td>
<td align="left">后端代码崩溃</td>
</tr>
<tr>
<td align="left"><strong>502 Bad Gateway</strong></td>
<td align="left">网关错误</td>
<td align="left"><strong>代理服务器（如 Nginx）收到无效响应</strong></td>
<td align="left">后端服务（如 Tomcat）崩溃</td>
</tr>
<tr>
<td align="left"><strong>503 Service Unavailable</strong></td>
<td align="left">服务不可用</td>
<td align="left"><strong>服务器暂时过载或维护</strong></td>
<td align="left">网站维护中</td>
</tr>
<tr>
<td align="left"><strong>504 Gateway Timeout</strong></td>
<td align="left">网关超时</td>
<td align="left"><strong>代理服务器等待后端响应超时</strong></td>
<td align="left">后端处理太慢</td>
</tr>
</tbody></table>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP &#x2F; UDP"></a>TCP &#x2F; UDP</h2><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong>TCP（传输控制协议）</strong></th>
<th align="left"><strong>UDP（用户数据报协议）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议类型</strong></td>
<td align="left"><strong>面向连接</strong>（可靠传输）</td>
<td align="left"><strong>无连接</strong>（不可靠传输）</td>
</tr>
<tr>
<td align="left"><strong>连接方式</strong></td>
<td align="left"><strong>三次握手建立连接</strong>，四次挥手断开</td>
<td align="left"><strong>直接发送数据，无需连接</strong></td>
</tr>
<tr>
<td align="left"><strong>可靠性</strong></td>
<td align="left"><strong>可靠</strong>（确保数据完整、有序到达）</td>
<td align="left"><strong>不可靠</strong>（可能丢包、乱序）</td>
</tr>
<tr>
<td align="left"><strong>数据顺序</strong></td>
<td align="left"><strong>保证顺序</strong>（按发送顺序到达）</td>
<td align="left"><strong>不保证顺序</strong>（可能乱序）</td>
</tr>
<tr>
<td align="left"><strong>流量控制</strong></td>
<td align="left"><strong>有</strong>（避免发送过快导致接收方缓冲区溢出）</td>
<td align="left"><strong>无</strong></td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left"><strong>有</strong>（动态调整发送速率）</td>
<td align="left"><strong>无</strong></td>
</tr>
<tr>
<td align="left"><strong>传输速度</strong></td>
<td align="left"><strong>较慢</strong>（因握手、确认、重传等机制）</td>
<td align="left"><strong>较快</strong>（无额外控制机制）</td>
</tr>
<tr>
<td align="left"><strong>头部大小</strong></td>
<td align="left"><strong>20~60字节</strong>（较复杂）</td>
<td align="left"><strong>8字节</strong>（非常轻量）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>需要可靠传输的应用</strong>（如网页、文件传输、邮件）</td>
<td align="left"><strong>实时性要求高的应用</strong>（如视频、语音、游戏）</td>
</tr>
<tr>
<td align="left"><strong>典型协议&#x2F;应用</strong></td>
<td align="left"><strong>HTTP、HTTPS、FTP、SSH、Email</strong></td>
<td align="left"><strong>DNS、视频会议（Zoom）、在线游戏、VoIP（Skype）</strong></td>
</tr>
</tbody></table>
<h3 id="UDP如何保证消息不丢失"><a href="#UDP如何保证消息不丢失" class="headerlink" title="UDP如何保证消息不丢失"></a>UDP如何保证消息不丢失</h3><ul>
<li>UDP不保证消息不丢失。</li>
<li>如果希望UDP可靠，可以在应用层实现</li>
</ul>
<h3 id="三次握手，为什么不是两次或四次握手"><a href="#三次握手，为什么不是两次或四次握手" class="headerlink" title="三次握手，为什么不是两次或四次握手"></a>三次握手，为什么不是两次或四次握手</h3><ol>
<li><p>为什么不是两次？</p>
<ol>
<li>本质是考虑数据报的丢失</li>
<li>假设：TCP 只用两次握手（客户端 SYN → 服务器 SYN-ACK）</li>
<li>问题：<strong>无法防止“历史连接”导致的资源浪费！</strong></li>
<li>*场景：<ol>
<li>客户端之前发送了一个连接请求，但由于 网络延迟，这个包 很久才到达服务器。</li>
<li>客户端早就 <strong>放弃了这次连接</strong>（超时重传或主动关闭），但 <strong>服务器</strong>现在才收到这个旧的 SYN。</li>
<li><strong>如果只有两次握手</strong>：服务器收到 SYN 后，会 <strong>直接认为这是一个新连接</strong>，并分配资源（如内存、端口）。服务器回复 SYN-ACK，然后等待客户端的 ACK（但客户端根本不会回复，因为它已经放弃了）。</li>
<li><strong>结果</strong>：<strong>服务器一直等待，浪费资源（内存、端口、CPU）</strong>，形成 “半连接”。</li>
</ol>
</li>
<li>三次握手如何解决？<ul>
<li>第三次握手（客户端 → 服务器 ACK）是 客户端对服务器 SYN 的确认。</li>
<li>如果客户端不发送第三次握手（说明它根本不想要这个连接），服务器 不会真正建立连接，避免资源浪费。</li>
<li>只有双方都确认了对方的初始序列号，连接才算真正建立。</li>
</ul>
</li>
<li>结论：</li>
</ol>
<ul>
<li>两次握手无法防止“历史无效连接”占用服务器资源。</li>
<li>三次握手确保双方都“真心想连接”，避免无效连接占用系统资源。</li>
</ul>
</li>
<li><p>为什么不是四次</p>
<ol>
<li><p>假设：TCP 用四次握手</p>
</li>
<li><p>问题：<strong>第三次握手已经足够，第四次是多余的！</strong></p>
</li>
<li><p>三次握手已经完成的任务：</p>
<ol>
<li>客户端 → 服务器 SYN（客户端说：“我想连接，我的序号是 x。”）。</li>
<li>服务器 → 客户端 SYN-ACK（服务器说：“我同意，我的序号是 y，我收到了你的 x。”）。</li>
<li>客户端 → 服务器 ACK（客户端说：“我收到了你的 y，我准备好了。”）。</li>
</ol>
<ul>
<li><p>此时：</p>
<ul>
<li><p>双方都已经确认了对方的初始序列号（ISN）。</p>
</li>
<li><p>连接已经可以安全传输数据。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第四次握手的作用？</p>
<ul>
<li>服务器再发一个 ACK 给客户端？→ 完全没必要，因为客户端已经确认了服务器的 SYN（第三次握手）。</li>
<li>这样只会增加 1 个 RTT（往返时间），降低连接效率。</li>
</ul>
</li>
<li><p>结论：</p>
<ul>
<li>三次握手已经足够保证可靠性，四次握手不会带来额外好处，反而降低效率。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h3><ol>
<li>回顾一下四次挥手的过程就知道了。本质还是考虑数据报的丢失。</li>
<li>客户端请求断开连接时，服务端可能还在发送数据。必须要等他发送完。</li>
<li>服务端如果不等待客户端的确认，可能导致客户端的半连接。</li>
</ol>
<h3 id="为什么要等待2MSL，才进入CLOSE"><a href="#为什么要等待2MSL，才进入CLOSE" class="headerlink" title="为什么要等待2MSL，才进入CLOSE"></a>为什么要等待2MSL，才进入CLOSE</h3><ul>
<li><strong>MSL（Maximum Segment Lifetime）<strong>是指一个TCP报文段在网络中</strong>最长可以存活的时间</strong>。超过这个时间，该报文段就会被网络丢弃。</li>
<li>在 <strong>第四次挥手后</strong>，<strong>客户端</strong>不会立刻关闭连接，而是进入 <strong><code>TIME_WAIT</code>状态（等待 2MSL）</strong></li>
<li><strong>防止服务端没有收到断开确认</strong></li>
</ul>
<ol>
<li>如果服务端没有收到断开确认，会在一定时间后重发FIN报文。客户端就是要等待这个报文。</li>
<li>如果不等，但是服务端又没有收到断开确认，会导致断开失败。</li>
<li>如果服务器在这个期间挂了怎么办？<ol>
<li>一般情况下，不会对客户端产生实质性的负面影响，客户端仍然会正常结束 TIME_WAIT 状态。</li>
<li>既然服务端挂了，就不会重发FIN了，客户端就会在2MSL自然断开连接</li>
</ol>
</li>
</ol>
<h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><table>
<thead>
<tr>
<th align="left">机制</th>
<th align="left">作用</th>
<th align="left">解决的问题</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>确认应答（ACK）</strong></td>
<td align="left">接收方通知发送方数据已收到</td>
<td align="left">防止数据丢失，确保送达</td>
</tr>
<tr>
<td align="left"><strong>超时重传</strong></td>
<td align="left">没收到ACK就重发数据</td>
<td align="left">应对丢包</td>
</tr>
<tr>
<td align="left"><strong>序列号</strong></td>
<td align="left">给每个字节编号，用于排序和去重</td>
<td align="left">保证顺序、去重</td>
</tr>
<tr>
<td align="left"><strong>确认号</strong></td>
<td align="left">告诉发送方下一次该发哪个字节</td>
<td align="left">精准控制发送</td>
</tr>
<tr>
<td align="left"><strong>滑动窗口</strong></td>
<td align="left">动态控制发送速率，匹配接收能力</td>
<td align="left">流量控制，防止接收方过载</td>
</tr>
<tr>
<td align="left"><strong>拥塞控制</strong></td>
<td align="left">根据网络状况调整发送速率</td>
<td align="left">避免网络拥堵，提高整体性能</td>
</tr>
<tr>
<td align="left"><strong>校验和</strong></td>
<td align="left">检测数据在传输中是否损坏</td>
<td align="left">数据完整性保护</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>确认应答机制（ACK - Acknowledgement）</strong></p>
<ul>
<li>原理：发送方每发送一段数据，接收方收到后都会返回一个 <strong>ACK（确认报文）</strong>，表示已经成功收到该数据。</li>
<li>作用：发送方通过是否收到 ACK 来判断数据是否成功到达对端。如果没有收到 ACK，发送方会认为数据可能丢失，进而<strong>重传</strong>。</li>
</ul>
</li>
<li><p><strong>超时重传机制（Retransmission Timeout, RTO）</strong></p>
<ul>
<li>原理：发送方在发出数据后，会<strong>启动一个定时器</strong>，如果在规定时间内（超时时间，RTO）<strong>没有收到对应的ACK</strong>，就认为该数据包可能丢失了，于是<strong>重新发送</strong>该数据。</li>
</ul>
</li>
<li><p><strong>序列号机制（Sequence Number）</strong></p>
<ul>
<li>原理：TCP 会给每个<strong>字节</strong>都分配一个唯一的编号，称为 <strong>序列号（Sequence Number）</strong>，而不是针对每个数据包。</li>
</ul>
</li>
<li><p><strong>确认号机制（Acknowledgement Number）</strong></p>
</li>
</ol>
<ul>
<li>原理：接收方在回复 ACK 时，会告诉发送方：“我已经成功收到了序号 X 之前的所有数据，你<strong>下一个可以发送序号 X 的数据</strong>”。</li>
<li>作用：让发送方知道哪些数据已经被成功接收，从而避免不必要的重传，提高效率。</li>
</ul>
<ol start="5">
<li><p><strong>流量控制（Flow Control）——滑动窗口机制</strong></p>
<ul>
<li>问题：接收方的处理能力有限，如果发送方发送得太快，接收方缓冲区可能会溢出。</li>
<li>解决方案：使用滑动窗口（Sliding Window）机制来进行流量控制。接收方会通过 TCP 报文中的 <strong>窗口大小字段</strong>告诉发送方：“我当前还能接收多少数据”。发送方根据这个窗口大小来调整自己的发送速率，避免淹没接收方。</li>
</ul>
<p>滑动窗口让发送和接收双方能够动态协调发送速率，既高效又不会出错。</p>
</li>
<li><p><strong>拥塞控制（Congestion Control）</strong></p>
<ul>
<li>问题：不仅是接收方，整个网络的承载能力也是有限的，如果发送方不顾网络拥堵而疯狂发包，会导致丢包、延迟剧增，甚至网络瘫痪。</li>
<li>解决方案：TCP 实现了多种拥塞控制算法，比如：慢启动（Slow Start）拥塞避免（Congestion Avoidance）快速重传（Fast Retransmit）快速恢复（Fast Recovery）</li>
</ul>
<blockquote>
<p>这些算法让发送方根据网络的实时状态（比如是否出现丢包）来动态调整发送窗口大小，从而避免网络过度拥挤，提升整体通信质量与稳定性。</p>
</blockquote>
<p> <strong>拥塞控制关注的是“整个网络的负载情况”，而流量控制关注的是“接收方的能力”。两者共同作用，保证发送既高效又可靠。</strong></p>
</li>
<li><p><strong>校验和（Checksum）</strong></p>
<ul>
<li>原理：TCP 报文头部包含一个<strong>校验和字段</strong>，用于校验<strong>报文在传输过程中是否发生了错误（比如比特翻转）</strong>。</li>
<li>作用：接收方收到数据后，会重新计算校验和并与报文中的校验和比对，如果不匹配，说明数据可能损坏，直接丢弃该报文，等待重传。</li>
</ul>
</li>
</ol>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ol>
<li><p>为什么需要流量控制？</p>
<ol>
<li>TCP 是全双工、基于字节流的协议，数据在发送时是连续不断的。但如果<strong>发送方不顾接收方的处理能力，疯狂地发数据</strong>，接收方的<strong>接收缓冲区（Receive Buffer）可能会被填满</strong>，导致错误。</li>
</ol>
</li>
<li><p>如何实现？—— 滑动窗口（Sliding Window）机制</p>
<ol>
<li><strong>接收窗口（RWND, Receive Window）</strong><ol>
<li>接收方在自己的 TCP 报文头部中，通过 **窗口大小字段（Window Size）**告诉发送方：“我当前还能接收多少字节的数据”。</li>
<li>这个值就是<strong>接收窗口（RWND）</strong>，代表接收方缓冲区中<strong>剩余可用的空间大小</strong>。</li>
</ol>
</li>
<li><strong>发送方根据接收窗口调整发送速率</strong><ol>
<li>发送方根据接收方通告的窗口大小，<strong>决定自己一次可以发送多少数据</strong>，而不会超过接收方的处理能力。</li>
<li>当接收方处理了一些数据，并腾出了缓冲区空间后，会再次通告一个更大的窗口，发送方就可以继续多发数据。</li>
</ol>
</li>
<li><strong>滑动窗口动态调整</strong><ol>
<li>接收窗口的值是<strong>动态变化</strong>的，随着接收方应用程序读取数据的速度而改变。</li>
<li>发送方维护一个<strong>发送窗口</strong>，只有在窗口允许的范围内才能发送数据，从而实现“边发边等确认”的高效可靠传输。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><ol>
<li><p>是什么？</p>
<ol>
<li>拥塞控制是 TCP 用来感知并应对网络中的拥塞状况，动态调整发送速率，以避免网络过载和丢包的一种机制。</li>
<li>简单来说：发送方根据网络的拥堵程度，自动调整自己发多少数据，以免把网络“堵死”。</li>
</ol>
</li>
<li><p>为什么需要拥塞控制？</p>
<ol>
<li>网络中的带宽是<strong>共享的、有限的</strong>，如果多个设备同时大量发包，或者某一发送方发得过快，就可能导致：<ol>
<li>路由器&#x2F;交换机队列满</li>
<li>网络丢包（数据包被丢弃）</li>
<li>延迟急剧上升</li>
<li>吞吐量反而下降（越快越堵）</li>
</ol>
</li>
</ol>
<p>如果不加以控制，发送方“自顾自地快速发包”，不仅影响自己，还会<strong>影响整个网络的通信质量</strong>。</p>
</li>
<li><p>如何实现</p>
<ol>
<li>TCP 拥塞控制的核心是：<strong>通过维护一个“拥塞窗口（cwnd, Congestion Window）”来限制发送方在单位时间内可以发送的数据量</strong>，并且这个窗口大小会根据网络状况<strong>动态调整</strong>。</li>
</ol>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">新建连接 → 慢启动（指数增长）→ 达到 ssthresh → 拥塞避免（线性增长）</span><br><span class="line">                     ↓</span><br><span class="line">                出现丢包或 3 个 Dup ACK</span><br><span class="line">                     ↓</span><br><span class="line">           快速重传 → （可能进入）快速恢复 → 拥塞避免</span><br><span class="line">                     ↓</span><br><span class="line">                拥塞后重置 cwnd = 1，重新慢启动</span><br></pre></td></tr></table></figure>


<ol>
<li><p><strong>慢启动（Slow Start）</strong></p>
<ul>
<li>**初始状态：**连接刚建立时，发送方不知道网络状况，不敢发太多。</li>
<li>**策略：**从小窗口开始，<strong>每收到一个 ACK，cwnd 就指数级增长（翻倍）</strong>，即“慢慢提速”。</li>
<li>**触发条件：**刚开始发送，或网络发生丢包后重置。</li>
<li>**停止条件：**当 cwnd 达到一个阈值（ssthresh，慢启动阈值）时，进入拥塞避免阶段。</li>
</ul>
</li>
<li><p><strong>拥塞避免（Congestion Avoidance）</strong></p>
<ul>
<li><strong>策略：<strong>当 cwnd 达到 ssthresh 后，不再指数增长，而是</strong>每 RTT（往返时间）只增加 1 MSS（最大报文段长度）</strong>，即线性增长，<strong>更稳、更温和</strong>。</li>
<li>**目标：**尽量利用网络带宽，但避免触发拥塞。</li>
</ul>
</li>
<li><p><strong>快速重传（Fast Retransmit）</strong></p>
<ul>
<li><strong>触发条件：<strong>发送方</strong>连续收到 3 个重复的 ACK</strong>（说明某个数据包可能丢了，但网络还没完全拥塞）。</li>
<li>**行为：**不等超时，<strong>立刻重传那个丢失的数据包</strong>，而不必等到超时重传。</li>
<li>**效果：**更快恢复，避免等待超时带来的延迟。</li>
</ul>
</li>
<li><p><strong>快速恢复（Fast Recovery）</strong>（部分实现，如 Reno）</p>
<ul>
<li>**触发条件：**在快速重传之后，进入此状态。</li>
<li><strong>策略：<strong>不直接回到慢启动，而是</strong>将 ssthresh 设为当前 cwnd 的一半，cwnd 也适当减小，然后进入拥塞避免</strong>。</li>
<li>**目标：**快速恢复传输，同时避免网络再次拥塞。</li>
</ul>
</li>
</ol>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/03/life/%E4%BB%8A%E5%A4%A9%E7%9C%8B%E5%88%B0%E4%B8%80%E5%8F%A5%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D/" rel="prev" title="今天看到一句很喜欢的话，关于历史的">
                  <i class="fa fa-angle-left"></i> 今天看到一句很喜欢的话，关于历史的
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/12/04/tech/python%E6%A0%B8%E5%BF%83%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="python核心库学习笔记">
                  python核心库学习笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
