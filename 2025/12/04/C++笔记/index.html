<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"kongshan.me","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"gitalk":{"enable":true,"github_id":"mukongshan","repo":"mukongshan.github.io","client_id":"Ov23lifObx8GLwJlVsh3","client_secret":"ebc5f2cd8493752a92129fa16b4bf1635308b0d6","admin_user":"mukongshan","distraction_free_mode":true,"language":"zh-CN"}},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="课程内容第一章（C1、C2） · 介绍主流编程范式对比 面向对象编程（OOP） 起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言 核心概念：类&#x2F;对象、继承、多态、垃圾回收 设计哲学：自底向上程序设计，虚拟过程机制   函数式编程（FP） 理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑 核心特性：数据">
<meta property="og:type" content="article">
<meta property="og:title" content="C++编程">
<meta property="og:url" content="https://kongshan.me/2025/12/04/C++%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="kongshan&#39;s blog">
<meta property="og:description" content="课程内容第一章（C1、C2） · 介绍主流编程范式对比 面向对象编程（OOP） 起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言 核心概念：类&#x2F;对象、继承、多态、垃圾回收 设计哲学：自底向上程序设计，虚拟过程机制   函数式编程（FP） 理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑 核心特性：数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251016114647033.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251030092343301.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251114110904959.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251114163104987.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251127101044950.png">
<meta property="og:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251127102607959.png">
<meta property="article:published_time" content="2025-12-04T06:40:00.000Z">
<meta property="article:modified_time" content="2025-12-02T15:08:42.505Z">
<meta property="article:author" content="mukongshan">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251016114647033.png">


<link rel="canonical" href="https://kongshan.me/2025/12/04/C++%E7%AC%94%E8%AE%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://kongshan.me/2025/12/04/C++%E7%AC%94%E8%AE%B0/","path":"2025/12/04/C++笔记/","title":"C++编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++编程 | kongshan's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">kongshan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-blog"><a href="/blog/" rel="section"><i class="fa fa-book-open fa-fw"></i>博客</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="nav-number">1.</span> <span class="nav-text">课程内容</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88C1%E3%80%81C2%EF%BC%89-%C2%B7-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">第一章（C1、C2） · 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.1.</span> <span class="nav-text">主流编程范式对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E7%9A%84%E7%8B%AC%E7%89%B9%E4%BB%B7%E5%80%BC%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">C++的独特价值与设计哲学</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88C3%E3%80%81C4%EF%BC%89-%C2%B7-DataType"><span class="nav-number">1.2.</span> <span class="nav-text">第二章（C3、C4） · DataType</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%B0%83%E5%BA%A6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">类型擦除与函数指针调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5%E4%B8%8E%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%EF%BC%88SSO%EF%BC%89"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">存储策略与小对象优化（SSO）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">union类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC-%E5%A4%9A%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">多返回值  &#x2F; 多输出参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%BB%84%EF%BC%88tuple%EF%BC%89"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">元组（tuple）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%EF%BC%88optional%EF%BC%89"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">可选类型（optional）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88C5%EF%BC%89-%C2%B7-PointerFunc"><span class="nav-number">1.3.</span> <span class="nav-text">第三章（C5） · PointerFunc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">1.3.1.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function"><span class="nav-number">1.3.3.</span> <span class="nav-text">Function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88C6%EF%BC%89-%C2%B7-Function"><span class="nav-number">1.4.</span> <span class="nav-text">第四章（C6） · Function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Functional-Programming"><span class="nav-number">1.4.2.</span> <span class="nav-text">Functional Programming</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%88C7%E3%80%81C8%EF%BC%89-%C2%B7-%E5%B0%81%E8%A3%85"><span class="nav-number">1.5.</span> <span class="nav-text">第五章（C7、C8） ·  封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP"><span class="nav-number">1.5.1.</span> <span class="nav-text">面向对象编程OOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.5.2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.6.</span> <span class="nav-text">拷贝构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.7.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.5.8.</span> <span class="nav-text">动态内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E6%88%90%E5%91%98"><span class="nav-number">1.5.9.</span> <span class="nav-text">const成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.5.10.</span> <span class="nav-text">常量表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">1.5.11.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">1.5.12.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.12.1.</span> <span class="nav-text">虚函数的绑定机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.12.2.</span> <span class="nav-text">后期绑定的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.5.12.3.</span> <span class="nav-text">构造函数中的虚函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.5.12.4.</span> <span class="nav-text">纯虚函数与抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E4%B8%8Eoverride"><span class="nav-number">1.5.12.5.</span> <span class="nav-text">final与override</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.12.6.</span> <span class="nav-text">访问控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.5.13.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.14.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.5.14.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.14.2.</span> <span class="nav-text">虚继承</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">常用库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Calgorithm%E2%80%9D"><span class="nav-number">2.1.</span> <span class="nav-text">“algorithm”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Cfstream%E2%80%9D"><span class="nav-number">2.2.</span> <span class="nav-text">“fstream”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Cmemory%E2%80%9D"><span class="nav-number">2.3.</span> <span class="nav-text">“memory”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Cqueue%E2%80%9D"><span class="nav-number">2.4.</span> <span class="nav-text">“queue”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-number">2.4.1.</span> <span class="nav-text">priority_queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9Cstring%E2%80%9D"><span class="nav-number">2.5.</span> <span class="nav-text">“string”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9Cunordered-set%E2%80%9D%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="nav-number">2.5.1.</span> <span class="nav-text">“unordered_set”（哈希表）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">Lambda匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">值传递和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">输入输出操作</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mukongshan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">mukongshan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mukongshan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mukongshan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2087179041@qq.com" title="E-Mail → mailto:2087179041@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongshan.me/2025/12/04/C++%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="mukongshan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kongshan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++编程 | kongshan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-12-04 14:40:00" itemprop="dateCreated datePublished" datetime="2025-12-04T14:40:00+08:00">2025-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-02 23:08:42" itemprop="dateModified" datetime="2025-12-02T23:08:42+08:00">2025-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><h2 id="第一章（C1、C2）-·-介绍"><a href="#第一章（C1、C2）-·-介绍" class="headerlink" title="第一章（C1、C2） · 介绍"></a>第一章（C1、C2） · 介绍</h2><h3 id="主流编程范式对比"><a href="#主流编程范式对比" class="headerlink" title="主流编程范式对比"></a>主流编程范式对比</h3><ol>
<li>面向对象编程（OOP）<ul>
<li>起源：1962年Kristen Nygaard和Ole-Johan Dahl为模拟开发Simula语言</li>
<li>核心概念：类&#x2F;对象、继承、多态、垃圾回收</li>
<li>设计哲学：自底向上程序设计，虚拟过程机制</li>
</ul>
</li>
<li>函数式编程（FP）<ul>
<li>理论基础：Alonzo Church的λ演算，Haskell Curry的组合逻辑</li>
<li>核心特性：数据不可变性、无副作用、函数一等公民引用透明性：相同输入始终产生相同输出</li>
<li>应用场景：实时游戏状态管理、高频交易系统</li>
<li>局限：学习曲线陡峭，调试复杂，不适合状态密集型场景</li>
</ul>
</li>
<li>逻辑编程<ul>
<li>代表语言：Prolog</li>
<li>特点：基于公理、推理规则和查询的自动证明</li>
<li>经典案例：专家系统诊断、鸡兔同笼问题、斑马逻辑谜题</li>
</ul>
</li>
<li>并发编程与泛型编程</li>
</ol>
<ul>
<li>并发编程：程序分解为可独立运行部分的能力</li>
<li>泛型编程：通过抽象找到算法实现的共性，提高代码复用性</li>
</ul>
<span id="more"></span>

<h3 id="C-的独特价值与设计哲学"><a href="#C-的独特价值与设计哲学" class="headerlink" title="C++的独特价值与设计哲学"></a>C++的独特价值与设计哲学</h3><ol>
<li>核心优势：零开销抽象<ul>
<li>设计原则：<ul>
<li>不用的特性不需要付出代价</li>
<li>使用的特性无法手工编码得更好</li>
</ul>
</li>
<li>硬件访问与抽象的结合：直接映射语言结构到硬件设施</li>
</ul>
</li>
<li>与C语言的关系<ul>
<li>超集特性：C++支持C的所有编程技巧</li>
<li>兼容性：任何C程序都能用C++以基本相同方式编写，具备同等开销</li>
</ul>
</li>
<li>当代C++发展<ul>
<li>LLM代码生成工具：介绍了Cursor、Augmentcode、Copilot等主流工具</li>
<li>Bjarne Stroustrup的观点：强调教授现代C++，关注AI代码质量风险</li>
<li>未来方向：C++26改进异步支持，静态反射等新特性</li>
</ul>
</li>
</ol>
<h2 id="第二章（C3、C4）-·-DataType"><a href="#第二章（C3、C4）-·-DataType" class="headerlink" title="第二章（C3、C4） · DataType"></a>第二章（C3、C4） · DataType</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ol>
<li><p><code>short</code>型</p>
<ol>
<li>占2字节</li>
</ol>
</li>
<li><p><code>int</code>型</p>
<ol>
<li>无符号整型（<code>uint</code>）类型有溢出回绕机制</li>
<li>有符号整型(<code>int</code>)的溢出是UB。</li>
</ol>
</li>
<li><p><code>float</code>型</p>
<ol>
<li><p>特殊浮点数类型</p>
<ol>
<li><strong>无穷大（Infinity）</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>() + numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();  <span class="comment">// ∞ + ∞ = ∞</span></span><br><span class="line">numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>() * numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();  <span class="comment">// ∞ × ∞ = ∞</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>非数（NaN，Not a Number）</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NaN: 0 11111111 10000000000000000000000</span></span><br><span class="line"></span><br><span class="line">numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">quiet_NaN</span>();                    <span class="comment">// 静态NaN</span></span><br><span class="line">numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>() / numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>();  <span class="comment">// ∞/∞ = NaN</span></span><br><span class="line">numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>() - numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();    <span class="comment">// ∞-∞ = NaN</span></span><br><span class="line">numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">infinity</span>() * <span class="number">0.0</span>;              <span class="comment">// ∞×0 = NaN</span></span><br><span class="line"><span class="type">float</span> f = <span class="number">0.0f</span> / <span class="number">0.0f</span>;                                <span class="comment">// 0/0 = NaN</span></span><br><span class="line"><span class="type">float</span> fs = <span class="built_in">sqrt</span>(<span class="number">-1.0f</span>);                                <span class="comment">// √(-1) = NaN</span></span><br><span class="line"><span class="type">float</span> fl = <span class="built_in">log</span>(<span class="number">-1.0f</span>);                                 <span class="comment">// ln(-1) = NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>次正规数</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">正规数</th>
<th align="left">次正规数（非规格化数）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">指数字段</td>
<td align="left">不为全 0，也不为全 1</td>
<td align="left"><strong>全为 0</strong></td>
</tr>
<tr>
<td align="left">尾数字段</td>
<td align="left">隐含前导 1（如 1.xxx…）</td>
<td align="left"><strong>无隐含 1，以 0.xxx… 开头</strong></td>
</tr>
<tr>
<td align="left">数值范围</td>
<td align="left">较大，常规浮点数范围</td>
<td align="left">极小，<strong>比最小正规数还小</strong></td>
</tr>
<tr>
<td align="left">是否支持极小非零值</td>
<td align="left">否（会下溢为 0）</td>
<td align="left"><strong>是，可表示极小非零值</strong></td>
</tr>
<tr>
<td align="left">精度</td>
<td align="left">较高</td>
<td align="left"><strong>相对较低</strong></td>
</tr>
<tr>
<td align="left">目的</td>
<td align="left">常规数值表示</td>
<td align="left">填补零与正规数之间的空隙，支持渐进下溢</td>
</tr>
</tbody></table>
</li>
<li><pre><code class="language-c++">#include &lt;cmath&gt;
std::fpclassify(subnormal_num);  // 返回FP_SUBNORMAL
std::isnormal(n);                // 检查是否为正规数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 类型转换机制</span><br><span class="line"></span><br><span class="line">1. 静态类型转换（`static_cast&lt;&gt;`）</span><br><span class="line">   1. 整型转换有高位截断风险（int转short）</span><br><span class="line">   2. 浮点数转换有精度损失.</span><br><span class="line">2. 重新解释转换（`reinterpret_cast&lt;&gt;`）</span><br><span class="line">   1. 是什么</span><br><span class="line">      1. `reinterpret_cast`是 C++ 中的一种 类型强制转换运算符，用于在不改变底层二进制数据的前提下，将一种类型的指针或引用转换为另一种完全不同类型的指针或引用。**它是最“底层”、最“危险”的类型转换之一**，通常用于一些特殊的、与系统底层或硬件相关的编程场景。</span><br><span class="line"></span><br><span class="line">### 数据序列化（Serialize）</span><br><span class="line"></span><br><span class="line">1. 序列化是将数据结构或对象状态转换为可以存储或传输的形式（如二进制、文本等），以便之后可以在相同或不同环境中重建数据的过程。</span><br><span class="line"></span><br><span class="line">2. POD类型</span><br><span class="line"></span><br><span class="line">   1. 一个类型（或类/结构体）被认为是 POD，通常具备以下特征：</span><br><span class="line"></span><br><span class="line">      1. 类似 C 的数据结构</span><br><span class="line"></span><br><span class="line">         1. 没有用户自定义的构造函数、析构函数。</span><br><span class="line">         2. 没有虚函数（即没有虚函数表 vtable）。</span><br><span class="line">         3. 没有继承关系（不是从其它类继承来的）。</span><br><span class="line">         4. 所有成员变量也都是 POD 类型。</span><br><span class="line"></span><br><span class="line">      2. 支持逐字节拷贝（memcpy 安全）</span><br><span class="line"></span><br><span class="line">         1. 可以安全地使用 `memcpy`、`memset`等函数对其进行内存操作，不会破坏其内部状态。</span><br><span class="line">         2. 可以直接进行二进制读写（比如读写文件、网络传输）。</span><br><span class="line"></span><br><span class="line">      3. 内存布局是确定且简单的</span><br><span class="line"></span><br><span class="line">         1. 成员变量的排列顺序和内存布局是明确的，通常与声明顺序一致（尤其是在使用了 `#pragma pack`等对齐控制后）。</span><br><span class="line">         2. 没有隐藏的成员（比如虚表指针）。</span><br><span class="line"></span><br><span class="line">      4. 不是POD的例子</span><br><span class="line"></span><br><span class="line">         1. ```c++</span><br><span class="line">            class Person &#123;</span><br><span class="line">            public:</span><br><span class="line">                Person() &#123;&#125;                    // 有用户定义的构造函数</span><br><span class="line">                virtual ~Person() &#123;&#125;           // 有虚析构函数（隐含虚表）</span><br><span class="line">                std::string name;              // 成员是非 POD 类型（std::string）</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>内存对齐设置：</p>
<ol>
<li><pre><code class="language-c++">#pragma pack(push, 1)  // 1字节对齐
struct PacketHeader {
    std::uint32_t packetId;    // 4字节
    std::uint16_t payloadSize; // 2字节  
    std::uint8_t flags;        // 1字节
};  // 总共7字节，无填充
#pragma pack(pop)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. 通过 `#pragma pack(push, 1)`和 `#pragma pack(pop)`这两个编译器指令，对 `PacketHeader`结构体的内存对齐方式进行了设置。这里设置为按 1 字节对齐，目的是让结构体成员在内存中紧密排列，不存在额外的填充字节。这样做在涉及网络传输或者文件存储时，能够确保数据在不同平台上具有一致性，避免因不同平台的默认内存对齐规则差异导致数据解析错误。</span><br><span class="line"></span><br><span class="line">### any类型</span><br><span class="line"></span><br><span class="line">#### 概述</span><br><span class="line"></span><br><span class="line">1. 特性</span><br><span class="line"></span><br><span class="line">| 特性                                         | 说明                                                         |</span><br><span class="line">| :------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">| **类型安全**                                 | 存储任意类型，但取出的时候必须匹配原类型，否则会抛出 `std::bad_any_cast`异常。 |</span><br><span class="line">| **动态类型**                                 | 可以存储任何可复制（或可移动）构造的类型，不需要提前知道具体类型。 |</span><br><span class="line">| **不需要模板参数**                           | 不像 `std::vector&lt;T&gt;`需要在编译期指定类型，`std::any`是运行时多态的。 |</span><br><span class="line">| **支持拷贝和移动语义**                       | 可以拷贝或移动 `std::any`对象，但内部存储的值也会相应拷贝或移动。 |</span><br><span class="line">| **底层实现通常基于类型擦除（type erasure）** | 一般通过继承、虚函数、模板等技术实现运行时类型信息（RTTI）管理。 |</span><br><span class="line"></span><br><span class="line">1. 常见用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 功能 / 用法                  | 方法 / 操作                           | 代码示例                                                     | 说明                                                         |</span><br><span class="line">      | :--------------------------- | :------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">      | **创建并存储任意类型值**     | 直接赋值                              | `std::any a = 42;` `std::any b = std::string(&quot;Hello&quot;);` `std::any c = 3.14;` | 可存储 `int`、`string`、自定义类等几乎任何类型。             |</span><br><span class="line">      | **检查是否有存储值**         | `.has_value()`                        | `if (a.has_value()) &#123; /* 有值 */ &#125;`                          | 返回 `bool`，表示当前 `std::any`是否持有某个对象。           |</span><br><span class="line">      | **获取存储的值（类型安全）** | `std::any_cast&lt;T&gt;(any_obj)`           | `int x = std::any_cast&lt;int&gt;(a);` `std::string s = std::any_cast&lt;std::string&gt;(b);` | 必须与存入时的类型 **完全一致**，否则抛出 `std::bad_any_cast`异常。 |</span><br><span class="line">      | **安全获取值（避免异常）**   | 先检查 `.type()`再 `any_cast`         | `if (a.type() == typeid(int)) &#123; int x = std::any_cast&lt;int&gt;(a); &#125;` | 推荐做法：先通过 `type()`判断类型，再安全转换。              |</span><br><span class="line">      | **获取当前存储值的类型信息** | `.type()`                             | `if (a.type() == typeid(std::string)) &#123; ... &#125;`               | 返回 `std::type_info`，可用于与 `typeid(T)`比较，判断存储了什么类型。 |</span><br><span class="line">      | **处理类型转换失败**         | `try / catch`捕获 `std::bad_any_cast` | `&lt;br&gt;try &#123;&lt;br&gt;    auto s = std::any_cast&lt;std::string&gt;(a);&lt;br&gt;&#125; catch (const std::bad_any_cast&amp; e) &#123;&lt;br&gt;    std::cerr &lt;&lt; &quot;转换失败: &quot; &lt;&lt; e.what();&lt;br&gt;&#125;&lt;br&gt;` | 当 `any_cast`的类型不匹配时，会抛出此异常。                  |</span><br><span class="line">      | **移动语义支持**             | 移动构造 / 赋值                       | `std::any a = std::string(&quot;Hi&quot;);` `std::any b = std::move(a);` | 支持移动构造和移动赋值，避免不必要的拷贝（特别是大对象）。   |</span><br><span class="line">      | **清空 / 重置 any 对象**     | 赋值为 `std::any()`或赋新值           | `a = std::any();`或 `a = 42;`（覆盖）                        | 将其置为空状态（无值），或直接覆盖为新值。                   |</span><br><span class="line">      | **判断存储类型是否为某类型** | `type() == typeid(T)`                 | `if (a.type() == typeid(double)) &#123; ... &#125;`                    | 用于在运行时判断当前 `any`中存储的对象类型。                 |</span><br><span class="line"></span><br><span class="line">3. 注意事项</span><br><span class="line">   1. 不要滥用 `std::any`，**如果能用模板、具体类型、`std::variant`，优先考虑它们**，因为它们更高效、更安全。</span><br><span class="line">   2. 存储引用需谨慎（一般不推荐），建议存储值或智能指针。</span><br><span class="line">   3. 有性能开销，适用于灵活性优先、性能要求不极致的场景。</span><br><span class="line"></span><br><span class="line">#### any的底层数据结构</span><br><span class="line"></span><br><span class="line">`std::any`的内部实现通常包含如下两个关键成员（或类似结构）：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">struct any &#123;</span><br><span class="line">    using _Handler = ...;  // 函数指针类型，用于管理对象的生命周期、拷贝、移动等</span><br><span class="line">    _Handler _h_;          // 管理函数指针（存储了针对当前类型T的处理逻辑）</span><br><span class="line"></span><br><span class="line">    union Storage &#123;        // 联合体，用于存储对象指针或内联缓冲区</span><br><span class="line">        void* ptr;         // 指向堆上分配的对象</span><br><span class="line">        __any_imp::__Buffer __buf;  // 内部小对象缓冲区（SSO）</span><br><span class="line">    &#125; _s_;                 // 实际存储区域</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p><code>std::any</code>内部通常由两部分构成：</p>
<ul>
<li><strong><code>_Handler _h_</code></strong>：一个函数指针（或函数对象），负责管理当前存储对象的所有操作（构造、析构、拷贝、移动、获取类型信息等）。它本质上是<strong>类型擦除的核心</strong>，通过函数指针动态分发操作。</li>
<li><strong><code>_Storage _s_</code></strong>：一个联合体（union），用于实际存储数据。它可能包含：一个 <code>void* ptr</code>：指向堆上分配的对象（当对象太大，无法放入内部缓冲区时）。一个 <code>__Buffer __buf</code>：内部的小对象缓冲区（通常几个机器字长，用于小对象优化，直接存储对象，避免堆分配）</li>
</ul>
</blockquote>
<h4 id="类型擦除与函数指针调度"><a href="#类型擦除与函数指针调度" class="headerlink" title="类型擦除与函数指针调度"></a>类型擦除与函数指针调度</h4><ol>
<li>什么是类型擦除？</li>
</ol>
<blockquote>
<p>类型擦除（Type Erasure）是一种设计技术，它允许我们在<strong>运行时处理不同类型的对象</strong>，但在<strong>编译期不依赖具体类型</strong>。<code>std::any</code>通过类型擦除，把不同类型对象的操作（构造、析构、拷贝、移动等）统一封装到一组函数指针中。</p>
</blockquote>
<ol start="2">
<li>函数指针类型定义（来自第5张图）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _HandleFuncPtr = <span class="type">void</span>* (*)( _Action act, </span><br><span class="line">                                  <span class="type">const</span> any* self, </span><br><span class="line">                                  any* other, </span><br><span class="line">                                  <span class="type">const</span> std::type_info* info, </span><br><span class="line">                                  <span class="type">const</span> std::type_info* fallback );</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个<strong>通用函数指针类型</strong>，它接收一个 <code>_Action</code>（表示要执行的操作类型，比如拷贝、析构、获取类型信息等），以及一些上下文参数（比如当前 <code>any</code>对象、目标对象、类型信息等）。</li>
<li>通过这个函数指针，<code>std::any</code>可以在<strong>运行时动态调用与当前存储类型 T 相关的正确操作函数</strong>。</li>
</ul>
<ol start="3">
<li>操作类型枚举（<code>_Action</code>，来自第5张图）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">_Action</span> &#123;</span><br><span class="line">    _Destroy,   <span class="comment">// 析构当前存储的对象</span></span><br><span class="line">    _Copy,      <span class="comment">// 拷贝构造一个新对象</span></span><br><span class="line">    _Move,      <span class="comment">// 移动构造一个新对象</span></span><br><span class="line">    _Get,       <span class="comment">// 获取存储的对象（类型安全地 cast 出来）</span></span><br><span class="line">    _TypeInfo   <span class="comment">// 获取类型信息（std::type_info）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每当你对 <code>std::any</code>执行某个操作（比如拷贝、析构、获取值），<code>std::any</code>内部的 <code>_Handler</code>函数指针就会被调用，并根据 <code>_Action</code>参数，执行对应的逻辑。</p>
</blockquote>
<h4 id="存储策略与小对象优化（SSO）"><a href="#存储策略与小对象优化（SSO）" class="headerlink" title="存储策略与小对象优化（SSO）"></a>存储策略与小对象优化（SSO）</h4><ol>
<li><p>什么是小对象优化（SSO）？</p>
<ol>
<li>对于<strong>较小的对象</strong>（比如 <code>int</code>、<code>float</code>、小型结构体），<code>std::any</code><strong>不会在堆上分配内存</strong>，而是直接将其存储在 <code>any</code>对象内部的**固定大小的缓冲区（<code>__Buffer</code>）**中，这样可以：<ol>
<li>避免堆分配的开销（malloc&#x2F;new）</li>
<li>提高性能（访问局部性更好）</li>
<li>减少内存碎片</li>
</ol>
</li>
</ol>
</li>
<li><p>内部缓冲区：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    <span class="type">void</span>* ptr;                        <span class="comment">// 指向堆内存（大对象）</span></span><br><span class="line">    __any_imp::__Buffer __buf;        <span class="comment">// 内部缓冲区（小对象，SSO）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果存储的对象<strong>足够小（比如小于等于 3 个机器字长，约 24~32 字节）</strong>，<code>std::any</code>会直接把对象存到内部的 <code>__buf</code>缓冲区中，<strong>不分配堆内存</strong>。</li>
<li>如果对象<strong>太大</strong>，则会通过 <code>new</code>在堆上分配内存，并将指针存到 <code>ptr</code>中。</li>
</ul>
<h3 id="union类型"><a href="#union类型" class="headerlink" title="union类型"></a>union类型</h3><ol>
<li><p>是什么</p>
<ol>
<li><p>联合体(Union)是C++中的一种特殊数据类型，允许多个成员变量<strong>共享同一块内存空间</strong>。与结构体(struct)不同，union的所有成员从同一内存地址开始存储。</p>
</li>
<li><p>内存布局原理</p>
<ol>
<li><pre><code>0x1000 ┌─────────────┐ ← char b (1字节)
       │             │
       │             │ ← int a (4字节)  
       │             │
0x1004 ├─────────────┤ ← double c (8字节)
       │             │
       │             │
       │             │
       │             │
0x1008 └─────────────┘
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. Union的技术优势与局限性</span><br><span class="line"></span><br><span class="line">   1.  技术优势</span><br><span class="line">      1. **内存高效**：极大节省存储空间，特别适合嵌入式系统</span><br><span class="line">      2. **数据多态**：同一内存块可解释为不同类型数据</span><br><span class="line">      3. **硬件接口**：直接映射到硬件寄存器或协议格式</span><br><span class="line">      4. **类型转换**：避免reinterpret_cast的显式转换</span><br><span class="line">   2. 局限性</span><br><span class="line">      1. **类型安全**：缺乏运行时类型检查，容易误用</span><br><span class="line">      2. **构造析构**：不能包含需要构造/析构的成员（C++11后放宽）</span><br><span class="line">      3. **继承限制**：不能作为基类参与继承体系</span><br><span class="line">      4. **维护困难**：需要手动管理当前有效成员</span><br><span class="line"></span><br><span class="line">   3. 现代C++中的替代方案</span><br><span class="line">      1. `std::variant`：类型安全的union替代品</span><br><span class="line">      2.  继承多态：面向对象的标准解决方案</span><br><span class="line">      3. 模板特化：编译时多态机制</span><br><span class="line"></span><br><span class="line">### Variant类型</span><br><span class="line"></span><br><span class="line">#### 概述</span><br><span class="line"></span><br><span class="line">1. 是什么</span><br><span class="line"></span><br><span class="line">   1. **类型安全的union**。它可以在同一个内存位置上存储一组预定义类型中的某一个值，但同一时间只能存储其中一个类型。可以把它理解为一个类型安全的、有限选择的“万能盒子”，比如这个盒子只能装 `int`、`double`或 `std::string`中的某一个，但你不能同时装多个，也不能装这三种之外的类型。</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. variant 初始状态：默认会初始化为第一个类型（如这里的 `int`）的值初始化</span><br><span class="line"></span><br><span class="line">   2. 访问错误类型会怎样：如果当前 `variant`不是类型 `T`，调用 `std::get&lt;T&gt;(v)`会抛出异常：`std::bad_variant_access`。</span><br><span class="line"></span><br><span class="line">   3. 常见使用场景：适用于：JSON 值、配置项、事件携带数据、状态机返回值等需要存储“某一类可能类型”但不确定具体是哪一个的场景。</span><br><span class="line"></span><br><span class="line">   4. | 功能 / 用法                                | 方法 / 操作                                           | 代码示例                                                     | 说明                                                         |</span><br><span class="line">      | :----------------------------------------- | :---------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |</span><br><span class="line">      | **定义**                                   | `std::variant&lt;T1, T2, ...&gt;`                           | `std::variant&lt;int, double, std::string&gt; v;`                  | 定义一个可以存储 `int`、`double`或 `std::string`中某一个值的变量 `v`，但**同一时间只能存其中一个**。 |</span><br><span class="line">      | **赋值**                                   | 直接赋值 `v = value;`                                 | `v = 42;` `v = 3.14;` `v = std::string(&quot;Hello&quot;);`            | 给 `variant`赋一个它支持的类型值，会替换掉当前存储的值。     |</span><br><span class="line">      | **检查当前存储的类型（编译期/运行时）**    | `v.index()`                                           | `int idx = v.index();` // 返回当前存储类型在模板参数列表中的索引（从 0 开始） | 比如 `std::variant&lt;int, string&gt;`中，`int`是 0，`string`是 1。 |</span><br><span class="line">      | **按类型安全地获取值**                     | `std::get&lt;T&gt;(v)`                                      | `int x = std::get&lt;int&gt;(v);` `std::string s = std::get&lt;std::string&gt;(v);` | 获取当前存储的值，但 **必须类型完全匹配**，否则抛出 `std::bad_variant_access`异常。 |</span><br><span class="line">      | **安全地按类型获取值**                     | `std::get_if&lt;T&gt;(&amp;v)`                                  | `if (auto p = std::get_if&lt;int&gt;(&amp;v)) &#123; /* 使用 *p */ &#125;`       | 如果当前存储的是类型 `T`，则返回指向该值的指针，否则返回 `nullptr`，更安全。 |</span><br><span class="line">      | **安全访问所有可能类型）**                 | `std::visit(visitor, v)`                              | `&lt;br&gt;std::visit([](auto&amp;&amp; arg) &#123;&lt;br&gt;    using T = decltype(arg);&lt;br&gt;    if constexpr (std::is_same_v&lt;T, int&gt;) &#123; /* int 处理 */ &#125;&lt;br&gt;    else if constexpr (std::is_same_v&lt;T, std::string&gt;) &#123; /* string 处理 */ &#125;&lt;br&gt;&#125;, v);&lt;br&gt;` | 最强大、最通用的方式，通过 **访问者（visitor）** 处理 `variant`当前可能的所有类型，支持编译期多态。 |</span><br><span class="line">      | **判断当前存储的是否是某个类型（运行时）** | `v.index() == N`或结合 `std::holds_alternative&lt;T&gt;(v)` | `if (std::holds_alternative&lt;std::string&gt;(v)) &#123; /* 是 string */ &#125;` | `std::holds_alternative&lt;T&gt;(v)`是类型安全的判断，返回 `bool`，表示当前是否存储了类型 `T`。 |</span><br><span class="line"></span><br><span class="line">3. 和any比较</span><br><span class="line"></span><br><span class="line">   1. 能用variant就尽量用，因为效率高</span><br><span class="line"></span><br><span class="line">   2. | 特性             | std::any            | std::variant    |</span><br><span class="line">      | :--------------- | :------------------ | :-------------- |</span><br><span class="line">      | **类型确定时机** | 运行时检查          | 编译期确定      |</span><br><span class="line">      | **类型安全性**   | 运行时类型检查      | 编译期类型检查  |</span><br><span class="line">      | **访问开销**     | 函数调用+类型比较   | 直接索引访问    |</span><br><span class="line">      | **内存布局**     | 类型擦除+小对象优化 | 联合体+类型标签 |</span><br><span class="line"></span><br><span class="line">#### variant的内部结构</span><br><span class="line"></span><br><span class="line">1. **`variant`的内部可以理解为一个 “带索引的联合体（union + index）”**</span><br><span class="line">2. 主要包含三个部分：</span><br><span class="line">   1. **索引（index）**：一个整数（通常是 `unsigned int`），表示当前存储的是联合体中的哪个类型（比如 0 表示 `int`，1 表示 `double`，2 表示 `string`）。</span><br><span class="line">   2. **值（value）**：一个联合体（union），实际存储了 `int`/ `double`/ `string`等类型的某一个值。</span><br><span class="line">   3. **对齐填充（alignment）**:用填充字节把整个 Variant 填到对齐边界上.</span><br><span class="line"></span><br><span class="line">![image-20251116162658657](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251116162658657.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 访问者模式（visitor partten）</span><br><span class="line"></span><br><span class="line">1. 是什么</span><br><span class="line"></span><br><span class="line">   1. 访问者（Visitor）模式是一种行为型设计模式，它允许你在不改变各元素类的前提下定义作用于这些元素的新操作。</span><br><span class="line"></span><br><span class="line">2. 下面结合你提供的修正后更清晰的代码片段，一步步拆解**访问者（Visitor）模式**在这段 C++ 代码里的体现与运作逻辑：</span><br><span class="line"></span><br><span class="line">   1. 整体功能概览</span><br><span class="line"></span><br><span class="line">      这段代码演示了如何用「访问者模式」来给不同的几何形状（圆形、矩形）**动态地附加“计算面积”这一操作**。核心思路是：把「对元素的操作」从元素类本身抽离出来，放到专门的「访问者（Visitor）」类中；这样既能让元素类保持简洁，又能在不修改元素类的情况下，灵活添加新操作（比如未来再加“绘制形状”“导出 SVG”等）。</span><br><span class="line"></span><br><span class="line">   2. 代码逐部分解析</span><br><span class="line"></span><br><span class="line">      1. 先看「抽象元素（Shape）」与「具体元素（Circle、Rectangle）」</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   // --------------------------</span><br><span class="line">   // 1. 抽象元素：Shape 基类</span><br><span class="line">   // --------------------------</span><br><span class="line">   class Shape &#123;</span><br><span class="line">   public:</span><br><span class="line">       virtual ~Shape() = default;       // 虚析构，保证多态销毁</span><br><span class="line">       virtual void accept(ShapeVisitor* visitor) = 0;  // 核心：接受访问者的抽象方法</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   // --------------------------</span><br><span class="line">   // 2. 具体元素：Circle（圆形）</span><br><span class="line">   // --------------------------</span><br><span class="line">   class Circle : public Shape &#123;</span><br><span class="line">   private:</span><br><span class="line">       double radius;</span><br><span class="line">   public:</span><br><span class="line">       Circle(double r) : radius(r) &#123;&#125;          // 构造时传入半径</span><br><span class="line">   </span><br><span class="line">       // 获取半径（供访问者后续计算用）</span><br><span class="line">       double getRadius() const &#123; return radius; &#125;  </span><br><span class="line">   </span><br><span class="line">       // 实现 accept：把自己（this）交给访问者去“访问”</span><br><span class="line">       void accept(ShapeVisitor* visitor) override &#123;  </span><br><span class="line">           visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Circle*) 方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   // --------------------------</span><br><span class="line">   // 3. 具体元素：Rectangle（矩形）</span><br><span class="line">   // --------------------------</span><br><span class="line">   class Rectangle : public Shape &#123;</span><br><span class="line">   private:</span><br><span class="line">       double width, height;</span><br><span class="line">   public:</span><br><span class="line">       Rectangle(double w, double h) : width(w), height(h) &#123;&#125;  // 构造时传入宽高</span><br><span class="line">   </span><br><span class="line">       // 获取宽、高（供访问者后续计算用）</span><br><span class="line">       double getWidth() const &#123; return width; &#125;   </span><br><span class="line">       double getHeight() const &#123; return height; &#125;  </span><br><span class="line">   </span><br><span class="line">       // 实现 accept：把自己（this）交给访问者去“访问”</span><br><span class="line">       void accept(ShapeVisitor* visitor) override &#123;  </span><br><span class="line">           visitor-&gt;visit(this);  // 关键！调用访问者的 visit(Rectangle*) 方法</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<ul>
<li><strong>设计意图</strong>：<code>Shape</code>是所有几何形状的“根”，它只定义了一个抽象方法 <code>accept</code>，用来接收「访问者」。这样不管未来加多少种形状（三角形、椭圆…），都只要继承 <code>Shape</code>并实现 <code>accept</code>即可。</li>
<li><strong><code>accept</code>方法的意义</strong>：它是「双分派（Double Dispatch）」的关键入口。你可以简单理解成：“我是什么类型的元素” + “你是什么类型的访问者” 这两层信息，共同决定要执行哪一段逻辑。</li>
</ul>
<ol start="2">
<li>再看「抽象访问者（ShapeVisitor）」与「具体访问者（AreaCalculator）」</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------------</span></span><br><span class="line"><span class="comment">// 4. 抽象访问者：ShapeVisitor</span></span><br><span class="line"><span class="comment">// --------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ShapeVisitor</span>() = <span class="keyword">default</span>;  <span class="comment">// 虚析构，保证多态销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对圆形的访问接口（纯虚函数，子类必须实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Circle* circle)</span> </span>= <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对矩形的访问接口（纯虚函数，子类必须实现）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(Rectangle* rectangle)</span> </span>= <span class="number">0</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------</span></span><br><span class="line"><span class="comment">// 5. 具体访问者：AreaCalculator（面积计算器）</span></span><br><span class="line"><span class="comment">// --------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaCalculator</span> : <span class="keyword">public</span> ShapeVisitor &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> totalArea = <span class="number">0.0</span>;  <span class="comment">// 累加所有形状的面积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实现对 Circle 的访问：计算圆形面积并累加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Circle* circle)</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="type">double</span> area = <span class="number">3.14159</span> * circle-&gt;<span class="built_in">getRadius</span>() * circle-&gt;<span class="built_in">getRadius</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle area: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">        totalArea += area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现对 Rectangle 的访问：计算矩形面积并累加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(Rectangle* rectangle)</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        <span class="type">double</span> area = rectangle-&gt;<span class="built_in">getWidth</span>() * rectangle-&gt;<span class="built_in">getHeight</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rectangle area: &quot;</span> &lt;&lt; area &lt;&lt; std::endl;</span><br><span class="line">        totalArea += area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取总面积的方法</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getTotalArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> totalArea; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>设计意图</strong>：<code>ShapeVisitor</code>定义了「对每种具体元素要执行的操作」的接口（<code>visit(Circle*)</code>、<code>visit(Rectangle*)</code>）。这样以后想加新操作（比如“绘制形状”“导出 JSON”），只需要新增一个继承 <code>ShapeVisitor</code>的类、实现对应的 <code>visit</code>即可，不用碰原来的 <code>Shape</code>及其子类。</li>
<li><strong><code>AreaCalculator</code>的职责</strong>：它专门干“计算面积”这件事。里面针对 <code>Circle</code>和 <code>Rectangle</code>各自实现了不同的计算逻辑；同时用 <code>totalArea</code>来累加所有形状的面积，最后能通过 <code>getTotalArea()</code>拿到结果。</li>
</ul>
<ol start="3">
<li>最后看「客户端如何组织 &amp; 执行访问逻辑」</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 准备对象结构：装各种 Shape 的容器</span></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 往容器里塞具体的形状（Circle、Rectangle）</span></span><br><span class="line">    shapes.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Circle&gt;(<span class="number">5.0</span>));     <span class="comment">// 半径 5 的圆</span></span><br><span class="line">    shapes.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;Rectangle&gt;(<span class="number">4.0</span>, <span class="number">6.0</span>)); <span class="comment">// 宽4 高6 的矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建「访问者」实例</span></span><br><span class="line">    AreaCalculator areaCalc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 遍历所有形状，让每个形状“接受”访问者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; shape : shapes) &#123;</span><br><span class="line">        shape-&gt;<span class="built_in">accept</span>(&amp;areaCalc);  <span class="comment">// 关键：触发双分派！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 拿到访问者计算的“总面积”</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total area of all shapes: &quot;</span> &lt;&lt; areaCalc.<span class="built_in">getTotalArea</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程解释</strong>：<ul>
<li>先创建一个 <code>vector</code>，里面存的是各种 <code>Shape</code>的智能指针（这里用了 <code>unique_ptr</code>管理内存）。</li>
<li>往这个 <code>vector</code>里分别 <code>emplace_back</code>了 <code>Circle</code>和 <code>Rectangle</code>的实例——这就是所谓的「对象结构」：一组不同类型的元素，统一用基类指针管理。</li>
<li>新建 <code>AreaCalculator</code>（具体访问者）的实例 <code>areaCalc</code>。</li>
<li>遍历 <code>shapes</code>里的每一个 <code>Shape</code>，调用它的 <code>accept(&amp;areaCalc)</code>。这时候就会触发「双分派」：<ul>
<li>首先，<code>shape</code>自己会判断自己是 <code>Circle</code>还是 <code>Rectangle</code>，然后调用 <code>visitor-&gt;visit(this)</code>—— 如果是 <code>Circle</code>，就调用 <code>areaCalc.visit(Circle*)</code>；如果是 <code>Rectangle</code>，就调用 <code>areaCalc.visit(Rectangle*)</code>。</li>
</ul>
</li>
<li>进入到 <code>visit</code>之后，访问者内部根据元素类型，执行对应的面积计算逻辑，还能累加总面积。</li>
<li>最后打印出总面积，演示「访问者帮我们完成了跨元素的通用操作」。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>访问者模式的核心要点总结</strong></p>
<ol>
<li>**双分派（Double Dispatch）**第一次分派：由「元素（如 <code>Circle</code>&#x2F;<code>Rectangle</code>）」决定调用哪个 <code>accept</code>方法（多态）。第二次分派：在 <code>accept</code>里调用 <code>visitor-&gt;visit(this)</code>时，又由「访问者（如 <code>AreaCalculator</code>）」决定调用哪个 <code>visit</code>重载（多态）。通过这两次动态绑定，最终执行哪段逻辑，既取决于“元素是什么类型”，也取决于“访问者是什么类型”。</li>
<li><strong>元素与操作的解耦</strong><code>Shape</code>及其子类只负责“自己是哪种形状、有哪些属性”，完全不关心“要怎么计算面积、怎么绘制”这些操作。所有操作都被收拢到 <code>ShapeVisitor</code>及其子类里。想加新操作？只需要新增 Visitor 子类，不用改任何 <code>Shape</code>代码。</li>
<li>**符合开闭原则（OCP）**对扩展开放：要新增操作（比如“绘制形状”），只需要写新的 Visitor 类，实现 <code>visit(Circle*)</code>、<code>visit(Rectangle*)</code>… 不用碰原有元素类。对修改封闭：原有的 <code>Shape</code>、<code>Circle</code>、<code>Rectangle</code>… 都不用因为加了新操作而改动。</li>
</ol>
</li>
<li><p>什么时候该用访问者模式？</p>
<ul>
<li><strong>对象结构稳定，但操作频繁变化</strong>：比如游戏里的各种 NPC、道具，它们的类型相对固定，但运营过程中可能不断加“统计战力”“批量强化”“导出清单”等新操作 → 用 Visitor 把操作抽出去，方便扩展。</li>
<li><strong>需要对复杂对象结构做多种不相关操作</strong>：比如编译器的抽象语法树（AST），节点类型很多，但要分别做“语法检查”“代码生成”“优化”等完全不同的操作 → 每个操作写一个 Visitor，遍历 AST 时传入不同 Visitor 即可。</li>
<li><strong>元素类已经有较多方法，不想再往里面塞新方法</strong>：如果直接在 <code>Shape</code>里加 <code>calculateArea()</code>，会让 <code>Shape</code>变得臃肿；用 Visitor 就能把 <code>calculateArea</code>相关逻辑挪到外面，让 <code>Shape</code>保持简洁。</li>
</ul>
</li>
</ol>
<h3 id="多返回值-多输出参数"><a href="#多返回值-多输出参数" class="headerlink" title="多返回值  &#x2F; 多输出参数"></a>多返回值  &#x2F; 多输出参数</h3><ul>
<li>这部分内容围绕 C++ 中用于<strong>返回或处理多个值</strong>的不同技术和工具展开，分别介绍了 <strong>元组（tuple）、可选类型（optional）</strong> ，核心是解决函数<strong>如何优雅地返回多个值、处理可能缺失的值、以及更现代的初始化与解包方式</strong>。</li>
</ul>
<h4 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h4><ol>
<li><p>是什么</p>
<ol>
<li><code>std::tuple</code>是一个<strong>固定大小（编译期确定）、可以存储多个不同类型（异构）数据</strong>的模板类，它将多个值“打包”成一个整体对象，便于<strong>一起返回、传递或存储</strong>。</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>函数返回多个值：<code>std::tuple&lt;int, float&gt; calculate();</code></li>
<li>组合异构数据：<code>std::tuple&lt;int, std::string, double&gt; user = {1, &quot;Tom&quot;, 3.5};</code></li>
</ol>
</li>
<li><p>三种解包方式</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">方式</th>
<th align="left">语法</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用标准</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>std::get&lt;N&gt;(t)</code></strong></td>
<td align="left">按索引访问，如 <code>std::get&lt;0&gt;(t)</code></td>
<td align="left">精准访问某个位置的值</td>
<td align="left">需记住索引，类型不匹配编译报错</td>
<td align="left">C++11 起</td>
</tr>
<tr>
<td align="left"><strong><code>std::tie(var1, std::ignore, var2)</code></strong></td>
<td align="left">解包到已有变量，可配合 <code>std::ignore</code></td>
<td align="left">可选择性接收部分返回值</td>
<td align="left">需提前定义变量，代码稍显冗长</td>
<td align="left">C++11 起</td>
</tr>
<tr>
<td align="left"><strong><code>auto [v1, v2, ...] = t</code>（结构化绑定）</strong></td>
<td align="left">C++17 最简洁的解包方式</td>
<td align="left"><strong>代码最清晰、可读性最强，自动绑定</strong></td>
<td align="left">仅限 C++17 及以上</td>
<td align="left">C++17 起</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h4 id="可选类型（optional）"><a href="#可选类型（optional）" class="headerlink" title="可选类型（optional）"></a>可选类型（optional）</h4><ol>
<li><p><code>std::optional&lt;T&gt;</code>是 C++17 标准库引入的一个<strong>类型安全的容器类</strong>，用于表示<strong>一个可能包含某个类型 <code>T</code>的值，也可能不包含任何值（即“空”）</strong> 的对象。</p>
</li>
<li><p>示例：</p>
<ol>
<li><p>定义</p>
<ol>
<li><pre><code class="language-c++">// 示例：根据用户名查找用户 ID，可能找到也可能找不到
std::optional&lt;int&gt; findUserID(const std::string&amp; username) {
    if (username == &quot;Alice&quot;) {
        return 1001;  // 找到了，返回 ID
    } else {
        return std::nullopt;  // 没找到，返回“空”
    }
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 调用</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      int main() &#123;</span><br><span class="line">          auto idOpt = findUserID(&quot;Alice&quot;);</span><br><span class="line">          </span><br><span class="line">          if (idOpt.has_value()) &#123;            // 检查是否有值</span><br><span class="line">              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; idOpt.value() &lt;&lt; std::endl;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              std::cout &lt;&lt; &quot;未找到该用户&quot; &lt;&lt; std::endl;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          // 更推荐的简洁方式（C++17 起）：</span><br><span class="line">          if (idOpt) &#123;  // 可隐式转换为 bool，判断是否有值</span><br><span class="line">              std::cout &lt;&lt; &quot;找到用户，ID = &quot; &lt;&lt; *idOpt &lt;&lt; std::endl;  // 用 * 解引用获取值</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          // 提供默认值（如果没找到，返回 -1）</span><br><span class="line">          int id = idOpt.value_or(-1);  // 如果没有值，返回 -1，不会抛异常</span><br><span class="line">          std::cout &lt;&lt; &quot;用户ID（带默认值）: &quot; &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">      </span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="第三章（C5）-·-PointerFunc"><a href="#第三章（C5）-·-PointerFunc" class="headerlink" title="第三章（C5） · PointerFunc"></a>第三章（C5） · PointerFunc</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><ol>
<li><p>多维数组的表示</p>
<ol>
<li><p>最常见<code>int a[1][2]</code></p>
</li>
<li><p>使用<strong>类型别名</strong>：等价于上面的表示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T = <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">    T a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">T* b; <span class="comment">// 表示b是一个指向int[2]的指针，即int(*)[2]或int[][2]  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等效于传统写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>[<span class="number">2</span>] T;  <span class="comment">// 等效的 typedef 写法</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>数组升维</p>
<ol>
<li><pre><code class="language-c++">void main(){
    int b[1];
    
    // 如何把b存给一个需要二维数组的函数呢
    // 用类型别名
    using T = int[2];
    func2( (T*)b );
}

void fnc(int a[][2]){...}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 内存管理</span><br><span class="line"></span><br><span class="line">#### malloc</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">   1. `malloc`是 C 标准库（通常是 `&lt;stdlib.h&gt;`或 `&lt;cstdlib&gt;`）提供的一个函数，用于在 程序的**堆（heap）**内存区域上动态分配指定大小的内存块。</span><br><span class="line">   2. `malloc`通常会先从进程的堆内存中管理的一块“内存池”里分配，只有当剩余内存不足时，才会向操作系统申请更多的堆内存（通常通过 `brk`或 `mmap`系统调用）</span><br><span class="line">   3. `malloc`的返回值：只是地址，内存未初始化！</span><br><span class="line"></span><br><span class="line">2. 系统调用</span><br><span class="line"></span><br><span class="line">   `malloc`底层会依赖操作系统的系统调用来真正获取或释放内存，PPT 中提到了两种最常用的系统调用：</span><br><span class="line"></span><br><span class="line">   - **`brk`**：`brk`是一个比较基础的用于调整进程堆空间（heap）大小的系统调用。简单来说，它会移动进程的 “堆顶指针”（break pointer），从而扩大或缩小堆的空间范围。`malloc`在小内存分配场景下，经常通过调整 `brk`来获得连续的堆内存。</span><br><span class="line">   - **`mmap`/`munmap`**：**`mmap`（memory map）可以把一个文件或者其他设备映射到进程的地址空间，也可以直接用来申请一块匿名内存**（不对应任何文件的纯内存区域）。</span><br><span class="line"></span><br><span class="line">3. 设计原则</span><br><span class="line"></span><br><span class="line">   1. **减少系统调用**</span><br><span class="line">   2. **快速匹配**</span><br><span class="line">   3. **减少锁竞争**</span><br><span class="line"></span><br><span class="line">#### 设计模式RAII</span><br><span class="line"></span><br><span class="line">1. 概述：RAII（Resource Acquisition Is Initialization，资源获取即初始化）的设计模式，以及如何通过智能指针类来避免内存泄漏。</span><br><span class="line"></span><br><span class="line">   &gt; 理解：把资源和相关操作封装到对象中，这样就可以利用构造函数和析构函数管理资源，避免内存泄露风险。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 比如智能指针、vector都是RAII设计模式。</span><br><span class="line"></span><br><span class="line">2. 核心思想：</span><br><span class="line"></span><br><span class="line">   1. **“谁申请，谁释放”**：资源的生命周期由其所有者（通常是封装资源的对象）管理。</span><br><span class="line">   2. **利用栈展开（Stack Unwinding）**：当函数退出（正常返回或异常抛出）时，C++ 会自动调用栈上对象的析构函数。</span><br><span class="line">   3. **异常安全**：即使发生异常，资源也能被正确释放，避免泄漏。</span><br><span class="line">   4. **零开销抽象**：运行时性能与手动管理相同（无额外动态分配或虚函数调用开销）。</span><br><span class="line"></span><br><span class="line">3. 理解</span><br><span class="line"></span><br><span class="line">   1. **传统方式（old_use）—— 存在内存泄漏风险**</span><br><span class="line"></span><br><span class="line">      ```c++</span><br><span class="line">      void old_use(Args a) &#123;</span><br><span class="line">          auto q = new Blob(a);  // 在堆上分配内存，返回指针</span><br><span class="line">          // ...</span><br><span class="line">          if (foo) throw Bad();  // 抛出异常 → 函数提前退出</span><br><span class="line">          if (bar) return;       // 正常返回 → 函数提前退出</span><br><span class="line">          // ...</span><br><span class="line">          delete q;  // 如果前面抛出异常或提前返回，此句不会执行 → 内存泄漏！</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

**问题**：

- 手动管理内存（`new`/`delete`）需要严格匹配，若中途因异常或 `return`提前退出，会导致 `delete`被跳过，引发内存泄漏。
- 代码复杂且易出错，尤其是多层嵌套的资源管理。

**2. RAII 方式（newer_use）—— 自动管理内存**

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">newer_use</span><span class="params">(Args a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">int_ptr</span>(<span class="keyword">new</span> <span class="built_in">Blob</span>(a));  <span class="comment">// 使用智能指针包装资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (foo) <span class="keyword">throw</span> <span class="built_in">Bad</span>();  <span class="comment">// 异常抛出 → 函数退出时 p 的析构函数自动调用</span></span><br><span class="line">    <span class="keyword">if</span> (bar) <span class="keyword">return</span>;       <span class="comment">// 提前返回 → 函数退出时 p 的析构函数自动调用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;  <span class="comment">// 函数结束时，p 被销毁 → 析构函数自动调用 delete 释放内存</span></span><br></pre></td></tr></table></figure>

**优势**：

- 无需手动调用 `delete`，资源随对象生命周期自动释放。
- 即使发生异常或提前返回，析构函数也会被调用，保证内存安全。

**3. 智能指针类 `int_ptr`的实现**

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">int_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：接收裸指针并接管资源</span></span><br><span class="line">    <span class="built_in">int_ptr</span>(<span class="type">int</span>* p = <span class="literal">nullptr</span>) : <span class="built_in">ptr</span>(p) &#123;&#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：释放资源</span></span><br><span class="line">    ~<span class="built_in">int_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 -&gt; 操作符：让 int_ptr 对象像指针一样访问成员</span></span><br><span class="line">    <span class="type">int</span>* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载 * 操作符：让 int_ptr 对象像指针一样解引用</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* ptr;  <span class="comment">// 存储裸指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

关键点解析

1. **构造函数 `int_ptr(int\* p)`**：接收裸指针 `p`并初始化成员变量 `ptr`，完成资源的“获取”。默认参数 `p = nullptr`允许空指针初始化（防止未初始化）。
2. **析构函数 `~int_ptr()`**：释放 `ptr`指向的内存（`delete ptr`），完成资源的“释放”。当 `int_ptr`对象离开作用域（函数结束、异常抛出等）时，析构函数自动调用。
3. **操作符重载 `operator-&gt;`和 `operator*`**：**`operator-&gt;`**：返回裸指针 `ptr`，使得 `int_ptr`对象可以通过 `-&gt;`访问指向对象的成员。示例：`p-&gt;someMethod()`等价于 `(p.operator-&gt;())-&gt;someMethod()`。**`operator*`**：返回裸指针解引用的结果（`*ptr`），使得 `int_ptr`对象可以通过 `*`直接访问指向的值。示例：`*p`等价于 `*(p.operator*())`。

为什么需要操作符重载？

- **语法兼容性**：让智能指针的使用方式与原生指针几乎一致，降低学习成本。
- **封装安全性**：虽然内部持有裸指针，但外部无法直接访问（`ptr`是私有成员），只能通过受控的操作符（`-&gt;`和 `*`）访问资源，防止误操作（如悬垂指针、重复释放等）。
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ol>
<li><p><code>auto_ptr</code></p>
<ol>
<li>概述<ol>
<li>在前面的介绍中，我们实现了int_ptr，那么为什么不能有其他的智能指针呢？所以有了auto_ptr</li>
</ol>
</li>
<li><code>auto_ptr</code>有什么问题？<ol>
<li><strong>反直觉的拷贝语义</strong>：当使用赋值操作符或拷贝构造函数对<code>auto_ptr</code>进行操作时，会发生所有权的转移。</li>
<li><strong>不适合STL容器</strong>：由于<code>auto_ptr</code>的这种非传统的拷贝语义，在STL容器中使用<code>auto_ptr</code>会导致未定义行为。例如，向<code>vector&lt;auto_ptr&lt;int&gt;&gt;</code>中插入元素时，可能会触发容器的重新分配内存，从而导致资源的所有权混乱。</li>
<li><strong>不支持数组</strong>：<code>auto_ptr</code>的析构函数使用<code>delete</code>来释放资源，而不是<code>delete[]</code>，因此不能用于管理动态分配的数组。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>unique_ptr</code></p>
<ol>
<li>为了改进auto_ptr，增加了以下特性：<ol>
<li><strong>禁止拷贝构造和赋值</strong>：<code>unique_ptr</code>通过删除拷贝构造函数和赋值操作符，确保每个资源只有一个所有者，避免了<code>auto_ptr</code>的所有权转移问题。</li>
<li><strong>移动语义</strong>：<code>unique_ptr</code>支持移动构造函数和移动赋值操作符，允许资源所有权的转移，但需要显式使用<code>std::move</code>。</li>
<li><strong>支持自定义删除器</strong>：<code>unique_ptr</code>可以接受自定义的删除器，这使得它能够管理更复杂的资源，如文件句柄、网络连接等。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>shared_ptr</code></p>
<ol>
<li>核心特性：<ol>
<li><strong>引用计数</strong>：<code>shared_ptr</code>内部维护一个“引用计数器”，记录有多少个 <code>shared_ptr</code>实例共同指向同一块资源。当最后一个 <code>shared_ptr</code>被销毁（或其引用计数减到 0）时，才会自动释放资源。</li>
<li><strong>共享所有权</strong>：允许多个 <code>shared_ptr</code>同时拥有对同一资源的控制权，适合多个对象&#x2F;模块需要协作管理同一块内存的场景。</li>
</ol>
</li>
<li>注意<ol>
<li><strong>注意事项</strong>：<ul>
<li><strong>循环引用</strong>：如果两个（或多个）<code>shared_ptr</code>彼此持有对方的指针，就会形成循环引用，导致引用计数永远无法归 0，资源泄漏。这时需要配合 <code>weak_ptr</code>来打破循环。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p><code>weak_ptr</code></p>
<ol>
<li>核心特性：<ol>
<li><strong>不增加强引用计数</strong>：<code>weak_ptr</code>不会增加 <code>shared_ptr</code>的引用计数，它只“观察”<code>shared_ptr</code>管理的资源，本身并不拥有资源。</li>
<li><strong>解决循环引用</strong>：常与 <code>shared_ptr</code>配合使用，用来打破 <code>shared_ptr</code>之间可能出现的循环引用，防止内存泄漏。</li>
<li><strong>临时获取资源</strong>：可以通过 <code>lock()</code>方法临时获取一个有效的 <code>shared_ptr</code>，如果资源还存在（即原 <code>shared_ptr</code>还没被销毁），则返回一个指向该资源的 <code>shared_ptr</code>；否则返回空。</li>
</ol>
</li>
<li>如何配合shared_ptr解决循环引用（以双链表为例）<ol>
<li>next用<code>shared_ptr</code>，prev用<code>weak_ptr</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ol>
<li><p>c++允许同名函数</p>
</li>
<li><p>执行机制：</p>
<ol>
<li>函数的执行机制<ol>
<li>建立被调用函数的栈空间</li>
<li>参数传递<ol>
<li>值传递 (call by value)</li>
<li>引用传递 (call by reference)</li>
</ol>
</li>
<li>保存调用函数的运行状态</li>
<li>将控制转交被调函数</li>
</ol>
</li>
</ol>
</li>
<li><p>Function Call</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251016114647033.png" alt="image-20251016114647033"></li>
</ol>
</li>
</ol>
<h2 id="第四章（C6）-·-Function"><a href="#第四章（C6）-·-Function" class="headerlink" title="第四章（C6） · Function"></a>第四章（C6） · Function</h2><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ol>
<li>调用流程</li>
</ol>
<p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251030092343301.png" alt="image-20251030092343301"></p>
<ol start="2">
<li><p>调用约定</p>
<ol>
<li>_cdecl<br>1. <ol>
<li>参数传递顺序：从右到左将参数压入堆栈。</li>
<li><strong>堆栈清理：由调用者（caller）负责清理堆栈。</strong></li>
<li><strong>支持可变参数函数</strong>：比如 <code>printf</code>就是使用 <code>cdecl</code>，因为它需要支持可变数量的参数，只有调用者知道传了多少参数，所以必须由调用者来清理堆栈。</li>
</ol>
</li>
<li>_stdcall<ol>
<li>参数传递顺序：也是从右到左将参数压入堆栈。</li>
<li><strong>堆栈清理</strong>：由**被调用函数（callee）**负责清理堆栈。</li>
<li><strong>不支持可变参数函数</strong>：因为只有调用者知道传了几个参数，而被调用者负责清理堆栈，所以在参数数量不固定的情况下无法正确清理。因此，像 <code>printf</code>这样的函数就不能用 <code>stdcall</code>。</li>
</ol>
</li>
<li>_fastcall<ol>
<li><strong>参数传递方式</strong>：部分或全部参数<strong>优先通过寄存器传递</strong>（通常是前两个或前三个），其余的仍然通过堆栈传递。</li>
<li>堆栈清理：通常是 <strong>被调用者（callee）</strong> 负责清理堆栈（和 <code>stdcall</code>类似），但也有编译器实现不同。</li>
</ol>
</li>
<li>_thiscall</li>
</ol>
</li>
<li><p>混合编程</p>
<ol>
<li>由前面可知，C++允许同名函数，但是C不能，所以二者的符号表不同。如果C++程序想调用C的库函数，需要把函数写为<code>extern &#39;C&#39; void func()</code></li>
</ol>
</li>
<li><p>内联函数<code>inline</code></p>
<ol>
<li><p>由前面可知，函数调用需要额外的开销，包括参数、返回地址等等的空间，以及指针跳转的时间。对于一个小函数来说，没必要使用函数调用。</p>
</li>
<li><p>优点</p>
<ol>
<li><p><strong>减少函数调用的开销，提高程序运行效率</strong></p>
<p>适用于：</p>
<ul>
<li><strong>函数体很小</strong>（比如只有一两行代码）；</li>
<li><strong>调用非常频繁</strong>（比如在循环中被多次调用）；</li>
<li><strong>追求极致性能的场景</strong>，如嵌入式系统、游戏引擎、高频交易等。</li>
</ul>
</li>
</ol>
</li>
<li><p>实现方式：编译器把inline函数的代码逻辑复制到调用点。和宏类似，但是有区别。</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">宏（Macro）</th>
<th align="left">内联函数（Inline Function）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">❌ 无类型检查</td>
<td align="left">✅ 有类型检查，是真正的函数</td>
</tr>
<tr>
<td align="left"><strong>调试支持</strong></td>
<td align="left">❌ 难以调试</td>
<td align="left">✅ 可以调试</td>
</tr>
<tr>
<td align="left"><strong>防止副作用</strong></td>
<td align="left">❌ 容易产生副作用</td>
<td align="left">✅ 参数只求值一次，更安全</td>
</tr>
<tr>
<td align="left"><strong>代码可读性</strong></td>
<td align="left">❌ 差</td>
<td align="left">✅ 好</td>
</tr>
<tr>
<td align="left"><strong>编译器优化</strong></td>
<td align="left">❌ 无智能优化</td>
<td align="left">✅ 编译器可以做更多优化</td>
</tr>
</tbody></table>
<p>🔒 <strong>结论：在 C++ 中，应该优先使用内联函数，而不是宏，来实现类似“代码展开”的功能。</strong></p>
</li>
<li><p><code>inline</code>只能申请内联，最终决定权在编译器</p>
</li>
</ol>
</li>
<li><p>限制：</p>
<ol>
<li>不能递归</li>
<li>没有函数指针</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><ol>
<li><p>两种编程范式的比较</p>
<ol>
<li>Imperative Programming<ol>
<li>把计算看做状态机，通过一系列语句改变状态</li>
</ol>
</li>
<li>Functional Programming<ol>
<li>把计算看做数学函数的求值，避免状态和可变数据</li>
</ol>
</li>
</ol>
</li>
<li><p>对比的例子</p>
<ol>
<li><pre><code class="language-c++">// C++ 示例（命令式风格）
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; nums = {1, 2, 3, 4};
    int sum = 0;

    for (int num : nums) {
        int squared = num * num;  // 每个数平方
        sum += squared;           // 累加到总和（修改状态）
    }

    std::cout &lt;&lt; &quot;Sum of squares: &quot; &lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1. 用 **for 循环** 逐步遍历</span><br><span class="line">   2. 用 **变量（sum, squared）存储中间状态并不断修改**</span><br><span class="line">   3. 强调 **“如何一步步做”**</span><br><span class="line"></span><br><span class="line">2. ```python</span><br><span class="line">   # Python 示例（函数式风格）</span><br><span class="line">   nums = [1, 2, 3, 4]</span><br><span class="line">   </span><br><span class="line">   # map: 每个元素平方</span><br><span class="line">   squared = map(lambda x: x ** 2, nums)</span><br><span class="line">   </span><br><span class="line">   # reduce: 求和（这里用 sum() 更简单，但为了展示函数组合，可以用 reduce）</span><br><span class="line">   from functools import reduce</span><br><span class="line">   total = reduce(lambda x, y: x + y, squared)</span><br><span class="line">   </span><br><span class="line">   print(&quot;Sum of squares:&quot;, total)</span><br></pre></td></tr></table></figure>

1. 没有显式循环，通过 **map（映射）、reduce（归约）** 等高阶函数处理数据
2. 没有中间变量被修改，强调 **数据变换的流水线**
3. 更接近 **“做什么”** 而非 **“怎么做”**
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="第五章（C7、C8）-·-封装"><a href="#第五章（C7、C8）-·-封装" class="headerlink" title="第五章（C7、C8） ·  封装"></a>第五章（C7、C8） ·  封装</h2><h3 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h3><ol>
<li>为什么要用OO（Non-OO有什么问题）<ol>
<li>非面向对象的实现方式虽然直观，但<strong>暴露了内部数据结构，缺乏封装，容易导致错误和安全问题</strong>，从而引出为什么要考虑更安全的面向对象方案。</li>
<li>面向对象可以<strong>将数据和行为封装在一起，限制对内部状态的直接访问，提高代码的安全性、可维护性和模块化程度</strong>，这是对非OO方案问题的改进。<ol>
<li>封装为类之后，可以通过访问关键字控制权限，可以通过构造函数隐藏信息等等</li>
</ol>
</li>
</ol>
</li>
<li>OO的基本概念<ol>
<li><strong>内容要点</strong>：<strong>Concepts（概念）</strong>：<ol>
<li>程序是由多个对象组成的（Program &#x3D; Object1 + Object2 + …）</li>
<li>对象包含数据与操作（Data + Operation）</li>
<li>消息传递本质是函数调用</li>
<li>类 是对象的模板或蓝图</li>
</ol>
</li>
<li><strong>Classify（分类）</strong>：<ol>
<li>面向对象（Object-Oriented）：具备封装、继承、多态等完整特性。</li>
<li>基于对象（Object-Based）：如Ada语言，有对象和封装，但<strong>没有继承等高级特性</strong>。</li>
</ol>
</li>
<li><strong>小结</strong>：这张PPT从理论层面解释了什么是OOP，它的基本构建单元是对象与类，并对OOP的不同实现层次进行了分类，帮助理解OOP的范畴与特征。</li>
</ol>
</li>
</ol>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol>
<li><p>类的声明和实现一般是分开的。声明在头文件，实现在源文件</p>
<ol>
<li><p>源文件中实现对象方法的例子</p>
<ol>
<li><pre><code class="language-c++">// SetDate 的实现：把传入的 y/m/d 分别赋值给成员变量 year/month/day
void TDate::SetDate(int y, int m, int d) {  
    year = y;
    month = m;
    day = d;
}

// IsLeapYear 的实现：判断是否为闰年的逻辑
int TDate::IsLeapYear() {  
    return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">2. 但是有一些短小的函数可以在头文件中**内联**</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      class TDate &#123;</span><br><span class="line">      public:</span><br><span class="line">          inline void SetDate(int y, int m, int d) &#123;  </span><br><span class="line">              year = y; month = m; day = d; </span><br><span class="line">          &#125;</span><br><span class="line">          int IsLeapYear() &#123;  </span><br><span class="line">              return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0); </span><br><span class="line">          &#125;</span><br><span class="line">      private:</span><br><span class="line">          int year, month, day;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>类的创建于初始化</p>
<ol>
<li><p>在栈上创建:<code>TDate g;</code>这样的写法表示 <code>g</code>是一个<strong>值类型</strong>的对象，在栈上分配内存，生命周期随作用域结束自动销毁。</p>
<ol>
<li><pre><code class="language-c++">Date g;
g.SetDate(2000, 1, 1);    // 给对象 g 设置日期为 2000-1-1
// 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在堆上创建：与值对象相对的是指针/引用等方式管理的对象（比如堆上的 `p`）。</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      TDate *p = new TDate;</span><br><span class="line">      p-&gt;SetDate(2015, 11, 17);  // 给指针 p 所指向的对象设置日期</span><br><span class="line">      // （注意：实际项目中要记得用 delete p; 释放内存，避免内存泄漏）</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251114110904959.png" alt="image-20251114110904959"></p>
<ol>
<li><code>foo.cppm</code>文件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> M;</span><br><span class="line"><span class="keyword">import</span> K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">square</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码定义了一个名为 <code>M</code>的模块，导入了模块 <code>K</code>，并导出了一个函数 <code>func</code>，该函数调用 <code>square</code>函数并返回计算结果。</p>
<ol start="2">
<li>Clang 模块相关信息<ul>
<li><strong>模块单元文件扩展名</strong>：在 Clang 中，模块单元文件使用 <code>.cppm</code>或 <code>.ixx</code>作为扩展名。</li>
<li><strong>编译后输出</strong>：<strong>可导入的 pcm（Precompiled Module）</strong>：模块经过预编译后生成的中间文件，便于后续快速导入和使用。<strong>可链接的对象文件</strong>：包含模块代码的机器码文件，可用于链接生成最终可执行文件。</li>
<li><strong>编译过程</strong>：首先使用 <code>make</code>编译模块 <code>K</code>，因为模块 <code>M</code>依赖于 <code>K</code>，所以需要先编译 <code>K</code>。接着使用 <code>make</code>编译模块 <code>M</code>，此时 <code>K</code>已经编译完成可供其导入。最后使用 <code>make</code>编译其他源文件，如 <code>bar.cpp</code>。</li>
<li>这种模块化的编程方式有助于组织和管理大型项目的代码，减少编译依赖和重复编译等问题。</li>
</ul>
</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol>
<li><p>是什么</p>
<ol>
<li>构造函数是 <strong>与类同名、无返回类型（连 <code>void</code>也没有）的特殊成员函数</strong>，用于 <strong>对象的初始化</strong>（如为成员变量赋初值、分配资源等）。它在 <strong>创建对象时自动调用</strong>，开发者无需显式调用，且 <strong>不可手动直接调用</strong>（如 <code>obj.构造函数()</code>是错误的）。</li>
</ol>
</li>
<li><p>关键特性</p>
<ol>
<li><p><strong>可重载</strong>：一个类可以定义多个构造函数（参数列表不同），根据对象创建时的实参匹配对应的构造函数（例如支持无参初始化、带参初始化等场景）。</p>
</li>
<li><p><strong>默认构造函数</strong>：若类中 <strong>未显式定义任何构造函数</strong>，编译系统会自动生成一个 <strong>无参数的默认构造函数</strong>（即 <code>类名() {}</code>）；但 <strong>一旦自定义了任意构造函数（无论是否有参数）</strong>，编译器就不再提供默认构造函数（需手动补全无参版本，否则 <code>类名 obj;</code>这种无参创建方式会报错）。</p>
</li>
<li><p><strong>访问控制</strong>：构造函数可以被定义为 <code>public</code>（默认，允许外部直接创建对象）或 <code>private</code>（限制外部直接创建，常用于 <strong>单例模式&#x2F;工厂模式</strong> 中接管对象创建逻辑，例如通过静态方法间接生成对象）。</p>
</li>
<li><p><strong>委托构造</strong>：允许一个构造函数调用同一个类中的 <strong>其他构造函数</strong>，从而 <strong>复用初始化代码</strong>，避免重复逻辑，提高代码可维护性。</p>
<ol>
<li><pre><code class="language-c++">class MyClass {
public:
    // 目标构造函数（真正的初始化逻辑）
    MyClass(int x, int y) : a(x), b(y) { /* ... */ }

    // 委托构造函数（调用目标构造函数）
    MyClass(int x) : MyClass(x, 0) {  // ✅ 委托调用
        // ⬇️ 这里可以写额外的逻辑（函数体）
        // 但是不允许再初始化成员变量了
        std::cout &lt;&lt; &quot;委托构造，x = &quot; &lt;&lt; x &lt;&lt; std::endl;
    }
    
private:
    int a;
    int b;
};
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 构造函数的调用</span><br><span class="line"></span><br><span class="line">   1. **自动调用场景**</span><br><span class="line">      1. 构造函数会在 **对象定义时自动触发**，无需手动干预。第2张图通过 `class A`的三种构造函数（无参 `A()`、带 `int`参数 `A(int i)`、带 `char*`参数 `A(char* p)`）演示了不同对象定义方式对应的构造函数调用逻辑。</span><br><span class="line"></span><br><span class="line">   2. **典型调用示例与等价写法**</span><br><span class="line">      1. `A a1 = A(1);`⇔ `A a1(1);`⇔ `A a1 = 1;`→ 均调用 带 `int`参数的构造函数 `A(int i)`（前两种是显式调用，第三种是**隐式类型转换后调用**）。</span><br><span class="line">      2. `A a2 = A();`⇔ `A a2;`→ 调用 无参构造函数 `A()`；但 **`A a2();`是错误写法**！它会被编译器解析为 ****函数声明****（声明了一个返回 `A`类型、无参数的函数 `a2`），而非对象定义。</span><br><span class="line">      3. `A a3 = A(&quot;abcd&quot;);`⇔ `A a3(&quot;abcd&quot;);`⇔ `A a3 = &quot;abcd&quot;;`→ 调用 带 `char\*`参数的构造函数 `A(char\* p)`（同样存在隐式转换逻辑）。</span><br><span class="line">   3. **数组对象的构造**：`A a[4];`→ 定义包含4个 `A`对象的数组，每个元素会自动调用 **无参构造函数 `A()`**（依次初始化 `a[0]`到 `a[3]`）。`A b[5] = &#123; A(), A(1), A(&quot;abcd&quot;), 2, &quot;xyz&quot; &#125;;`→ 初始化5个元素的数组：前3个分别显式调用 `A()`、`A(int i)`、`A(char* p)`；后2个（`2`和 `&quot;xyz&quot;`）会尝试 **隐式转换为 `A`对象**（需类中存在对应的构造函数，例如 `A(int)`或 `A(const char*)`，否则编译报错）。</span><br><span class="line"></span><br><span class="line">### 成员初始化表</span><br><span class="line"></span><br><span class="line">1. 定义</span><br><span class="line"></span><br><span class="line">   1. 成员初始化表（Member Initializer List） 是 构造函数的一部分，位于 **构造函数参数列表之后、函数体之前**，以冒号 `:`开头，后面跟着一系列 **成员变量初始化项**，各初始化项之间用逗号分隔。</span><br><span class="line"></span><br><span class="line">   2. 语法格式：</span><br><span class="line"></span><br><span class="line">      ```c++</span><br><span class="line">      类名(参数列表) : 成员1(值1), 成员2(值2), ... &#123;</span><br><span class="line">          // 构造函数函数体（可选）</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>核心作用</p>
<ol>
<li><strong>用于初始化类的数据成员</strong>（尤其是那些 <strong>不能或不应该在构造函数体内赋值</strong> 的成员）。是构造函数的补充（不是替代，但推荐优先使用）。</li>
</ol>
</li>
<li><p>执行顺序</p>
<ol>
<li><strong>先于构造函数体执行</strong>（即成员初始化发生在进入构造函数 <code>{ ... }</code>之前）。</li>
<li><strong>按类中数据成员的声明顺序初始化</strong>（<strong>不是按初始化表中的书写顺序！</strong>）。</li>
</ol>
</li>
<li><p>为什么能“减轻 Compiler 负担”？</p>
<ul>
<li>如果没有成员初始化表，某些成员（如 <code>const</code>成员、引用成员、没有默认构造函数的类对象成员）必须依赖构造函数体内的赋值语句，但这类成员 <strong>无法被赋值（只能初始化）</strong>，编译器会报错。</li>
<li>使用成员初始化表 可以 <strong>直接初始化这些成员，避免额外的默认构造 + 赋值操作</strong>，从而 提高效率并减少编译器的隐式处理负担。</li>
</ul>
</li>
<li><p>典型使用场景</p>
<ol>
<li><p>推荐在构造函数中尽量使用成员初始化表取代赋值动作</p>
</li>
<li><p><strong>必须使用成员初始化表的场景</strong></p>
<ol>
<li><strong>初始化 <code>const</code>成员</strong></li>
</ol>
<ul>
<li><p><code>const</code>成员变量 <strong>必须在声明时或构造函数初始化列表中初始化</strong>，<strong>不能在构造函数体内赋值</strong>（因为 <code>const</code>变量一旦初始化后就不能再修改）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">y</span>(<span class="number">1</span>) &#123;&#125;  <span class="comment">// ✅ 正确：必须在初始化列表中初始化</span></span><br><span class="line">    <span class="comment">// A() &#123; y = 1; &#125;  // ❌ 错误：不能在构造函数体内赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p><strong>初始化引用成员</strong></p>
<ul>
<li><p>引用成员 <strong>必须在定义时绑定到一个对象</strong>，因此 <strong>只能在初始化列表中初始化</strong>，<strong>不能后期赋值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span>&amp; z;  <span class="comment">// 引用成员</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>&amp; ref) : <span class="built_in">z</span>(ref), <span class="built_in">x</span>(<span class="number">0</span>) &#123;&#125;  <span class="comment">// ✅ 正确：引用必须在初始化列表中绑定</span></span><br><span class="line">    <span class="comment">// A(int&amp; ref) &#123; z = ref; &#125;  // ❌ 错误：引用不能在构造函数体内赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化没有默认构造函数的对象成员</strong></p>
<ul>
<li><p>如果类中包含 <strong>其他类的对象成员</strong>，且该对象 <strong>没有默认构造函数</strong>，则必须通过成员初始化表 <strong>显式调用其有参构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x) &#123;&#125;  <span class="comment">// 没有默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;  <span class="comment">// B 没有默认构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">b</span>(<span class="number">10</span>) &#123;&#125;  <span class="comment">// ✅ 必须通过初始化列表调用 B(int)</span></span><br><span class="line">    <span class="comment">// A() &#123; b = B(10); &#125;  // ❌ 错误：先默认构造 B（不存在），再赋值（不允许）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol>
<li>基本定义<ol>
<li><strong>语法格式</strong>：<code>~类名()</code>（例如 <code>~A()</code>、<code>~String()</code>）。</li>
<li><strong>作用</strong>：在 <strong>对象生命周期结束时（消亡时）自动调用</strong>，主要用于 <strong>释放对象持有的非内存资源</strong>（因为内存资源即栈上资源是会自动回收的），如动态分配的内存、文件句柄、网络连接等。</li>
<li><strong>调用时机</strong>：当对象离开其作用域（如局部对象在函数结束时）、被 <code>delete</code>删除（动态对象）、或程序终止时，系统 <strong>自动调用析构函数</strong>。</li>
<li>默认是 <code>public</code>（允许对象正常销毁）可显式定义为 <code>private</code></li>
</ol>
</li>
<li>访问控制与特殊用法<ol>
<li><strong>访问权限灵活性</strong><ul>
<li><strong>默认 <code>public</code></strong>：允许对象正常销毁（如局部对象作用域结束、<code>delete</code>动态对象）。</li>
<li><strong>可定义为 <code>private</code></strong>：<ul>
<li><strong>用途</strong>：禁止外部直接调用 <code>delete</code>或对象离开作用域时自动销毁（例如实现单例模式、对象池等）。</li>
<li><strong>示例</strong>：若析构函数为 <code>private</code>，则必须通过类内部的特定方法（如 <code>destroy()</code>）手动控制销毁逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong>强制自主控制对象存储分配</strong><ul>
<li>通过将析构函数设为 <code>private</code>并提供自定义销毁方法（如 <code>destroy()</code>），可以实现强制自主控制对象的存储分配与释放（避免依赖自动析构）。</li>
</ul>
</li>
</ol>
</li>
<li>使用场景<ol>
<li>析构函数默认是空实现</li>
<li>如果在类中有动态分配的内存、文件句柄、网络连接等非内存资源，就必须手动写析构函数。</li>
</ol>
</li>
</ol>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ol>
<li><p>是什么</p>
<ol>
<li>拷贝构造函数（Copy Constructor） 是一种 特殊的构造函数，用于 <strong>用一个已存在的同类对象来初始化一个新对象</strong>。</li>
<li><strong>语法形式</strong>：<code>A(const A&amp; a)</code>（参数是对同类对象的 <strong>常量引用</strong>）。</li>
</ol>
</li>
<li><p>核心特点</p>
<ol>
<li><strong>自动调用</strong>：在特定场景下（如<strong>对象初始化、函数传参、返回对象</strong>等），编译器会自动调用拷贝构造函数。</li>
<li>与普通构造函数区分：普通构造函数用于创建新对象，而拷贝构造函数用于 <strong>基于已有对象创建新对象</strong>。</li>
</ol>
</li>
<li><p><strong>典型调用场景</strong>（拷贝构造函数在以下情况会被 <strong>自动调用</strong>）</p>
<ul>
<li><strong>对象初始化时用另一个对象赋值</strong>：<code>A a; A b = a;</code></li>
<li><strong>函数传参时传递对象（按值传递）</strong>：<code>f(A a)</code>，调用时传入对象会触发拷贝构造。</li>
<li><strong>函数返回对象（按值返回）</strong>：<code>A f() { A a; return a; }</code>，返回时会调用拷贝构造（可能被编译器优化）。</li>
</ul>
</li>
<li><p>定义拷贝构造</p>
<ol>
<li><p><strong>默认拷贝构造函数</strong></p>
<ul>
<li><strong>如果类未显式定义拷贝构造函数，编译器会自动生成一个默认拷贝构造函数</strong>。</li>
<li>默认行为：逐个成员初始化（member-wise initialization）<ul>
<li>对于 基本类型（如 <code>int</code>、<code>float</code>）：直接复制值。</li>
<li>对于 对象成员：递归调用其自身的拷贝构造函数（即深层次地依次初始化每个成员对象）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>何时需要自定义拷贝构造函数？</strong></p>
<ol>
<li><p>当类中包含指针成员并管理动态内存时，默认拷贝构造函数会导致**“浅拷贝”**问题，进而可能引发 <strong>悬挂指针、双重释放等严重错误</strong>。</p>
</li>
<li><p>浅拷贝问题示例：默认拷贝构造函数只会 <strong>简单复制指针的值（地址）</strong>，而 <strong>不会复制指针指向的实际内存内容</strong>。导致多个对象共享同一块动态内存，当其中一个对象析构并释放内存后，其他对象的指针会变成 <strong>“悬挂指针”（指向已释放的内存）</strong>，后续访问会导致程序崩溃。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251114163104987.png" alt="image-20251114163104987"></p>
</li>
<li><p><strong>解决方案：深拷贝</strong></p>
<ol>
<li><p>自定义拷贝构造函数，为指针成员分配新的内存，并复制原对象指针指向的内容，从而实现 <strong>深拷贝（deep copy）</strong>。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">string</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;  <span class="comment">// 动态分配的字符指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数（深拷贝实现）</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="type">const</span> string&amp; s) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s.p) + <span class="number">1</span>];  <span class="comment">// 为新对象分配新内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p, s.p);  <span class="comment">// 复制原字符串内容到新内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>效果</strong>：<code>string s2 = s1;</code>时，<code>s2</code>的指针 <code>p</code>会指向 <strong>新分配的内存</strong>，并复制 <code>s1</code>的字符串内容，<strong>避免与 <code>s1</code>共享内存</strong>，从而防止悬挂指针问题。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>自定义拷贝构造函数的风险</p>
<ol>
<li><strong>默认拷贝构造函数</strong>会自动调用成员对象的<strong>拷贝构造函数</strong>，这是正确的。</li>
<li><strong>自定义拷贝构造函数</strong>，如果没有主动调用成员对象的拷贝构造函数，可能会触发成员对象的<strong>默认构造函数</strong>，导致没能复制成员对象。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ol>
<li><p><strong>左值（LValue）</strong></p>
<ol>
<li><p><strong>定义</strong>：具有程序运行时可访问的<strong>存储地址的值</strong>，通常是变量或具有名称的对象。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变量 <code>a</code></strong> → 有名字、有内存地址 → 是 <strong>左值（Lvalue）</strong></li>
<li><strong>表达式 <code>1 + 2</code></strong> → 临时计算结果，没有名字、没有固定存储位置 → 是 <strong>右值（Rvalue）</strong></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>右值</strong></p>
<ol>
<li><p><strong>定义</strong>：通常是临时值、字面量、表达式结果或临时对象，<strong>没有持久的内存地址</strong>，一般不能被取地址，也不能出现在赋值语句左边。</p>
<ol>
<li><strong>示例（第1张图右下角）：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="built_in">A</span>();  <span class="comment">// A() 是一个临时对象（构造出的匿名对象）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>A()</code></strong> → 是一个临时构造出来的对象，没有变量名，无法直接访问 → 是 <strong>右值（Rvalue）</strong>，图中已用箭头标出。</li>
</ul>
</li>
<li><p><strong>核心特点：只能绑定到右值！</strong> ，为移动语义（Move Semantics）和完美转发奠定基础。</p>
</li>
<li><p>使用示例</p>
<ol>
<li><p><strong>右值引用（A&amp;&amp;）绑定到右值（重点！）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &amp;&amp;aa = getA();  // ✅ 合法：A&amp;&amp; 是右值引用，getA() 返回临时对象（右值）</span><br><span class="line">aa.setVal(2);     // ✅ 可以通过右值引用修改该临时对象（前提是该对象非 const）</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>主要用途（为什么要用右值引用）</p>
<ol>
<li><p>实现 <strong>移动语义（Move Semantics）</strong>，通过移动构造函数&#x2F;移动赋值运算符，<strong>“窃取”临时对象的资源，避免深拷贝</strong>，极大提升程序运行效率。</p>
<ol>
<li><pre><code class="language-c++">class Buffer {
...
    // 移动构造函数（使用右值引用 T&amp;&amp;）
    Buffer(Buffer&amp;&amp; other) noexcept {
        data = other.data;  // 直接“窃取”资源
        size = other.size;
        other.data = nullptr;  // 避免原对象析构时 delete data
        other.size = 0;
        std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;
    }
...
};

Buffer createBuffer() {
    Buffer temp(&quot;Hello from temp!&quot;);
    return temp;  // 返回临时对象（右值），可触发移动构造
}

int main() {
    Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. </span><br><span class="line"></span><br><span class="line">2. 支持 **std::move**，将左值显式转化为右值，主动触发移动而非拷贝。</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      int main() &#123;</span><br><span class="line">          BigData a(1000);         // 普通构造</span><br><span class="line">          BigData b(std::move(a)); // 显式转为右值，触发移动构造！</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>是 <strong>完美转发（Perfect Forwarding）</strong> 的基础，用于高效传递参数（尤其在模板和标准库中）。</p>
<ol>
<li><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;utility&gt;

// 目标函数
void process(int&amp; x) { std::cout &lt;&lt; &quot;处理左值: &quot; &lt;&lt; x &lt;&lt; std::endl; }
void process(int&amp;&amp; x) { std::cout &lt;&lt; &quot;处理右值: &quot; &lt;&lt; x &lt;&lt; std::endl; }

// 模板转发函数
template&lt;typename T&gt;
void forwarder(T&amp;&amp; arg) {
    process(std::forward&lt;T&gt;(arg));  // 完美转发：保持左值/右值性质
}

int main() {
    int x = 42;
    forwarder(x);            // 传左值 -&gt; 调用 process(int&amp;)
    forwarder(123);          // 传右值 -&gt; 调用 process(int&amp;&amp;)
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      4. 优化标准库容器（如 `std::vector`、`std::string`）在插入、扩容、返回值等场景下的性能表现。</span><br><span class="line"></span><br><span class="line">### 三种引用类型对比</span><br><span class="line"></span><br><span class="line">| 类型       | 绑定对象   | 是否可修改被引用对象 | 示例 / 说明           | 典型用途                                    |</span><br><span class="line">| :--------- | :--------- | :------------------- | --------------------- | :------------------------------------------ |</span><br><span class="line">| 非常量引用 | 左值       | ✅ 能                 | int &amp;ra = a;          | 函数内要修改传入的对象                      |</span><br><span class="line">| 常量引用   | 左值、右值 | ❌ 不能               | const A &amp;ca = getA(); | 只读访问，避免拷贝（如传参时）              |</span><br><span class="line">| 右值引用   | 右值       | ✅ 能（通常自己管理） | A &amp;&amp;aa = getA();      | 移动语义、高效资源管理、完美转发（C++11起） |</span><br><span class="line"></span><br><span class="line">### 移动构造函数</span><br><span class="line"></span><br><span class="line">| 特性           | 拷贝构造函数（Copy Constructor）           | 移动构造函数（Move Constructor）                     |</span><br><span class="line">| :------------- | :----------------------------------------- | :--------------------------------------------------- |</span><br><span class="line">| **语法**       | `A(const A&amp; a)`（常量左值引用）            | `B(B&amp;&amp; b)`（右值引用）                               |</span><br><span class="line">| **资源操作**   | **复制资源**（如深拷贝动态内存、复制内容） | **转移资源所有权**（如指针指向的资源直接“接管”）     |</span><br><span class="line">| **适用场景**   | 一般对象初始化、需要独立副本时             | **临时对象、大资源管理（避免深拷贝开销）**           |</span><br><span class="line">| **性能影响**   | 可能较慢（如深拷贝大内存）                 | **更快（仅转移指针等轻量操作）**                     |</span><br><span class="line">| **原对象状态** | 原对象保持有效，资源独立                   | **原对象资源被“掏空”（如指针置空），不再管理原资源** |</span><br><span class="line"></span><br><span class="line">1. 移动构造函数的实现</span><br><span class="line"></span><br><span class="line">   1. **接收一个右值引用参数（`T&amp;&amp;`）**，表示它只能绑定到临时对象（右值）。</span><br><span class="line">   2. **“窃取”源对象（右值）内部的资源（如动态内存指针、文件句柄等）**，而不是重新分配和深拷贝。</span><br><span class="line">   3. **将源对象的资源指针“置空”或置为有效但无害的状态**，防止原对象析构时误释放已转移的资源，或产生双重释放。</span><br><span class="line"></span><br><span class="line">2. 示例</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      class Buffer &#123;</span><br><span class="line">      ...</span><br><span class="line">          // 移动构造函数（使用右值引用 T&amp;&amp;）</span><br><span class="line">          Buffer(Buffer&amp;&amp; other) noexcept &#123;</span><br><span class="line">              data = other.data;  // 直接“窃取”资源</span><br><span class="line">              size = other.size;</span><br><span class="line">              other.data = nullptr;  // 避免原对象析构时 delete data</span><br><span class="line">              other.size = 0;</span><br><span class="line">              std::cout &lt;&lt; &quot;调用移动构造函数，窃取资源&quot; &lt;&lt; std::endl;</span><br><span class="line">          &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      Buffer createBuffer() &#123;</span><br><span class="line">          Buffer temp(&quot;Hello from temp!&quot;);</span><br><span class="line">          return temp;  // 返回临时对象（右值），可触发移动构造</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      int main() &#123;</span><br><span class="line">          Buffer b = createBuffer();  // 构造函数的隐式写法。createBuffer()返回值是一个右值，所以触发移动构造，而非深拷贝！</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><ol>
<li><p>操作系统内的内存管理</p>
<ol>
<li><p>两种类型：栈和堆</p>
</li>
<li><p>C &#x2F; C++对比</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">C (<code>malloc/free</code>)</th>
<th align="left">C++ (<code>new/delete</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>分配内存</strong></td>
<td align="left"><code>malloc(sizeof(T))</code></td>
<td align="left"><code>new T</code></td>
</tr>
<tr>
<td align="left"><strong>释放内存</strong></td>
<td align="left"><code>free(ptr)</code></td>
<td align="left"><code>delete ptr</code></td>
</tr>
<tr>
<td align="left"><strong>调用构造函数&#x2F;析构函数？</strong></td>
<td align="left">❌ 不调用</td>
<td align="left">✅ 调用</td>
</tr>
<tr>
<td align="left"><strong>是否类型安全？</strong></td>
<td align="left">❌ 不安全（返回 <code>void*</code>）</td>
<td align="left">✅ 类型安全操作</td>
</tr>
</tbody></table>
</li>
<li><p>C 语言：</p>
<ol>
<li><code>malloc()</code>：分配内存</li>
<li><code>free()</code>：释放内存</li>
<li>⚠️ 不会调用构造函数和析构函数</li>
</ol>
</li>
<li><p>C++ 语言：</p>
<ol>
<li><code>new</code>：分配内存 <strong>并调用构造函数</strong></li>
<li><code>delete</code>：释放内存 <strong>并调用析构函数</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>C++ 动态对象（<code>new</code>&#x2F; <code>delete</code>）</p>
<ol>
<li><p>动态对象：在 <strong>堆（Heap）</strong> 上创建的对象，生命周期由程序员控制。</p>
<ol>
<li><p><code>new</code>的作用：</p>
<ol>
<li>分配内存 <strong>并调用构造函数</strong>（比 <code>malloc</code>更安全）。</li>
<li>语法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* ptr = <span class="keyword">new</span> T;          <span class="comment">// 无参构造</span></span><br><span class="line">T* ptr = <span class="keyword">new</span> <span class="built_in">T</span>(args...); <span class="comment">// 带参构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>delete</code>的作用：</p>
<ol>
<li>释放内存 <strong>并调用析构函数</strong>（比 <code>free</code>更安全）。</li>
<li>语法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;       <span class="comment">// 单个对象</span></span><br><span class="line"><span class="keyword">delete</span>[] ptrArr;  <span class="comment">// 对象数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
</li>
<li><p><strong><code>new</code>和 <code>delete</code>必须配对</strong>（<code>new[]</code>必须对应 <code>delete[]</code>）。</p>
</li>
<li><p><strong>释放后置空指针</strong>（<code>ptr = nullptr</code>），避免 <strong>悬空指针（Dangling Pointer）</strong>。</p>
</li>
<li><p><strong>不要混用 <code>malloc/free</code>和 <code>new/delete</code></strong>（可能导致未定义行为）。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>动态数组</p>
<ol>
<li><p>一维动态数组创建与释放</p>
<ol>
<li><p><strong>创建动态数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* arr = new T[100];  // 100 个 T 对象（调用默认构造函数）</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放动态数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete[] arr;  // 必须用 delete[]，否则行为未定义！</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点：</p>
<ol>
<li>类必须提供<strong>默认构造函数</strong>（否则 <code>new T[100]</code>编译失败）。</li>
<li><strong><code>delete[]</code>不能漏掉 <code>[]</code></strong>，否则可能只释放第一个对象，导致内存泄漏。</li>
</ol>
</li>
</ol>
</li>
<li><p>二维动态数组创建与释放</p>
<ol>
<li><p>分配方式（分两步）：</p>
<ol>
<li><strong>分配行指针数组</strong>（<code>char**</code>）</li>
<li><strong>为每一行分配列数组</strong>（<code>char*</code>）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int ROWS = 3, COLS = 4;</span><br><span class="line">char** arr2D = new char*[ROWS];  // 分配行指针</span><br><span class="line">for (int i = 0; i &lt; ROWS; i++) &#123;</span><br><span class="line">    arr2D[i] = new char[COLS];   // 每行分配列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放方式</strong>（逆向释放）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; ROWS; i++) &#123;</span><br><span class="line">    delete[] arr2D[i];  // 先释放每一行的列</span><br><span class="line">&#125;</span><br><span class="line">delete[] arr2D;  // 再释放行指针数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点：必须按分配顺序逆向释放（先释放“子数组”）。<code>new[]</code>和 <code>delete[]</code>必须配对，否则内存泄漏。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h3><ol>
<li><p>const成员变量</p>
<ol>
<li><strong><code>const</code>成员变量</strong> 是类的成员变量，一旦初始化后 <strong>不能被修改</strong>。</li>
<li><strong>必须通过构造函数的成员初始化列表（Member Initializer List）进行初始化</strong>，不能在构造函数体内直接赋值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x;  <span class="comment">// const 成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 必须通过成员初始化列表初始化 const 成员变量</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;  <span class="comment">// ✅ 正确</span></span><br><span class="line">    <span class="comment">// A(int val) &#123; x = val; &#125;  // ❌ 错误！不能在构造函数体内赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>const</code>成员函数（常量成员函数）</strong></p>
<ol>
<li><p>定义</p>
<ol>
<li><code>const</code>成员函数 是 <strong>不会修改对象状态</strong> 的成员函数，用 <code>const</code>修饰。</li>
<li><strong>承诺不会修改类的任何非 <code>mutable</code>成员变量。</strong></li>
<li><strong>可以访问 <code>const</code>和非 <code>const</code>对象，但非 <code>const</code>成员函数只能访问非 <code>const</code>对象。</strong></li>
</ol>
</li>
<li><p>示例</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TDate</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetYear</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> year;       <span class="comment">// 只能读取，不能修改 year</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetYear</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;  <span class="comment">// 非 const 成员函数</span></span><br><span class="line">        year = y;          <span class="comment">// 可以修改 year</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关键点<ol>
<li><p><strong><code>const</code>成员函数不能修改成员变量</strong>（除非变量是 <code>mutable</code>）。</p>
</li>
<li><p><strong><code>const</code>对象只能调用 <code>const</code>成员函数</strong>，非 <code>const</code>对象可以调用所有成员函数。</p>
<blockquote>
<p>很好理解，如果const对象可以调用非const函数，就可能间接修改了对象状态。</p>
</blockquote>
</li>
<li><p><strong><code>const</code>成员函数可以重载</strong>（例如，<code>GetYear()</code>和 <code>GetYear() const</code>可以同时存在）。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong><code>mutable</code>（可变成员变量）</strong></p>
<ol>
<li><p>定义</p>
<ol>
<li><strong><code>mutable</code></strong> 用于修饰 <strong>即使在 <code>const</code>成员函数中也可以被修改的成员变量</strong>。</li>
<li>通常用于 缓存、日志、调试计数等不影响对象逻辑状态的变量。</li>
</ol>
</li>
<li><p>示例</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheExample</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> cacheHits;  <span class="comment">// 即使在 const 函数中也可以修改</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cacheHits++;  <span class="comment">// ✅ 允许，因为 cacheHits 是 mutable</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>关键点</li>
</ol>
<ul>
<li><strong><code>mutable</code>变量可以绕过 <code>const</code>限制</strong>，但应谨慎使用（通常用于内部优化）。</li>
</ul>
</li>
<li><p><strong><code>const</code>参数（函数参数）</strong></p>
<ol>
<li>定义<ol>
<li><strong><code>const</code>参数</strong> 表示 <strong>函数内部不会修改该参数</strong>。</li>
<li>可以用于 <strong>指针、引用</strong>，防止意外修改传入的数据。</li>
</ol>
</li>
<li>示例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;  <span class="comment">// str 不会被修改</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Modify</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> p)</span> </span>&#123;  <span class="comment">// p 本身不能改（指针不能指向别的地址），但 *p 可以改</span></span><br><span class="line">    <span class="comment">// p = nullptr;  // ❌ 错误！p 是 const 的</span></span><br><span class="line">    *p = <span class="number">100</span>;  <span class="comment">// ✅ 可以修改 *p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>关键点</p>
<ul>
<li><p><strong><code>const T&amp;</code>（常量引用）</strong>：避免拷贝，同时防止修改。</p>
</li>
<li><p><strong><code>const T*</code>（指向常量的指针）</strong>：<strong>指针可以改，但指向的数据不能改。</strong></p>
</li>
<li><p><strong><code>T* const</code>（常量指针）</strong>：<strong>指针不能改，但指向的数据可以改。</strong></p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><ol>
<li><p>是什么</p>
<ol>
<li><strong>常量表达式</strong> 是指 <strong>在编译期就能计算出结果的表达式</strong>（即不需要等到运行时才计算）。</li>
</ol>
</li>
<li><p><strong>核心优势</strong>：<strong>更快</strong>：因为计算在编译期完成，运行时无需额外开销。<strong>更安全</strong>：错误（如非法计算、类型不匹配）能在编译期提前暴露，而不是等到运行时崩溃。</p>
</li>
<li><p>两个关键字</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
<th align="left">适用场景</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>constexpr</code></strong></td>
<td align="left">可编译期或运行期求值</td>
<td align="left">数组大小、模板参数、查表、位运算</td>
<td align="left"><code>constexpr int sqr(int x) { return x * x; }</code></td>
</tr>
<tr>
<td align="left"><strong><code>consteval</code>(C++20)</strong></td>
<td align="left">必须编译期求值，调用点必须为常量</td>
<td align="left">强制编译期计算</td>
<td align="left"><code>consteval int pow2(int n) { return 1 &lt;&lt; n; }</code></td>
</tr>
</tbody></table>
</li>
<li><p><strong><code>constexpr</code>（C++11 起）</strong></p>
<ol>
<li><p>定义</p>
<ol>
<li><code>constexpr</code> 表示 该函数或变量可以在编译期求值，但也允许在运行期使用（灵活性更高）。</li>
<li>适用对象：变量：<code>constexpr int x = 10;</code>（编译期常量）函数：<code>constexpr int sqr(int x) { return x * x; }</code>（若参数是编译期常量，则结果也是编译期常量）</li>
</ol>
</li>
<li><p>特点</p>
<ol>
<li><strong>可以在编译期或运行期求值（取决于调用时的参数是否为编译期常量）。</strong></li>
<li><strong>适用于数组大小、模板参数、<code>switch-case</code>标签等需要编译期确定值的场景。</strong></li>
<li><strong>提升运行时效率（因为很多计算提前到编译期完成）。</strong></li>
</ol>
</li>
<li><p>示例</p>
<ol>
<li><pre><code class="language-c++">struct Point {
    int x, y;
    constexpr Point(int xx, int yy) : x(xx), y(yy) { }  // constexpr 构造函数
};

int main() {
    constexpr Point origo(0, 0);  // 编译期对象
    constexpr int z = origo.x;    // 编译期访问成员
    constexpr Point a[] = {       // 编译期数组
        Point(0, 0), Point(1, 1), Point(2, 2)
    };
    constexpr int x = a[1].x;     // 编译期计算，x = 1
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. </span><br><span class="line"></span><br><span class="line">3. **`consteval`（C++20 新增）**</span><br><span class="line"></span><br><span class="line">   1. 定义</span><br><span class="line"></span><br><span class="line">      - `consteval` 是 C++20 引入的关键字，比 `constexpr`更严格。</span><br><span class="line"></span><br><span class="line">      - 要求函数必须在编译期执行，并且 调用点必须传入编译期常量，否则 编译报错。</span><br><span class="line"></span><br><span class="line">      - 适用场景：当你 强制要求某个函数只能在编译期运行（不允许运行期调用）。</span><br><span class="line"></span><br><span class="line">   2. 特点</span><br><span class="line"></span><br><span class="line">      1. **只能在函数声明上使用。**</span><br><span class="line">      2. **函数调用必须在编译期完成（参数必须是编译期常量）。**</span><br><span class="line">      3. **如果调用时传入运行期变量（非编译期常量），则编译报错。**</span><br><span class="line"></span><br><span class="line">   3. 示例</span><br><span class="line"></span><br><span class="line">      1. ```c++</span><br><span class="line">         constexpr int sqr(int x) &#123; return x * x; &#125;  // 可编译期/运行期求值</span><br><span class="line">         constexpr int A = sqr(10);  // ✅ 编译期计算</span><br><span class="line">         int y = 3;</span><br><span class="line">         int B = sqr(y);  // ✅ 允许（运行期计算）</span><br><span class="line">         </span><br><span class="line">         consteval int pow2(int n) &#123; return 1 &lt;&lt; n; &#125;  // 必须编译期求值</span><br><span class="line">         constexpr int M = pow2(8);  // ✅ 编译期计算（合法）</span><br><span class="line">         // int r = pow2(y);  // ❌ 编译报错！y 不是编译期常量</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><ol>
<li><p>是什么</p>
<ol>
<li><strong>静态成员属于类本身，而不是某个对象</strong>，是 <strong>类的所有对象共享的</strong>。</li>
</ol>
</li>
<li><p><strong>静态成员变量（Static Member Variables）</strong></p>
<ol>
<li>定义<ol>
<li>静态成员变量 是类的所有对象 共享的变量，只有一份拷贝，无论创建多少个对象。</li>
<li><strong>必须要在类外单独定义和初始化</strong>（C++17 前），C++17 开始可以用 <code>inline</code>在类内直接初始化。</li>
</ol>
</li>
<li><strong>语法</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;                    <span class="comment">// 普通成员变量（每个对象独立一份）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> shared;           <span class="comment">// 静态成员变量声明（类内声明）</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// C++17 支持：</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> shared = <span class="number">0</span>; （类内直接初始化）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义并初始化（C++17 前必须这样做）</span></span><br><span class="line"><span class="type">int</span> A::shared = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a, b;  <span class="comment">// a 和 b 共享同一个 shared 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数</p>
<ol>
<li><p>同Java静态函数</p>
</li>
<li><p>特性</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>只能访问静态成员</strong></td>
<td align="left">不能直接访问 <strong>非静态成员变量&#x2F;函数</strong></td>
</tr>
<tr>
<td align="left"><strong>没有 <code>this</code>指针</strong></td>
<td align="left">因为它不依赖于某个具体对象</td>
</tr>
<tr>
<td align="left"><strong>可通过类名直接调用</strong></td>
<td align="left">如 <code>A::f()</code>，无需创建对象</td>
</tr>
<tr>
<td align="left"><strong>遵循类访问控制</strong></td>
<td align="left">可声明为 <code>public</code>&#x2F; <code>private</code>&#x2F; <code>protected</code></td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
<li><p>静态成员的应用</p>
<pre><code>1. **单例模式**

1. 利用 **静态成员变量（保存唯一实例）** 和 **静态成员函数（获取实例）** 实现。

2. ```c++
   class Singleton {
   protected:
       Singleton() {}  // 构造函数保护，防止外部创建对象
       Singleton(const Singleton&amp;) = delete;  // 禁止拷贝
   
   public:
       // 获取唯一实例（静态函数）
       static Singleton* instance() {
           if (m_instance == nullptr)
               m_instance = new Singleton();
           return m_instance;
       }
   
       // 销毁实例（静态函数）
       static void destroy() {
           delete m_instance;
           m_instance = nullptr;
       }
   
   private:
       static Singleton* m_instance;  // 唯一实例指针
   };
   
   // 类外初始化静态成员
   Singleton* Singleton::m_instance = nullptr;
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 对象计数</span><br><span class="line"></span><br><span class="line">1. ```c++</span><br><span class="line">        </span><br><span class="line">   class A &#123;</span><br><span class="line">       static int obj_count;  // 静态成员变量，记录对象个数</span><br><span class="line">  </span><br><span class="line">   public:</span><br><span class="line">       A() &#123; obj_count++; &#125;          // 构造时 +1</span><br><span class="line">       ~A() &#123; obj_count--; &#125;         // 析构时 -1</span><br><span class="line">  </span><br><span class="line">       // 静态函数，返回当前对象数</span><br><span class="line">       static int get_num_of_obj() &#123;</span><br><span class="line">           return obj_count;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">  </span><br><span class="line">   // 类外定义静态成员变量</span><br><span class="line">   int A::obj_count = 0;</span><br><span class="line">  </span><br><span class="line">   int main() &#123;</span><br><span class="line">       A a1, a2;</span><br><span class="line">       std::cout &lt;&lt; A::get_num_of_obj();  // 输出 2</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
    
    2.
</code></pre>
</li>
</ol>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ol>
<li><p>是什么</p>
<ol>
<li>C++ 的封装性 要求类的 私有（private）和保护（protected）成员只能被本类的成员函数访问。</li>
<li>但有时，某些外部函数或类也需要访问这些私有成员（比如运算符重载、矩阵运算、工具函数等）。</li>
<li>友元机制 提供了一种 “特殊权限”，允许 指定的外部函数或类访问当前类的私有成员，突破封装限制，但仅限于被声明为友元的部分。</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
<th align="left">示例（代码片段）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>友元函数（Friend Function）</strong></td>
<td align="left">一个 <strong>普通函数（非成员函数）</strong>，被声明为某个类的友元后，可以访问该类的 <strong>私有（private）和保护（protected）成员</strong></td>
<td align="left"><code>friend void func();</code>（在类内声明）</td>
</tr>
<tr>
<td align="left"><strong>友元类（Friend Class）</strong></td>
<td align="left">一个 <strong>类（Class B）</strong> 被声明为另一个类（Class A）的友元后，<strong>该类的所有成员函数</strong> 都可以访问 Class A 的 <strong>私有成员</strong></td>
<td align="left"><code>friend class B;</code></td>
</tr>
<tr>
<td align="left"><strong>友元类成员函数（Friend Class Member Function）</strong></td>
<td align="left"><strong>某个特定类（如 Class C）的某个成员函数（如 <code>void f()</code>）</strong> 被声明为友元，<strong>只有这个函数</strong> 可以访问当前类的私有成员</td>
<td align="left"><code>friend void C::f();</code></td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>使用方法</p>
<ol>
<li><pre><code class="language-c++">class A {
private:
    int secret;
public:
    friend void func();             // 友元函数
    friend class B;                 // 友元类
    friend void C::f();             // 友元类成员函数（需提前声明 C 和 f）
};
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 重要特性</span><br><span class="line"></span><br><span class="line">   1. | 特性                 | 说明                                                         |</span><br><span class="line">      | :------------------- | :----------------------------------------------------------- |</span><br><span class="line">      | **友元不具有传递性** | 如果 A 是 B 的友元，B 是 C 的友元，**不代表 A 是 C 的友元**  |</span><br><span class="line">      | **友元不具有继承性** | 如果 B 是 A 的友元，B 的子类 **不自动成为 A 的友元**         |</span><br><span class="line">      | **友元关系是单向的** | 如果 A 声明 B 是友元，**不代表 B 也自动声明 A 是友元**       |</span><br><span class="line">      | **编译检查**         | 友元函数/类必须在类 **外部定义**，但必须在类 **内部声明为 friend** |</span><br><span class="line"></span><br><span class="line">## 第六章（C9） · 继承</span><br><span class="line"></span><br><span class="line">### 继承</span><br><span class="line"></span><br><span class="line">1. 概述</span><br><span class="line"></span><br><span class="line">   1. 定义：继承是面向对象程序设计中的核心机制，它允许新的类（派生类）基于已有的类（基类）来构建，从而实现**代码复用**和**层次化分类**。</span><br><span class="line">   2. 主要作用</span><br><span class="line">      1. **基于目标代码的复用**：避免重复编写相同功能的代码</span><br><span class="line">      2. **对事物进行分类**：通过层次结构清晰地描述现实世界的关系</span><br><span class="line">      3. **增量开发**：在现有类的基础上扩展新功能，实现渐进式开发</span><br><span class="line"></span><br><span class="line">2. 语法：</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      // 以单继承为例</span><br><span class="line">      class 基类 &#123;</span><br><span class="line">          // 基类的成员（数据成员和成员函数）</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      class 派生类 : 访问控制 基类 &#123;</span><br><span class="line">          // 派生类的成员</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>三种继承类别</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">访问级别（基类的访问控制）</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">成员可以被任何代码访问，包括类的使用者、派生类等</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">成员只能被该类自身及其派生类访问，外部代码不能直接访问</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">成员只能被该类自身访问，派生类和外部代码均<strong>不能直接访问</strong></td>
</tr>
</tbody></table>
</li>
<li><table>
<thead>
<tr>
<th align="left">继承方式（继承时指出）</th>
<th align="left">说明</th>
<th align="left">基类成员访问权限变化</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">公有继承</td>
<td align="left">保持原有访问权限</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">保护继承</td>
<td align="left">public→protected</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">私有继承</td>
<td align="left">所有成员→private</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>常见问题：</p>
<ol>
<li><p>名覆盖：</p>
<ol>
<li><p>在派生类中定义了和基类中同名的函数或类，会导致基类中的对象不可见（被隐藏、被覆盖），调用时可能找不到而报错。如果要调用需要显示指明命名空间。</p>
</li>
<li><pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class Base {
public:
    void show() {
        cout &lt;&lt; &quot;Base::show()&quot; &lt;&lt; endl;
    }

    void show(int x) {
        cout &lt;&lt; &quot;Base::show(int): &quot; &lt;&lt; x &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    void show() {  // 派生类定义了一个同名的 show() 函数
        cout &lt;&lt; &quot;Derived::show()&quot; &lt;&lt; endl;
    }
};

int main() {
    Derived d;
    d.show();        // OK，调用 Derived::show()
    // d.show(10);   // 错误！Base::show(int) 被隐藏了，找不到这个函数
    d.Base::show(10); // 正确：通过 Base:: 明确调用基类的版本
    return 0;
}
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 对象切片</span><br><span class="line"></span><br><span class="line">      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。</span><br><span class="line">      2. 对象身份变化分析</span><br><span class="line">         - 派生类特有的成员被&quot;切掉&quot;</span><br><span class="line">         - 只保留基类部分的成员</span><br><span class="line">         - 对象身份从派生类变为基类类型</span><br><span class="line"></span><br><span class="line">   3. 私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数</span><br><span class="line"></span><br><span class="line">5. 构造与析构</span><br><span class="line"></span><br><span class="line">   1. 构造顺序</span><br><span class="line"></span><br><span class="line">      1. 第一，基类构造函数</span><br><span class="line">      2. 第二，派生类的成员类的构造函数（所依赖的类）</span><br><span class="line">      3. 第三，派生类构造函数</span><br><span class="line"></span><br><span class="line">   2. 析构顺序：和构造顺序相反</span><br><span class="line"></span><br><span class="line">   3. 如何调用基类的构造函数</span><br><span class="line"></span><br><span class="line">      1. 基类有默认构造函数（无参构造函数）</span><br><span class="line"></span><br><span class="line">         1. 如果你的基类有一个无参构造函数（默认构造函数），而你在派生类中没有显式调用基类构造函数，编译器会**自动调用基类的默认构造函数**。</span><br><span class="line"></span><br><span class="line">         2. ```c++</span><br><span class="line">            class Base &#123;</span><br><span class="line">            public:</span><br><span class="line">                Base() &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;Base 默认构造函数&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            class Derived : public Base &#123;</span><br><span class="line">            public:</span><br><span class="line">                Derived() &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;Derived 默认构造函数&quot; &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            int main() &#123;</span><br><span class="line">                Derived d;  // 先调用 Base()，再调用 Derived()</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

3. 
</code></pre>
</li>
<li><p>基类没有默认构造函数，或你想调用指定的基类构造函数</p>
<ol>
<li><p>如果基类没有无参构造函数，或者你想要调用基类的某个有参构造函数，那么你<strong>必须在派生类的构造函数初始化列表中显式调用基类的构造函数</strong></p>
</li>
<li><pre><code class="language-c++">class Base {
public:
    Base(int x) {
        cout &lt;&lt; &quot;Base(int): &quot; &lt;&lt; x &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    Derived(int y) : Base(y) {  // 显式调用基类构造函数
        cout &lt;&lt; &quot;Derived(int): &quot; &lt;&lt; y &lt;&lt; endl;
    }
};
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">         3. </span><br><span class="line"></span><br><span class="line">### 虚函数</span><br><span class="line"></span><br><span class="line">#### 虚函数的定义与特性</span><br><span class="line"></span><br><span class="line">1. 通过上面的介绍我们知道了：**虚函数就是多态函数**</span><br><span class="line">2. 重定义规则：</span><br><span class="line">   1. 如果基类函数声明为`virtual`，派生类中的重定义函数自动成为虚函数</span><br><span class="line">   2. 重定义函数必须与基类虚函数具有相同的签名</span><br><span class="line">   3. 使用`override`关键字（C++11）可以增强安全性</span><br><span class="line"></span><br><span class="line">3. 限制条件</span><br><span class="line"></span><br><span class="line">   1. | 函数类型     | 能否为虚函数 | 说明                       |</span><br><span class="line">      | :----------- | :----------- | :------------------------- |</span><br><span class="line">      | 普通成员函数 | ✅            | 主要的虚函数应用场景       |</span><br><span class="line">      | 静态成员函数 | ❌            | 与具体对象无关             |</span><br><span class="line">      | 内联成员函数 | ❌            | 编译时展开，与动态绑定冲突 |</span><br><span class="line">      | 构造函数     | ❌            | 对象构造期间虚表未完全建立 |</span><br><span class="line">      | 析构函数     | ✅            | 应该声明为虚函数           |</span><br><span class="line"></span><br><span class="line">   2. 在 C++ 的**继承与多态**场景中，**如果基类的析构函数不是虚函数（non-virtual destructor），而你通过基类指针删除派生类对象，就可能导致派生类部分的资源没有被正确释放，从而引发内存泄漏或其他未定义行为。**</span><br><span class="line">      1. 经典且推荐的实现：`virtual ~B() = default;`</span><br><span class="line"></span><br><span class="line">#### 类型相容与对象赋值机制</span><br><span class="line"></span><br><span class="line">1. 基础概念：</span><br><span class="line">   1. 类型相容是指不同数据类型之间能否进行赋值操作的兼容性规则。在继承体系中，派生类对象可以赋值给基类对象，但反之不成立。</span><br><span class="line">   2. 这里引出了**对象切片**的问题。</span><br><span class="line">      1. 派生类对象比基类对象大，怎么赋值？只把需要的赋值过去就行了。也是这个原因，不能反过来赋值。</span><br><span class="line">      2. 对象身份变化分析</span><br><span class="line">         - 派生类特有的成员被&quot;切掉&quot;</span><br><span class="line">         - 只保留基类部分的成员</span><br><span class="line">         - 对象身份从派生类变为基类类型</span><br><span class="line"></span><br><span class="line">2. 指针和引用的类型相容</span><br><span class="line"></span><br><span class="line">   1. 基类的指针或引用可以指向派生类对象，这是实现多态的基础：</span><br><span class="line"></span><br><span class="line">   2. ```c++</span><br><span class="line">      B* pb = new B();</span><br><span class="line">      A* pa = pb;     // 合法：基类指针指向派生类对象</span><br><span class="line">      A&amp; ra = *pb;    // 合法：基类引用绑定派生类对象</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对象身份发生变化，调用命名空间随之变化。</p>
</li>
</ol>
<h4 id="虚函数的绑定机制"><a href="#虚函数的绑定机制" class="headerlink" title="虚函数的绑定机制"></a>虚函数的绑定机制</h4><ol>
<li><p>引入</p>
<ol>
<li><img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251127101044950.png" alt="image-20251127101044950"></li>
<li>func2()调用的是A还是B呢？这涉及到绑定机制。C++在默认情况下，是静态绑定，那么就会按照参数类型调用A::f()。如果需要动态绑定，则需要手动用<code>virtual</code>显式指出。</li>
</ol>
</li>
<li><p>静态绑定</p>
<ol>
<li><p>发生时机：编译时刻</p>
</li>
<li><p>依据：对象的静态类型（声明类型）</p>
</li>
<li><p>优点：执行效率高</p>
</li>
<li><p>缺点：灵活性差</p>
</li>
<li><pre><code class="language-c++">class Base {
public:
    void nonVirtual() { cout &lt;&lt; &quot;Base::nonVirtual&quot;; }
};

Base* ptr = new Derived();
ptr-&gt;nonVirtual();  // 总是调用Base::nonVirtual（前期绑定）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 动态绑定</span><br><span class="line"></span><br><span class="line">   1. 发生时机：运行时刻</span><br><span class="line"></span><br><span class="line">   2. 依据：对象的实际类型（动态类型）</span><br><span class="line"></span><br><span class="line">   3. 优点：灵活性高，支持多态</span><br><span class="line"></span><br><span class="line">   4. 缺点：效率相对较低</span><br><span class="line"></span><br><span class="line">   5. ```c++</span><br><span class="line">      class Base &#123;</span><br><span class="line">      public:</span><br><span class="line">          virtual void virtualFunc() &#123; cout &lt;&lt; &quot;Base::virtualFunc&quot;; &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      Base* ptr = new Derived();</span><br><span class="line">      ptr-&gt;virtualFunc();  // 根据实际对象类型调用（动态绑定）</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="后期绑定的实现"><a href="#后期绑定的实现" class="headerlink" title="后期绑定的实现"></a>后期绑定的实现</h4><ol>
<li><p>虚函数表的内存布局</p>
<p>每个包含虚函数的类都有一个虚函数表（vtable），对象中包含指向该表的指针（vptr）。<img src="C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251127102607959.png" alt="image-20251127102607959"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 重写虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;           <span class="comment">// 重定义普通函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚函数调用过程</p>
<ol>
<li>通过对象的vptr找到虚函数表</li>
<li>在虚函数表中查找函数地址</li>
<li>根据实际对象类型调用正确的函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a; B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用B::f（通过虚函数表动态绑定）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="构造函数中的虚函数调用"><a href="#构造函数中的虚函数调用" class="headerlink" title="构造函数中的虚函数调用"></a>构造函数中的虚函数调用</h4><ol>
<li><p>构造函数中的虚函数调用</p>
<ol>
<li><p><strong>虚函数表是在构造函数中完成的，这就意味着构造到哪里，身份就到哪里。</strong></p>
</li>
<li><p>在构造函数执行期间，虚函数机制尚未完全建立：</p>
<ol>
<li>虚函数表指针（vptr）在构造函数中逐步设置</li>
<li>在基类构造函数中调用虚函数，实际调用的是当前类的版本</li>
<li>直到构造函数返回后，对象才能正常使用虚函数机制</li>
</ol>
</li>
<li><pre><code class="language-c++">class A {
public:
    A() { f(); }  // 构造函数中调用虚函数
    virtual void f() { cout &lt;&lt; &quot;A::f&quot;; }
    void g() { cout &lt;&lt; &quot;A::g&quot;; }
    void h() { f(); g(); }
};

class B : public A {
public:
    void f() override { g(); }  // 调用g()函数
    void g() { cout &lt;&lt; &quot;B::g&quot;; }
};

B b;           // 输出：A::f（构造函数中调用A::f） *** 重点看这里 ***
A* p = &amp;b;
p-&gt;f();        // 输出：B::g（通过虚函数表调用B::f，其中调用B::g）
p-&gt;g();        // 输出：A::g（非虚函数，静态绑定）
p-&gt;h();        // 输出：B::g A::g（h()中f()动态绑定，g()静态绑定） *** 重点看这里 ***
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 友元与protected</span><br><span class="line"></span><br><span class="line">1. 友元的友元不是友元</span><br><span class="line"></span><br><span class="line">2. 派生类的友元不是友元</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      class Base &#123;</span><br><span class="line">      protected:</span><br><span class="line">          int prot_mem; // protected 成员</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      class Sneaky : public Base &#123;</span><br><span class="line">          friend void clobber(Sneaky&amp;);  // 能访问Sneaky::prot_mem</span><br><span class="line">          friend void clobber(Base&amp;);    // 不能访问Base::prot_mem</span><br><span class="line">          int j;                         // j 默认是private</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>friend void clobber(Base&amp;);</code>：表示 <code>clobber</code>函数是 <code>Base</code>类的友元吗？不，这里是 <code>Sneaky</code>类把 <code>clobber(Base&amp;)</code>声明为友元。但 <code>protected</code>成员的访问权限有个关键限制：<strong>派生类只能让自己的友元访问自己继承来的 protected 成员，而不能直接让友元去访问基类的 protected 成员（除非友元是基类本身声明的，或者有其他特殊继承&#x2F;友元关系）</strong>。所以这个 <code>clobber(Base&amp;)</code>虽然是 <code>Sneaky</code>的友元，但它并不能访问 <code>Base</code>类里的 <code>prot_mem</code>。</p>
</li>
</ol>
</li>
</ol>
<h4 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h4><ol>
<li>纯虚函数<ol>
<li>是什么<ol>
<li>在 C++ 中，如果一个<strong>虚函数没有具体的实现</strong>，并且在声明时被赋值为 <code>0</code>，这样的函数就称为<strong>纯虚函数</strong>。</li>
<li><code>virtual 返回类型 函数名(参数列表) = 0;</code></li>
<li>注意纯虚函数<strong>没有函数体（可以没有实现）</strong>。</li>
</ol>
</li>
<li>为什么要纯虚函数<ol>
<li>它定义了一个接口，<strong>要求派生类必须去实现它（除非派生类也是抽象类）</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>抽象类<ol>
<li>是什么<ol>
<li>如果一个类<strong>包含至少一个纯虚函数</strong>，那么这个类就称为<strong>抽象类</strong>。</li>
<li><strong>抽象类不能创建对象（不能实例化）</strong>，它只能作为<strong>基类被继承</strong>。</li>
<li>抽象类的目的是为了定义一个<strong>通用的接口或行为规范</strong>，强制派生类去实现这些行为。</li>
<li>一般作为指针类型实现接口。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="final与override"><a href="#final与override" class="headerlink" title="final与override"></a>final与override</h4><ol>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>; <span class="comment">// 正确: f1与基类中的f1 匹配</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;       <span class="comment">// 错误: B没有形如f2(int) 的函数。int f2()?</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误: f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误: B没有名为f4的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f5</span><span class="params">(<span class="type">int</span>)</span></span>;                <span class="comment">// 错误: B已经将f5声明成final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建议重写虚函数时要用上<code>override</code>关键字</p>
</li>
<li><p>为什么要使用override</p>
<ol>
<li><strong>编译时检查</strong>：确保重写的函数确实存在于基类</li>
<li><strong>代码可读性</strong>：明确标识这是重写函数</li>
<li><strong>维护性</strong>：当基类虚函数改变时，派生类中的override会报错</li>
</ol>
</li>
<li><p>为什么要使用final</p>
<ol>
<li><strong>设计约束</strong>：明确某些类或函数不应该被进一步扩展</li>
<li><strong>性能优化</strong>：编译器可能对final函数进行去虚拟化优化</li>
<li><strong>安全性</strong>：防止意外的重写或继承</li>
</ol>
</li>
</ol>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><ol>
<li><p><strong>访问控制检查在编译时期执行，因此只会检查静态类型</strong></p>
</li>
<li><p>如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。</p>
</li>
<li><p>所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。</p>
</li>
<li></li>
</ol>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p><strong>确定共有继承是真正意义的 ‘is_a’ 关系</strong></p>
<ol>
<li>在面向对象设计里，<code>public</code>继承表示 “是一种（is-a）” 关系。例如，如果写 <code>class Dog : public Animal</code>，就意味着 “狗是一种动物”——Dog 必须能替代 Animal 做所有 Animal 能做的事（里氏替换原则 Liskov Substitution Principle）。</li>
<li>反过来，如果不是 “is-a” 关系，就不应该用 <code>public</code>继承；否则会导致语义混乱、代码难以维护甚至出现难以调试的错误。</li>
</ol>
</li>
<li><p><strong>不要定义与继承而来的非虚成员函数同名的成员函数</strong></p>
<ol>
<li>如果基类里有<strong>非虚</strong>成员函数，派生类里又定义了一个<strong>同名</strong>的成员函数，这在 C++ 里属于 “隐藏（Name Hiding）”，而非 “重写（Override）”。这很容易让程序员误以为是 “多态”，结果却出现和预期完全不同的行为（比如根据指针&#x2F;引用类型调用到不同函数，而不是根据实际对象类型）。</li>
<li>更糟糕的是，一旦基类把那个函数改成 <code>virtual</code>，派生类里同名的函数就会自动变成 “重写”，行为可能瞬间改变，埋下隐患。</li>
</ol>
</li>
<li><p><strong>保持派生类实现与基类虚函数的访问控制一致</strong></p>
<ol>
<li>如果一个虚函数在派生类中为public而在基类中为protected，但是通过基类的指针去访问派生类的对象时，会报错。</li>
<li>所以，我们要在设计代码时，就要让派生类和基类的虚函数的访问控制一致。</li>
</ol>
</li>
<li><p><strong>慎用私有继承</strong></p>
<ol>
<li><p>私有继承常用于 “Implemented - in - term - of” 场景，也就是当派生类想要复用基类的实现（比如使用基类的 <code>protected</code>成员，或者重写基类的虚函数），但又不希望把基类暴露给外部客户端时，就可以使用私有继承。</p>
</li>
<li><p>私有继承在 “设计层面” 并没有太多语义上的含义（不像公有继承那样表达 “is - a” 关系），它更多是在 “实现层面” 帮我们复用代码。</p>
</li>
<li><p>私有继承后，派生类对象在类外部不能直接转换为基类对象去匹配接受基类引用的函数（就像示例中 <code>eat(b)</code>会报错那样）</p>
</li>
<li><pre><code class="language-c++">class CHumanBeing { ... };
class CStudent: private CHumanBeing { ... };
void eat(const CHumanBeing&amp; h) { ... }
CHumanBeing a; CStudent b;
eat(a);
eat(b); // Error
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **绝对不要重新定义继承而来的缺省参数值**</span><br><span class="line"></span><br><span class="line">   1. 核心问题</span><br><span class="line"></span><br><span class="line">      1. **虚函数** 是实现**动态绑定（运行时多态）** 的关键。 虚函数的调用会根据对象的**实际类型** 来决定调用哪个类的虚函数版本。</span><br><span class="line"></span><br><span class="line">      2. **默认参数** 是在**编译时期** 就确定下来的，属于**静态绑定**。 默认参数的值由**指针或引用的声明类型** 决定，而不是对象的**实际类型** 决定。</span><br><span class="line"></span><br><span class="line">      3. 当你在派生类中重新定义了从基类继承而来的虚函数的默认参数值时，就会产生混淆和潜在的错误，因为：</span><br><span class="line"></span><br><span class="line">         - 函数调用是动态绑定的（决定调用哪个虚函数）。</span><br><span class="line"></span><br><span class="line">         - 默认参数值是静态绑定的（决定用什么默认值）。</span><br><span class="line"></span><br><span class="line">      4. 这会导致**函数的调用版本** 和 **默认参数的值** 可能不匹配， 从而出现不符合预期的行为。</span><br><span class="line"></span><br><span class="line">   2. 代码分析</span><br><span class="line"></span><br><span class="line">      1. ```c++</span><br><span class="line">         class A </span><br><span class="line">         &#123; </span><br><span class="line">         public: </span><br><span class="line">             virtual void f(int x=0) =0; </span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         class B: public A </span><br><span class="line">         &#123; </span><br><span class="line">         public: </span><br><span class="line">             virtual void f(int x=1)   // ❌ 错误示范：重新定义了继承来的默认参数！</span><br><span class="line">             &#123; cout &lt;&lt; x;&#125; </span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         class C: public A </span><br><span class="line">         &#123; </span><br><span class="line">         public: </span><br><span class="line">             virtual void f(int x) &#123; cout&lt;&lt; x;&#125; </span><br><span class="line">         &#125;;</span><br><span class="line">         </span><br><span class="line">         // 主逻辑：</span><br><span class="line">         A *p_a; </span><br><span class="line">         B b; </span><br><span class="line">         p_a = &amp;b; </span><br><span class="line">         p_a-&gt;f(); </span><br><span class="line">         </span><br><span class="line">         A *p_a1; </span><br><span class="line">         C c; </span><br><span class="line">         p_a1 = &amp;c; </span><br><span class="line">         p_a1-&gt;f();</span><br></pre></td></tr></table></figure>

2. 分析函数调用和默认参数

   1. 调用 `p_a-&gt;f()`（p_a 指向 B 对象 b）

      1. 虚函数调用（动态绑定）： 因为 `p_a`是指向 `A`的指针，而 `A`中的 `f`是虚函数，并且 `b`实际上是 `B`类型，所以会**动态绑定到 `B::f`**。

      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a`的声明类型 `A\*` 决定的，而不是由 `p_a`实际指向的对象类型 `B`决定的。所以，`B::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`**（而不是 `B`中错误定义的 `x=1`）**。因此，`p_a-&gt;f()`等价于 `B::f(0)`， 输出 `0`。

   3. 调用 `p_a1-&gt;f()`（p_a1 指向 C 对象 c）

      1. 虚函数调用（动态绑定）： `p_a1`是指向 `A`的指针，`A`中的 `f`是虚函数，并且 `c`实际上是 `C`类型，所以会**动态绑定到 `C::f`**。

      1. 默认参数（静态绑定）： 默认参数的值是由 指针 `p_a1`的声明类型 `A\*` 决定的，而不是由 `p_a1`实际指向的对象类型 `C`决定的。所以，`C::f`的默认参数值会使用 `A`中定义的默认参数 `x=0`（因为 `C`中没有重新定义默认参数）。因此，`p_a1-&gt;f()`等价于 `C::f(0)`， 输出 `0`。
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li><p>是什么</p>
<ol>
<li><p>定义：多继承是C++面向对象编程中的重要特性，它允许一个派生类同时从<strong>多个基类</strong>继承属性和方法。这种机制提供了更大的灵活性，但也带来了更复杂的语义和实现问题。</p>
</li>
<li><p>基本语法：</p>
<ol>
<li><pre><code class="language-c++">class &lt;派生类名&gt; : [&lt;继承方式&gt;] &lt;基类名1&gt;, [&lt;继承方式&gt;] &lt;基类名2&gt;, ...
{
    &lt;成员表&gt;
};
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      2. </span><br><span class="line"></span><br><span class="line">2. 多继承中的名冲突问题</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      class Base1 &#123;</span><br><span class="line">      public:</span><br><span class="line">          void display() &#123; cout &lt;&lt; &quot;Base1 display&quot; &lt;&lt; endl; &#125;</span><br><span class="line">          int value = 10;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      class Base2 &#123;</span><br><span class="line">      public:</span><br><span class="line">          void display() &#123; cout &lt;&lt; &quot;Base2 display&quot; &lt;&lt; endl; &#125;</span><br><span class="line">          int value = 20;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      class Derived : public Base1, public Base2 &#123;</span><br><span class="line">      public:</span><br><span class="line">          void show() &#123;</span><br><span class="line">              // display();     // 错误：名冲突，不知道调用哪个display</span><br><span class="line">              // cout &lt;&lt; value; // 错误：名冲突，不知道访问哪个value</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;	</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
<li><p>当多个基类包含同名成员时，会产生名冲突（Name Conflict）</p>
</li>
<li><p>用使用<strong>作用域解析运算符</strong>明确指定要访问的成员</p>
</li>
</ol>
</li>
<li><p>菱形继承的数据冗余问题</p>
<ol>
<li><p>是什么：</p>
<ol>
<li>当B，C继承自A，而D多继承自B，C，那么D中就会出现<code>B::x</code>和<code>C::x</code>，然而x实际上都来自<code>A::x</code>，这就造成了冗余。</li>
</ol>
</li>
<li><p>造成的后果</p>
<ol>
<li>派生类D中将包含<strong>两份A的成员副本</strong></li>
<li>访问A的成员时会产生二义性</li>
<li>内存布局复杂，存在冗余数据</li>
</ol>
</li>
<li><p>解决方案：虚继承</p>
</li>
</ol>
</li>
</ol>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><ol>
<li><p>虚继承是解决菱形继承问题的关键技术，它确保公共基类在派生类中只有<strong>一个副本</strong>：</p>
<ol>
<li><p>示例：</p>
</li>
<li><pre><code class="language-c++">class A {
public:
    int x;
};

class B : virtual public A {  // 虚继承
    // 虚继承A
};

class C : public virtual A {  // 虚继承，两种写法等价
    // 虚继承A
};

class D : public B, public C {
    // 现在D中只有一份A的成员x
};
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 虚继承的工作原理</span><br><span class="line"></span><br><span class="line">   1. 虚继承通过引入**虚基类表指针**来实现：</span><br><span class="line"></span><br><span class="line">      1. 每个虚继承的类包含一个指向共享基类的指针</span><br><span class="line">      2. 最终派生类负责初始化虚基类</span><br><span class="line">      3. 所有中间类共享同一个基类实例</span><br><span class="line"></span><br><span class="line">   2. 内存模型</span><br><span class="line"></span><br><span class="line">      1. ```</span><br><span class="line">         D对象：</span><br><span class="line">         +-------------------+</span><br><span class="line">         | 虚基类表指针(B)   |</span><br><span class="line">         | B特有成员         |</span><br><span class="line">         +-------------------+</span><br><span class="line">         | 虚基类表指针(C)   |</span><br><span class="line">         | C特有成员         |</span><br><span class="line">         +-------------------+</span><br><span class="line">         | D特有成员         |</span><br><span class="line">         +-------------------+</span><br><span class="line">         | 共享的A部分       |  ← B和C通过指针共享</span><br><span class="line">         +-------------------+</span><br></pre></td></tr></table></figure>

2.
</code></pre>
</li>
</ol>
</li>
<li><p>虚继承的特殊规则</p>
<ol>
<li><p>构造函数调用顺序</p>
<p>虚基类的构造函数调用有特殊规则：</p>
<ol>
<li><strong>虚基类的构造函数</strong>优先执行</li>
<li>然后按声明顺序执行<strong>非虚基类的构造函数</strong></li>
<li>最后执行<strong>派生类自身的构造函数</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;C constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;D constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建D对象时的输出顺序：</span></span><br><span class="line"><span class="comment">// A constructor (虚基类优先)</span></span><br><span class="line"><span class="comment">// B constructor</span></span><br><span class="line"><span class="comment">// C constructor  </span></span><br><span class="line"><span class="comment">// D constructor</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>最新派生类责任<ol>
<li>在虚继承中，<strong>最底层派生类</strong>负责直接初始化所有虚基类</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123; cout &lt;&lt; <span class="string">&quot;A(&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">1</span>) &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">A</span>(<span class="number">2</span>) &#123; cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 必须直接初始化虚基类A</span></span><br><span class="line">    <span class="built_in">D</span>() : <span class="built_in">A</span>(<span class="number">100</span>), <span class="built_in">B</span>(), <span class="built_in">C</span>() &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// A(100)  - 虚基类由D直接初始化，B和C中的A初始化被忽略</span></span><br><span class="line"><span class="comment">// B()</span></span><br><span class="line"><span class="comment">// C()</span></span><br><span class="line"><span class="comment">// D() </span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>虚基类表</p>
<ol>
<li>每个虚继承的类都包含一个虚基类表，记录：<ol>
<li>虚基类相对于当前对象的偏移量</li>
<li>虚基类成员的访问信息</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="“algorithm”"><a href="#“algorithm”" class="headerlink" title="“algorithm”"></a>“algorithm”</h2><table>
<thead>
<tr>
<th align="left">函数&#x2F;算法</th>
<th align="left">功能描述</th>
<th align="left">是否修改原数据</th>
<th align="left">适用对象</th>
<th align="left">备注 &#x2F; 示例关键词</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>std::sort</code>***</td>
<td align="left">对范围进行排序（默认升序）</td>
<td align="left">✅ 是</td>
<td align="left">支持随机访问迭代器（如 <code>vector</code>, <code>deque</code>, 普通数组）</td>
<td align="left"><code>std::sort(v.begin(), v.end())</code></td>
</tr>
<tr>
<td align="left"><code>std::stable_sort</code></td>
<td align="left">稳定排序（相等元素相对顺序不变）</td>
<td align="left">✅ 是</td>
<td align="left">同上</td>
<td align="left">适合需要保持顺序的场景</td>
</tr>
<tr>
<td align="left"><code>std::reverse</code>***</td>
<td align="left">反转范围内的元素顺序</td>
<td align="left">✅ 是</td>
<td align="left">双向迭代器（如 <code>vector</code>, <code>list</code>, <code>deque</code>）</td>
<td align="left"><code>std::reverse(v.begin(), v.end())</code></td>
</tr>
<tr>
<td align="left"><code>std::find</code></td>
<td align="left">查找某个值，返回第一个匹配的迭代器</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>find(v.begin(), v.end(), 42)</code></td>
</tr>
<tr>
<td align="left"><code>std::find_if</code></td>
<td align="left">按条件查找（使用谓词 predicate）</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>find_if(v.begin(), v.end(), [](int x){...})</code></td>
</tr>
<tr>
<td align="left"><code>std::count</code></td>
<td align="left">统计某个值出现的次数</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>count(v.begin(), v.end(), 10)</code></td>
</tr>
<tr>
<td align="left"><code>std::count_if</code></td>
<td align="left">按条件统计个数</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>count_if(v.begin(), v.end(), [](int x){...})</code></td>
</tr>
<tr>
<td align="left"><code>std::copy</code></td>
<td align="left">复制一个范围的元素到另一个位置</td>
<td align="left">❌ 否（目标被修改）</td>
<td align="left">输入 → 输出迭代器</td>
<td align="left"><code>copy(src.begin(), src.end(), dest.begin())</code></td>
</tr>
<tr>
<td align="left"><code>std::copy_if</code></td>
<td align="left">按条件复制元素</td>
<td align="left">❌ 否</td>
<td align="left">输入 → 输出迭代器</td>
<td align="left"><code>copy_if(v.begin(), v.end(), out, predicate)</code></td>
</tr>
<tr>
<td align="left"><code>std::transform</code></td>
<td align="left">对每个元素进行变换，生成新序列或原地修改</td>
<td align="left">✅ &#x2F; ❌ 取决于用法</td>
<td align="left">输入&#x2F;输出迭代器</td>
<td align="left">可用于 map-like 操作</td>
</tr>
<tr>
<td align="left"><code>std::for_each</code></td>
<td align="left">对每个元素执行某个操作（函数&#x2F;lambda）</td>
<td align="left">❌ 通常否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>for_each(v.begin(), v.end(), func)</code></td>
</tr>
<tr>
<td align="left"><code>std::min</code>&#x2F; <code>std::max</code></td>
<td align="left">返回两个（或多个）值中的最小&#x2F;最大值</td>
<td align="left">❌ 否</td>
<td align="left">值</td>
<td align="left"><code>min(a, b)</code>, <code>max(a, b)</code></td>
</tr>
<tr>
<td align="left"><code>std::min_element</code>&#x2F; <code>std::max_element</code></td>
<td align="left">返回范围内最小&#x2F;最大元素的<strong>迭代器</strong></td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left"><code>min_element(v.begin(), v.end())</code></td>
</tr>
<tr>
<td align="left"><code>std::clamp</code>（C++17）</td>
<td align="left">将值限制在 [low, high] 范围内</td>
<td align="left">❌ 否</td>
<td align="left">值</td>
<td align="left"><code>clamp(x, low, high)</code></td>
</tr>
<tr>
<td align="left"><code>std::swap</code>***</td>
<td align="left">交换两个对象的值</td>
<td align="left">✅ 是</td>
<td align="left">任意可交换类型</td>
<td align="left"><code>swap(a, b)</code>或 <code>std::swap(a, b)</code></td>
</tr>
<tr>
<td align="left"><code>std::unique</code></td>
<td align="left">移除相邻的重复元素（需先排序）</td>
<td align="left">✅ 是（实际是移动到前面，需配合 erase）</td>
<td align="left">双向迭代器</td>
<td align="left">通常与 <code>sort</code>+ <code>erase</code>配合使用</td>
</tr>
<tr>
<td align="left"><code>std::fill</code></td>
<td align="left">用指定值填充某个范围</td>
<td align="left">✅ 是</td>
<td align="left">输出迭代器</td>
<td align="left"><code>fill(v.begin(), v.end(), 0)</code></td>
</tr>
<tr>
<td align="left"><code>std::generate</code></td>
<td align="left">用生成器函数填充范围</td>
<td align="left">✅ 是</td>
<td align="left">输出迭代器</td>
<td align="left">常用于生成随机数等</td>
</tr>
<tr>
<td align="left"><code>std::accumulate</code>（在 <code>&lt;numeric&gt;</code>）</td>
<td align="left">计算累计值（如求和、累积）</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器</td>
<td align="left">常与 lambda 配合做自定义累加</td>
</tr>
<tr>
<td align="left"><code>std::lower_bound</code></td>
<td align="left">返回第一个 <strong>不小于</strong> 指定值的迭代器（二分查找）</td>
<td align="left">❌ 否</td>
<td align="left">已排序的范围，随机访问迭代器</td>
<td align="left">用于有序容器</td>
</tr>
<tr>
<td align="left"><code>std::upper_bound</code></td>
<td align="left">返回第一个 <strong>大于</strong> 指定值的迭代器</td>
<td align="left">❌ 否</td>
<td align="left">已排序的范围</td>
<td align="left">与 lower_bound 一起可确定插入位置</td>
</tr>
<tr>
<td align="left"><code>std::binary_search</code></td>
<td align="left">判断某个值是否存在于<strong>已排序</strong>的范围中</td>
<td align="left">❌ 否</td>
<td align="left">已排序</td>
<td align="left">返回 <code>true/false</code></td>
</tr>
<tr>
<td align="left"><code>std::equal</code></td>
<td align="left">判断两个范围是否相等</td>
<td align="left">❌ 否</td>
<td align="left">两个输入范围</td>
<td align="left">比较两段数据内容是否相同</td>
</tr>
<tr>
<td align="left"><code>std::all_of</code>&#x2F; <code>any_of</code>&#x2F; <code>none_of</code></td>
<td align="left">判断范围内是否<strong>全部&#x2F;任一&#x2F;无</strong>满足条件</td>
<td align="left">❌ 否</td>
<td align="left">输入迭代器 + 谓词</td>
<td align="left">常搭配 lambda 使用</td>
</tr>
</tbody></table>
<h2 id="“fstream”"><a href="#“fstream”" class="headerlink" title="“fstream”"></a>“fstream”</h2><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">方法&#x2F;对象</th>
<th align="left">调用示例</th>
<th align="left">返回值</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">文件输出</td>
<td align="left"><code>std::ofstream</code></td>
<td align="left"><code>std::ofstream fout(&quot;file.txt&quot;);</code></td>
<td align="left"><code>ofstream</code>对象</td>
<td align="left">输出文件流（写入文件）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fout &lt;&lt; &quot;text&quot;;</code></td>
<td align="left"><code>fout &lt;&lt; data;</code></td>
<td align="left"><code>ostream&amp;</code></td>
<td align="left">写入内容到文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fout.open(&quot;file.txt&quot;)</code></td>
<td align="left"><code>fout.open(&quot;data.txt&quot;);</code></td>
<td align="left"><code>void</code></td>
<td align="left">打开文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fout.close()</code></td>
<td align="left"><code>fout.close();</code></td>
<td align="left"><code>void</code></td>
<td align="left">关闭文件</td>
</tr>
<tr>
<td align="left">文件输入</td>
<td align="left"><code>std::ifstream</code></td>
<td align="left"><code>std::ifstream fin(&quot;file.txt&quot;);</code></td>
<td align="left"><code>ifstream</code>对象</td>
<td align="left">输入文件流（读取文件）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fin &gt;&gt; x;</code></td>
<td align="left"><code>fin &gt;&gt; value;</code></td>
<td align="left"><code>istream&amp;</code></td>
<td align="left">从文件读取变量</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>std::getline(fin, str)</code></td>
<td align="left"><code>std::getline(fin, line);</code></td>
<td align="left"><code>istream&amp;</code></td>
<td align="left">读取文件中的一行文本</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fin.open(&quot;file.txt&quot;)</code></td>
<td align="left"><code>fin.open(&quot;data.txt&quot;);</code></td>
<td align="left"><code>void</code></td>
<td align="left">打开文件</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>fin.close()</code></td>
<td align="left"><code>fin.close();</code></td>
<td align="left"><code>void</code></td>
<td align="left">关闭文件</td>
</tr>
</tbody></table>
<h2 id="“memory”"><a href="#“memory”" class="headerlink" title="“memory”"></a>“memory”</h2><ol>
<li><table>
<thead>
<tr>
<th align="left">类别&#x2F;方法</th>
<th align="left">方法&#x2F;函数</th>
<th align="left">调用示例</th>
<th align="left">返回值</th>
<th align="left">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>智能指针类型</strong></td>
<td align="left"><code>std::unique_ptr&lt;T&gt;</code></td>
<td align="left"><code>std::unique_ptr&lt;int&gt; p(new int(10));</code> 或更推荐：<code>auto p = std::make_unique&lt;int&gt;(10);</code>(C++14)</td>
<td align="left"><code>std::unique_ptr&lt;T&gt;</code>对象</td>
<td align="left">独占所有权的智能指针，不能复制，只能移动，离开作用域时自动释放资源。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>std::shared_ptr&lt;T&gt;</code></td>
<td align="left"><code>std::shared_ptr&lt;int&gt; p(new int(20));</code> 或推荐：<code>auto p = std::make_shared&lt;int&gt;(20);</code></td>
<td align="left"><code>std::shared_ptr&lt;T&gt;</code>对象</td>
<td align="left">共享所有权的智能指针，多个 <code>shared_ptr</code>可指向同一对象，通过引用计数管理生命周期。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>std::weak_ptr&lt;T&gt;</code></td>
<td align="left"><code>std::weak_ptr&lt;int&gt; wp(sp);</code>（sp 是 shared_ptr）</td>
<td align="left"><code>std::weak_ptr&lt;T&gt;</code>对象</td>
<td align="left">弱引用指针，不增加引用计数，常用于解决 <code>shared_ptr</code>的循环引用问题，或安全访问可能已释放的资源。</td>
</tr>
<tr>
<td align="left"><strong>工厂函数（推荐）</strong></td>
<td align="left"><code>std::make_unique&lt;T&gt;(args...)</code></td>
<td align="left"><code>auto p = std::make_unique&lt;int&gt;(42);</code> （C++14 起支持）</td>
<td align="left"><code>std::unique_ptr&lt;T&gt;</code></td>
<td align="left">安全、高效地创建 <code>unique_ptr</code>，避免显式使用 <code>new</code>，推荐首选方式。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>std::make_shared&lt;T&gt;(args...)</code></td>
<td align="left"><code>auto p = std::make_shared&lt;int&gt;(42);</code> （C++11 起支持）</td>
<td align="left"><code>std::shared_ptr&lt;T&gt;</code></td>
<td align="left">安全、高效地创建 <code>shared_ptr</code>，通常比 <code>new</code>+ <code>shared_ptr</code>构造更高效（一次分配）。</td>
</tr>
<tr>
<td align="left"><strong>通用方法（适用于 shared_ptr &#x2F; unique_ptr）</strong></td>
<td align="left"><code>.get()</code></td>
<td align="left"><code>int* raw = p.get();</code></td>
<td align="left"><code>T*</code>（原始指针）</td>
<td align="left">返回智能指针管理的<strong>原始指针</strong>，但<strong>不释放所有权</strong>，慎用，避免手动 <code>delete</code>。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>.reset()</code></td>
<td align="left"><code>p.reset();</code>或 <code>p.reset(new int(100));</code></td>
<td align="left"><code>void</code></td>
<td align="left">释放当前管理的对象（如果有），并可选择指向一个新对象。如果无参数，则释放当前资源。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>.release()</code></td>
<td align="left"><code>int* raw = p.release();</code></td>
<td align="left"><code>T*</code></td>
<td align="left"><strong>释放所有权</strong>，返回原始指针，<strong>智能指针不再管理该内存</strong>，需手动管理（如 <code>delete</code>）。慎用！</td>
</tr>
<tr>
<td align="left"><strong>shared_ptr 独有方法</strong></td>
<td align="left"><code>.use_count()</code></td>
<td align="left"><code>int count = sp.use_count();</code></td>
<td align="left"><code>long</code>（或 size_t，取决于实现）</td>
<td align="left">返回当前有多少个 <code>shared_ptr</code>共享该对象（即引用计数），<strong>主要用于调试</strong>，不建议用于逻辑控制。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>.unique()</code></td>
<td align="left"><code>bool is_unique = sp.unique();</code></td>
<td align="left"><code>bool</code></td>
<td align="left">判断当前 <code>shared_ptr</code>是否是唯一拥有该对象的指针（即 use_count &#x3D;&#x3D; 1），C++17 起被标记为 deprecated，推荐用 <code>use_count() == 1</code>。</td>
</tr>
<tr>
<td align="left"><strong>weak_ptr 独有方法</strong></td>
<td align="left"><code>.lock()</code></td>
<td align="left"><code>if (auto tmp = wp.lock()) { /* 使用 tmp */ }</code></td>
<td align="left"><code>std::shared_ptr&lt;T&gt;</code>（如果资源还在） 或 <code>nullptr</code>（如果资源已释放）</td>
<td align="left">尝试将 <code>weak_ptr</code>提升为 <code>shared_ptr</code>，如果对象还存在则返回有效的 <code>shared_ptr</code>，否则返回空。用于安全访问可能被释放的资源。</td>
</tr>
<tr>
<td align="left"><strong>析构行为（隐式）</strong></td>
<td align="left">析构函数 <code>~unique_ptr()</code> <code>~shared_ptr()</code> <code>~weak_ptr()</code></td>
<td align="left">无需显式调用，在对象离开作用域时自动调用</td>
<td align="left"><code>void</code></td>
<td align="left">自动释放所管理的资源： - <code>unique_ptr</code>：直接 <code>delete</code>资源 - <code>shared_ptr</code>：引用计数减 1，归零时 <code>delete</code> - <code>weak_ptr</code>：不影响引用计数，仅观察</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="“queue”"><a href="#“queue”" class="headerlink" title="“queue”"></a>“queue”</h2><table>
<thead>
<tr>
<th>方法</th>
<th>用法示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>push(x)</code></td>
<td><code>q.push(10);</code></td>
<td>元素入队（到队尾）</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>q.pop();</code></td>
<td>队首元素出队（无返回值）</td>
</tr>
<tr>
<td><code>front()</code></td>
<td><code>int a = q.front();</code></td>
<td>访问队首元素（不删除）</td>
</tr>
<tr>
<td><code>back()</code></td>
<td><code>int b = q.back();</code></td>
<td>访问队尾元素（不删除）</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td><code>if(q.empty()) ...</code></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td><code>size()</code></td>
<td><code>int n = q.size();</code></td>
<td>返回元素个数</td>
</tr>
</tbody></table>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ol>
<li><p>概述</p>
<ol>
<li>C++ 的 <code>std::priority_queue</code> 本质上是对 <code>std::vector</code> + <strong>堆算法 (<code>std::make_heap</code> &#x2F; <code>std::push_heap</code> &#x2F; <code>std::pop_heap</code>)</strong> 的封装。</li>
<li>默认实现是 <strong>大顶堆</strong>（堆顶是最大元素）。</li>
<li>小顶堆或自定义顺序，其实是改比较器（<code>greater&lt;T&gt;</code> 或自定义 <code>cmp</code>）。</li>
</ol>
</li>
<li><p>构造</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th>用法</th>
<th>示例代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>默认大顶堆</td>
<td><code>priority_queue&lt;int&gt; pq;</code></td>
<td>取出最大元素</td>
</tr>
<tr>
<td>小顶堆</td>
<td><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;</code></td>
<td>取出最小元素</td>
</tr>
<tr>
<td>自定义比较</td>
<td><code>priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;</code></td>
<td>可定义结构体比较方式</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>用法</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th>方法</th>
<th>用法示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>push(x)</code></td>
<td><code>pq.push(5);</code></td>
<td>插入一个元素（自动调整堆）</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>pq.pop();</code></td>
<td>删除当前最大元素（或最小，取决于堆类型）</td>
</tr>
<tr>
<td><code>top()</code></td>
<td><code>int t = pq.top();</code></td>
<td>返回堆顶元素（最大&#x2F;最小）</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td><code>if(pq.empty()) ...</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>size()</code></td>
<td><code>int n = pq.size();</code></td>
<td>返回元素个数</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="“string”"><a href="#“string”" class="headerlink" title="“string”"></a>“string”</h2><ol>
<li><p>getline</p>
<ol>
<li><pre><code class="language-c++">std::getline(std::cin, str);  // 读取一行，包含空格
std::getline(std::cin, str, &#39;,&#39;);  // 读取直到逗号为止

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. 构造与初始化</span><br><span class="line"></span><br><span class="line">   | 方法                  | 说明                        | 示例                               |</span><br><span class="line">   | :-------------------- | :-------------------------- | :--------------------------------- |</span><br><span class="line">   | `string s;`           | 构造空字符串                | `string s;`→ `s = &quot;&quot;`              |</span><br><span class="line">   | `string s(&quot;hello&quot;);`  | 用 C 风格字符串初始化       | `string s(&quot;abc&quot;);`                 |</span><br><span class="line">   | `string s = &quot;world&quot;;` | 用字符串字面量初始化        | `string s = &quot;xyz&quot;;`                |</span><br><span class="line">   | `string s(5, &#x27;a&#x27;);`   | 构造 5 个 `&#x27;a&#x27;`组成的字符串 | `string s(3, &#x27;x&#x27;);`→ `&quot;xxx&quot;`       |</span><br><span class="line">   | `string s(other);`    | 拷贝构造                    | `string s1 = &quot;hi&quot;; string s2(s1);` |</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   2️⃣ 容量相关</span><br><span class="line"></span><br><span class="line">   | 方法                      | 说明                                                  | 示例                      |</span><br><span class="line">   | :------------------------ | :---------------------------------------------------- | :------------------------ |</span><br><span class="line">   | `s.size()`或 `s.length()` | 返回字符串中字符的个数（不包括 `\0`）                 | `s.size()`→ 如 `&quot;abc&quot;`→ 3 |</span><br><span class="line">   | `s.capacity()`            | 返回当前分配的存储空间（可能 ≥ size）                 | 一般用于优化，不常用      |</span><br><span class="line">   | `s.empty()`               | 判断字符串是否为空（size == 0）                       | `if (s.empty()) &#123;...&#125;`    |</span><br><span class="line">   | `s.resize(n)`             | 将字符串调整为 n 个字符（多出的补空字符，少则截断）   | `s.resize(5);`            |</span><br><span class="line">   | `s.resize(n, c)`          | 调整大小为 n，新增的字符为 `c`                        | `s.resize(5, &#x27;*&#x27;);`       |</span><br><span class="line">   | `s.reserve(n)`            | 预留至少能容纳 n 个字符的空间（优化用，避免多次扩容） | `s.reserve(100);`         |</span><br><span class="line"></span><br><span class="line">   &gt; ✅ `size()`和 `length()`是完全等价的，都返回字符数。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   3️⃣ 访问元素</span><br><span class="line"></span><br><span class="line">   | 方法      | 说明                                                    | 示例                |</span><br><span class="line">   | :-------- | :------------------------------------------------------ | :------------------ |</span><br><span class="line">   | `s[i]`    | 访问第 i 个字符（不检查越界）                           | `char c = s[0];`    |</span><br><span class="line">   | `s.at(i)` | 访问第 i 个字符（**越界会抛异常** `std::out_of_range`） | `char c = s.at(2);` |</span><br><span class="line"></span><br><span class="line">   &gt; ⚠️ 推荐在不确定索引是否合法时使用 `at()`，更安全。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   4️⃣ 修改字符串</span><br><span class="line"></span><br><span class="line">   | 方法                          | 说明                                   | 示例                      |</span><br><span class="line">   | :---------------------------- | :------------------------------------- | :------------------------ |</span><br><span class="line">   | `s.clear()`                   | 清空字符串                             | `s.clear();`→ `s == &quot;&quot;`   |</span><br><span class="line">   | `s.push_back(ch)`             | 在末尾添加一个字符                     | `s.push_back(&#x27;a&#x27;);`       |</span><br><span class="line">   | `s.pop_back()`                | 删除最后一个字符（字符串非空）         | `s.pop_back();`           |</span><br><span class="line">   | `s.append(str)`               | 在末尾追加字符串（或字符、C 字符串等） | `s.append(&quot;123&quot;);`        |</span><br><span class="line">   | `s += str`                    | 追加字符串（常用简洁写法）             | `s += &quot;abc&quot;;`             |</span><br><span class="line">   | `s.insert(pos, str)`          | 在 pos 位置插入字符串                  | `s.insert(2, &quot;XX&quot;);`      |</span><br><span class="line">   | `s.erase(pos, len)`           | 从 pos 开始删除 len 个字符             | `s.erase(1, 2);`          |</span><br><span class="line">   | `s.replace(pos, len, newStr)` | 替换从 pos 开始的 len 个字符为新字符串 | `s.replace(1, 2, &quot;123&quot;);` |</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   5️⃣ 查找相关</span><br><span class="line"></span><br><span class="line">   | 方法                         | 说明                                                      | 示例                         |</span><br><span class="line">   | :--------------------------- | :-------------------------------------------------------- | :--------------------------- |</span><br><span class="line">   | `s.find(sub)`                | 查找子串 `sub`第一次出现的位置，找不到返回 `string::npos` | `size_t pos = s.find(&quot;lo&quot;);` |</span><br><span class="line">   | `s.find(ch)`                 | 查找字符第一次出现的位置                                  | `size_t pos = s.find(&#x27;a&#x27;);`  |</span><br><span class="line">   | `s.rfind(sub)`               | 查找子串最后一次出现的位置                                | `s.rfind(&quot;lo&quot;);`             |</span><br><span class="line">   | `s.find_first_of(&quot;abc&quot;)`     | 查找第一个出现在 `&quot;abc&quot;`中的字符                          |                              |</span><br><span class="line">   | `s.find_last_of(&quot;abc&quot;)`      | 查找最后一个出现在 `&quot;abc&quot;`中的字符                        |                              |</span><br><span class="line">   | `s.find_first_not_of(&quot;abc&quot;)` | 查找第一个 **不**在 `&quot;abc&quot;`中的字符                       |                              |</span><br><span class="line">   | `s.find_last_not_of(&quot;abc&quot;)`  | 查找最后一个 **不**在 `&quot;abc&quot;`中的字符                     |                              |</span><br><span class="line"></span><br><span class="line">   &gt; ⚠️ 找不到时返回 `string::npos`（一个很大的数，通常是 `size_t(-1)`），判断时要用：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>if (pos !&#x3D; string::npos) { &#x2F;* 找到了 *&#x2F; }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   6️⃣ 子串操作</span><br><span class="line"></span><br><span class="line">   | 方法                 | 说明                                                         | 示例                                                       |</span><br><span class="line">   | :------------------- | :----------------------------------------------------------- | :--------------------------------------------------------- |</span><br><span class="line">   | `s.substr(pos, len)` | 返回从 pos 开始，长度为 len 的子串 （len 可省略，表示到末尾） | `string sub = s.substr(2, 3);` `string sub = s.substr(1);` |</span><br><span class="line"></span><br><span class="line">   &gt; ⚠️ `pos`不能越界，否则未定义行为（最好先检查范围）。</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   7️⃣ 比较操作</span><br><span class="line"></span><br><span class="line">   | 方法                                          | 说明                                                  | 示例                               |</span><br><span class="line">   | :-------------------------------------------- | :---------------------------------------------------- | :--------------------------------- |</span><br><span class="line">   | `s.compare(str)`                              | 比较两个字符串 返回 0 表示相等，&lt;0 或 &gt;0 表示大小关系 | `if (s.compare(&quot;abc&quot;) == 0) &#123;...&#125;` |</span><br><span class="line">   | 也可以直接用 `==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=` | 更直观的比较方式                                      | `if (s == &quot;test&quot;) &#123;...&#125;`✅推荐      |</span><br><span class="line"></span><br><span class="line">   &gt; ✅ 推荐直接使用 `==`、`!=`等运算符，更简洁直观！</span><br><span class="line"></span><br><span class="line">   ------</span><br><span class="line"></span><br><span class="line">   8️⃣ 其他实用方法</span><br><span class="line"></span><br><span class="line">   | 方法                     | 说明                                                         | 示例                                             |</span><br><span class="line">   | :----------------------- | :----------------------------------------------------------- | :----------------------------------------------- |</span><br><span class="line">   | `s.c_str()`              | 返回 C 风格字符串（`const char*`），以 `\0`结尾              | 常用于兼容 C 函数，如 `printf(&quot;%s&quot;, s.c_str());` |</span><br><span class="line">   | `s.data()`               | C++17 起也返回 `const char*`，但不保证以 `\0`结尾（一般也可当 C 字符串用） | 类似 `c_str()`                                   |</span><br><span class="line">   | `s.copy(dest, len, pos)` | 将字符串的一部分拷贝到 dest 缓冲区（C 风格）                 | 较少使用                                         |</span><br><span class="line">   | `s.swap(other)`          | 交换两个字符串的内容                                         | `s.swap(s2);`                                    |</span><br><span class="line"></span><br><span class="line">   - 转换</span><br><span class="line"></span><br><span class="line">     - </span><br><span class="line"></span><br><span class="line">     - | 函数              | 说明                   | 转换目标类型  |</span><br><span class="line">       | :---------------- | :--------------------- | :------------ |</span><br><span class="line">       | `std::stoi(str)`  | 字符串 → `int`         | `int`         |</span><br><span class="line">       | `std::stol(str)`  | 字符串 → `long`        | `long`        |</span><br><span class="line">       | `std::stoll(str)` | 字符串 → `long long`   | `long long`   |</span><br><span class="line">       | `std::stof(str)`  | 字符串 → `float`       | `float`       |</span><br><span class="line">       | `std::stod(str)`  | 字符串 → `double`      | `double`      |</span><br><span class="line">       | `std::stold(str)` | 字符串 → `long double` | `long double` |</span><br><span class="line"></span><br><span class="line">     - </span><br><span class="line"></span><br><span class="line">     - | **`std::to_string(int)`** | `std::to_string(num)` | ✅ **最推荐** | C++11 及以上，简单直接的 int → string |</span><br><span class="line">       | ------------------------- | --------------------- | ------------ | ------------------------------------- |</span><br><span class="line"></span><br><span class="line">## &quot;vector&quot;</span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line"></span><br><span class="line">2. | 分类     | 方法/示例                                                   | 返回值（文字说明）           | 说明                     |</span><br><span class="line">   | -------- | ----------------------------------------------------------- | ---------------------------- | ------------------------ |</span><br><span class="line">   | **定义** | `vector&lt;int&gt; v1;`                                           | 空容器                       | 定义一个空 vector        |</span><br><span class="line">   |          | `vector&lt;int&gt; v2(5);`                                        | 含 5 个元素，值为 0          | 指定大小，默认初始化     |</span><br><span class="line">   |          | `vector&lt;int&gt; v3(5, 100);`                                   | 含 5 个元素，值全是 100      | 指定大小和值             |</span><br><span class="line">   |          | `vector&lt;int&gt; v4 = &#123;1,2,3&#125;;`                                 | 含 3 个元素：1,2,3           | 列表初始化               |</span><br><span class="line">   | **访问** | `v4[0]`                                                     | 元素引用（可能越界，不检查） | 下标访问                 |</span><br><span class="line">   |          | `v4.at(1)`                                                  | 元素引用（带越界检查）       | 越界会抛 `out_of_range`  |</span><br><span class="line">   |          | `v4.front()`                                                | 第一个元素引用               | 访问首元素               |</span><br><span class="line">   |          | `v4.back()`                                                 | 最后一个元素引用             | 访问尾元素               |</span><br><span class="line">   |          | `v4.begin()`                                                | 指向首元素的迭代器           | 迭代遍历起点             |</span><br><span class="line">   |          | `v4.end()`                                                  | 指向尾后元素的迭代器         | 遍历终点（左闭右开）     |</span><br><span class="line">   | **修改** | `ans.push_back(10);`                                        | 无返回值                     | 在尾部追加元素           |</span><br><span class="line">   |          | `ans.emplace_back(20);`                                     | 无返回值                     | 原地构造，效率更高       |</span><br><span class="line">   |          | `ans.pop_back();`                                           | 无返回值                     | 删除最后一个元素         |</span><br><span class="line">   |          | `ans.insert(ans.begin()+1, 99);`                            | 指向新元素的迭代器           | 在第 2 个位置插入 99     |</span><br><span class="line">   |          | `ans.insert(ans.end(), &#123;7,8,9&#125;);`                           | 指向第一个新元素的迭代器     | 在尾部插入多个元素       |</span><br><span class="line">   |          | `ans.erase(ans.begin());`                                   | 指向被删元素后的迭代器       | 删除第一个元素           |</span><br><span class="line">   |          | `ans.erase(ans.begin()+1, ans.begin()+3);`                  | 指向区间后的迭代器           | 删除区间 `[2,3)`         |</span><br><span class="line">   |          | `ans.clear();`                                              | 无返回值                     | 清空所有元素             |</span><br><span class="line">   |          | `ans.swap(other);`                                          | 无返回值                     | 与另一个 vector 交换内容 |</span><br><span class="line">   | **遍历** | `for (auto it=ans.begin(); it!=ans.end(); it++) cout&lt;&lt;*it;` | 无返回值                     | 迭代器遍历               |</span><br><span class="line">   |          | `for (auto &amp;x : ans) cout&lt;&lt;x;`                              | 无返回值                     | 范围 for 遍历            |</span><br><span class="line">   | **容量** | `ans.size();`                                               | 当前元素数量                 | O(1)                     |</span><br><span class="line">   |          | `ans.empty();`                                              | 布尔值                       | 是否为空                 |</span><br><span class="line">   |          | `ans.capacity();`                                           | 已分配的容量                 | 可能大于 size            |</span><br><span class="line">   |          | `ans.reserve(100);`                                         | 无返回值                     | 预留至少 100 个容量      |</span><br><span class="line">   |          | `ans.shrink_to_fit();`                                      | 无返回值                     | 收缩容量到 size          |</span><br><span class="line">   | **算法** | `sort(ans.begin(), ans.end());`                             | 无返回值                     | 升序排序                 |</span><br><span class="line">   |          | `sort(ans.rbegin(), ans.rend());`                           | 无返回值                     | 降序排序                 |</span><br><span class="line">   |          | `reverse(ans.begin(), ans.end());`                          | 无返回值                     | 反转元素顺序             |</span><br><span class="line"></span><br><span class="line">3. 注意，算法需要导入算法库：\#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">## 关联容器</span><br><span class="line"></span><br><span class="line">| 容器            | 底层   | 是否有序 | 是否允许重复 | 查找/插入/删除 |</span><br><span class="line">| --------------- | ------ | -------- | ------------ | -------------- |</span><br><span class="line">| `map`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       |</span><br><span class="line">| `set`           | 红黑树 | ✅ 有序   | ❌ 不允许     | O(log n)       |</span><br><span class="line">| `unordered_map` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      |</span><br><span class="line">| `unordered_set` | 哈希表 | ❌ 无序   | ❌ 不允许     | 平均 O(1)      |</span><br><span class="line"></span><br><span class="line">### &quot;map&quot;</span><br><span class="line"></span><br><span class="line">1. 有序存放键值对</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 方法         | 用法                   | 返回值（文字说明）                                           |</span><br><span class="line">      | ------------ | ---------------------- | ------------------------------------------------------------ |</span><br><span class="line">      | `insert`     | `m.insert(&#123;1,&quot;one&quot;&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（表示是否插入成功） |</span><br><span class="line">      | `operator[]` | `m[2] = &quot;two&quot;;`        | 返回指定键对应的值的引用（如果键不存在会新建）               |</span><br><span class="line">      | `at`         | `m.at(2)`              | 返回指定键对应的值的引用（如果键不存在会抛异常）             |</span><br><span class="line">      | `find`       | `m.find(2)`            | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |</span><br><span class="line">      | `erase(key)` | `m.erase(2)`           | 返回删除的元素个数（0 或 1）                                 |</span><br><span class="line">      | `erase(it)`  | `m.erase(it)`          | 返回一个迭代器，指向下一个有效元素                           |</span><br><span class="line">      | `count(key)` | `m.count(2)`           | 返回匹配的元素个数（在 map 中永远是 0 或 1）                 |</span><br><span class="line">      | `size`       | `m.size()`             | 返回当前存储的元素数量                                       |</span><br><span class="line">      | `empty`      | `m.empty()`            | 返回是否为空（true/false）                                   |</span><br><span class="line"></span><br><span class="line">   3. </span><br><span class="line"></span><br><span class="line">### &quot;set&quot;</span><br><span class="line"></span><br><span class="line">1. 有序存放键（没有值）</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 方法         | 用法            | 返回值（文字说明）                                           |</span><br><span class="line">      | ------------ | --------------- | ------------------------------------------------------------ |</span><br><span class="line">      | `insert`     | `s.insert(10);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |</span><br><span class="line">      | `find`       | `s.find(10)`    | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |</span><br><span class="line">      | `erase(key)` | `s.erase(10)`   | 返回删除的元素个数（0 或 1）                                 |</span><br><span class="line">      | `erase(it)`  | `s.erase(it)`   | 返回一个迭代器，指向下一个有效元素                           |</span><br><span class="line">      | `count(key)` | `s.count(10)`   | 返回匹配的元素个数（在 set 中永远是 0 或 1）                 |</span><br><span class="line">      | `size`       | `s.size()`      | 返回当前存储的元素数量                                       |</span><br><span class="line">      | `empty`      | `s.empty()`     | 返回是否为空（true/false）                                   |</span><br><span class="line"></span><br><span class="line">   3. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### &quot;unordered_map&quot;（哈希表）</span><br><span class="line"></span><br><span class="line">1. 无序存放键值对</span><br><span class="line"></span><br><span class="line">2. 用法</span><br><span class="line"></span><br><span class="line">   1. </span><br><span class="line"></span><br><span class="line">   2. | 方法         | 用法                      | 返回值（文字说明）                                           |</span><br><span class="line">      | ------------ | ------------------------- | ------------------------------------------------------------ |</span><br><span class="line">      | `insert`     | `um.insert(&#123;&quot;apple&quot;,3&#125;);` | 返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功） |</span><br><span class="line">      | `operator[]` | `um[&quot;banana&quot;]=5;`         | 返回指定键对应的值的引用（如果键不存在会新建）               |</span><br><span class="line">      | `at`         | `um.at(&quot;apple&quot;)`          | 返回指定键对应的值的引用（如果键不存在会抛异常）             |</span><br><span class="line">      | `find`       | `um.find(&quot;apple&quot;)`        | 返回一个迭代器，指向找到的元素；如果没找到，返回 `end()`     |</span><br><span class="line">      | `erase(key)` | `um.erase(&quot;apple&quot;)`       | 返回删除的元素个数（0 或 1）                                 |</span><br><span class="line">      | `erase(it)`  | `um.erase(it)`            | 返回一个迭代器，指向下一个有效元素                           |</span><br><span class="line">      | `count(key)` | `um.count(&quot;apple&quot;)`       | 返回匹配的元素个数（在 unordered_map 中永远是 0 或 1）       |</span><br><span class="line">      | `size`       | `um.size()`               | 返回当前存储的元素数量                                       |</span><br><span class="line">      | `empty`      | `um.empty()`              | 返回是否为空（true/false）                                   |</span><br><span class="line"></span><br><span class="line">   3. 我想进行如下操作：如果表中已存在，则取出值并操作，否则新建并设置默认值：</span><br><span class="line">   </span><br><span class="line">      1. ```c++</span><br><span class="line">         // 包含隐式创建默认对象</span><br><span class="line">         std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; graphMap;</span><br><span class="line">         </span><br><span class="line">         int node = 1;</span><br><span class="line">         </span><br><span class="line">         // 直接使用 operator[]，如果 node 不存在，会自动插入一个空的 vector&lt;int&gt;</span><br><span class="line">         std::vector&lt;int&gt;&amp; neighbors = graphMap[node]; // 如果不存在，会创建空vector</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果希望显示创建，则使用find（）</li>
</ol>
</li>
</ol>
<h3 id="“unordered-set”（哈希表）"><a href="#“unordered-set”（哈希表）" class="headerlink" title="“unordered_set”（哈希表）"></a>“unordered_set”（哈希表）</h3><ol>
<li><p>无序存放键（没有值）</p>
</li>
<li><p>用法</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th>方法</th>
<th>用法</th>
<th>返回值（文字说明）</th>
</tr>
</thead>
<tbody><tr>
<td><code>insert</code></td>
<td><code>us.insert(100);</code></td>
<td>返回一个结果对，里面有迭代器（指向元素位置）和布尔值（是否插入成功）</td>
</tr>
<tr>
<td><code>find</code></td>
<td><code>us.find(100)</code></td>
<td>返回一个迭代器，指向找到的元素；如果没找到，返回 <code>end()</code></td>
</tr>
<tr>
<td><code>erase(key)</code></td>
<td><code>us.erase(100)</code></td>
<td>返回删除的元素个数（0 或 1）</td>
</tr>
<tr>
<td><code>erase(it)</code></td>
<td><code>us.erase(it)</code></td>
<td>返回一个迭代器，指向下一个有效元素</td>
</tr>
<tr>
<td><code>count(key)</code></td>
<td><code>us.count(100)</code></td>
<td>返回匹配的元素个数（在 unordered_set 中永远是 0 或 1）</td>
</tr>
<tr>
<td><code>size</code></td>
<td><code>us.size()</code></td>
<td>返回当前存储的元素数量</td>
</tr>
<tr>
<td><code>empty</code></td>
<td><code>us.empty()</code></td>
<td>返回是否为空（true&#x2F;false）</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Lambda匿名函数"><a href="#Lambda匿名函数" class="headerlink" title="Lambda匿名函数"></a>Lambda匿名函数</h2><ol>
<li><p>基本语法</p>
<p>一个最基本的 Lambda 表达式的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表] (参数列表) -&gt; 返回类型 &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>[捕获列表]</strong>：定义了 Lambda 表达式能访问的外部变量及其方式（值捕获、引用捕获等），可以为空。</li>
<li><strong>(参数列表)</strong>：和普通函数的参数列表一样，如果不需要参数，可以省略，但括号不能省略（除非使用特殊形式）。</li>
<li><strong>-&gt; 返回类型</strong>：可省略，编译器会自动推导返回类型（如果只有一条 return 语句，或者没有 return）。</li>
<li><strong>{ 函数体 }</strong>：函数的实现部分。</li>
</ul>
</li>
<li><p>注意：如果引用的变量在 Lambda 执行前已经被销毁（比如局部变量离开作用域），会导致未定义行为（悬空引用）。</p>
</li>
</ol>
<h2 id="值传递和引用"><a href="#值传递和引用" class="headerlink" title="值传递和引用"></a>值传递和引用</h2><ol>
<li><p><code>for(T sth : sths)</code>的逻辑是值传递，不能修改对象本身。而<code>for(int i = 0 ...) {sths[i]} </code>是直接访问对象。</p>
<ol>
<li>如果希望简化写法直接修改对象，应该写作<code>for(T&amp; sth : sths)</code></li>
</ol>
</li>
<li><p><code>&amp;</code>引用：&amp;操作符用于别名时：</p>
<ol>
<li><p>作用：</p>
<p><code>&amp;</code>用于声明 <strong>引用（reference）</strong>，引用是一个别名，是某个已存在变量的另一个名字，对引用的操作就是对被引用对象的操作。</p>
</li>
<li><p>特点：</p>
<ul>
<li>必须初始化（不能先声明再赋值）。</li>
<li>不能重新绑定到其他对象。</li>
<li>引用本身不是对象，没有自己的内存地址（不像指针）。</li>
<li>更安全，更直观，常用于函数参数传递和返回值优化。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref 是 a 的引用（别名）</span></span><br><span class="line"></span><br><span class="line">ref = <span class="number">20</span>;      <span class="comment">// 实际上是修改了 a</span></span><br><span class="line">cout &lt;&lt; a;     <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用 vs 指针（简要对比）</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">引用 (<code>&amp;</code>)</th>
<th align="left">指针 (<code>*</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否必须初始化</td>
<td align="left">✅ 必须初始化</td>
<td align="left">❌ 可以不初始化（但不推荐）</td>
</tr>
<tr>
<td align="left">是否可重新绑定</td>
<td align="left">❌ 不能重新绑定到其他对象</td>
<td align="left">✅ 可以修改指向的对象</td>
</tr>
<tr>
<td align="left">是否占用额外内存</td>
<td align="left">❌ 一般不占用（是别名）</td>
<td align="left">✅ 占用内存（存储地址）</td>
</tr>
<tr>
<td align="left">是否可以为空</td>
<td align="left">❌ 不能为空</td>
<td align="left">✅ 可以为 nullptr</td>
</tr>
<tr>
<td align="left">语法简洁性</td>
<td align="left">✅ 更简洁，更安全</td>
<td align="left">❌ 需要解引用，容易出错</td>
</tr>
</tbody></table>
</li>
<li><p>&amp;在C++中的主要用途</p>
<p>1. </p>
<ol start="2">
<li><table>
<thead>
<tr>
<th align="left">号</th>
<th align="left">用法类别</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>引用声明</strong></td>
<td align="left">声明一个变量的引用（别名）</td>
<td align="left"><code>int&amp; ref = a;</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>取地址运算符</strong></td>
<td align="left">获取变量的内存地址，用于指针</td>
<td align="left"><code>int* p = &amp;a;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>引用参数</strong></td>
<td align="left">函数参数传引用，避免拷贝，可修改原值</td>
<td align="left"><code>void func(int&amp; x)</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>引用返回值</strong></td>
<td align="left">函数返回引用，可修改原对象或支持链式调用</td>
<td align="left"><code>int&amp; getElement()</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>指针的引用</strong></td>
<td align="left">引用指向指针，用于修改指针本身</td>
<td align="left"><code>int*&amp; refPtr = ptr;</code></td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="输入输出操作"><a href="#输入输出操作" class="headerlink" title="输入输出操作"></a>输入输出操作</h2><ol>
<li><p><code>getline</code>用法：</p>
<ol>
<li><code>getline(cin, str)</code>：把一行读到str中</li>
<li><code>getline(cin, str, delimiter)</code>：读一行，知道遇见第一个隔断符</li>
</ol>
</li>
<li><p><code>stringstream</code>用法</p>
<ol>
<li><p><code>stringsstream ss(str)</code>：把字符串作为字符串流。这样可以搭配getline。</p>
</li>
<li><p>示例</p>
<ol>
<li><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

int main() {
    std::string str = &quot;apple,banana,orange&quot;;
    char delimiter = &#39;,&#39;;  // 按逗号分割

    std::vector&lt;std::string&gt; tokens;  // 存储分割后的子串
    std::stringstream ss(str);        // 将字符串放入字符串流
    std::string token;

    // 按 delimiter 分割
    while (std::getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }

    // 输出分割结果
    for (const auto&amp; t : tokens) {
        std::cout &lt;&lt; t &lt;&lt; std::endl;
    }

    return 0;
}

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 操作符重载</span><br><span class="line"></span><br><span class="line">1. 是什么：</span><br><span class="line"></span><br><span class="line">   1. 让你可以用内置操作符的方式来操作你自己定义的类型（比如类对象）</span><br><span class="line"></span><br><span class="line">2. 基本语法</span><br><span class="line"></span><br><span class="line">   1. 操作符重载本质上就是 **定义一个特殊的成员函数 或 友元函数**，函数名是 `operator`加上要重载的操作符符号。</span><br><span class="line"></span><br><span class="line">      1. 一般形式（成员函数）：</span><br><span class="line"></span><br><span class="line">      ```c++</span><br><span class="line">      返回类型 operator操作符(参数列表) &#123;</span><br><span class="line">          // 自定义操作符的实现</span><br><span class="line">      &#125;</span><br><span class="line">      // 参数个数 = 操作符需要的操作数个数 - 1（因为左操作数是 this)</span><br></pre></td></tr></table></figure>

  2. 它可以是一个：
       1. **成员函数**（常见，操作符左边的对象是当前对象，即 `this`）
       2. **友元函数**（当左操作数不是当前类对象，或者需要访问私有成员但又不能是成员时）
</code></pre>
</li>
<li><p>友元函数方式：</p>
<ol>
<li><p>friend 返回类型 operator操作符(参数1, 参数2);</p>
<ol>
<li><pre><code class="language-c++">friend 返回类型 operator操作符(参数1, 参数2);
// 参数个数 = 操作符总的操作数个数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 举例</span><br><span class="line"></span><br><span class="line">   1. ```c++</span><br><span class="line">      #include &lt;iostream&gt;</span><br><span class="line">      using namespace std;</span><br><span class="line">      </span><br><span class="line">      class MyArray &#123;</span><br><span class="line">      private:</span><br><span class="line">          int data[5];  // 假设我们只管理 5 个整数</span><br><span class="line">      public:</span><br><span class="line">          // 构造函数，初始化数组</span><br><span class="line">          MyArray() &#123;</span><br><span class="line">              for (int i = 0; i &lt; 5; ++i) &#123;</span><br><span class="line">                  data[i] = i * 10;  // 0, 10, 20, 30, 40</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          // 重载 [] 操作符 —— 用于访问元素（读写）</span><br><span class="line">          int&amp; operator[](int index) &#123;</span><br><span class="line">              return data[index];  // 返回第 index 个元素的引用</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/04/Java%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="prev" title="Java与JVM">
                  <i class="fa fa-angle-left"></i> Java与JVM
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mukongshan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
